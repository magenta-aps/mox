--
-- PostgreSQL database dump
--

-- Dumped from database version 9.5.7
-- Dumped by pg_dump version 9.5.7

SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: actual_state; Type: SCHEMA; Schema: -; Owner: mox
--

CREATE SCHEMA actual_state;


ALTER SCHEMA actual_state OWNER TO mox;

--
-- Name: test; Type: SCHEMA; Schema: -; Owner: mox
--

CREATE SCHEMA test;


ALTER SCHEMA test OWNER TO mox;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


--
-- Name: btree_gist; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS btree_gist WITH SCHEMA public;


--
-- Name: EXTENSION btree_gist; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION btree_gist IS 'support for indexing common datatypes in GiST';


--
-- Name: pg_trgm; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA public;


--
-- Name: EXTENSION pg_trgm; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_trgm IS 'text similarity measurement and index searching based on trigrams';


--
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;


--
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION "uuid-ossp" IS 'generate universally unique identifiers (UUIDs)';


SET search_path = actual_state, pg_catalog;

--
-- Name: aktivitetrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktivitetrelationkode AS ENUM (
    'aktivitetstype',
    'emne',
    'foelsomhedklasse',
    'ansvarligklasse',
    'rekvirentklasse',
    'ansvarlig',
    'tilhoerer',
    'udfoererklasse',
    'deltagerklasse',
    'objektklasse',
    'resultatklasse',
    'grundlagklasse',
    'facilitetklasse',
    'adresse',
    'geoobjekt',
    'position',
    'facilitet',
    'lokale',
    'aktivitetdokument',
    'aktivitetgrundlag',
    'aktivitetresultat',
    'udfoerer',
    'deltager'
);


ALTER TYPE aktivitetrelationkode OWNER TO mox;

--
-- Name: _aktivitetrelationmaxindex; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE _aktivitetrelationmaxindex AS (
	reltype aktivitetrelationkode,
	indeks integer
);


ALTER TYPE _aktivitetrelationmaxindex OWNER TO mox;

--
-- Name: _dokumentvariantdelkey; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE _dokumentvariantdelkey AS (
	varianttekst text,
	deltekst text
);


ALTER TYPE _dokumentvariantdelkey OWNER TO mox;

--
-- Name: indsatsrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE indsatsrelationkode AS ENUM (
    'indsatsmodtager',
    'indsatstype',
    'indsatskvalitet',
    'indsatsaktoer',
    'samtykke',
    'indsatssag',
    'indsatsdokument'
);


ALTER TYPE indsatsrelationkode OWNER TO mox;

--
-- Name: _indsatsrelationmaxindex; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE _indsatsrelationmaxindex AS (
	reltype indsatsrelationkode,
	indeks integer
);


ALTER TYPE _indsatsrelationmaxindex OWNER TO mox;

--
-- Name: sagrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE sagrelationkode AS ENUM (
    'behandlingarkiv',
    'afleveringsarkiv',
    'primaerklasse',
    'opgaveklasse',
    'handlingsklasse',
    'kontoklasse',
    'sikkerhedsklasse',
    'foelsomhedsklasse',
    'indsatsklasse',
    'ydelsesklasse',
    'ejer',
    'ansvarlig',
    'primaerbehandler',
    'udlaanttil',
    'primaerpart',
    'ydelsesmodtager',
    'oversag',
    'praecedens',
    'afgiftsobjekt',
    'ejendomsskat',
    'andetarkiv',
    'andrebehandlere',
    'sekundaerpart',
    'andresager',
    'byggeri',
    'fredning',
    'journalpost'
);


ALTER TYPE sagrelationkode OWNER TO mox;

--
-- Name: _sagrelationmaxindex; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE _sagrelationmaxindex AS (
	reltype sagrelationkode,
	indeks integer
);


ALTER TYPE _sagrelationmaxindex OWNER TO mox;

--
-- Name: tilstandrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE tilstandrelationkode AS ENUM (
    'tilstandsobjekt',
    'tilstandstype',
    'tilstandsvaerdi',
    'begrundelse',
    'tilstandskvalitet',
    'tilstandsvurdering',
    'tilstandsaktoer',
    'tilstandsudstyr',
    'samtykke',
    'tilstandsdokument'
);


ALTER TYPE tilstandrelationkode OWNER TO mox;

--
-- Name: _tilstandrelationmaxindex; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE _tilstandrelationmaxindex AS (
	reltype tilstandrelationkode,
	indeks integer
);


ALTER TYPE _tilstandrelationmaxindex OWNER TO mox;

--
-- Name: aktivitetaktoerattraccepteretkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktivitetaktoerattraccepteretkode AS ENUM (
    'accepteret',
    'foreloebigt',
    'afslaaet'
);


ALTER TYPE aktivitetaktoerattraccepteretkode OWNER TO mox;

--
-- Name: aktivitetaktoerattrobligatoriskkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktivitetaktoerattrobligatoriskkode AS ENUM (
    'noedvendig',
    'valgfri'
);


ALTER TYPE aktivitetaktoerattrobligatoriskkode OWNER TO mox;

--
-- Name: aktivitetaktoerattr; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktivitetaktoerattr AS (
	obligatorisk aktivitetaktoerattrobligatoriskkode,
	accepteret aktivitetaktoerattraccepteretkode,
	repraesentation_uuid uuid,
	repraesentation_urn text
);


ALTER TYPE aktivitetaktoerattr OWNER TO mox;

--
-- Name: aktoertypekode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktoertypekode AS ENUM (
    'Organisation',
    'OrganisationEnhed',
    'OrganisationFunktion',
    'Bruger',
    'ItSystem',
    'Interessefaellesskab'
);


ALTER TYPE aktoertypekode OWNER TO mox;

--
-- Name: clearableinterval; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE clearableinterval AS (
	value interval(0),
	cleared boolean
);


ALTER TYPE clearableinterval OWNER TO mox;

--
-- Name: clearabletimestamptz; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE clearabletimestamptz AS (
	value timestamp with time zone,
	cleared boolean
);


ALTER TYPE clearabletimestamptz OWNER TO mox;

--
-- Name: virkning; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE virkning AS (
	timeperiod tstzrange,
	aktoerref uuid,
	aktoertypekode aktoertypekode,
	notetekst text
);


ALTER TYPE virkning OWNER TO mox;

--
-- Name: aktivitetegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktivitetegenskaberattrtype AS (
	brugervendtnoegle text,
	aktivitetnavn text,
	beskrivelse text,
	starttidspunkt clearabletimestamptz,
	sluttidspunkt clearabletimestamptz,
	tidsforbrug clearableinterval,
	formaal text,
	virkning virkning
);


ALTER TYPE aktivitetegenskaberattrtype OWNER TO mox;

--
-- Name: aktivitetpublicerettils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktivitetpublicerettils AS ENUM (
    'Publiceret',
    'IkkePubliceret',
    'Normal',
    ''
);


ALTER TYPE aktivitetpublicerettils OWNER TO mox;

--
-- Name: aktivitetpublicerettilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktivitetpublicerettilstype AS (
	virkning virkning,
	publiceret aktivitetpublicerettils
);


ALTER TYPE aktivitetpublicerettilstype OWNER TO mox;

--
-- Name: aktivitetrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktivitetrelationtype AS (
	reltype aktivitetrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text,
	indeks integer,
	aktoerattr aktivitetaktoerattr
);


ALTER TYPE aktivitetrelationtype OWNER TO mox;

--
-- Name: aktivitetstatustils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktivitetstatustils AS ENUM (
    'Inaktiv',
    'Aktiv',
    'Aflyst',
    ''
);


ALTER TYPE aktivitetstatustils OWNER TO mox;

--
-- Name: aktivitetstatustilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktivitetstatustilstype AS (
	virkning virkning,
	status aktivitetstatustils
);


ALTER TYPE aktivitetstatustilstype OWNER TO mox;

--
-- Name: livscykluskode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE livscykluskode AS ENUM (
    'Opstaaet',
    'Importeret',
    'Passiveret',
    'Slettet',
    'Rettet'
);


ALTER TYPE livscykluskode OWNER TO mox;

--
-- Name: registreringbase; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE registreringbase AS (
	timeperiod tstzrange,
	livscykluskode livscykluskode,
	brugerref uuid,
	note text
);


ALTER TYPE registreringbase OWNER TO mox;

--
-- Name: aktivitetregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktivitetregistreringtype AS (
	registrering registreringbase,
	tilsstatus aktivitetstatustilstype[],
	tilspubliceret aktivitetpublicerettilstype[],
	attregenskaber aktivitetegenskaberattrtype[],
	relationer aktivitetrelationtype[]
);


ALTER TYPE aktivitetregistreringtype OWNER TO mox;

--
-- Name: aktivitettype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE aktivitettype AS (
	id uuid,
	registrering aktivitetregistreringtype[]
);


ALTER TYPE aktivitettype OWNER TO mox;

--
-- Name: brugeregenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE brugeregenskaberattrtype AS (
	brugervendtnoegle text,
	brugernavn text,
	brugertype text,
	virkning virkning
);


ALTER TYPE brugeregenskaberattrtype OWNER TO mox;

--
-- Name: brugergyldighedtils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE brugergyldighedtils AS ENUM (
    'Aktiv',
    'Inaktiv',
    ''
);


ALTER TYPE brugergyldighedtils OWNER TO mox;

--
-- Name: brugergyldighedtilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE brugergyldighedtilstype AS (
	virkning virkning,
	gyldighed brugergyldighedtils
);


ALTER TYPE brugergyldighedtilstype OWNER TO mox;

--
-- Name: brugerrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE brugerrelationkode AS ENUM (
    'tilhoerer',
    'adresser',
    'brugertyper',
    'opgaver',
    'tilknyttedeenheder',
    'tilknyttedefunktioner',
    'tilknyttedeinteressefaellesskaber',
    'tilknyttedeorganisationer',
    'tilknyttedepersoner',
    'tilknyttedeitsystemer'
);


ALTER TYPE brugerrelationkode OWNER TO mox;

--
-- Name: brugerrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE brugerrelationtype AS (
	reltype brugerrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text
);


ALTER TYPE brugerrelationtype OWNER TO mox;

--
-- Name: brugerregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE brugerregistreringtype AS (
	registrering registreringbase,
	tilsgyldighed brugergyldighedtilstype[],
	attregenskaber brugeregenskaberattrtype[],
	relationer brugerrelationtype[]
);


ALTER TYPE brugerregistreringtype OWNER TO mox;

--
-- Name: brugertype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE brugertype AS (
	id uuid,
	registrering brugerregistreringtype[]
);


ALTER TYPE brugertype OWNER TO mox;

--
-- Name: clearableboolean; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE clearableboolean AS (
	value boolean,
	cleared boolean
);


ALTER TYPE clearableboolean OWNER TO mox;

--
-- Name: clearabledate; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE clearabledate AS (
	value date,
	cleared boolean
);


ALTER TYPE clearabledate OWNER TO mox;

--
-- Name: clearableint; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE clearableint AS (
	value integer,
	cleared boolean
);


ALTER TYPE clearableint OWNER TO mox;

--
-- Name: dokumentdelegenskabertype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumentdelegenskabertype AS (
	indeks clearableint,
	indhold text,
	lokation text,
	mimetype text,
	virkning virkning
);


ALTER TYPE dokumentdelegenskabertype OWNER TO mox;

--
-- Name: dokumentdelrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumentdelrelationkode AS ENUM (
    'underredigeringaf'
);


ALTER TYPE dokumentdelrelationkode OWNER TO mox;

--
-- Name: dokumentdelrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumentdelrelationtype AS (
	reltype dokumentdelrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text
);


ALTER TYPE dokumentdelrelationtype OWNER TO mox;

--
-- Name: dokumentdeltype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumentdeltype AS (
	deltekst text,
	egenskaber dokumentdelegenskabertype[],
	relationer dokumentdelrelationtype[]
);


ALTER TYPE dokumentdeltype OWNER TO mox;

--
-- Name: offentlighedundtagettype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE offentlighedundtagettype AS (
	alternativtitel text,
	hjemmel text
);


ALTER TYPE offentlighedundtagettype OWNER TO mox;

--
-- Name: dokumentegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumentegenskaberattrtype AS (
	brugervendtnoegle text,
	beskrivelse text,
	brevdato clearabledate,
	kassationskode text,
	major clearableint,
	minor clearableint,
	offentlighedundtaget offentlighedundtagettype,
	titel text,
	dokumenttype text,
	virkning virkning
);


ALTER TYPE dokumentegenskaberattrtype OWNER TO mox;

--
-- Name: dokumentfremdrifttils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumentfremdrifttils AS ENUM (
    'Modtaget',
    'Fordelt',
    'Underudarbejdelse',
    'Underreview',
    'Publiceret',
    'Endeligt',
    'Afleveret',
    ''
);


ALTER TYPE dokumentfremdrifttils OWNER TO mox;

--
-- Name: dokumentfremdrifttilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumentfremdrifttilstype AS (
	virkning virkning,
	fremdrift dokumentfremdrifttils
);


ALTER TYPE dokumentfremdrifttilstype OWNER TO mox;

--
-- Name: dokumentrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumentrelationkode AS ENUM (
    'nyrevision',
    'primaerklasse',
    'ejer',
    'ansvarlig',
    'primaerbehandler',
    'fordelttil',
    'arkiver',
    'besvarelser',
    'udgangspunkter',
    'kommentarer',
    'bilag',
    'andredokumenter',
    'andreklasser',
    'andrebehandlere',
    'parter',
    'kopiparter',
    'tilknyttedesager'
);


ALTER TYPE dokumentrelationkode OWNER TO mox;

--
-- Name: dokumentrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumentrelationtype AS (
	reltype dokumentrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text
);


ALTER TYPE dokumentrelationtype OWNER TO mox;

--
-- Name: dokumentvariantegenskabertype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumentvariantegenskabertype AS (
	arkivering clearableboolean,
	delvisscannet clearableboolean,
	offentliggoerelse clearableboolean,
	produktion clearableboolean,
	virkning virkning
);


ALTER TYPE dokumentvariantegenskabertype OWNER TO mox;

--
-- Name: dokumentvarianttype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumentvarianttype AS (
	varianttekst text,
	egenskaber dokumentvariantegenskabertype[],
	dele dokumentdeltype[]
);


ALTER TYPE dokumentvarianttype OWNER TO mox;

--
-- Name: dokumentregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumentregistreringtype AS (
	registrering registreringbase,
	tilsfremdrift dokumentfremdrifttilstype[],
	attregenskaber dokumentegenskaberattrtype[],
	relationer dokumentrelationtype[],
	varianter dokumentvarianttype[]
);


ALTER TYPE dokumentregistreringtype OWNER TO mox;

--
-- Name: dokumenttype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE dokumenttype AS (
	id uuid,
	registrering dokumentregistreringtype[]
);


ALTER TYPE dokumenttype OWNER TO mox;

--
-- Name: facetegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE facetegenskaberattrtype AS (
	brugervendtnoegle text,
	beskrivelse text,
	opbygning text,
	ophavsret text,
	plan text,
	supplement text,
	retskilde text,
	virkning virkning
);


ALTER TYPE facetegenskaberattrtype OWNER TO mox;

--
-- Name: facetpublicerettils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE facetpublicerettils AS ENUM (
    'Publiceret',
    'IkkePubliceret',
    ''
);


ALTER TYPE facetpublicerettils OWNER TO mox;

--
-- Name: facetpublicerettilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE facetpublicerettilstype AS (
	virkning virkning,
	publiceret facetpublicerettils
);


ALTER TYPE facetpublicerettilstype OWNER TO mox;

--
-- Name: facetrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE facetrelationkode AS ENUM (
    'ansvarlig',
    'ejer',
    'facettilhoerer',
    'redaktoerer'
);


ALTER TYPE facetrelationkode OWNER TO mox;

--
-- Name: facetrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE facetrelationtype AS (
	reltype facetrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text
);


ALTER TYPE facetrelationtype OWNER TO mox;

--
-- Name: facetregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE facetregistreringtype AS (
	registrering registreringbase,
	tilspubliceret facetpublicerettilstype[],
	attregenskaber facetegenskaberattrtype[],
	relationer facetrelationtype[]
);


ALTER TYPE facetregistreringtype OWNER TO mox;

--
-- Name: facettype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE facettype AS (
	id uuid,
	registrering facetregistreringtype[]
);


ALTER TYPE facettype OWNER TO mox;

--
-- Name: indsatsegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE indsatsegenskaberattrtype AS (
	brugervendtnoegle text,
	beskrivelse text,
	starttidspunkt clearabletimestamptz,
	sluttidspunkt clearabletimestamptz,
	virkning virkning
);


ALTER TYPE indsatsegenskaberattrtype OWNER TO mox;

--
-- Name: indsatsfremdrifttils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE indsatsfremdrifttils AS ENUM (
    'Uoplyst',
    'Visiteret',
    'Disponeret',
    'Leveret',
    'Vurderet',
    ''
);


ALTER TYPE indsatsfremdrifttils OWNER TO mox;

--
-- Name: indsatsfremdrifttilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE indsatsfremdrifttilstype AS (
	virkning virkning,
	fremdrift indsatsfremdrifttils
);


ALTER TYPE indsatsfremdrifttilstype OWNER TO mox;

--
-- Name: indsatspublicerettils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE indsatspublicerettils AS ENUM (
    'Publiceret',
    'IkkePubliceret',
    'Normal',
    ''
);


ALTER TYPE indsatspublicerettils OWNER TO mox;

--
-- Name: indsatspublicerettilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE indsatspublicerettilstype AS (
	virkning virkning,
	publiceret indsatspublicerettils
);


ALTER TYPE indsatspublicerettilstype OWNER TO mox;

--
-- Name: indsatsrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE indsatsrelationtype AS (
	reltype indsatsrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text,
	indeks integer
);


ALTER TYPE indsatsrelationtype OWNER TO mox;

--
-- Name: indsatsregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE indsatsregistreringtype AS (
	registrering registreringbase,
	tilspubliceret indsatspublicerettilstype[],
	tilsfremdrift indsatsfremdrifttilstype[],
	attregenskaber indsatsegenskaberattrtype[],
	relationer indsatsrelationtype[]
);


ALTER TYPE indsatsregistreringtype OWNER TO mox;

--
-- Name: indsatstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE indsatstype AS (
	id uuid,
	registrering indsatsregistreringtype[]
);


ALTER TYPE indsatstype OWNER TO mox;

--
-- Name: interessefaellesskabegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE interessefaellesskabegenskaberattrtype AS (
	brugervendtnoegle text,
	interessefaellesskabsnavn text,
	interessefaellesskabstype text,
	virkning virkning
);


ALTER TYPE interessefaellesskabegenskaberattrtype OWNER TO mox;

--
-- Name: interessefaellesskabgyldighedtils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE interessefaellesskabgyldighedtils AS ENUM (
    'Aktiv',
    'Inaktiv',
    ''
);


ALTER TYPE interessefaellesskabgyldighedtils OWNER TO mox;

--
-- Name: interessefaellesskabgyldighedtilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE interessefaellesskabgyldighedtilstype AS (
	virkning virkning,
	gyldighed interessefaellesskabgyldighedtils
);


ALTER TYPE interessefaellesskabgyldighedtilstype OWNER TO mox;

--
-- Name: interessefaellesskabrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE interessefaellesskabrelationkode AS ENUM (
    'branche',
    'interessefaellesskabstype',
    'overordnet',
    'tilhoerer',
    'adresser',
    'opgaver',
    'tilknyttedebrugere',
    'tilknyttedeenheder',
    'tilknyttedefunktioner',
    'tilknyttedeinteressefaellesskaber',
    'tilknyttedeorganisationer',
    'tilknyttedepersoner',
    'tilknyttedeitsystemer'
);


ALTER TYPE interessefaellesskabrelationkode OWNER TO mox;

--
-- Name: interessefaellesskabrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE interessefaellesskabrelationtype AS (
	reltype interessefaellesskabrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text
);


ALTER TYPE interessefaellesskabrelationtype OWNER TO mox;

--
-- Name: interessefaellesskabregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE interessefaellesskabregistreringtype AS (
	registrering registreringbase,
	tilsgyldighed interessefaellesskabgyldighedtilstype[],
	attregenskaber interessefaellesskabegenskaberattrtype[],
	relationer interessefaellesskabrelationtype[]
);


ALTER TYPE interessefaellesskabregistreringtype OWNER TO mox;

--
-- Name: interessefaellesskabtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE interessefaellesskabtype AS (
	id uuid,
	registrering interessefaellesskabregistreringtype[]
);


ALTER TYPE interessefaellesskabtype OWNER TO mox;

--
-- Name: itsystemegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE itsystemegenskaberattrtype AS (
	brugervendtnoegle text,
	itsystemnavn text,
	itsystemtype text,
	konfigurationreference text[],
	virkning virkning
);


ALTER TYPE itsystemegenskaberattrtype OWNER TO mox;

--
-- Name: itsystemgyldighedtils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE itsystemgyldighedtils AS ENUM (
    'Aktiv',
    'Inaktiv',
    ''
);


ALTER TYPE itsystemgyldighedtils OWNER TO mox;

--
-- Name: itsystemgyldighedtilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE itsystemgyldighedtilstype AS (
	virkning virkning,
	gyldighed itsystemgyldighedtils
);


ALTER TYPE itsystemgyldighedtilstype OWNER TO mox;

--
-- Name: itsystemrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE itsystemrelationkode AS ENUM (
    'tilhoerer',
    'tilknyttedeorganisationer',
    'tilknyttedeenheder',
    'tilknyttedefunktioner',
    'tilknyttedebrugere',
    'tilknyttedeinteressefaellesskaber',
    'tilknyttedeitsystemer',
    'tilknyttedepersoner',
    'systemtyper',
    'opgaver',
    'adresser'
);


ALTER TYPE itsystemrelationkode OWNER TO mox;

--
-- Name: itsystemrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE itsystemrelationtype AS (
	reltype itsystemrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text
);


ALTER TYPE itsystemrelationtype OWNER TO mox;

--
-- Name: itsystemregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE itsystemregistreringtype AS (
	registrering registreringbase,
	tilsgyldighed itsystemgyldighedtilstype[],
	attregenskaber itsystemegenskaberattrtype[],
	relationer itsystemrelationtype[]
);


ALTER TYPE itsystemregistreringtype OWNER TO mox;

--
-- Name: itsystemtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE itsystemtype AS (
	id uuid,
	registrering itsystemregistreringtype[]
);


ALTER TYPE itsystemtype OWNER TO mox;

--
-- Name: journalnotattype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE journalnotattype AS (
	titel text,
	notat text,
	format text
);


ALTER TYPE journalnotattype OWNER TO mox;

--
-- Name: journalpostdokumentattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE journalpostdokumentattrtype AS (
	dokumenttitel text,
	offentlighedundtaget offentlighedundtagettype
);


ALTER TYPE journalpostdokumentattrtype OWNER TO mox;

--
-- Name: klassesoegeordtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klassesoegeordtype AS (
	soegeordidentifikator text,
	beskrivelse text,
	soegeordskategori text
);


ALTER TYPE klassesoegeordtype OWNER TO mox;

--
-- Name: klasseegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klasseegenskaberattrtype AS (
	brugervendtnoegle text,
	beskrivelse text,
	eksempel text,
	omfang text,
	titel text,
	retskilde text,
	aendringsnotat text,
	soegeord klassesoegeordtype[],
	virkning virkning
);


ALTER TYPE klasseegenskaberattrtype OWNER TO mox;

--
-- Name: klassepublicerettils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klassepublicerettils AS ENUM (
    'Publiceret',
    'IkkePubliceret',
    ''
);


ALTER TYPE klassepublicerettils OWNER TO mox;

--
-- Name: klassepublicerettilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klassepublicerettilstype AS (
	virkning virkning,
	publiceret klassepublicerettils
);


ALTER TYPE klassepublicerettilstype OWNER TO mox;

--
-- Name: klasserelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klasserelationkode AS ENUM (
    'ejer',
    'ansvarlig',
    'overordnetklasse',
    'facet',
    'redaktoerer',
    'sideordnede',
    'mapninger',
    'tilfoejelser',
    'erstatter',
    'lovligekombinationer'
);


ALTER TYPE klasserelationkode OWNER TO mox;

--
-- Name: klasserelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klasserelationtype AS (
	reltype klasserelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text
);


ALTER TYPE klasserelationtype OWNER TO mox;

--
-- Name: klasseregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klasseregistreringtype AS (
	registrering registreringbase,
	tilspubliceret klassepublicerettilstype[],
	attregenskaber klasseegenskaberattrtype[],
	relationer klasserelationtype[]
);


ALTER TYPE klasseregistreringtype OWNER TO mox;

--
-- Name: klassetype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klassetype AS (
	id uuid,
	registrering klasseregistreringtype[]
);


ALTER TYPE klassetype OWNER TO mox;

--
-- Name: klassifikationegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klassifikationegenskaberattrtype AS (
	brugervendtnoegle text,
	beskrivelse text,
	kaldenavn text,
	ophavsret text,
	virkning virkning
);


ALTER TYPE klassifikationegenskaberattrtype OWNER TO mox;

--
-- Name: klassifikationpublicerettils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klassifikationpublicerettils AS ENUM (
    'Publiceret',
    'IkkePubliceret',
    ''
);


ALTER TYPE klassifikationpublicerettils OWNER TO mox;

--
-- Name: klassifikationpublicerettilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klassifikationpublicerettilstype AS (
	virkning virkning,
	publiceret klassifikationpublicerettils
);


ALTER TYPE klassifikationpublicerettilstype OWNER TO mox;

--
-- Name: klassifikationrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klassifikationrelationkode AS ENUM (
    'ansvarlig',
    'ejer'
);


ALTER TYPE klassifikationrelationkode OWNER TO mox;

--
-- Name: klassifikationrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klassifikationrelationtype AS (
	reltype klassifikationrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text
);


ALTER TYPE klassifikationrelationtype OWNER TO mox;

--
-- Name: klassifikationregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klassifikationregistreringtype AS (
	registrering registreringbase,
	tilspubliceret klassifikationpublicerettilstype[],
	attregenskaber klassifikationegenskaberattrtype[],
	relationer klassifikationrelationtype[]
);


ALTER TYPE klassifikationregistreringtype OWNER TO mox;

--
-- Name: klassifikationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE klassifikationtype AS (
	id uuid,
	registrering klassifikationregistreringtype[]
);


ALTER TYPE klassifikationtype OWNER TO mox;

--
-- Name: loghaendelseegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE loghaendelseegenskaberattrtype AS (
	service text,
	klasse text,
	tidspunkt text,
	operation text,
	objekttype text,
	returkode text,
	returtekst text,
	note text,
	virkning virkning
);


ALTER TYPE loghaendelseegenskaberattrtype OWNER TO mox;

--
-- Name: loghaendelsegyldighedtils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE loghaendelsegyldighedtils AS ENUM (
    'Rettet',
    'Ikke rettet',
    ''
);


ALTER TYPE loghaendelsegyldighedtils OWNER TO mox;

--
-- Name: loghaendelsegyldighedtilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE loghaendelsegyldighedtilstype AS (
	virkning virkning,
	gyldighed loghaendelsegyldighedtils
);


ALTER TYPE loghaendelsegyldighedtilstype OWNER TO mox;

--
-- Name: loghaendelserelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE loghaendelserelationkode AS ENUM (
    'objekt',
    'bruger',
    'brugerrolle'
);


ALTER TYPE loghaendelserelationkode OWNER TO mox;

--
-- Name: loghaendelserelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE loghaendelserelationtype AS (
	reltype loghaendelserelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text
);


ALTER TYPE loghaendelserelationtype OWNER TO mox;

--
-- Name: loghaendelseregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE loghaendelseregistreringtype AS (
	registrering registreringbase,
	tilsgyldighed loghaendelsegyldighedtilstype[],
	attregenskaber loghaendelseegenskaberattrtype[],
	relationer loghaendelserelationtype[]
);


ALTER TYPE loghaendelseregistreringtype OWNER TO mox;

--
-- Name: loghaendelsetype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE loghaendelsetype AS (
	id uuid,
	registrering loghaendelseregistreringtype[]
);


ALTER TYPE loghaendelsetype OWNER TO mox;

--
-- Name: organisationegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationegenskaberattrtype AS (
	brugervendtnoegle text,
	organisationsnavn text,
	virkning virkning
);


ALTER TYPE organisationegenskaberattrtype OWNER TO mox;

--
-- Name: organisationenhedegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationenhedegenskaberattrtype AS (
	brugervendtnoegle text,
	enhedsnavn text,
	virkning virkning
);


ALTER TYPE organisationenhedegenskaberattrtype OWNER TO mox;

--
-- Name: organisationenhedgyldighedtils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationenhedgyldighedtils AS ENUM (
    'Aktiv',
    'Inaktiv',
    ''
);


ALTER TYPE organisationenhedgyldighedtils OWNER TO mox;

--
-- Name: organisationenhedgyldighedtilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationenhedgyldighedtilstype AS (
	virkning virkning,
	gyldighed organisationenhedgyldighedtils
);


ALTER TYPE organisationenhedgyldighedtilstype OWNER TO mox;

--
-- Name: organisationenhedrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationenhedrelationkode AS ENUM (
    'branche',
    'enhedstype',
    'overordnet',
    'produktionsenhed',
    'skatteenhed',
    'tilhoerer',
    'adresser',
    'ansatte',
    'opgaver',
    'tilknyttedebrugere',
    'tilknyttedeenheder',
    'tilknyttedefunktioner',
    'tilknyttedeinteressefaellesskaber',
    'tilknyttedeorganisationer',
    'tilknyttedepersoner',
    'tilknyttedeitsystemer'
);


ALTER TYPE organisationenhedrelationkode OWNER TO mox;

--
-- Name: organisationenhedrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationenhedrelationtype AS (
	reltype organisationenhedrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text
);


ALTER TYPE organisationenhedrelationtype OWNER TO mox;

--
-- Name: organisationenhedregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationenhedregistreringtype AS (
	registrering registreringbase,
	tilsgyldighed organisationenhedgyldighedtilstype[],
	attregenskaber organisationenhedegenskaberattrtype[],
	relationer organisationenhedrelationtype[]
);


ALTER TYPE organisationenhedregistreringtype OWNER TO mox;

--
-- Name: organisationenhedtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationenhedtype AS (
	id uuid,
	registrering organisationenhedregistreringtype[]
);


ALTER TYPE organisationenhedtype OWNER TO mox;

--
-- Name: organisationfunktionegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationfunktionegenskaberattrtype AS (
	brugervendtnoegle text,
	funktionsnavn text,
	virkning virkning
);


ALTER TYPE organisationfunktionegenskaberattrtype OWNER TO mox;

--
-- Name: organisationfunktiongyldighedtils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationfunktiongyldighedtils AS ENUM (
    'Aktiv',
    'Inaktiv',
    ''
);


ALTER TYPE organisationfunktiongyldighedtils OWNER TO mox;

--
-- Name: organisationfunktiongyldighedtilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationfunktiongyldighedtilstype AS (
	virkning virkning,
	gyldighed organisationfunktiongyldighedtils
);


ALTER TYPE organisationfunktiongyldighedtilstype OWNER TO mox;

--
-- Name: organisationfunktionrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationfunktionrelationkode AS ENUM (
    'organisatoriskfunktionstype',
    'adresser',
    'opgaver',
    'tilknyttedebrugere',
    'tilknyttedeenheder',
    'tilknyttedeorganisationer',
    'tilknyttedeitsystemer',
    'tilknyttedeinteressefaellesskaber',
    'tilknyttedepersoner'
);


ALTER TYPE organisationfunktionrelationkode OWNER TO mox;

--
-- Name: organisationfunktionrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationfunktionrelationtype AS (
	reltype organisationfunktionrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text
);


ALTER TYPE organisationfunktionrelationtype OWNER TO mox;

--
-- Name: organisationfunktionregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationfunktionregistreringtype AS (
	registrering registreringbase,
	tilsgyldighed organisationfunktiongyldighedtilstype[],
	attregenskaber organisationfunktionegenskaberattrtype[],
	relationer organisationfunktionrelationtype[]
);


ALTER TYPE organisationfunktionregistreringtype OWNER TO mox;

--
-- Name: organisationfunktiontype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationfunktiontype AS (
	id uuid,
	registrering organisationfunktionregistreringtype[]
);


ALTER TYPE organisationfunktiontype OWNER TO mox;

--
-- Name: organisationgyldighedtils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationgyldighedtils AS ENUM (
    'Aktiv',
    'Inaktiv',
    ''
);


ALTER TYPE organisationgyldighedtils OWNER TO mox;

--
-- Name: organisationgyldighedtilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationgyldighedtilstype AS (
	virkning virkning,
	gyldighed organisationgyldighedtils
);


ALTER TYPE organisationgyldighedtilstype OWNER TO mox;

--
-- Name: organisationrelationkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationrelationkode AS ENUM (
    'branche',
    'myndighed',
    'myndighedstype',
    'overordnet',
    'produktionsenhed',
    'skatteenhed',
    'tilhoerer',
    'virksomhed',
    'virksomhedstype',
    'adresser',
    'ansatte',
    'opgaver',
    'tilknyttedebrugere',
    'tilknyttedeenheder',
    'tilknyttedefunktioner',
    'tilknyttedeinteressefaellesskaber',
    'tilknyttedeorganisationer',
    'tilknyttedepersoner',
    'tilknyttedeitsystemer'
);


ALTER TYPE organisationrelationkode OWNER TO mox;

--
-- Name: organisationrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationrelationtype AS (
	reltype organisationrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text
);


ALTER TYPE organisationrelationtype OWNER TO mox;

--
-- Name: organisationregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationregistreringtype AS (
	registrering registreringbase,
	tilsgyldighed organisationgyldighedtilstype[],
	attregenskaber organisationegenskaberattrtype[],
	relationer organisationrelationtype[]
);


ALTER TYPE organisationregistreringtype OWNER TO mox;

--
-- Name: organisationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE organisationtype AS (
	id uuid,
	registrering organisationregistreringtype[]
);


ALTER TYPE organisationtype OWNER TO mox;

--
-- Name: sagegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE sagegenskaberattrtype AS (
	brugervendtnoegle text,
	afleveret clearableboolean,
	beskrivelse text,
	hjemmel text,
	kassationskode text,
	offentlighedundtaget offentlighedundtagettype,
	principiel clearableboolean,
	sagsnummer text,
	titel text,
	virkning virkning
);


ALTER TYPE sagegenskaberattrtype OWNER TO mox;

--
-- Name: sagfremdrifttils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE sagfremdrifttils AS ENUM (
    'Opstaaet',
    'Oplyst',
    'Afgjort',
    'Bestilt',
    'Udfoert',
    'Afsluttet',
    ''
);


ALTER TYPE sagfremdrifttils OWNER TO mox;

--
-- Name: sagfremdrifttilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE sagfremdrifttilstype AS (
	virkning virkning,
	fremdrift sagfremdrifttils
);


ALTER TYPE sagfremdrifttilstype OWNER TO mox;

--
-- Name: sagrelationjournalpostspecifikkode; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE sagrelationjournalpostspecifikkode AS ENUM (
    'journalnotat',
    'vedlagtdokument',
    'tilakteretdokument'
);


ALTER TYPE sagrelationjournalpostspecifikkode OWNER TO mox;

--
-- Name: sagrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE sagrelationtype AS (
	reltype sagrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text,
	indeks integer,
	reltypespec sagrelationjournalpostspecifikkode,
	journalnotat journalnotattype,
	journaldokumentattr journalpostdokumentattrtype
);


ALTER TYPE sagrelationtype OWNER TO mox;

--
-- Name: sagregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE sagregistreringtype AS (
	registrering registreringbase,
	tilsfremdrift sagfremdrifttilstype[],
	attregenskaber sagegenskaberattrtype[],
	relationer sagrelationtype[]
);


ALTER TYPE sagregistreringtype OWNER TO mox;

--
-- Name: sagtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE sagtype AS (
	id uuid,
	registrering sagregistreringtype[]
);


ALTER TYPE sagtype OWNER TO mox;

--
-- Name: tilstandegenskaberattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE tilstandegenskaberattrtype AS (
	brugervendtnoegle text,
	beskrivelse text,
	virkning virkning
);


ALTER TYPE tilstandegenskaberattrtype OWNER TO mox;

--
-- Name: tilstandpublicerettils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE tilstandpublicerettils AS ENUM (
    'Publiceret',
    'IkkePubliceret',
    'Normal',
    ''
);


ALTER TYPE tilstandpublicerettils OWNER TO mox;

--
-- Name: tilstandpublicerettilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE tilstandpublicerettilstype AS (
	virkning virkning,
	publiceret tilstandpublicerettils
);


ALTER TYPE tilstandpublicerettilstype OWNER TO mox;

--
-- Name: tilstandvaerdirelationattrtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE tilstandvaerdirelationattrtype AS (
	forventet boolean,
	nominelvaerdi text
);


ALTER TYPE tilstandvaerdirelationattrtype OWNER TO mox;

--
-- Name: tilstandrelationtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE tilstandrelationtype AS (
	reltype tilstandrelationkode,
	virkning virkning,
	uuid uuid,
	urn text,
	objekttype text,
	indeks integer,
	tilstandsvaerdiattr tilstandvaerdirelationattrtype
);


ALTER TYPE tilstandrelationtype OWNER TO mox;

--
-- Name: tilstandstatustils; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE tilstandstatustils AS ENUM (
    'Inaktiv',
    'Aktiv',
    ''
);


ALTER TYPE tilstandstatustils OWNER TO mox;

--
-- Name: tilstandstatustilstype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE tilstandstatustilstype AS (
	virkning virkning,
	status tilstandstatustils
);


ALTER TYPE tilstandstatustilstype OWNER TO mox;

--
-- Name: tilstandregistreringtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE tilstandregistreringtype AS (
	registrering registreringbase,
	tilsstatus tilstandstatustilstype[],
	tilspubliceret tilstandpublicerettilstype[],
	attregenskaber tilstandegenskaberattrtype[],
	relationer tilstandrelationtype[]
);


ALTER TYPE tilstandregistreringtype OWNER TO mox;

--
-- Name: tilstandtype; Type: TYPE; Schema: actual_state; Owner: mox
--

CREATE TYPE tilstandtype AS (
	id uuid,
	registrering tilstandregistreringtype[]
);


ALTER TYPE tilstandtype OWNER TO mox;

--
-- Name: _aktivitet_aktoer_attr_repr_urn_to_text(aktivitetaktoerattr); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _aktivitet_aktoer_attr_repr_urn_to_text(aktivitetaktoerattr) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT NULLIF($1.repraesentation_urn::TEXT,'') $_$;


ALTER FUNCTION actual_state._aktivitet_aktoer_attr_repr_urn_to_text(aktivitetaktoerattr) OWNER TO mox;

--
-- Name: _aktivitet_aktoer_attr_repr_uuid_to_text(aktivitetaktoerattr); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _aktivitet_aktoer_attr_repr_uuid_to_text(aktivitetaktoerattr) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1.repraesentation_uuid::TEXT$_$;


ALTER FUNCTION actual_state._aktivitet_aktoer_attr_repr_uuid_to_text(aktivitetaktoerattr) OWNER TO mox;

--
-- Name: _as_convert_aktivitet_relation_kode_to_txt(aktivitetrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_aktivitet_relation_kode_to_txt(aktivitetrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_aktivitet_relation_kode_to_txt(aktivitetrelationkode) OWNER TO mox;

--
-- Name: _as_convert_bruger_relation_kode_to_txt(brugerrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_bruger_relation_kode_to_txt(brugerrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_bruger_relation_kode_to_txt(brugerrelationkode) OWNER TO mox;

--
-- Name: _as_convert_dokument_relation_kode_to_txt(dokumentrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_dokument_relation_kode_to_txt(dokumentrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_dokument_relation_kode_to_txt(dokumentrelationkode) OWNER TO mox;

--
-- Name: _as_convert_facet_relation_kode_to_txt(facetrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_facet_relation_kode_to_txt(facetrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_facet_relation_kode_to_txt(facetrelationkode) OWNER TO mox;

--
-- Name: _as_convert_indsats_relation_kode_to_txt(indsatsrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_indsats_relation_kode_to_txt(indsatsrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_indsats_relation_kode_to_txt(indsatsrelationkode) OWNER TO mox;

--
-- Name: _as_convert_interessefaellesskab_relation_kode_to_txt(interessefaellesskabrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_interessefaellesskab_relation_kode_to_txt(interessefaellesskabrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_interessefaellesskab_relation_kode_to_txt(interessefaellesskabrelationkode) OWNER TO mox;

--
-- Name: _as_convert_itsystem_relation_kode_to_txt(itsystemrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_itsystem_relation_kode_to_txt(itsystemrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_itsystem_relation_kode_to_txt(itsystemrelationkode) OWNER TO mox;

--
-- Name: _as_convert_klasse_relation_kode_to_txt(klasserelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_klasse_relation_kode_to_txt(klasserelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_klasse_relation_kode_to_txt(klasserelationkode) OWNER TO mox;

--
-- Name: _as_convert_klassifikation_relation_kode_to_txt(klassifikationrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_klassifikation_relation_kode_to_txt(klassifikationrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_klassifikation_relation_kode_to_txt(klassifikationrelationkode) OWNER TO mox;

--
-- Name: _as_convert_loghaendelse_relation_kode_to_txt(loghaendelserelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_loghaendelse_relation_kode_to_txt(loghaendelserelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_loghaendelse_relation_kode_to_txt(loghaendelserelationkode) OWNER TO mox;

--
-- Name: _as_convert_organisation_relation_kode_to_txt(organisationrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_organisation_relation_kode_to_txt(organisationrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_organisation_relation_kode_to_txt(organisationrelationkode) OWNER TO mox;

--
-- Name: _as_convert_organisationenhed_relation_kode_to_txt(organisationenhedrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_organisationenhed_relation_kode_to_txt(organisationenhedrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_organisationenhed_relation_kode_to_txt(organisationenhedrelationkode) OWNER TO mox;

--
-- Name: _as_convert_organisationfunktion_relation_kode_to_txt(organisationfunktionrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_organisationfunktion_relation_kode_to_txt(organisationfunktionrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_organisationfunktion_relation_kode_to_txt(organisationfunktionrelationkode) OWNER TO mox;

--
-- Name: _as_convert_sag_relation_kode_to_txt(sagrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_sag_relation_kode_to_txt(sagrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_sag_relation_kode_to_txt(sagrelationkode) OWNER TO mox;

--
-- Name: _as_convert_tilstand_relation_kode_to_txt(tilstandrelationkode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_convert_tilstand_relation_kode_to_txt(tilstandrelationkode) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT $1::text;
   $_$;


ALTER FUNCTION actual_state._as_convert_tilstand_relation_kode_to_txt(tilstandrelationkode) OWNER TO mox;

--
-- Name: aktivitet_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE aktivitet_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aktivitet_registrering_id_seq OWNER TO mox;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: aktivitet_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE aktivitet_registrering (
    id bigint DEFAULT nextval('aktivitet_registrering_id_seq'::regclass) NOT NULL,
    aktivitet_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT aktivitet_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE aktivitet_registrering OWNER TO mox;

--
-- Name: _as_create_aktivitet_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_aktivitet_registrering(aktivitet_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS aktivitet_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
aktivitet_registrering_id bigint;
aktivitet_registrering aktivitet_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE aktivitet_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE aktivitet_id = aktivitet_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating aktivitet with uuid [%], Invalid [livscyklus] transition to [%]',aktivitet_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new aktivitet registrering
 
aktivitet_registrering_id :=  nextval('aktivitet_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



aktivitet_registrering := ROW(
    aktivitet_registrering_id,
    aktivitet_uuid,
    registreringObj
)::aktivitet_registrering
;


INSERT INTO aktivitet_registrering SELECT aktivitet_registrering.*;


RETURN aktivitet_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_aktivitet_registrering(aktivitet_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: bruger_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE bruger_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE bruger_registrering_id_seq OWNER TO mox;

--
-- Name: bruger_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE bruger_registrering (
    id bigint DEFAULT nextval('bruger_registrering_id_seq'::regclass) NOT NULL,
    bruger_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT bruger_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE bruger_registrering OWNER TO mox;

--
-- Name: _as_create_bruger_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_bruger_registrering(bruger_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS bruger_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
bruger_registrering_id bigint;
bruger_registrering bruger_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE bruger_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE bruger_id = bruger_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating bruger with uuid [%], Invalid [livscyklus] transition to [%]',bruger_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new bruger registrering
 
bruger_registrering_id :=  nextval('bruger_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



bruger_registrering := ROW(
    bruger_registrering_id,
    bruger_uuid,
    registreringObj
)::bruger_registrering
;


INSERT INTO bruger_registrering SELECT bruger_registrering.*;


RETURN bruger_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_bruger_registrering(bruger_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: dokument_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE dokument_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dokument_registrering_id_seq OWNER TO mox;

--
-- Name: dokument_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE dokument_registrering (
    id bigint DEFAULT nextval('dokument_registrering_id_seq'::regclass) NOT NULL,
    dokument_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT dokument_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE dokument_registrering OWNER TO mox;

--
-- Name: _as_create_dokument_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_dokument_registrering(dokument_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS dokument_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
dokument_registrering_id bigint;
dokument_registrering dokument_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE dokument_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE dokument_id = dokument_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating dokument with uuid [%], Invalid [livscyklus] transition to [%]',dokument_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new dokument registrering
 
dokument_registrering_id :=  nextval('dokument_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



dokument_registrering := ROW(
    dokument_registrering_id,
    dokument_uuid,
    registreringObj
)::dokument_registrering
;


INSERT INTO dokument_registrering SELECT dokument_registrering.*;


RETURN dokument_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_dokument_registrering(dokument_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: facet_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE facet_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE facet_registrering_id_seq OWNER TO mox;

--
-- Name: facet_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE facet_registrering (
    id bigint DEFAULT nextval('facet_registrering_id_seq'::regclass) NOT NULL,
    facet_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT facet_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE facet_registrering OWNER TO mox;

--
-- Name: _as_create_facet_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_facet_registrering(facet_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS facet_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
facet_registrering_id bigint;
facet_registrering facet_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE facet_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE facet_id = facet_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating facet with uuid [%], Invalid [livscyklus] transition to [%]',facet_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new facet registrering
 
facet_registrering_id :=  nextval('facet_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



facet_registrering := ROW(
    facet_registrering_id,
    facet_uuid,
    registreringObj
)::facet_registrering
;


INSERT INTO facet_registrering SELECT facet_registrering.*;


RETURN facet_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_facet_registrering(facet_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: indsats_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE indsats_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE indsats_registrering_id_seq OWNER TO mox;

--
-- Name: indsats_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE indsats_registrering (
    id bigint DEFAULT nextval('indsats_registrering_id_seq'::regclass) NOT NULL,
    indsats_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT indsats_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE indsats_registrering OWNER TO mox;

--
-- Name: _as_create_indsats_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_indsats_registrering(indsats_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS indsats_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
indsats_registrering_id bigint;
indsats_registrering indsats_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE indsats_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE indsats_id = indsats_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating indsats with uuid [%], Invalid [livscyklus] transition to [%]',indsats_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new indsats registrering
 
indsats_registrering_id :=  nextval('indsats_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



indsats_registrering := ROW(
    indsats_registrering_id,
    indsats_uuid,
    registreringObj
)::indsats_registrering
;


INSERT INTO indsats_registrering SELECT indsats_registrering.*;


RETURN indsats_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_indsats_registrering(indsats_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: interessefaellesskab_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE interessefaellesskab_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE interessefaellesskab_registrering_id_seq OWNER TO mox;

--
-- Name: interessefaellesskab_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE interessefaellesskab_registrering (
    id bigint DEFAULT nextval('interessefaellesskab_registrering_id_seq'::regclass) NOT NULL,
    interessefaellesskab_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT interessefaellesskab_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE interessefaellesskab_registrering OWNER TO mox;

--
-- Name: _as_create_interessefaellesskab_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_interessefaellesskab_registrering(interessefaellesskab_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS interessefaellesskab_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
interessefaellesskab_registrering_id bigint;
interessefaellesskab_registrering interessefaellesskab_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE interessefaellesskab_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE interessefaellesskab_id = interessefaellesskab_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating interessefaellesskab with uuid [%], Invalid [livscyklus] transition to [%]',interessefaellesskab_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new interessefaellesskab registrering
 
interessefaellesskab_registrering_id :=  nextval('interessefaellesskab_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



interessefaellesskab_registrering := ROW(
    interessefaellesskab_registrering_id,
    interessefaellesskab_uuid,
    registreringObj
)::interessefaellesskab_registrering
;


INSERT INTO interessefaellesskab_registrering SELECT interessefaellesskab_registrering.*;


RETURN interessefaellesskab_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_interessefaellesskab_registrering(interessefaellesskab_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: itsystem_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE itsystem_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE itsystem_registrering_id_seq OWNER TO mox;

--
-- Name: itsystem_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE itsystem_registrering (
    id bigint DEFAULT nextval('itsystem_registrering_id_seq'::regclass) NOT NULL,
    itsystem_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT itsystem_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE itsystem_registrering OWNER TO mox;

--
-- Name: _as_create_itsystem_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_itsystem_registrering(itsystem_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS itsystem_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
itsystem_registrering_id bigint;
itsystem_registrering itsystem_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE itsystem_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE itsystem_id = itsystem_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating itsystem with uuid [%], Invalid [livscyklus] transition to [%]',itsystem_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new itsystem registrering
 
itsystem_registrering_id :=  nextval('itsystem_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



itsystem_registrering := ROW(
    itsystem_registrering_id,
    itsystem_uuid,
    registreringObj
)::itsystem_registrering
;


INSERT INTO itsystem_registrering SELECT itsystem_registrering.*;


RETURN itsystem_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_itsystem_registrering(itsystem_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: klasse_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE klasse_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE klasse_registrering_id_seq OWNER TO mox;

--
-- Name: klasse_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE klasse_registrering (
    id bigint DEFAULT nextval('klasse_registrering_id_seq'::regclass) NOT NULL,
    klasse_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT klasse_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE klasse_registrering OWNER TO mox;

--
-- Name: _as_create_klasse_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_klasse_registrering(klasse_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS klasse_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
klasse_registrering_id bigint;
klasse_registrering klasse_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE klasse_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE klasse_id = klasse_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating klasse with uuid [%], Invalid [livscyklus] transition to [%]',klasse_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new klasse registrering
 
klasse_registrering_id :=  nextval('klasse_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



klasse_registrering := ROW(
    klasse_registrering_id,
    klasse_uuid,
    registreringObj
)::klasse_registrering
;


INSERT INTO klasse_registrering SELECT klasse_registrering.*;


RETURN klasse_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_klasse_registrering(klasse_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: klassifikation_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE klassifikation_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE klassifikation_registrering_id_seq OWNER TO mox;

--
-- Name: klassifikation_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE klassifikation_registrering (
    id bigint DEFAULT nextval('klassifikation_registrering_id_seq'::regclass) NOT NULL,
    klassifikation_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT klassifikation_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE klassifikation_registrering OWNER TO mox;

--
-- Name: _as_create_klassifikation_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_klassifikation_registrering(klassifikation_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS klassifikation_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
klassifikation_registrering_id bigint;
klassifikation_registrering klassifikation_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE klassifikation_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE klassifikation_id = klassifikation_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating klassifikation with uuid [%], Invalid [livscyklus] transition to [%]',klassifikation_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new klassifikation registrering
 
klassifikation_registrering_id :=  nextval('klassifikation_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



klassifikation_registrering := ROW(
    klassifikation_registrering_id,
    klassifikation_uuid,
    registreringObj
)::klassifikation_registrering
;


INSERT INTO klassifikation_registrering SELECT klassifikation_registrering.*;


RETURN klassifikation_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_klassifikation_registrering(klassifikation_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: loghaendelse_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE loghaendelse_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE loghaendelse_registrering_id_seq OWNER TO mox;

--
-- Name: loghaendelse_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE loghaendelse_registrering (
    id bigint DEFAULT nextval('loghaendelse_registrering_id_seq'::regclass) NOT NULL,
    loghaendelse_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT loghaendelse_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE loghaendelse_registrering OWNER TO mox;

--
-- Name: _as_create_loghaendelse_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_loghaendelse_registrering(loghaendelse_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS loghaendelse_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
loghaendelse_registrering_id bigint;
loghaendelse_registrering loghaendelse_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE loghaendelse_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE loghaendelse_id = loghaendelse_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating loghaendelse with uuid [%], Invalid [livscyklus] transition to [%]',loghaendelse_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new loghaendelse registrering
 
loghaendelse_registrering_id :=  nextval('loghaendelse_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



loghaendelse_registrering := ROW(
    loghaendelse_registrering_id,
    loghaendelse_uuid,
    registreringObj
)::loghaendelse_registrering
;


INSERT INTO loghaendelse_registrering SELECT loghaendelse_registrering.*;


RETURN loghaendelse_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_loghaendelse_registrering(loghaendelse_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: organisation_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE organisation_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE organisation_registrering_id_seq OWNER TO mox;

--
-- Name: organisation_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisation_registrering (
    id bigint DEFAULT nextval('organisation_registrering_id_seq'::regclass) NOT NULL,
    organisation_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT organisation_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE organisation_registrering OWNER TO mox;

--
-- Name: _as_create_organisation_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_organisation_registrering(organisation_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS organisation_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
organisation_registrering_id bigint;
organisation_registrering organisation_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE organisation_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE organisation_id = organisation_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating organisation with uuid [%], Invalid [livscyklus] transition to [%]',organisation_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new organisation registrering
 
organisation_registrering_id :=  nextval('organisation_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



organisation_registrering := ROW(
    organisation_registrering_id,
    organisation_uuid,
    registreringObj
)::organisation_registrering
;


INSERT INTO organisation_registrering SELECT organisation_registrering.*;


RETURN organisation_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_organisation_registrering(organisation_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: organisationenhed_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE organisationenhed_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE organisationenhed_registrering_id_seq OWNER TO mox;

--
-- Name: organisationenhed_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisationenhed_registrering (
    id bigint DEFAULT nextval('organisationenhed_registrering_id_seq'::regclass) NOT NULL,
    organisationenhed_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT organisationenhed_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE organisationenhed_registrering OWNER TO mox;

--
-- Name: _as_create_organisationenhed_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_organisationenhed_registrering(organisationenhed_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS organisationenhed_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
organisationenhed_registrering_id bigint;
organisationenhed_registrering organisationenhed_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE organisationenhed_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE organisationenhed_id = organisationenhed_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating organisationenhed with uuid [%], Invalid [livscyklus] transition to [%]',organisationenhed_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new organisationenhed registrering
 
organisationenhed_registrering_id :=  nextval('organisationenhed_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



organisationenhed_registrering := ROW(
    organisationenhed_registrering_id,
    organisationenhed_uuid,
    registreringObj
)::organisationenhed_registrering
;


INSERT INTO organisationenhed_registrering SELECT organisationenhed_registrering.*;


RETURN organisationenhed_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_organisationenhed_registrering(organisationenhed_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: organisationfunktion_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE organisationfunktion_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE organisationfunktion_registrering_id_seq OWNER TO mox;

--
-- Name: organisationfunktion_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisationfunktion_registrering (
    id bigint DEFAULT nextval('organisationfunktion_registrering_id_seq'::regclass) NOT NULL,
    organisationfunktion_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT organisationfunktion_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE organisationfunktion_registrering OWNER TO mox;

--
-- Name: _as_create_organisationfunktion_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_organisationfunktion_registrering(organisationfunktion_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS organisationfunktion_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
organisationfunktion_registrering_id bigint;
organisationfunktion_registrering organisationfunktion_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE organisationfunktion_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE organisationfunktion_id = organisationfunktion_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating organisationfunktion with uuid [%], Invalid [livscyklus] transition to [%]',organisationfunktion_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new organisationfunktion registrering
 
organisationfunktion_registrering_id :=  nextval('organisationfunktion_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



organisationfunktion_registrering := ROW(
    organisationfunktion_registrering_id,
    organisationfunktion_uuid,
    registreringObj
)::organisationfunktion_registrering
;


INSERT INTO organisationfunktion_registrering SELECT organisationfunktion_registrering.*;


RETURN organisationfunktion_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_organisationfunktion_registrering(organisationfunktion_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: sag_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE sag_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sag_registrering_id_seq OWNER TO mox;

--
-- Name: sag_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE sag_registrering (
    id bigint DEFAULT nextval('sag_registrering_id_seq'::regclass) NOT NULL,
    sag_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT sag_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE sag_registrering OWNER TO mox;

--
-- Name: _as_create_sag_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_sag_registrering(sag_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS sag_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
sag_registrering_id bigint;
sag_registrering sag_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE sag_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE sag_id = sag_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating sag with uuid [%], Invalid [livscyklus] transition to [%]',sag_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new sag registrering
 
sag_registrering_id :=  nextval('sag_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



sag_registrering := ROW(
    sag_registrering_id,
    sag_uuid,
    registreringObj
)::sag_registrering
;


INSERT INTO sag_registrering SELECT sag_registrering.*;


RETURN sag_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_sag_registrering(sag_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: tilstand_registrering_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE tilstand_registrering_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tilstand_registrering_id_seq OWNER TO mox;

--
-- Name: tilstand_registrering; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE tilstand_registrering (
    id bigint DEFAULT nextval('tilstand_registrering_id_seq'::regclass) NOT NULL,
    tilstand_id uuid NOT NULL,
    registrering registreringbase NOT NULL,
    CONSTRAINT tilstand_registrering_registrering_check CHECK ((((registrering).timeperiod IS NOT NULL) AND (NOT isempty((registrering).timeperiod))))
);


ALTER TABLE tilstand_registrering OWNER TO mox;

--
-- Name: _as_create_tilstand_registrering(uuid, livscykluskode, uuid, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_create_tilstand_registrering(tilstand_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text DEFAULT ''::text) RETURNS tilstand_registrering
    LANGUAGE plpgsql
    AS $$
DECLARE
registreringTime        TIMESTAMPTZ := clock_timestamp();
registreringObj RegistreringBase;
rows_affected int;
tilstand_registrering_id bigint;
tilstand_registrering tilstand_registrering;
BEGIN

--limit the scope of the current unlimited registrering

UPDATE tilstand_registrering as a
    SET registrering.timeperiod =
      TSTZRANGE(lower((registrering).timeperiod), registreringTime, 
    concat(
            CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
            ')'
        ))
    WHERE tilstand_id = tilstand_uuid 
    AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
    AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.     

;


GET DIAGNOSTICS rows_affected = ROW_COUNT;

IF rows_affected=0 THEN
  RAISE EXCEPTION 'Error updating tilstand with uuid [%], Invalid [livscyklus] transition to [%]',tilstand_uuid,livscykluskode USING ERRCODE = 'MO400';
END IF;

--create a new tilstand registrering
 
tilstand_registrering_id :=  nextval('tilstand_registrering_id_seq'::regclass);

 registreringObj := ROW (
      TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
      livscykluskode,
      brugerref,
      note
  ) :: RegistreringBase
 ;



tilstand_registrering := ROW(
    tilstand_registrering_id,
    tilstand_uuid,
    registreringObj
)::tilstand_registrering
;


INSERT INTO tilstand_registrering SELECT tilstand_registrering.*;


RETURN tilstand_registrering;

END;
$$;


ALTER FUNCTION actual_state._as_create_tilstand_registrering(tilstand_uuid uuid, livscykluskode livscykluskode, brugerref uuid, note text) OWNER TO mox;

--
-- Name: _as_filter_unauth_aktivitet(uuid[], aktivitetregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_aktivitet(aktivitet_uuids uuid[], registreringobjarr aktivitetregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	aktivitet_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	aktivitet_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj AktivitetEgenskaberAttrType;
	
  	tilsStatusTypeObj AktivitetStatusTilsType;
  	tilsPubliceretTypeObj AktivitetPubliceretTilsType;
	relationTypeObj AktivitetRelationType;
	registreringObj AktivitetRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN aktivitet_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF aktivitet_uuids IS NULL OR  coalesce(array_length(aktivitet_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

aktivitet_candidates:= aktivitet_uuids;



--RAISE DEBUG 'aktivitet_candidates_is_initialized step 1:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 1:%',aktivitet_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_aktivitet: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(aktivitet_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_attr_egenskaber a 
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.aktivitetnavn IS NULL
					OR 
					a.aktivitetnavn = attrEgenskaberTypeObj.aktivitetnavn 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.starttidspunkt IS NULL
					OR 
					a.starttidspunkt = attrEgenskaberTypeObj.starttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.sluttidspunkt IS NULL
					OR 
					a.sluttidspunkt = attrEgenskaberTypeObj.sluttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.tidsforbrug IS NULL
					OR 
					a.tidsforbrug = attrEgenskaberTypeObj.tidsforbrug 
				)
				AND
				(
					attrEgenskaberTypeObj.formaal IS NULL
					OR 
					a.formaal = attrEgenskaberTypeObj.formaal 
				)
				AND b.aktivitet_id = ANY (aktivitet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'aktivitet_candidates_is_initialized step 3:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 3:%',aktivitet_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Status
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsStatus IS NULL THEN
	--RAISE DEBUG 'as_search_aktivitet: skipping filtration on tilsStatus';
ELSE
	IF coalesce(array_length(aktivitet_candidates,1),0)>0 THEN 

		FOREACH tilsStatusTypeObj IN ARRAY registreringObj.tilsStatus
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_tils_status a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsStatusTypeObj.status IS NULL
					OR
					tilsStatusTypeObj.status = a.status
				)
				AND b.aktivitet_id = ANY (aktivitet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;
--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_aktivitet: skipping filtration on tilsPubliceret';
ELSE
	IF coalesce(array_length(aktivitet_candidates,1),0)>0 THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_tils_publiceret a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND b.aktivitet_id = ANY (aktivitet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer AktivitetRelationType[]
*/


--RAISE DEBUG 'aktivitet_candidates_is_initialized step 4:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 4:%',aktivitet_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_aktivitet: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(aktivitet_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_relation a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.aktivitet_id = ANY (aktivitet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'aktivitet_candidates_is_initialized step 5:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 5:%',aktivitet_candidates;

aktivitet_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (aktivitet_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (aktivitet_candidates) b(id)
);

--optimization 
IF coalesce(array_length(aktivitet_passed_auth_filter,1),0)=coalesce(array_length(aktivitet_uuids,1),0) AND aktivitet_passed_auth_filter @>aktivitet_uuids THEN
	RETURN aktivitet_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN aktivitet_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_aktivitet(aktivitet_uuids uuid[], registreringobjarr aktivitetregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_bruger(uuid[], brugerregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_bruger(bruger_uuids uuid[], registreringobjarr brugerregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	bruger_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	bruger_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj BrugerEgenskaberAttrType;
	
  	tilsGyldighedTypeObj BrugerGyldighedTilsType;
	relationTypeObj BrugerRelationType;
	registreringObj BrugerRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN bruger_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF bruger_uuids IS NULL OR  coalesce(array_length(bruger_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

bruger_candidates:= bruger_uuids;



--RAISE DEBUG 'bruger_candidates_is_initialized step 1:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 1:%',bruger_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_bruger: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(bruger_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			bruger_candidates:=array(
			SELECT DISTINCT
			b.bruger_id 
			FROM  bruger_attr_egenskaber a 
			JOIN bruger_registrering b on a.bruger_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.brugernavn IS NULL
					OR 
					a.brugernavn = attrEgenskaberTypeObj.brugernavn 
				)
				AND
				(
					attrEgenskaberTypeObj.brugertype IS NULL
					OR 
					a.brugertype = attrEgenskaberTypeObj.brugertype 
				)
				AND b.bruger_id = ANY (bruger_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'bruger_candidates_is_initialized step 3:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 3:%',bruger_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_bruger: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(bruger_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			bruger_candidates:=array(
			SELECT DISTINCT
			b.bruger_id 
			FROM  bruger_tils_gyldighed a
			JOIN bruger_registrering b on a.bruger_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.bruger_id = ANY (bruger_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer BrugerRelationType[]
*/


--RAISE DEBUG 'bruger_candidates_is_initialized step 4:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 4:%',bruger_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_bruger: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(bruger_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			bruger_candidates:=array(
			SELECT DISTINCT
			b.bruger_id 
			FROM  bruger_relation a
			JOIN bruger_registrering b on a.bruger_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.bruger_id = ANY (bruger_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'bruger_candidates_is_initialized step 5:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 5:%',bruger_candidates;

bruger_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (bruger_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (bruger_candidates) b(id)
);

--optimization 
IF coalesce(array_length(bruger_passed_auth_filter,1),0)=coalesce(array_length(bruger_uuids,1),0) AND bruger_passed_auth_filter @>bruger_uuids THEN
	RETURN bruger_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN bruger_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_bruger(bruger_uuids uuid[], registreringobjarr brugerregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_dokument(uuid[], dokumentregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_dokument(dokument_uuids uuid[], registreringobjarr dokumentregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	dokument_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	dokument_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj DokumentEgenskaberAttrType;
	
  	tilsFremdriftTypeObj DokumentFremdriftTilsType;
	relationTypeObj DokumentRelationType;
	registreringObj DokumentRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN dokument_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF dokument_uuids IS NULL OR  coalesce(array_length(dokument_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

dokument_candidates:= dokument_uuids;



--RAISE DEBUG 'dokument_candidates_is_initialized step 1:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 1:%',dokument_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_dokument: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(dokument_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
			FROM  dokument_attr_egenskaber a 
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.brevdato IS NULL
					OR 
					a.brevdato = attrEgenskaberTypeObj.brevdato 
				)
				AND
				(
					attrEgenskaberTypeObj.kassationskode IS NULL
					OR 
					a.kassationskode = attrEgenskaberTypeObj.kassationskode 
				)
				AND
				(
					attrEgenskaberTypeObj.major IS NULL
					OR 
					a.major = attrEgenskaberTypeObj.major 
				)
				AND
				(
					attrEgenskaberTypeObj.minor IS NULL
					OR 
					a.minor = attrEgenskaberTypeObj.minor 
				)
				AND
				(
					attrEgenskaberTypeObj.offentlighedundtaget IS NULL
					OR
						(
							(
								(attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel IS NULL
								OR
								(a.offentlighedundtaget).AlternativTitel = (attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel 
							)
							AND
							(
								(attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel IS NULL
								OR
								(a.offentlighedundtaget).Hjemmel = (attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel
							)
						) 
				)
				AND
				(
					attrEgenskaberTypeObj.titel IS NULL
					OR 
					a.titel = attrEgenskaberTypeObj.titel 
				)
				AND
				(
					attrEgenskaberTypeObj.dokumenttype IS NULL
					OR 
					a.dokumenttype = attrEgenskaberTypeObj.dokumenttype 
				)
				AND b.dokument_id = ANY (dokument_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'dokument_candidates_is_initialized step 3:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 3:%',dokument_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Fremdrift
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsFremdrift IS NULL THEN
	--RAISE DEBUG 'as_search_dokument: skipping filtration on tilsFremdrift';
ELSE
	IF coalesce(array_length(dokument_candidates,1),0)>0 THEN 

		FOREACH tilsFremdriftTypeObj IN ARRAY registreringObj.tilsFremdrift
		LOOP
			dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
			FROM  dokument_tils_fremdrift a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsFremdriftTypeObj.fremdrift IS NULL
					OR
					tilsFremdriftTypeObj.fremdrift = a.fremdrift
				)
				AND b.dokument_id = ANY (dokument_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer DokumentRelationType[]
*/


--RAISE DEBUG 'dokument_candidates_is_initialized step 4:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 4:%',dokument_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_dokument: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(dokument_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
			FROM  dokument_relation a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.dokument_id = ANY (dokument_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'dokument_candidates_is_initialized step 5:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 5:%',dokument_candidates;

dokument_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (dokument_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (dokument_candidates) b(id)
);

--optimization 
IF coalesce(array_length(dokument_passed_auth_filter,1),0)=coalesce(array_length(dokument_uuids,1),0) AND dokument_passed_auth_filter @>dokument_uuids THEN
	RETURN dokument_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN dokument_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_dokument(dokument_uuids uuid[], registreringobjarr dokumentregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_facet(uuid[], facetregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_facet(facet_uuids uuid[], registreringobjarr facetregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	facet_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	facet_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj FacetEgenskaberAttrType;
	
  	tilsPubliceretTypeObj FacetPubliceretTilsType;
	relationTypeObj FacetRelationType;
	registreringObj FacetRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN facet_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF facet_uuids IS NULL OR  coalesce(array_length(facet_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

facet_candidates:= facet_uuids;



--RAISE DEBUG 'facet_candidates_is_initialized step 1:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 1:%',facet_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_facet: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(facet_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			facet_candidates:=array(
			SELECT DISTINCT
			b.facet_id 
			FROM  facet_attr_egenskaber a 
			JOIN facet_registrering b on a.facet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.opbygning IS NULL
					OR 
					a.opbygning = attrEgenskaberTypeObj.opbygning 
				)
				AND
				(
					attrEgenskaberTypeObj.ophavsret IS NULL
					OR 
					a.ophavsret = attrEgenskaberTypeObj.ophavsret 
				)
				AND
				(
					attrEgenskaberTypeObj.plan IS NULL
					OR 
					a.plan = attrEgenskaberTypeObj.plan 
				)
				AND
				(
					attrEgenskaberTypeObj.supplement IS NULL
					OR 
					a.supplement = attrEgenskaberTypeObj.supplement 
				)
				AND
				(
					attrEgenskaberTypeObj.retskilde IS NULL
					OR 
					a.retskilde = attrEgenskaberTypeObj.retskilde 
				)
				AND b.facet_id = ANY (facet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'facet_candidates_is_initialized step 3:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 3:%',facet_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_facet: skipping filtration on tilsPubliceret';
ELSE
	IF coalesce(array_length(facet_candidates,1),0)>0 THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			facet_candidates:=array(
			SELECT DISTINCT
			b.facet_id 
			FROM  facet_tils_publiceret a
			JOIN facet_registrering b on a.facet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND b.facet_id = ANY (facet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer FacetRelationType[]
*/


--RAISE DEBUG 'facet_candidates_is_initialized step 4:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 4:%',facet_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_facet: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(facet_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			facet_candidates:=array(
			SELECT DISTINCT
			b.facet_id 
			FROM  facet_relation a
			JOIN facet_registrering b on a.facet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.facet_id = ANY (facet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'facet_candidates_is_initialized step 5:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 5:%',facet_candidates;

facet_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (facet_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (facet_candidates) b(id)
);

--optimization 
IF coalesce(array_length(facet_passed_auth_filter,1),0)=coalesce(array_length(facet_uuids,1),0) AND facet_passed_auth_filter @>facet_uuids THEN
	RETURN facet_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN facet_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_facet(facet_uuids uuid[], registreringobjarr facetregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_indsats(uuid[], indsatsregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_indsats(indsats_uuids uuid[], registreringobjarr indsatsregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	indsats_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	indsats_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj IndsatsEgenskaberAttrType;
	
  	tilsPubliceretTypeObj IndsatsPubliceretTilsType;
  	tilsFremdriftTypeObj IndsatsFremdriftTilsType;
	relationTypeObj IndsatsRelationType;
	registreringObj IndsatsRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN indsats_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF indsats_uuids IS NULL OR  coalesce(array_length(indsats_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

indsats_candidates:= indsats_uuids;



--RAISE DEBUG 'indsats_candidates_is_initialized step 1:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 1:%',indsats_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_indsats: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(indsats_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_attr_egenskaber a 
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.starttidspunkt IS NULL
					OR 
					a.starttidspunkt = attrEgenskaberTypeObj.starttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.sluttidspunkt IS NULL
					OR 
					a.sluttidspunkt = attrEgenskaberTypeObj.sluttidspunkt 
				)
				AND b.indsats_id = ANY (indsats_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'indsats_candidates_is_initialized step 3:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 3:%',indsats_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_indsats: skipping filtration on tilsPubliceret';
ELSE
	IF coalesce(array_length(indsats_candidates,1),0)>0 THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_tils_publiceret a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND b.indsats_id = ANY (indsats_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;
--/**********************************************************//
--Filtration on state: Fremdrift
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsFremdrift IS NULL THEN
	--RAISE DEBUG 'as_search_indsats: skipping filtration on tilsFremdrift';
ELSE
	IF coalesce(array_length(indsats_candidates,1),0)>0 THEN 

		FOREACH tilsFremdriftTypeObj IN ARRAY registreringObj.tilsFremdrift
		LOOP
			indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_tils_fremdrift a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsFremdriftTypeObj.fremdrift IS NULL
					OR
					tilsFremdriftTypeObj.fremdrift = a.fremdrift
				)
				AND b.indsats_id = ANY (indsats_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer IndsatsRelationType[]
*/


--RAISE DEBUG 'indsats_candidates_is_initialized step 4:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 4:%',indsats_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_indsats: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(indsats_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_relation a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.indsats_id = ANY (indsats_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'indsats_candidates_is_initialized step 5:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 5:%',indsats_candidates;

indsats_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (indsats_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (indsats_candidates) b(id)
);

--optimization 
IF coalesce(array_length(indsats_passed_auth_filter,1),0)=coalesce(array_length(indsats_uuids,1),0) AND indsats_passed_auth_filter @>indsats_uuids THEN
	RETURN indsats_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN indsats_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_indsats(indsats_uuids uuid[], registreringobjarr indsatsregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_interessefaellesskab(uuid[], interessefaellesskabregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_interessefaellesskab(interessefaellesskab_uuids uuid[], registreringobjarr interessefaellesskabregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	interessefaellesskab_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	interessefaellesskab_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj InteressefaellesskabEgenskaberAttrType;
	
  	tilsGyldighedTypeObj InteressefaellesskabGyldighedTilsType;
	relationTypeObj InteressefaellesskabRelationType;
	registreringObj InteressefaellesskabRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN interessefaellesskab_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF interessefaellesskab_uuids IS NULL OR  coalesce(array_length(interessefaellesskab_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

interessefaellesskab_candidates:= interessefaellesskab_uuids;



--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 1:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 1:%',interessefaellesskab_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_interessefaellesskab: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(interessefaellesskab_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			interessefaellesskab_candidates:=array(
			SELECT DISTINCT
			b.interessefaellesskab_id 
			FROM  interessefaellesskab_attr_egenskaber a 
			JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.interessefaellesskabsnavn IS NULL
					OR 
					a.interessefaellesskabsnavn = attrEgenskaberTypeObj.interessefaellesskabsnavn 
				)
				AND
				(
					attrEgenskaberTypeObj.interessefaellesskabstype IS NULL
					OR 
					a.interessefaellesskabstype = attrEgenskaberTypeObj.interessefaellesskabstype 
				)
				AND b.interessefaellesskab_id = ANY (interessefaellesskab_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 3:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 3:%',interessefaellesskab_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_interessefaellesskab: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(interessefaellesskab_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			interessefaellesskab_candidates:=array(
			SELECT DISTINCT
			b.interessefaellesskab_id 
			FROM  interessefaellesskab_tils_gyldighed a
			JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.interessefaellesskab_id = ANY (interessefaellesskab_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer InteressefaellesskabRelationType[]
*/


--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 4:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 4:%',interessefaellesskab_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_interessefaellesskab: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(interessefaellesskab_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			interessefaellesskab_candidates:=array(
			SELECT DISTINCT
			b.interessefaellesskab_id 
			FROM  interessefaellesskab_relation a
			JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.interessefaellesskab_id = ANY (interessefaellesskab_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 5:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 5:%',interessefaellesskab_candidates;

interessefaellesskab_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (interessefaellesskab_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (interessefaellesskab_candidates) b(id)
);

--optimization 
IF coalesce(array_length(interessefaellesskab_passed_auth_filter,1),0)=coalesce(array_length(interessefaellesskab_uuids,1),0) AND interessefaellesskab_passed_auth_filter @>interessefaellesskab_uuids THEN
	RETURN interessefaellesskab_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN interessefaellesskab_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_interessefaellesskab(interessefaellesskab_uuids uuid[], registreringobjarr interessefaellesskabregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_itsystem(uuid[], itsystemregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_itsystem(itsystem_uuids uuid[], registreringobjarr itsystemregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	itsystem_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	itsystem_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj ItsystemEgenskaberAttrType;
	
  	tilsGyldighedTypeObj ItsystemGyldighedTilsType;
	relationTypeObj ItsystemRelationType;
	registreringObj ItsystemRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN itsystem_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF itsystem_uuids IS NULL OR  coalesce(array_length(itsystem_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

itsystem_candidates:= itsystem_uuids;



--RAISE DEBUG 'itsystem_candidates_is_initialized step 1:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 1:%',itsystem_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_itsystem: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(itsystem_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			itsystem_candidates:=array(
			SELECT DISTINCT
			b.itsystem_id 
			FROM  itsystem_attr_egenskaber a 
			JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.itsystemnavn IS NULL
					OR 
					a.itsystemnavn = attrEgenskaberTypeObj.itsystemnavn 
				)
				AND
				(
					attrEgenskaberTypeObj.itsystemtype IS NULL
					OR 
					a.itsystemtype = attrEgenskaberTypeObj.itsystemtype 
				)
				AND
				(
					attrEgenskaberTypeObj.konfigurationreference IS NULL
					OR
						( (coalesce(array_length(attrEgenskaberTypeObj.konfigurationreference,1),0)=0 AND coalesce(array_length(a.konfigurationreference,1),0)=0 ) OR (attrEgenskaberTypeObj.konfigurationreference @> a.konfigurationreference AND a.konfigurationreference @>attrEgenskaberTypeObj.konfigurationreference  )) 
				)
				AND b.itsystem_id = ANY (itsystem_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'itsystem_candidates_is_initialized step 3:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 3:%',itsystem_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_itsystem: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(itsystem_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			itsystem_candidates:=array(
			SELECT DISTINCT
			b.itsystem_id 
			FROM  itsystem_tils_gyldighed a
			JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.itsystem_id = ANY (itsystem_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer ItsystemRelationType[]
*/


--RAISE DEBUG 'itsystem_candidates_is_initialized step 4:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 4:%',itsystem_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_itsystem: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(itsystem_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			itsystem_candidates:=array(
			SELECT DISTINCT
			b.itsystem_id 
			FROM  itsystem_relation a
			JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.itsystem_id = ANY (itsystem_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'itsystem_candidates_is_initialized step 5:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 5:%',itsystem_candidates;

itsystem_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (itsystem_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (itsystem_candidates) b(id)
);

--optimization 
IF coalesce(array_length(itsystem_passed_auth_filter,1),0)=coalesce(array_length(itsystem_uuids,1),0) AND itsystem_passed_auth_filter @>itsystem_uuids THEN
	RETURN itsystem_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN itsystem_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_itsystem(itsystem_uuids uuid[], registreringobjarr itsystemregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_klasse(uuid[], klasseregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_klasse(klasse_uuids uuid[], registreringobjarr klasseregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	klasse_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	klasse_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj KlasseEgenskaberAttrType;
	
  	tilsPubliceretTypeObj KlassePubliceretTilsType;
	relationTypeObj KlasseRelationType;
	registreringObj KlasseRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN klasse_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF klasse_uuids IS NULL OR  coalesce(array_length(klasse_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

klasse_candidates:= klasse_uuids;



--RAISE DEBUG 'klasse_candidates_is_initialized step 1:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 1:%',klasse_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_klasse: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(klasse_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			klasse_candidates:=array(
			SELECT DISTINCT
			b.klasse_id 
			FROM  klasse_attr_egenskaber a 
			JOIN klasse_registrering b on a.klasse_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.eksempel IS NULL
					OR 
					a.eksempel = attrEgenskaberTypeObj.eksempel 
				)
				AND
				(
					attrEgenskaberTypeObj.omfang IS NULL
					OR 
					a.omfang = attrEgenskaberTypeObj.omfang 
				)
				AND
				(
					attrEgenskaberTypeObj.titel IS NULL
					OR 
					a.titel = attrEgenskaberTypeObj.titel 
				)
				AND
				(
					attrEgenskaberTypeObj.retskilde IS NULL
					OR 
					a.retskilde = attrEgenskaberTypeObj.retskilde 
				)
				AND
				(
					attrEgenskaberTypeObj.aendringsnotat IS NULL
					OR 
					a.aendringsnotat = attrEgenskaberTypeObj.aendringsnotat 
				)
				AND b.klasse_id = ANY (klasse_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'klasse_candidates_is_initialized step 3:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 3:%',klasse_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_klasse: skipping filtration on tilsPubliceret';
ELSE
	IF coalesce(array_length(klasse_candidates,1),0)>0 THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			klasse_candidates:=array(
			SELECT DISTINCT
			b.klasse_id 
			FROM  klasse_tils_publiceret a
			JOIN klasse_registrering b on a.klasse_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND b.klasse_id = ANY (klasse_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer KlasseRelationType[]
*/


--RAISE DEBUG 'klasse_candidates_is_initialized step 4:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 4:%',klasse_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_klasse: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(klasse_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			klasse_candidates:=array(
			SELECT DISTINCT
			b.klasse_id 
			FROM  klasse_relation a
			JOIN klasse_registrering b on a.klasse_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.klasse_id = ANY (klasse_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'klasse_candidates_is_initialized step 5:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 5:%',klasse_candidates;

klasse_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (klasse_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (klasse_candidates) b(id)
);

--optimization 
IF coalesce(array_length(klasse_passed_auth_filter,1),0)=coalesce(array_length(klasse_uuids,1),0) AND klasse_passed_auth_filter @>klasse_uuids THEN
	RETURN klasse_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN klasse_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_klasse(klasse_uuids uuid[], registreringobjarr klasseregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_klassifikation(uuid[], klassifikationregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_klassifikation(klassifikation_uuids uuid[], registreringobjarr klassifikationregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	klassifikation_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	klassifikation_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj KlassifikationEgenskaberAttrType;
	
  	tilsPubliceretTypeObj KlassifikationPubliceretTilsType;
	relationTypeObj KlassifikationRelationType;
	registreringObj KlassifikationRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN klassifikation_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF klassifikation_uuids IS NULL OR  coalesce(array_length(klassifikation_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

klassifikation_candidates:= klassifikation_uuids;



--RAISE DEBUG 'klassifikation_candidates_is_initialized step 1:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 1:%',klassifikation_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_klassifikation: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(klassifikation_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			klassifikation_candidates:=array(
			SELECT DISTINCT
			b.klassifikation_id 
			FROM  klassifikation_attr_egenskaber a 
			JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.kaldenavn IS NULL
					OR 
					a.kaldenavn = attrEgenskaberTypeObj.kaldenavn 
				)
				AND
				(
					attrEgenskaberTypeObj.ophavsret IS NULL
					OR 
					a.ophavsret = attrEgenskaberTypeObj.ophavsret 
				)
				AND b.klassifikation_id = ANY (klassifikation_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'klassifikation_candidates_is_initialized step 3:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 3:%',klassifikation_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_klassifikation: skipping filtration on tilsPubliceret';
ELSE
	IF coalesce(array_length(klassifikation_candidates,1),0)>0 THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			klassifikation_candidates:=array(
			SELECT DISTINCT
			b.klassifikation_id 
			FROM  klassifikation_tils_publiceret a
			JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND b.klassifikation_id = ANY (klassifikation_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer KlassifikationRelationType[]
*/


--RAISE DEBUG 'klassifikation_candidates_is_initialized step 4:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 4:%',klassifikation_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_klassifikation: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(klassifikation_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			klassifikation_candidates:=array(
			SELECT DISTINCT
			b.klassifikation_id 
			FROM  klassifikation_relation a
			JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.klassifikation_id = ANY (klassifikation_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'klassifikation_candidates_is_initialized step 5:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 5:%',klassifikation_candidates;

klassifikation_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (klassifikation_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (klassifikation_candidates) b(id)
);

--optimization 
IF coalesce(array_length(klassifikation_passed_auth_filter,1),0)=coalesce(array_length(klassifikation_uuids,1),0) AND klassifikation_passed_auth_filter @>klassifikation_uuids THEN
	RETURN klassifikation_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN klassifikation_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_klassifikation(klassifikation_uuids uuid[], registreringobjarr klassifikationregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_loghaendelse(uuid[], loghaendelseregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_loghaendelse(loghaendelse_uuids uuid[], registreringobjarr loghaendelseregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	loghaendelse_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	loghaendelse_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj LoghaendelseEgenskaberAttrType;
	
  	tilsGyldighedTypeObj LoghaendelseGyldighedTilsType;
	relationTypeObj LoghaendelseRelationType;
	registreringObj LoghaendelseRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN loghaendelse_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF loghaendelse_uuids IS NULL OR  coalesce(array_length(loghaendelse_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

loghaendelse_candidates:= loghaendelse_uuids;



--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 1:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 1:%',loghaendelse_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_loghaendelse: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(loghaendelse_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			loghaendelse_candidates:=array(
			SELECT DISTINCT
			b.loghaendelse_id 
			FROM  loghaendelse_attr_egenskaber a 
			JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.service IS NULL
					OR 
					a.service = attrEgenskaberTypeObj.service 
				)
				AND
				(
					attrEgenskaberTypeObj.klasse IS NULL
					OR 
					a.klasse = attrEgenskaberTypeObj.klasse 
				)
				AND
				(
					attrEgenskaberTypeObj.tidspunkt IS NULL
					OR 
					a.tidspunkt = attrEgenskaberTypeObj.tidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.operation IS NULL
					OR 
					a.operation = attrEgenskaberTypeObj.operation 
				)
				AND
				(
					attrEgenskaberTypeObj.objekttype IS NULL
					OR 
					a.objekttype = attrEgenskaberTypeObj.objekttype 
				)
				AND
				(
					attrEgenskaberTypeObj.returkode IS NULL
					OR 
					a.returkode = attrEgenskaberTypeObj.returkode 
				)
				AND
				(
					attrEgenskaberTypeObj.returtekst IS NULL
					OR 
					a.returtekst = attrEgenskaberTypeObj.returtekst 
				)
				AND
				(
					attrEgenskaberTypeObj.note IS NULL
					OR 
					a.note = attrEgenskaberTypeObj.note 
				)
				AND b.loghaendelse_id = ANY (loghaendelse_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 3:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 3:%',loghaendelse_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_loghaendelse: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(loghaendelse_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			loghaendelse_candidates:=array(
			SELECT DISTINCT
			b.loghaendelse_id 
			FROM  loghaendelse_tils_gyldighed a
			JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.loghaendelse_id = ANY (loghaendelse_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer LoghaendelseRelationType[]
*/


--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 4:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 4:%',loghaendelse_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_loghaendelse: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(loghaendelse_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			loghaendelse_candidates:=array(
			SELECT DISTINCT
			b.loghaendelse_id 
			FROM  loghaendelse_relation a
			JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.loghaendelse_id = ANY (loghaendelse_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 5:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 5:%',loghaendelse_candidates;

loghaendelse_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (loghaendelse_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (loghaendelse_candidates) b(id)
);

--optimization 
IF coalesce(array_length(loghaendelse_passed_auth_filter,1),0)=coalesce(array_length(loghaendelse_uuids,1),0) AND loghaendelse_passed_auth_filter @>loghaendelse_uuids THEN
	RETURN loghaendelse_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN loghaendelse_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_loghaendelse(loghaendelse_uuids uuid[], registreringobjarr loghaendelseregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_organisation(uuid[], organisationregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_organisation(organisation_uuids uuid[], registreringobjarr organisationregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	organisation_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	organisation_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj OrganisationEgenskaberAttrType;
	
  	tilsGyldighedTypeObj OrganisationGyldighedTilsType;
	relationTypeObj OrganisationRelationType;
	registreringObj OrganisationRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN organisation_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF organisation_uuids IS NULL OR  coalesce(array_length(organisation_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

organisation_candidates:= organisation_uuids;



--RAISE DEBUG 'organisation_candidates_is_initialized step 1:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 1:%',organisation_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_organisation: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(organisation_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			organisation_candidates:=array(
			SELECT DISTINCT
			b.organisation_id 
			FROM  organisation_attr_egenskaber a 
			JOIN organisation_registrering b on a.organisation_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.organisationsnavn IS NULL
					OR 
					a.organisationsnavn = attrEgenskaberTypeObj.organisationsnavn 
				)
				AND b.organisation_id = ANY (organisation_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'organisation_candidates_is_initialized step 3:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 3:%',organisation_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_organisation: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(organisation_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			organisation_candidates:=array(
			SELECT DISTINCT
			b.organisation_id 
			FROM  organisation_tils_gyldighed a
			JOIN organisation_registrering b on a.organisation_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.organisation_id = ANY (organisation_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer OrganisationRelationType[]
*/


--RAISE DEBUG 'organisation_candidates_is_initialized step 4:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 4:%',organisation_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_organisation: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(organisation_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			organisation_candidates:=array(
			SELECT DISTINCT
			b.organisation_id 
			FROM  organisation_relation a
			JOIN organisation_registrering b on a.organisation_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.organisation_id = ANY (organisation_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'organisation_candidates_is_initialized step 5:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 5:%',organisation_candidates;

organisation_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (organisation_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (organisation_candidates) b(id)
);

--optimization 
IF coalesce(array_length(organisation_passed_auth_filter,1),0)=coalesce(array_length(organisation_uuids,1),0) AND organisation_passed_auth_filter @>organisation_uuids THEN
	RETURN organisation_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN organisation_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_organisation(organisation_uuids uuid[], registreringobjarr organisationregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_organisationenhed(uuid[], organisationenhedregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_organisationenhed(organisationenhed_uuids uuid[], registreringobjarr organisationenhedregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	organisationenhed_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	organisationenhed_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj OrganisationenhedEgenskaberAttrType;
	
  	tilsGyldighedTypeObj OrganisationenhedGyldighedTilsType;
	relationTypeObj OrganisationenhedRelationType;
	registreringObj OrganisationenhedRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN organisationenhed_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF organisationenhed_uuids IS NULL OR  coalesce(array_length(organisationenhed_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

organisationenhed_candidates:= organisationenhed_uuids;



--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 1:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 1:%',organisationenhed_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_organisationenhed: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(organisationenhed_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			organisationenhed_candidates:=array(
			SELECT DISTINCT
			b.organisationenhed_id 
			FROM  organisationenhed_attr_egenskaber a 
			JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.enhedsnavn IS NULL
					OR 
					a.enhedsnavn = attrEgenskaberTypeObj.enhedsnavn 
				)
				AND b.organisationenhed_id = ANY (organisationenhed_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 3:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 3:%',organisationenhed_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_organisationenhed: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(organisationenhed_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			organisationenhed_candidates:=array(
			SELECT DISTINCT
			b.organisationenhed_id 
			FROM  organisationenhed_tils_gyldighed a
			JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.organisationenhed_id = ANY (organisationenhed_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer OrganisationenhedRelationType[]
*/


--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 4:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 4:%',organisationenhed_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_organisationenhed: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(organisationenhed_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			organisationenhed_candidates:=array(
			SELECT DISTINCT
			b.organisationenhed_id 
			FROM  organisationenhed_relation a
			JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.organisationenhed_id = ANY (organisationenhed_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 5:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 5:%',organisationenhed_candidates;

organisationenhed_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (organisationenhed_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (organisationenhed_candidates) b(id)
);

--optimization 
IF coalesce(array_length(organisationenhed_passed_auth_filter,1),0)=coalesce(array_length(organisationenhed_uuids,1),0) AND organisationenhed_passed_auth_filter @>organisationenhed_uuids THEN
	RETURN organisationenhed_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN organisationenhed_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_organisationenhed(organisationenhed_uuids uuid[], registreringobjarr organisationenhedregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_organisationfunktion(uuid[], organisationfunktionregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_organisationfunktion(organisationfunktion_uuids uuid[], registreringobjarr organisationfunktionregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	organisationfunktion_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	organisationfunktion_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj OrganisationfunktionEgenskaberAttrType;
	
  	tilsGyldighedTypeObj OrganisationfunktionGyldighedTilsType;
	relationTypeObj OrganisationfunktionRelationType;
	registreringObj OrganisationfunktionRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN organisationfunktion_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF organisationfunktion_uuids IS NULL OR  coalesce(array_length(organisationfunktion_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

organisationfunktion_candidates:= organisationfunktion_uuids;



--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 1:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 1:%',organisationfunktion_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_organisationfunktion: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(organisationfunktion_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			organisationfunktion_candidates:=array(
			SELECT DISTINCT
			b.organisationfunktion_id 
			FROM  organisationfunktion_attr_egenskaber a 
			JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.funktionsnavn IS NULL
					OR 
					a.funktionsnavn = attrEgenskaberTypeObj.funktionsnavn 
				)
				AND b.organisationfunktion_id = ANY (organisationfunktion_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 3:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 3:%',organisationfunktion_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_organisationfunktion: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(organisationfunktion_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			organisationfunktion_candidates:=array(
			SELECT DISTINCT
			b.organisationfunktion_id 
			FROM  organisationfunktion_tils_gyldighed a
			JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.organisationfunktion_id = ANY (organisationfunktion_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer OrganisationfunktionRelationType[]
*/


--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 4:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 4:%',organisationfunktion_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_organisationfunktion: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(organisationfunktion_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			organisationfunktion_candidates:=array(
			SELECT DISTINCT
			b.organisationfunktion_id 
			FROM  organisationfunktion_relation a
			JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.organisationfunktion_id = ANY (organisationfunktion_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 5:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 5:%',organisationfunktion_candidates;

organisationfunktion_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (organisationfunktion_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (organisationfunktion_candidates) b(id)
);

--optimization 
IF coalesce(array_length(organisationfunktion_passed_auth_filter,1),0)=coalesce(array_length(organisationfunktion_uuids,1),0) AND organisationfunktion_passed_auth_filter @>organisationfunktion_uuids THEN
	RETURN organisationfunktion_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN organisationfunktion_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_organisationfunktion(organisationfunktion_uuids uuid[], registreringobjarr organisationfunktionregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_sag(uuid[], sagregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_sag(sag_uuids uuid[], registreringobjarr sagregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	sag_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	sag_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj SagEgenskaberAttrType;
	
  	tilsFremdriftTypeObj SagFremdriftTilsType;
	relationTypeObj SagRelationType;
	registreringObj SagRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN sag_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF sag_uuids IS NULL OR  coalesce(array_length(sag_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

sag_candidates:= sag_uuids;



--RAISE DEBUG 'sag_candidates_is_initialized step 1:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 1:%',sag_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_sag: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(sag_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			sag_candidates:=array(
			SELECT DISTINCT
			b.sag_id 
			FROM  sag_attr_egenskaber a 
			JOIN sag_registrering b on a.sag_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.afleveret IS NULL
					OR 
					a.afleveret = attrEgenskaberTypeObj.afleveret 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.hjemmel IS NULL
					OR 
					a.hjemmel = attrEgenskaberTypeObj.hjemmel 
				)
				AND
				(
					attrEgenskaberTypeObj.kassationskode IS NULL
					OR 
					a.kassationskode = attrEgenskaberTypeObj.kassationskode 
				)
				AND
				(
					attrEgenskaberTypeObj.offentlighedundtaget IS NULL
					OR
						(
							(
								(attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel IS NULL
								OR
								(a.offentlighedundtaget).AlternativTitel = (attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel 
							)
							AND
							(
								(attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel IS NULL
								OR
								(a.offentlighedundtaget).Hjemmel = (attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel
							)
						) 
				)
				AND
				(
					attrEgenskaberTypeObj.principiel IS NULL
					OR 
					a.principiel = attrEgenskaberTypeObj.principiel 
				)
				AND
				(
					attrEgenskaberTypeObj.sagsnummer IS NULL
					OR 
					a.sagsnummer = attrEgenskaberTypeObj.sagsnummer 
				)
				AND
				(
					attrEgenskaberTypeObj.titel IS NULL
					OR 
					a.titel = attrEgenskaberTypeObj.titel 
				)
				AND b.sag_id = ANY (sag_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'sag_candidates_is_initialized step 3:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 3:%',sag_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Fremdrift
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsFremdrift IS NULL THEN
	--RAISE DEBUG 'as_search_sag: skipping filtration on tilsFremdrift';
ELSE
	IF coalesce(array_length(sag_candidates,1),0)>0 THEN 

		FOREACH tilsFremdriftTypeObj IN ARRAY registreringObj.tilsFremdrift
		LOOP
			sag_candidates:=array(
			SELECT DISTINCT
			b.sag_id 
			FROM  sag_tils_fremdrift a
			JOIN sag_registrering b on a.sag_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsFremdriftTypeObj.fremdrift IS NULL
					OR
					tilsFremdriftTypeObj.fremdrift = a.fremdrift
				)
				AND b.sag_id = ANY (sag_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer SagRelationType[]
*/


--RAISE DEBUG 'sag_candidates_is_initialized step 4:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 4:%',sag_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_sag: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(sag_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			sag_candidates:=array(
			SELECT DISTINCT
			b.sag_id 
			FROM  sag_relation a
			JOIN sag_registrering b on a.sag_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.sag_id = ANY (sag_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'sag_candidates_is_initialized step 5:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 5:%',sag_candidates;

sag_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (sag_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (sag_candidates) b(id)
);

--optimization 
IF coalesce(array_length(sag_passed_auth_filter,1),0)=coalesce(array_length(sag_uuids,1),0) AND sag_passed_auth_filter @>sag_uuids THEN
	RETURN sag_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN sag_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_sag(sag_uuids uuid[], registreringobjarr sagregistreringtype[]) OWNER TO mox;

--
-- Name: _as_filter_unauth_tilstand(uuid[], tilstandregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_filter_unauth_tilstand(tilstand_uuids uuid[], registreringobjarr tilstandregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	tilstand_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	tilstand_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj TilstandEgenskaberAttrType;
	
  	tilsStatusTypeObj TilstandStatusTilsType;
  	tilsPubliceretTypeObj TilstandPubliceretTilsType;
	relationTypeObj TilstandRelationType;
	registreringObj TilstandRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN tilstand_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF tilstand_uuids IS NULL OR  coalesce(array_length(tilstand_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

tilstand_candidates:= tilstand_uuids;



--RAISE DEBUG 'tilstand_candidates_is_initialized step 1:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 1:%',tilstand_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_tilstand: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(tilstand_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_attr_egenskaber a 
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND b.tilstand_id = ANY (tilstand_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'tilstand_candidates_is_initialized step 3:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 3:%',tilstand_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Status
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsStatus IS NULL THEN
	--RAISE DEBUG 'as_search_tilstand: skipping filtration on tilsStatus';
ELSE
	IF coalesce(array_length(tilstand_candidates,1),0)>0 THEN 

		FOREACH tilsStatusTypeObj IN ARRAY registreringObj.tilsStatus
		LOOP
			tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_tils_status a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsStatusTypeObj.status IS NULL
					OR
					tilsStatusTypeObj.status = a.status
				)
				AND b.tilstand_id = ANY (tilstand_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;
--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_tilstand: skipping filtration on tilsPubliceret';
ELSE
	IF coalesce(array_length(tilstand_candidates,1),0)>0 THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_tils_publiceret a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND b.tilstand_id = ANY (tilstand_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer TilstandRelationType[]
*/


--RAISE DEBUG 'tilstand_candidates_is_initialized step 4:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 4:%',tilstand_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_tilstand: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(tilstand_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_relation a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.tilstand_id = ANY (tilstand_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'tilstand_candidates_is_initialized step 5:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 5:%',tilstand_candidates;

tilstand_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (tilstand_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (tilstand_candidates) b(id)
);

--optimization 
IF coalesce(array_length(tilstand_passed_auth_filter,1),0)=coalesce(array_length(tilstand_uuids,1),0) AND tilstand_passed_auth_filter @>tilstand_uuids THEN
	RETURN tilstand_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN tilstand_passed_auth_filter;


END;
$$;


ALTER FUNCTION actual_state._as_filter_unauth_tilstand(tilstand_uuids uuid[], registreringobjarr tilstandregistreringtype[]) OWNER TO mox;

--
-- Name: _as_get_prev_aktivitet_registrering(aktivitet_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_aktivitet_registrering(aktivitet_registrering) RETURNS aktivitet_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM aktivitet_registrering as a WHERE
    aktivitet_id = $1.aktivitet_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_aktivitet_registrering(aktivitet_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_bruger_registrering(bruger_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_bruger_registrering(bruger_registrering) RETURNS bruger_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM bruger_registrering as a WHERE
    bruger_id = $1.bruger_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_bruger_registrering(bruger_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_dokument_registrering(dokument_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_dokument_registrering(dokument_registrering) RETURNS dokument_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM dokument_registrering as a WHERE
    dokument_id = $1.dokument_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_dokument_registrering(dokument_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_facet_registrering(facet_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_facet_registrering(facet_registrering) RETURNS facet_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM facet_registrering as a WHERE
    facet_id = $1.facet_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_facet_registrering(facet_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_indsats_registrering(indsats_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_indsats_registrering(indsats_registrering) RETURNS indsats_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM indsats_registrering as a WHERE
    indsats_id = $1.indsats_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_indsats_registrering(indsats_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_interessefaellesskab_registrering(interessefaellesskab_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_interessefaellesskab_registrering(interessefaellesskab_registrering) RETURNS interessefaellesskab_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM interessefaellesskab_registrering as a WHERE
    interessefaellesskab_id = $1.interessefaellesskab_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_interessefaellesskab_registrering(interessefaellesskab_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_itsystem_registrering(itsystem_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_itsystem_registrering(itsystem_registrering) RETURNS itsystem_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM itsystem_registrering as a WHERE
    itsystem_id = $1.itsystem_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_itsystem_registrering(itsystem_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_klasse_registrering(klasse_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_klasse_registrering(klasse_registrering) RETURNS klasse_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM klasse_registrering as a WHERE
    klasse_id = $1.klasse_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_klasse_registrering(klasse_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_klassifikation_registrering(klassifikation_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_klassifikation_registrering(klassifikation_registrering) RETURNS klassifikation_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM klassifikation_registrering as a WHERE
    klassifikation_id = $1.klassifikation_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_klassifikation_registrering(klassifikation_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_loghaendelse_registrering(loghaendelse_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_loghaendelse_registrering(loghaendelse_registrering) RETURNS loghaendelse_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM loghaendelse_registrering as a WHERE
    loghaendelse_id = $1.loghaendelse_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_loghaendelse_registrering(loghaendelse_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_organisation_registrering(organisation_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_organisation_registrering(organisation_registrering) RETURNS organisation_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM organisation_registrering as a WHERE
    organisation_id = $1.organisation_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_organisation_registrering(organisation_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_organisationenhed_registrering(organisationenhed_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_organisationenhed_registrering(organisationenhed_registrering) RETURNS organisationenhed_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM organisationenhed_registrering as a WHERE
    organisationenhed_id = $1.organisationenhed_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_organisationenhed_registrering(organisationenhed_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_organisationfunktion_registrering(organisationfunktion_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_organisationfunktion_registrering(organisationfunktion_registrering) RETURNS organisationfunktion_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM organisationfunktion_registrering as a WHERE
    organisationfunktion_id = $1.organisationfunktion_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_organisationfunktion_registrering(organisationfunktion_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_sag_registrering(sag_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_sag_registrering(sag_registrering) RETURNS sag_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM sag_registrering as a WHERE
    sag_id = $1.sag_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_sag_registrering(sag_registrering) OWNER TO mox;

--
-- Name: _as_get_prev_tilstand_registrering(tilstand_registrering); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_get_prev_tilstand_registrering(tilstand_registrering) RETURNS tilstand_registrering
    LANGUAGE sql STABLE
    AS $_$
  SELECT  * FROM tilstand_registrering as a WHERE
    tilstand_id = $1.tilstand_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
    $_$;


ALTER FUNCTION actual_state._as_get_prev_tilstand_registrering(tilstand_registrering) OWNER TO mox;

--
-- Name: _as_list_dokument_varianter(uuid[], tstzrange, tstzrange); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_list_dokument_varianter(dokument_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange) RETURNS TABLE(dokument_registrering_id bigint, varianter dokumentvarianttype[])
    LANGUAGE sql STABLE
    AS $$

  	SELECT
  	a.dokument_registrering_id,
  	_remove_nulls_in_array(array_agg(
  		CASE WHEN (a.DokumentVariantEgenskaberTypeArr IS NOT NULL and  coalesce(array_length(a.DokumentVariantEgenskaberTypeArr,1),0)>0) 
	  			OR (a.variant_dele IS NOT NULL and  coalesce(array_length(a.variant_dele,1),0)>0) 
	  			THEN
  		ROW (
  			a.varianttekst,
  			a.DokumentVariantEgenskaberTypeArr,
  			a.variant_dele 
  			) ::DokumentVariantType
  		ELSE
  		NULL
  		END
  		)) varianter
  	FROM
  	(
  		SELECT
  			a.dokument_id, 
  			a.dokument_registrering_id,
  			a.variant_id,
  			a.varianttekst,
  			a.DokumentVariantEgenskaberTypeArr,
	  		_remove_nulls_in_array(array_agg(
	  			CASE WHEN 
	  			(a.DokumentDelEgenskaberTypeArr IS NOT NULL and  coalesce(array_length(a.DokumentDelEgenskaberTypeArr,1),0)>0) 
	  			OR (a.DokumentdelRelationTypeArr IS NOT NULL and  coalesce(array_length(a.DokumentdelRelationTypeArr,1),0)>0) 
	  			THEN
	  			ROW (
	  				a.deltekst,
	  				a.DokumentDelEgenskaberTypeArr,
	  				a.DokumentdelRelationTypeArr 
	  				)::DokumentDelType
	  			ELSE
	  			NULL
	  			END
	  			order by a.deltekst
	  		)) variant_dele
  		FROM
		(  
  			SELECT
  			a.dokument_id, 
  			a.dokument_registrering_id,
  			a.variant_id,
  			a.varianttekst,
  			a.DokumentVariantEgenskaberTypeArr,
  			a.del_id,
  			a.deltekst,
  			a.DokumentDelEgenskaberTypeArr,
			_remove_nulls_in_array(array_agg(
					CASE
					WHEN b.id is not null THEN
					ROW (
							b.rel_type,
							b.virkning,
							b.rel_maal_uuid,
							b.rel_maal_urn,
							b.objekt_type 
						):: DokumentdelRelationType
					ELSE
					NULL
					END
					order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
				)) DokumentdelRelationTypeArr
  			FROM
  			(
  				SELECT 
  				a.dokument_id, 
  				a.dokument_registrering_id,
  				a.variant_id,
  				a.varianttekst,
  				a.DokumentVariantEgenskaberTypeArr,
  				b.id del_id,
  				b.deltekst,
  				_remove_nulls_in_array(array_agg(
						CASE 
						WHEN c.id is not null THEN
						ROW(
					 		c.indeks,
					 		c.indhold,
					 		c.lokation,
					 		c.mimetype,
					   		c.virkning 
							)::DokumentDelEgenskaberType
						ELSE
						NULL
						END
						order by c.indeks,c.indhold,c.lokation,c.mimetype,c.virkning
					)) DokumentDelEgenskaberTypeArr 
  				FROM	
  					(
					SELECT
					a.id dokument_id,
					b.id dokument_registrering_id,
					e.id variant_id,
					e.varianttekst,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN c.id is not null THEN
						ROW(
					 		c.arkivering,
					 		c.delvisscannet,
					 		c.offentliggoerelse,
					 		c.produktion,
					   		c.virkning 
							)::DokumentVariantEgenskaberType
						ELSE
						NULL
						END
						order by c.arkivering,c.delvisscannet,c.offentliggoerelse,c.produktion,c.virkning
					)) DokumentVariantEgenskaberTypeArr 
					FROM		dokument a
					JOIN 		dokument_registrering b 	ON b.dokument_id=a.id
					JOIN dokument_variant e on e.dokument_registrering_id=b.id
					LEFT JOIN dokument_variant_egenskaber c on c.variant_id = e.id AND (virkning_tstzrange is null OR (c.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			 
					WHERE a.id = ANY (dokument_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					GROUP BY a.id,b.id,e.id,e.varianttekst 	
					) as a
				LEFT JOIN dokument_del b on a.variant_id=b.variant_id
				LEFT JOIN dokument_del_egenskaber c on b.id = c.del_id AND (virkning_tstzrange is null OR (c.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			 
				GROUP BY 
				a.dokument_id, 
  				a.dokument_registrering_id,
  				a.variant_id,
  				a.varianttekst,
  				a.DokumentVariantEgenskaberTypeArr,
  				b.id,
  				b.deltekst
  			) as a
			LEFT JOIN dokument_del_relation b on b.del_id = a.del_id  AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			 
			GROUP BY 
			a.dokument_id, 
  			a.dokument_registrering_id,
  			a.variant_id,
  			a.varianttekst,
  			a.DokumentVariantEgenskaberTypeArr,
  			a.del_id,
  			a.deltekst,
  			a.DokumentDelEgenskaberTypeArr
		) as a
		GROUP BY
		a.dokument_id, 
  		a.dokument_registrering_id,
  		a.variant_id,
  		a.varianttekst,
  		a.DokumentVariantEgenskaberTypeArr
  	) as a 
	GROUP BY
	a.dokument_id, 
  	a.dokument_registrering_id

$$;


ALTER FUNCTION actual_state._as_list_dokument_varianter(dokument_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange) OWNER TO mox;

--
-- Name: _as_search_ilike_array(text, text[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_search_ilike_array(searchfor text, searchinarr text[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN

IF searchFor IS NULL or coalesce(array_length(searchInArr,1),0)=0 THEN  
	RETURN false;
ELSE
	--RAISE NOTICE 'SQL part  searchForArr[%], searchInArr[%]',to_json(searchForArr),to_json(searchInArr);
	IF EXISTS (
	SELECT
	a.searchInElement
	FROM
	unnest(searchInArr) a(searchInElement)
	WHERE  a.searchInElement ilike searchFor
	)
	THEN 
	RETURN TRUE;
	ELSE
	RETURN FALSE;
	END IF;

END IF;

END;
$$;


ALTER FUNCTION actual_state._as_search_ilike_array(searchfor text, searchinarr text[]) OWNER TO mox;

--
-- Name: _as_search_match_array(text[], text[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_search_match_array(searchforarr text[], searchinarr text[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN

IF coalesce(array_length(searchForArr,1),0)=0 and coalesce(array_length(searchInArr,1),0)>0 THEN  
	RETURN false;
ELSE
	--RAISE NOTICE 'SQL part  searchForArr[%], searchInArr[%]',to_json(searchForArr),to_json(searchInArr);
	IF EXISTS (
	SELECT
	a.searchForElement,
	b.searchTargetElement
	FROM
	unnest(searchForArr) a(searchForElement)
	LEFT JOIN unnest(searchInArr) b(searchTargetElement) on b.searchTargetElement ilike a.searchForElement
	WHERE b.searchTargetElement IS NULL
	)
	THEN 
	RETURN FALSE;
	ELSE
	RETURN TRUE;
	END IF;

END IF;

END;
$$;


ALTER FUNCTION actual_state._as_search_match_array(searchforarr text[], searchinarr text[]) OWNER TO mox;

--
-- Name: _as_valid_registrering_livscyklus_transition(livscykluskode, livscykluskode); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _as_valid_registrering_livscyklus_transition(current_reg_livscykluskode livscykluskode, new_reg_livscykluskode livscykluskode) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
IMPORTERET Livscykluskode := 'Importeret'::Livscykluskode ;
OPSTAAET Livscykluskode := 'Opstaaet'::Livscykluskode ;
PASSIVERET Livscykluskode := 'Passiveret'::Livscykluskode ;
SLETTET Livscykluskode := 'Slettet'::Livscykluskode ;
RETTET Livscykluskode := 'Rettet' ::Livscykluskode ;
BEGIN

CASE current_reg_livscykluskode
	WHEN OPSTAAET THEN
		CASE new_reg_livscykluskode
			WHEN IMPORTERET THEN return false;
			WHEN OPSTAAET THEN return false;
			WHEN PASSIVERET THEN return true;
			WHEN SLETTET THEN return true;
			WHEN RETTET THEN return true;
		END CASE;
	WHEN IMPORTERET THEN
		CASE new_reg_livscykluskode
			WHEN IMPORTERET THEN return false;
			WHEN OPSTAAET THEN return false;
			WHEN PASSIVERET  THEN return true;
			WHEN SLETTET THEN return true;
			WHEN RETTET THEN return true;
		END CASE;
	WHEN PASSIVERET THEN
		CASE new_reg_livscykluskode
			WHEN IMPORTERET THEN return true;
			WHEN OPSTAAET THEN return false;
			WHEN PASSIVERET  THEN return false;
			WHEN SLETTET THEN return true;
			WHEN RETTET THEN return false; 
		END CASE;
	WHEN SLETTET THEN 
		CASE new_reg_livscykluskode
			WHEN IMPORTERET THEN return true;
			WHEN OPSTAAET THEN return false;
			WHEN PASSIVERET  THEN return false;
			WHEN SLETTET THEN return false;
			WHEN RETTET THEN return false; 
                END CASE;
	WHEN RETTET THEN
		CASE new_reg_livscykluskode
			WHEN IMPORTERET THEN return false;
			WHEN OPSTAAET THEN return false;
			WHEN PASSIVERET  THEN return true;
			WHEN SLETTET THEN return true;
			WHEN RETTET THEN return true; 
		END CASE;

END CASE
;

RAISE EXCEPTION 'Undefined livscykluskode-transition, from [%] to [%] ',current_reg_livscykluskode,new_reg_livscykluskode;


END;
$$;


ALTER FUNCTION actual_state._as_valid_registrering_livscyklus_transition(current_reg_livscykluskode livscykluskode, new_reg_livscykluskode livscykluskode) OWNER TO mox;

--
-- Name: _cast_aktivitetregistreringtype_to_json(aktivitetregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_aktivitetregistreringtype_to_json(aktivitetregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END aktivitetegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsStatus,1),0)>0 THEN to_json($1.tilsStatus) 
        ELSE 
        NULL
        END aktivitetstatus
        ,
        
        CASE 
        WHEN coalesce(array_length($1.tilsPubliceret,1),0)>0 THEN to_json($1.tilsPubliceret) 
        ELSE 
        NULL
        END aktivitetpubliceret
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType,e.indeks,e.aktoerAttr)::AktivitetRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType,indeks,aktoerAttr) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_aktivitetregistreringtype_to_json(aktivitetregistreringtype) OWNER TO mox;

--
-- Name: _cast_aktivitettype_to_json(aktivitettype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_aktivitettype_to_json(aktivitettype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg AktivitetRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_aktivitettype_to_json(aktivitettype) OWNER TO mox;

--
-- Name: _cast_boolean_to_clearableboolean(boolean); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_boolean_to_clearableboolean(boolean_value boolean) RETURNS clearableboolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF boolean_value IS NULL THEN
  RETURN NULL;
ELSE
  RETURN ROW(boolean_value,null)::ClearableBoolean;
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_boolean_to_clearableboolean(boolean_value boolean) OWNER TO mox;

--
-- Name: _cast_brugerregistreringtype_to_json(brugerregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_brugerregistreringtype_to_json(brugerregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END brugeregenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END brugergyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::BrugerRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_brugerregistreringtype_to_json(brugerregistreringtype) OWNER TO mox;

--
-- Name: _cast_brugertype_to_json(brugertype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_brugertype_to_json(brugertype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg BrugerRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_brugertype_to_json(brugertype) OWNER TO mox;

--
-- Name: _cast_clearableboolean_to_boolean(clearableboolean); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_clearableboolean_to_boolean(clearable_boolean clearableboolean) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF clearable_boolean IS NULL THEN
  RETURN NULL;
ELSE
  RETURN clearable_boolean.value;
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_clearableboolean_to_boolean(clearable_boolean clearableboolean) OWNER TO mox;

--
-- Name: _cast_clearabledate_to_date(clearabledate); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_clearabledate_to_date(clearable_date clearabledate) RETURNS date
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF clearable_date IS NULL THEN
  RETURN NULL;
ELSE
  RETURN clearable_date.value;
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_clearabledate_to_date(clearable_date clearabledate) OWNER TO mox;

--
-- Name: _cast_clearableint_to_int(clearableint); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_clearableint_to_int(clearable_int clearableint) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF clearable_int IS NULL THEN
  RETURN NULL;
ELSE
  RETURN clearable_int.value;
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_clearableint_to_int(clearable_int clearableint) OWNER TO mox;

--
-- Name: _cast_clearableinterval_to_interval(clearableinterval); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_clearableinterval_to_interval(clearable_interval clearableinterval) RETURNS interval
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF clearable_interval IS NULL THEN
  RETURN NULL;
ELSE
  RETURN clearable_interval.value;
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_clearableinterval_to_interval(clearable_interval clearableinterval) OWNER TO mox;

--
-- Name: _cast_clearabletimestamptz_to_timestamptz(clearabletimestamptz); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_clearabletimestamptz_to_timestamptz(clearable_timestamptz clearabletimestamptz) RETURNS timestamp with time zone
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF clearable_timestamptz IS NULL THEN
  RETURN NULL;
ELSE
  RETURN clearable_timestamptz.value;
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_clearabletimestamptz_to_timestamptz(clearable_timestamptz clearabletimestamptz) OWNER TO mox;

--
-- Name: _cast_date_to_clearabledate(date); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_date_to_clearabledate(date_value date) RETURNS clearabledate
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF date_value IS NULL THEN
  RETURN NULL;
ELSE
  RETURN ROW(date_value,null)::ClearableDate;
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_date_to_clearabledate(date_value date) OWNER TO mox;

--
-- Name: _cast_dokumentregistreringtype_to_json(dokumentregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_dokumentregistreringtype_to_json(dokumentregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END dokumentegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsFremdrift,1),0)>0 THEN to_json($1.tilsFremdrift) 
        ELSE 
        NULL
        END dokumentfremdrift
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::DokumentRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  ,$1.varianter  
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_dokumentregistreringtype_to_json(dokumentregistreringtype) OWNER TO mox;

--
-- Name: _cast_dokumenttype_to_json(dokumenttype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_dokumenttype_to_json(dokumenttype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg DokumentRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_dokumenttype_to_json(dokumenttype) OWNER TO mox;

--
-- Name: _cast_facetregistreringtype_to_json(facetregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_facetregistreringtype_to_json(facetregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END facetegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsPubliceret,1),0)>0 THEN to_json($1.tilsPubliceret) 
        ELSE 
        NULL
        END facetpubliceret
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::FacetRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_facetregistreringtype_to_json(facetregistreringtype) OWNER TO mox;

--
-- Name: _cast_facettype_to_json(facettype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_facettype_to_json(facettype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg FacetRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_facettype_to_json(facettype) OWNER TO mox;

--
-- Name: _cast_indsatsregistreringtype_to_json(indsatsregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_indsatsregistreringtype_to_json(indsatsregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END indsatsegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsPubliceret,1),0)>0 THEN to_json($1.tilsPubliceret) 
        ELSE 
        NULL
        END indsatspubliceret
        ,
        
        CASE 
        WHEN coalesce(array_length($1.tilsFremdrift,1),0)>0 THEN to_json($1.tilsFremdrift) 
        ELSE 
        NULL
        END indsatsfremdrift
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType,e.indeks)::IndsatsRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType,indeks) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_indsatsregistreringtype_to_json(indsatsregistreringtype) OWNER TO mox;

--
-- Name: _cast_indsatstype_to_json(indsatstype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_indsatstype_to_json(indsatstype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg IndsatsRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_indsatstype_to_json(indsatstype) OWNER TO mox;

--
-- Name: _cast_int_to_clearableint(integer); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_int_to_clearableint(int_value integer) RETURNS clearableint
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF int_value IS NULL THEN
  RETURN NULL;
ELSE
  RETURN ROW(int_value,null)::ClearableInt;
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_int_to_clearableint(int_value integer) OWNER TO mox;

--
-- Name: _cast_interessefaellesskabregistreringtype_to_json(interessefaellesskabregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_interessefaellesskabregistreringtype_to_json(interessefaellesskabregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END interessefaellesskabegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END interessefaellesskabgyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::InteressefaellesskabRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_interessefaellesskabregistreringtype_to_json(interessefaellesskabregistreringtype) OWNER TO mox;

--
-- Name: _cast_interessefaellesskabtype_to_json(interessefaellesskabtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_interessefaellesskabtype_to_json(interessefaellesskabtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg InteressefaellesskabRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_interessefaellesskabtype_to_json(interessefaellesskabtype) OWNER TO mox;

--
-- Name: _cast_interval_to_clearableinterval(interval); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_interval_to_clearableinterval(interval_value interval) RETURNS clearableinterval
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF interval_value IS NULL THEN
  RETURN NULL;
ELSE
  RETURN ROW(interval_value,null)::ClearableInterval;
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_interval_to_clearableinterval(interval_value interval) OWNER TO mox;

--
-- Name: _cast_itsystemregistreringtype_to_json(itsystemregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_itsystemregistreringtype_to_json(itsystemregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END itsystemegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END itsystemgyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::ItsystemRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_itsystemregistreringtype_to_json(itsystemregistreringtype) OWNER TO mox;

--
-- Name: _cast_itsystemtype_to_json(itsystemtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_itsystemtype_to_json(itsystemtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg ItsystemRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_itsystemtype_to_json(itsystemtype) OWNER TO mox;

--
-- Name: _cast_klasseregistreringtype_to_json(klasseregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_klasseregistreringtype_to_json(klasseregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END klasseegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsPubliceret,1),0)>0 THEN to_json($1.tilsPubliceret) 
        ELSE 
        NULL
        END klassepubliceret
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::KlasseRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_klasseregistreringtype_to_json(klasseregistreringtype) OWNER TO mox;

--
-- Name: _cast_klassetype_to_json(klassetype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_klassetype_to_json(klassetype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg KlasseRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_klassetype_to_json(klassetype) OWNER TO mox;

--
-- Name: _cast_klassifikationregistreringtype_to_json(klassifikationregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_klassifikationregistreringtype_to_json(klassifikationregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END klassifikationegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsPubliceret,1),0)>0 THEN to_json($1.tilsPubliceret) 
        ELSE 
        NULL
        END klassifikationpubliceret
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::KlassifikationRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_klassifikationregistreringtype_to_json(klassifikationregistreringtype) OWNER TO mox;

--
-- Name: _cast_klassifikationtype_to_json(klassifikationtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_klassifikationtype_to_json(klassifikationtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg KlassifikationRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_klassifikationtype_to_json(klassifikationtype) OWNER TO mox;

--
-- Name: _cast_loghaendelseregistreringtype_to_json(loghaendelseregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_loghaendelseregistreringtype_to_json(loghaendelseregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END loghaendelseegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END loghaendelsegyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::LoghaendelseRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_loghaendelseregistreringtype_to_json(loghaendelseregistreringtype) OWNER TO mox;

--
-- Name: _cast_loghaendelsetype_to_json(loghaendelsetype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_loghaendelsetype_to_json(loghaendelsetype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg LoghaendelseRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_loghaendelsetype_to_json(loghaendelsetype) OWNER TO mox;

--
-- Name: _cast_organisationenhedregistreringtype_to_json(organisationenhedregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_organisationenhedregistreringtype_to_json(organisationenhedregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END organisationenhedegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END organisationenhedgyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::OrganisationenhedRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_organisationenhedregistreringtype_to_json(organisationenhedregistreringtype) OWNER TO mox;

--
-- Name: _cast_organisationenhedtype_to_json(organisationenhedtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_organisationenhedtype_to_json(organisationenhedtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg OrganisationenhedRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_organisationenhedtype_to_json(organisationenhedtype) OWNER TO mox;

--
-- Name: _cast_organisationfunktionregistreringtype_to_json(organisationfunktionregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_organisationfunktionregistreringtype_to_json(organisationfunktionregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END organisationfunktionegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END organisationfunktiongyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::OrganisationfunktionRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_organisationfunktionregistreringtype_to_json(organisationfunktionregistreringtype) OWNER TO mox;

--
-- Name: _cast_organisationfunktiontype_to_json(organisationfunktiontype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_organisationfunktiontype_to_json(organisationfunktiontype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg OrganisationfunktionRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_organisationfunktiontype_to_json(organisationfunktiontype) OWNER TO mox;

--
-- Name: _cast_organisationregistreringtype_to_json(organisationregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_organisationregistreringtype_to_json(organisationregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END organisationegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END organisationgyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::OrganisationRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_organisationregistreringtype_to_json(organisationregistreringtype) OWNER TO mox;

--
-- Name: _cast_organisationtype_to_json(organisationtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_organisationtype_to_json(organisationtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg OrganisationRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_organisationtype_to_json(organisationtype) OWNER TO mox;

--
-- Name: _cast_sagregistreringtype_to_json(sagregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_sagregistreringtype_to_json(sagregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END sagegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsFremdrift,1),0)>0 THEN to_json($1.tilsFremdrift) 
        ELSE 
        NULL
        END sagfremdrift
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType,e.indeks,e.relTypeSpec,e.journalNotat,e.journalDokumentAttr)::SagRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType,indeks,relTypeSpec,journalNotat,journalDokumentAttr) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_sagregistreringtype_to_json(sagregistreringtype) OWNER TO mox;

--
-- Name: _cast_sagtype_to_json(sagtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_sagtype_to_json(sagtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg SagRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_sagtype_to_json(sagtype) OWNER TO mox;

--
-- Name: _cast_text_to_clearableboolean(text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_text_to_clearableboolean(text_value text) RETURNS clearableboolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF text_value IS NULL THEN
  RETURN NULL;
ELSE
  IF text_value<>'' THEN 
    RAISE EXCEPTION 'Unable to cast text value [%] to ClearableBoolean. Only empty text is allowed (or null).',text_value USING ERRCODE = 22000;
  ELSE
    RETURN ROW(null,true)::ClearableBoolean;
  END IF;
  
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_text_to_clearableboolean(text_value text) OWNER TO mox;

--
-- Name: _cast_text_to_clearabledate(text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_text_to_clearabledate(text_value text) RETURNS clearabledate
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF text_value IS NULL THEN
  RETURN NULL;
ELSE
  IF text_value<>'' THEN 
    RAISE EXCEPTION 'Unable to cast text value [%] to ClearableDate. Only empty text is allowed (or null).',text_value USING ERRCODE = 22000;
  ELSE
    RETURN ROW(null,true)::ClearableDate;
  END IF;
  
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_text_to_clearabledate(text_value text) OWNER TO mox;

--
-- Name: _cast_text_to_clearableint(text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_text_to_clearableint(text_value text) RETURNS clearableint
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF text_value IS NULL THEN
  RETURN NULL;
ELSE
  IF text_value<>'' THEN 
    RAISE EXCEPTION 'Unable to cast text value [%] to ClearableInt. Only empty text is allowed (or null).',text_value USING ERRCODE = 22000;
  ELSE
    RETURN ROW(null,true)::ClearableInt;
  END IF;
  
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_text_to_clearableint(text_value text) OWNER TO mox;

--
-- Name: _cast_text_to_clearableinterval(text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_text_to_clearableinterval(text_value text) RETURNS clearableinterval
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF text_value IS NULL THEN
  RETURN NULL;
ELSE
  IF text_value<>'' THEN 
    RAISE EXCEPTION 'Unable to cast text value [%] to ClearableInterval. Only empty text is allowed (or null).',text_value USING ERRCODE = 22000;
  ELSE
    RETURN ROW(null,true)::ClearableInterval;
  END IF;
  
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_text_to_clearableinterval(text_value text) OWNER TO mox;

--
-- Name: _cast_text_to_clearabletimestamptz(text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_text_to_clearabletimestamptz(text_value text) RETURNS clearabletimestamptz
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF text_value IS NULL THEN
  RETURN NULL;
ELSE
  IF text_value<>'' THEN 
    RAISE EXCEPTION 'Unable to cast text value [%] to ClearableTimestamptz. Only empty text is allowed (or null).',text_value USING ERRCODE = 22000;
  ELSE
    RETURN ROW(null,true)::ClearableTimestamptz;
  END IF;
  
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_text_to_clearabletimestamptz(text_value text) OWNER TO mox;

--
-- Name: _cast_tilstandregistreringtype_to_json(tilstandregistreringtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_tilstandregistreringtype_to_json(tilstandregistreringtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END tilstandegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      ( 
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsStatus,1),0)>0 THEN to_json($1.tilsStatus) 
        ELSE 
        NULL
        END tilstandstatus
        ,
        
        CASE 
        WHEN coalesce(array_length($1.tilsPubliceret,1),0)>0 THEN to_json($1.tilsPubliceret) 
        ELSE 
        NULL
        END tilstandpubliceret
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(   to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,
      array_agg( _json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType,e.indeks,e.tilstandsVaerdiAttr)::TilstandRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType,indeks,tilstandsVaerdiAttr) 
      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid 
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator 
    ) as  FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as  TilTidspunkt
  

)
as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_tilstandregistreringtype_to_json(tilstandregistreringtype) OWNER TO mox;

--
-- Name: _cast_tilstandtype_to_json(tilstandtype); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_tilstandtype_to_json(tilstandtype) RETURNS json
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
result json;
reg_json_arr json[];
reg TilstandRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$_$;


ALTER FUNCTION actual_state._cast_tilstandtype_to_json(tilstandtype) OWNER TO mox;

--
-- Name: _cast_timestamptz_to_clearabletimestamptz(timestamp with time zone); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _cast_timestamptz_to_clearabletimestamptz(timestamptz_value timestamp with time zone) RETURNS clearabletimestamptz
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
BEGIN

IF timestamptz_value IS NULL THEN
  RETURN NULL;
ELSE
  RETURN ROW(timestamptz_value,null)::ClearableTimestamptz;
END IF;

END;
$$;


ALTER FUNCTION actual_state._cast_timestamptz_to_clearabletimestamptz(timestamptz_value timestamp with time zone) OWNER TO mox;

--
-- Name: _composite_type_to_time_range(anyelement); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _composite_type_to_time_range(anyelement) RETURNS tstzrange
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT $1.TimePeriod$_$;


ALTER FUNCTION actual_state._composite_type_to_time_range(anyelement) OWNER TO mox;

--
-- Name: _ensure_document_del_exists_and_get(bigint, bigint, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _ensure_document_del_exists_and_get(reg_id bigint, current_variant_id bigint, current_deltekst text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
res_del_id bigint;
BEGIN


SELECT b.id into res_del_id 
FROM dokument_variant a 
JOIN dokument_del b on b.variant_id=a.id 
WHERE 
a.dokument_registrering_id=reg_id
and a.id=current_variant_id
and b.deltekst=current_deltekst
;

IF res_del_id IS NULL THEN

res_del_id:=nextval('dokument_del_id_seq'::regclass);


    INSERT INTO dokument_del (
    id,
      deltekst,
        variant_id
    )
    VALUES
    (
    res_del_id,
        current_deltekst,
          current_variant_id
    )
    ;

END IF;

RETURN res_del_id;

END;
$$;


ALTER FUNCTION actual_state._ensure_document_del_exists_and_get(reg_id bigint, current_variant_id bigint, current_deltekst text) OWNER TO mox;

--
-- Name: _ensure_document_variant_and_del_exists_and_get_del(bigint, text, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _ensure_document_variant_and_del_exists_and_get_del(reg_id bigint, current_variant_text text, current_deltekst text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
current_del_id bigint;
current_variant_id bigint;
BEGIN

current_variant_id:=_ensure_document_variant_exists_and_get(reg_id,current_variant_text);
current_del_id:=_ensure_document_del_exists_and_get(reg_id, current_variant_id, current_deltekst);

RETURN current_del_id;

END;
$$;


ALTER FUNCTION actual_state._ensure_document_variant_and_del_exists_and_get_del(reg_id bigint, current_variant_text text, current_deltekst text) OWNER TO mox;

--
-- Name: _ensure_document_variant_exists_and_get(bigint, text); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _ensure_document_variant_exists_and_get(reg_id bigint, current_variant_text text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
res_variant_id bigint;
BEGIN


SELECT a.id into res_variant_id 
FROM dokument_variant a 
WHERE 
a.dokument_registrering_id=reg_id
and a.varianttekst=current_variant_text
;

IF res_variant_id IS NULL THEN

res_variant_id:=nextval('dokument_variant_id_seq'::regclass);

 INSERT INTO dokument_variant (
    id,
      varianttekst,
        dokument_registrering_id
  )
  VALUES
  (
    res_variant_id,
      current_variant_text,
        reg_id
  ); 

END IF;

RETURN res_variant_id;

END;
$$;


ALTER FUNCTION actual_state._ensure_document_variant_exists_and_get(reg_id bigint, current_variant_text text) OWNER TO mox;

--
-- Name: _json_object_delete_keys(json, text[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _json_object_delete_keys(json json, keys_to_delete text[]) RETURNS json
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
SELECT COALESCE(
  (SELECT ('{' || string_agg(to_json(key) || ':' || value::json::text, ',') || '}')
   FROM json_each(json)
   WHERE key not in (select key from unnest(keys_to_delete) as a(key))),
  '{}'
)::json
$$;


ALTER FUNCTION actual_state._json_object_delete_keys(json json, keys_to_delete text[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(aktivitetegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr aktivitetegenskaberattrtype[]) RETURNS aktivitetegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result AktivitetEgenskaberAttrType[]; 
   DECLARE element AktivitetEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.aktivitetnavn IS NULL AND element.beskrivelse IS NULL AND element.starttidspunkt IS NULL AND element.sluttidspunkt IS NULL AND element.tidsforbrug IS NULL AND element.formaal IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr aktivitetegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(aktivitetpublicerettilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr aktivitetpublicerettilstype[]) RETURNS aktivitetpublicerettilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result AktivitetPubliceretTilsType[];
  DECLARE element AktivitetPubliceretTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.publiceret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr aktivitetpublicerettilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(aktivitetrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr aktivitetrelationtype[]) RETURNS aktivitetrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result AktivitetRelationType[];
 DECLARE element AktivitetRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.indeks IS NULL AND (element.aktoerAttr IS NULL OR ((element.aktoerAttr).obligatorisk IS NULL AND (element.aktoerAttr).accepteret IS NULL AND (element.aktoerAttr).repraesentation_uuid IS NULL AND (element.aktoerAttr).repraesentation_urn IS NULL    )) AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr aktivitetrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(aktivitetstatustilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr aktivitetstatustilstype[]) RETURNS aktivitetstatustilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result AktivitetStatusTilsType[];
  DECLARE element AktivitetStatusTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.status IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr aktivitetstatustilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(brugeregenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr brugeregenskaberattrtype[]) RETURNS brugeregenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result BrugerEgenskaberAttrType[]; 
   DECLARE element BrugerEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.brugernavn IS NULL AND element.brugertype IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr brugeregenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(brugergyldighedtilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr brugergyldighedtilstype[]) RETURNS brugergyldighedtilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result BrugerGyldighedTilsType[];
  DECLARE element BrugerGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr brugergyldighedtilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(brugerrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr brugerrelationtype[]) RETURNS brugerrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result BrugerRelationType[];
 DECLARE element BrugerRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr brugerrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(dokumentdelegenskabertype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr dokumentdelegenskabertype[]) RETURNS dokumentdelegenskabertype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result DokumentDelEgenskaberType[]; 
   DECLARE element DokumentDelEgenskaberType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.indeks IS NULL AND element.indhold IS NULL AND element.lokation IS NULL AND element.mimetype IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr dokumentdelegenskabertype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(dokumentdelrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr dokumentdelrelationtype[]) RETURNS dokumentdelrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result DokumentdelRelationType[];
 DECLARE element DokumentdelRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr dokumentdelrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(dokumentdeltype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr dokumentdeltype[]) RETURNS dokumentdeltype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result DokumentDelType[];
 DECLARE element DokumentDelType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.deltekst IS NULL AND (element.egenskaber IS NULL OR  coalesce(array_length(element.egenskaber,1),0)=0) AND (element.relationer IS NULL OR  coalesce(array_length(element.relationer,1),0)=0)  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr dokumentdeltype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(dokumentegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr dokumentegenskaberattrtype[]) RETURNS dokumentegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result DokumentEgenskaberAttrType[]; 
   DECLARE element DokumentEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.beskrivelse IS NULL AND element.brevdato IS NULL AND element.kassationskode IS NULL AND element.major IS NULL AND element.minor IS NULL AND element.offentlighedundtaget IS NULL AND element.titel IS NULL AND element.dokumenttype IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr dokumentegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(dokumentfremdrifttilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr dokumentfremdrifttilstype[]) RETURNS dokumentfremdrifttilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result DokumentFremdriftTilsType[];
  DECLARE element DokumentFremdriftTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.fremdrift IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr dokumentfremdrifttilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(dokumentrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr dokumentrelationtype[]) RETURNS dokumentrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result DokumentRelationType[];
 DECLARE element DokumentRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr dokumentrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(dokumentvariantegenskabertype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr dokumentvariantegenskabertype[]) RETURNS dokumentvariantegenskabertype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result DokumentVariantEgenskaberType[]; 
   DECLARE element DokumentVariantEgenskaberType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.arkivering IS NULL AND element.delvisscannet IS NULL AND element.offentliggoerelse IS NULL AND element.produktion IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr dokumentvariantegenskabertype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(dokumentvarianttype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr dokumentvarianttype[]) RETURNS dokumentvarianttype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result DokumentVariantType[];
 DECLARE element DokumentVariantType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.varianttekst IS NULL AND (element.egenskaber IS NULL OR  coalesce(array_length(element.egenskaber,1),0)=0) AND (element.dele IS NULL OR  coalesce(array_length(element.dele,1),0)=0)  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr dokumentvarianttype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(facetegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr facetegenskaberattrtype[]) RETURNS facetegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result FacetEgenskaberAttrType[]; 
   DECLARE element FacetEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.beskrivelse IS NULL AND element.opbygning IS NULL AND element.ophavsret IS NULL AND element.plan IS NULL AND element.supplement IS NULL AND element.retskilde IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr facetegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(facetpublicerettilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr facetpublicerettilstype[]) RETURNS facetpublicerettilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result FacetPubliceretTilsType[];
  DECLARE element FacetPubliceretTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.publiceret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr facetpublicerettilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(facetrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr facetrelationtype[]) RETURNS facetrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result FacetRelationType[];
 DECLARE element FacetRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr facetrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(indsatsegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr indsatsegenskaberattrtype[]) RETURNS indsatsegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result IndsatsEgenskaberAttrType[]; 
   DECLARE element IndsatsEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.beskrivelse IS NULL AND element.starttidspunkt IS NULL AND element.sluttidspunkt IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr indsatsegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(indsatsfremdrifttilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr indsatsfremdrifttilstype[]) RETURNS indsatsfremdrifttilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result IndsatsFremdriftTilsType[];
  DECLARE element IndsatsFremdriftTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.fremdrift IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr indsatsfremdrifttilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(indsatspublicerettilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr indsatspublicerettilstype[]) RETURNS indsatspublicerettilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result IndsatsPubliceretTilsType[];
  DECLARE element IndsatsPubliceretTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.publiceret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr indsatspublicerettilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(indsatsrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr indsatsrelationtype[]) RETURNS indsatsrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result IndsatsRelationType[];
 DECLARE element IndsatsRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.indeks IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr indsatsrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(interessefaellesskabegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr interessefaellesskabegenskaberattrtype[]) RETURNS interessefaellesskabegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result InteressefaellesskabEgenskaberAttrType[]; 
   DECLARE element InteressefaellesskabEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.interessefaellesskabsnavn IS NULL AND element.interessefaellesskabstype IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr interessefaellesskabegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(interessefaellesskabgyldighedtilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr interessefaellesskabgyldighedtilstype[]) RETURNS interessefaellesskabgyldighedtilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result InteressefaellesskabGyldighedTilsType[];
  DECLARE element InteressefaellesskabGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr interessefaellesskabgyldighedtilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(interessefaellesskabrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr interessefaellesskabrelationtype[]) RETURNS interessefaellesskabrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result InteressefaellesskabRelationType[];
 DECLARE element InteressefaellesskabRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr interessefaellesskabrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(itsystemegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr itsystemegenskaberattrtype[]) RETURNS itsystemegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result ItsystemEgenskaberAttrType[]; 
   DECLARE element ItsystemEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.itsystemnavn IS NULL AND element.itsystemtype IS NULL AND element.konfigurationreference IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr itsystemegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(itsystemgyldighedtilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr itsystemgyldighedtilstype[]) RETURNS itsystemgyldighedtilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result ItsystemGyldighedTilsType[];
  DECLARE element ItsystemGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr itsystemgyldighedtilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(itsystemrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr itsystemrelationtype[]) RETURNS itsystemrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result ItsystemRelationType[];
 DECLARE element ItsystemRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr itsystemrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(klasseegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr klasseegenskaberattrtype[]) RETURNS klasseegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result KlasseEgenskaberAttrType[]; 
   DECLARE element KlasseEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.beskrivelse IS NULL AND element.eksempel IS NULL AND element.omfang IS NULL AND element.titel IS NULL AND element.retskilde IS NULL AND element.aendringsnotat IS NULL ) AND element.virkning IS NULL AND (element.soegeord IS NULL OR coalesce(array_length(element.soegeord,1),0)=0 )) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr klasseegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(klassepublicerettilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr klassepublicerettilstype[]) RETURNS klassepublicerettilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result KlassePubliceretTilsType[];
  DECLARE element KlassePubliceretTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.publiceret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr klassepublicerettilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(klasserelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr klasserelationtype[]) RETURNS klasserelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result KlasseRelationType[];
 DECLARE element KlasseRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr klasserelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(klassesoegeordtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr klassesoegeordtype[]) RETURNS klassesoegeordtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result KlasseSoegeordType[];
  DECLARE element KlasseSoegeordType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (element.soegeordidentifikator IS NULL AND element.beskrivelse IS NULL AND element.soegeordskategori IS NULL ) THEN
     -- RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  IF array_length(result,1)=0 THEN
    RETURN NULL;
  ELSE
    RETURN result;
  END IF;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr klassesoegeordtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(klassifikationegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr klassifikationegenskaberattrtype[]) RETURNS klassifikationegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result KlassifikationEgenskaberAttrType[]; 
   DECLARE element KlassifikationEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.beskrivelse IS NULL AND element.kaldenavn IS NULL AND element.ophavsret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr klassifikationegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(klassifikationpublicerettilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr klassifikationpublicerettilstype[]) RETURNS klassifikationpublicerettilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result KlassifikationPubliceretTilsType[];
  DECLARE element KlassifikationPubliceretTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.publiceret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr klassifikationpublicerettilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(klassifikationrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr klassifikationrelationtype[]) RETURNS klassifikationrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result KlassifikationRelationType[];
 DECLARE element KlassifikationRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr klassifikationrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(loghaendelseegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr loghaendelseegenskaberattrtype[]) RETURNS loghaendelseegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result LoghaendelseEgenskaberAttrType[]; 
   DECLARE element LoghaendelseEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.service IS NULL AND element.klasse IS NULL AND element.tidspunkt IS NULL AND element.operation IS NULL AND element.objekttype IS NULL AND element.returkode IS NULL AND element.returtekst IS NULL AND element.note IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr loghaendelseegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(loghaendelsegyldighedtilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr loghaendelsegyldighedtilstype[]) RETURNS loghaendelsegyldighedtilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result LoghaendelseGyldighedTilsType[];
  DECLARE element LoghaendelseGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr loghaendelsegyldighedtilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(loghaendelserelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr loghaendelserelationtype[]) RETURNS loghaendelserelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result LoghaendelseRelationType[];
 DECLARE element LoghaendelseRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr loghaendelserelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(organisationegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr organisationegenskaberattrtype[]) RETURNS organisationegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result OrganisationEgenskaberAttrType[]; 
   DECLARE element OrganisationEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.organisationsnavn IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr organisationegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(organisationenhedegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr organisationenhedegenskaberattrtype[]) RETURNS organisationenhedegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result OrganisationenhedEgenskaberAttrType[]; 
   DECLARE element OrganisationenhedEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.enhedsnavn IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr organisationenhedegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(organisationenhedgyldighedtilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr organisationenhedgyldighedtilstype[]) RETURNS organisationenhedgyldighedtilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result OrganisationenhedGyldighedTilsType[];
  DECLARE element OrganisationenhedGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr organisationenhedgyldighedtilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(organisationenhedrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr organisationenhedrelationtype[]) RETURNS organisationenhedrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result OrganisationenhedRelationType[];
 DECLARE element OrganisationenhedRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr organisationenhedrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(organisationfunktionegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr organisationfunktionegenskaberattrtype[]) RETURNS organisationfunktionegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result OrganisationfunktionEgenskaberAttrType[]; 
   DECLARE element OrganisationfunktionEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.funktionsnavn IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr organisationfunktionegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(organisationfunktiongyldighedtilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr organisationfunktiongyldighedtilstype[]) RETURNS organisationfunktiongyldighedtilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result OrganisationfunktionGyldighedTilsType[];
  DECLARE element OrganisationfunktionGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr organisationfunktiongyldighedtilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(organisationfunktionrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr organisationfunktionrelationtype[]) RETURNS organisationfunktionrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result OrganisationfunktionRelationType[];
 DECLARE element OrganisationfunktionRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr organisationfunktionrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(organisationgyldighedtilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr organisationgyldighedtilstype[]) RETURNS organisationgyldighedtilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result OrganisationGyldighedTilsType[];
  DECLARE element OrganisationGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr organisationgyldighedtilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(organisationrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr organisationrelationtype[]) RETURNS organisationrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result OrganisationRelationType[];
 DECLARE element OrganisationRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr organisationrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(sagegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr sagegenskaberattrtype[]) RETURNS sagegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result SagEgenskaberAttrType[]; 
   DECLARE element SagEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.afleveret IS NULL AND element.beskrivelse IS NULL AND element.hjemmel IS NULL AND element.kassationskode IS NULL AND element.offentlighedundtaget IS NULL AND element.principiel IS NULL AND element.sagsnummer IS NULL AND element.titel IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr sagegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(sagfremdrifttilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr sagfremdrifttilstype[]) RETURNS sagfremdrifttilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result SagFremdriftTilsType[];
  DECLARE element SagFremdriftTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.fremdrift IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr sagfremdrifttilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(sagrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr sagrelationtype[]) RETURNS sagrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result SagRelationType[];
 DECLARE element SagRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.indeks IS NULL AND element.relTypeSpec IS NULL AND (element.journalNotat IS NULL OR ( (element.journalNotat).titel IS NULL AND (element.journalNotat).notat IS NULL AND (element.journalNotat).format IS NULL )) AND (element.journalDokumentAttr IS NULL OR ((element.journalDokumentAttr).dokumenttitel IS NULL AND (element.journalDokumentAttr).offentlighedUndtaget IS NULL )) AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr sagrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(tilstandegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr tilstandegenskaberattrtype[]) RETURNS tilstandegenskaberattrtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result TilstandEgenskaberAttrType[]; 
   DECLARE element TilstandEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.beskrivelse IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr tilstandegenskaberattrtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(tilstandpublicerettilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr tilstandpublicerettilstype[]) RETURNS tilstandpublicerettilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result TilstandPubliceretTilsType[];
  DECLARE element TilstandPubliceretTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.publiceret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr tilstandpublicerettilstype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(tilstandrelationtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr tilstandrelationtype[]) RETURNS tilstandrelationtype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
 DECLARE result TilstandRelationType[];
 DECLARE element TilstandRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.indeks IS NULL AND (element.tilstandsVaerdiAttr IS NULL OR ((element.tilstandsVaerdiAttr).nominelVaerdi IS NULL AND (element.tilstandsVaerdiAttr).forventet IS NULL )) AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr tilstandrelationtype[]) OWNER TO mox;

--
-- Name: _remove_nulls_in_array(tilstandstatustilstype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _remove_nulls_in_array(inputarr tilstandstatustilstype[]) RETURNS tilstandstatustilstype[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
  DECLARE result TilstandStatusTilsType[];
  DECLARE element TilstandStatusTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY  inputArr
    LOOP
      IF element IS NULL OR (( element.status IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$;


ALTER FUNCTION actual_state._remove_nulls_in_array(inputarr tilstandstatustilstype[]) OWNER TO mox;

--
-- Name: _subtract_tstzrange(tstzrange, tstzrange); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _subtract_tstzrange(rangea tstzrange, rangeb tstzrange) RETURNS tstzrange[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    result tstzrange[];
    str_tzrange1_inc_excl text;
    str_tzrange2_inc_excl text;
    result_non_cont_part_a tstzrange;
    result_non_cont_part_b tstzrange;
BEGIN


if rangeA && rangeB then

--identify the special case the a subtraction of the ranges, would result in a non continuous range.
                if rangeA @> lower(rangeB) and  rangeA @> upper(rangeB)  
                        and not   --make sure that rangeA @> lower(rangeB) actually holds true, considering inc/exc.   
                            (
                                lower(rangeA)=lower(rangeB) 
                                and lower_inc(rangeB) 
                                and not lower_inc(rangeA) 
                            ) 
                        and not  --make sure that rangeA @> upper(rangeB) actually holds true, considering inc/exc.
                            (
                                upper(rangeA)=upper(rangeB) 
                                and upper_inc(rangeB) 
                                and not upper_inc(rangeA)   
                            )
                then
                    if lower_inc(rangeA) then
                        str_tzrange1_inc_excl:='[';
                        else
                        str_tzrange1_inc_excl:='(';
                    end if;

                     if lower_inc(rangeB) then
                        str_tzrange1_inc_excl:= str_tzrange1_inc_excl || ')';
                        else
                        str_tzrange1_inc_excl:= str_tzrange1_inc_excl || ']';
                    end if;

                    if upper_inc(rangeB) then
                        str_tzrange2_inc_excl:='(';
                        else
                        str_tzrange2_inc_excl:='[';
                    end if;

                     if upper_inc(rangeA) then
                        str_tzrange2_inc_excl:= str_tzrange2_inc_excl || ']';
                        else
                        str_tzrange2_inc_excl:= str_tzrange2_inc_excl || ')';
                    end if;
                        

                    result_non_cont_part_a :=tstzrange(lower(rangeA),lower(rangeB),str_tzrange1_inc_excl);
                    result_non_cont_part_b :=tstzrange(upper(rangeB),upper(rangeA),str_tzrange2_inc_excl);

                    if not isempty(result_non_cont_part_a) then
                        result:=array_append(result,result_non_cont_part_a);
                    end if;
                    
                    if  not isempty(result_non_cont_part_b) then
                        result:=array_append(result,result_non_cont_part_b);
                    end if;    
                        
                else
                        if (not isempty(rangeA-rangeB)) then
                            result[1]:= rangeA-rangeB;
                        end if;
                end if; 

else
    result[1]:=rangeA;

end if;


return result;


END;
$$;


ALTER FUNCTION actual_state._subtract_tstzrange(rangea tstzrange, rangeb tstzrange) OWNER TO mox;

--
-- Name: _subtract_tstzrange_arr(tstzrange, tstzrange[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _subtract_tstzrange_arr(rangea tstzrange, rangearr tstzrange[]) RETURNS tstzrange[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE 
result tstzrange[];
temp_result tstzrange[];
rangeB tstzrange;
rangeA_leftover tstzrange;
BEGIN

result[1]:=rangeA;

IF rangeArr IS NOT NULL THEN
	FOREACH rangeB in array rangeArr
	LOOP
		temp_result:=result;
		result:='{}';

		FOREACH rangeA_leftover in array temp_result
		LOOP
			result:=array_cat(result, _subtract_tstzrange(rangeA_leftover,rangeB) );
		END LOOP;

	END LOOP;
END IF;

return result;

END;
$$;


ALTER FUNCTION actual_state._subtract_tstzrange_arr(rangea tstzrange, rangearr tstzrange[]) OWNER TO mox;

--
-- Name: _uuid_to_text(uuid); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION _uuid_to_text(uuid) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1::TEXT$_$;


ALTER FUNCTION actual_state._uuid_to_text(uuid) OWNER TO mox;

--
-- Name: as_create_or_import_aktivitet(aktivitetregistreringtype, uuid, aktivitetregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_aktivitet(aktivitet_registrering aktivitetregistreringtype, aktivitet_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr aktivitetregistreringtype[] DEFAULT NULL::aktivitetregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  aktivitet_registrering_id bigint;
  aktivitet_attr_egenskaber_obj aktivitetEgenskaberAttrType;
  
  aktivitet_tils_status_obj aktivitetStatusTilsType;
  aktivitet_tils_publiceret_obj aktivitetPubliceretTilsType;
  
  aktivitet_relationer AktivitetRelationType;
  auth_filtered_uuids uuid[];
  aktivitet_relation_kode aktivitetRelationKode;
  aktivitet_uuid_underscores text;
  aktivitet_rel_seq_name text;
  aktivitet_rel_type_cardinality_unlimited aktivitetRelationKode[]:=ARRAY['udfoererklasse'::AktivitetRelationKode,'deltagerklasse'::AktivitetRelationKode,'objektklasse'::AktivitetRelationKode,'resultatklasse'::AktivitetRelationKode,'grundlagklasse'::AktivitetRelationKode,'facilitetklasse'::AktivitetRelationKode,'adresse'::AktivitetRelationKode,'geoobjekt'::AktivitetRelationKode,'position'::AktivitetRelationKode,'facilitet'::AktivitetRelationKode,'lokale'::AktivitetRelationKode,'aktivitetdokument'::AktivitetRelationKode,'aktivitetgrundlag'::AktivitetRelationKode,'aktivitetresultat'::AktivitetRelationKode,'udfoerer'::AktivitetRelationKode,'deltager'::AktivitetRelationKode]::aktivitetRelationKode[];
  aktivitet_rel_type_cardinality_unlimited_present_in_argument aktivitetRelationKode[];

BEGIN

IF aktivitet_uuid IS NULL THEN
    LOOP
    aktivitet_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from aktivitet WHERE id=aktivitet_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from aktivitet WHERE id=aktivitet_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing aktivitet with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_aktivitet (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',aktivitet_uuid USING ERRCODE='MO500';
END IF;

IF  (aktivitet_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (aktivitet_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_aktivitet.',(aktivitet_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      aktivitet (ID)
SELECT
      aktivitet_uuid
;


/*********************************/
--Insert new registrering

aktivitet_registrering_id:=nextval('aktivitet_registrering_id_seq');

INSERT INTO aktivitet_registrering (
      id,
        aktivitet_id,
          registrering
        )
SELECT
      aktivitet_registrering_id,
        aktivitet_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (aktivitet_registrering.registrering).livscykluskode,
            (aktivitet_registrering.registrering).brugerref,
            (aktivitet_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(aktivitet_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [aktivitet]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF aktivitet_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(aktivitet_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH aktivitet_attr_egenskaber_obj IN ARRAY aktivitet_registrering.attrEgenskaber
  LOOP

    INSERT INTO aktivitet_attr_egenskaber (
      brugervendtnoegle,
      aktivitetnavn,
      beskrivelse,
      starttidspunkt,
      sluttidspunkt,
      tidsforbrug,
      formaal,
      virkning,
      aktivitet_registrering_id
    )
    SELECT
     aktivitet_attr_egenskaber_obj.brugervendtnoegle,
      aktivitet_attr_egenskaber_obj.aktivitetnavn,
      aktivitet_attr_egenskaber_obj.beskrivelse,
      aktivitet_attr_egenskaber_obj.starttidspunkt,
      aktivitet_attr_egenskaber_obj.sluttidspunkt,
      aktivitet_attr_egenskaber_obj.tidsforbrug,
      aktivitet_attr_egenskaber_obj.formaal,
      aktivitet_attr_egenskaber_obj.virkning,
      aktivitet_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(aktivitet_registrering.tilsStatus, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [status] for aktivitet. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF aktivitet_registrering.tilsStatus IS NOT NULL AND coalesce(array_length(aktivitet_registrering.tilsStatus,1),0)>0 THEN
  FOREACH aktivitet_tils_status_obj IN ARRAY aktivitet_registrering.tilsStatus
  LOOP

    INSERT INTO aktivitet_tils_status (
      virkning,
      status,
      aktivitet_registrering_id
    )
    SELECT
      aktivitet_tils_status_obj.virkning,
      aktivitet_tils_status_obj.status,
      aktivitet_registrering_id;

  END LOOP;
END IF;

--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(aktivitet_registrering.tilsPubliceret, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [publiceret] for aktivitet. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF aktivitet_registrering.tilsPubliceret IS NOT NULL AND coalesce(array_length(aktivitet_registrering.tilsPubliceret,1),0)>0 THEN
  FOREACH aktivitet_tils_publiceret_obj IN ARRAY aktivitet_registrering.tilsPubliceret
  LOOP

    INSERT INTO aktivitet_tils_publiceret (
      virkning,
      publiceret,
      aktivitet_registrering_id
    )
    SELECT
      aktivitet_tils_publiceret_obj.virkning,
      aktivitet_tils_publiceret_obj.publiceret,
      aktivitet_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

IF coalesce(array_length(aktivitet_registrering.relationer,1),0)>0 THEN

--Create temporary sequences
aktivitet_uuid_underscores:=replace(aktivitet_uuid::text, '-', '_');

SELECT array_agg( DISTINCT a.RelType) into aktivitet_rel_type_cardinality_unlimited_present_in_argument FROM  unnest(aktivitet_registrering.relationer) a WHERE a.RelType = any (aktivitet_rel_type_cardinality_unlimited) ;
IF coalesce(array_length(aktivitet_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN

FOREACH aktivitet_relation_kode IN ARRAY (aktivitet_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  aktivitet_rel_seq_name := 'aktivitet_' || aktivitet_relation_kode::text || aktivitet_uuid_underscores;

  EXECUTE 'CREATE TEMPORARY SEQUENCE ' || aktivitet_rel_seq_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START 1
  CACHE 1;';

END LOOP;
END IF;

    INSERT INTO aktivitet_relation (
      aktivitet_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type,
      rel_index,
      aktoer_attr
    )
    SELECT
      aktivitet_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType,
        CASE WHEN a.relType = any (aktivitet_rel_type_cardinality_unlimited) THEN --rel_index
        nextval('aktivitet_' || a.relType::text || aktivitet_uuid_underscores)
        ELSE 
        NULL
        END,
        CASE 
          WHEN a.relType =('udfoerer'::AktivitetRelationKode)  OR a.relType=('deltager'::AktivitetRelationKode) OR a.relType=('ansvarlig'::AktivitetRelationKode) 
          AND NOT (a.aktoerAttr IS NULL)
          AND (
            (a.aktoerAttr).obligatorisk IS NOT NULL
            OR
            (a.aktoerAttr).accepteret IS NOT NULL
            OR
              (
                (a.aktoerAttr).repraesentation_uuid IS NOT NULL
                OR
                ((a.aktoerAttr).repraesentation_urn IS NOT NULL AND (a.aktoerAttr).repraesentation_urn<>'')
              )
            ) 
          THEN a.aktoerAttr
          ELSE
          NULL
        END
    FROM unnest(aktivitet_registrering.relationer) a
    ;


--Drop temporary sequences
IF coalesce(array_length(aktivitet_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH aktivitet_relation_kode IN ARRAY (aktivitet_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  aktivitet_rel_seq_name := 'aktivitet_' || aktivitet_relation_kode::text || aktivitet_uuid_underscores;
  EXECUTE 'DROP  SEQUENCE ' || aktivitet_rel_seq_name || ';';
END LOOP;
END IF;


END IF;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_aktivitet(array[aktivitet_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[aktivitet_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import aktivitet with uuid [%]. Object does not met stipulated criteria:%',aktivitet_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN aktivitet_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_aktivitet(aktivitet_registrering aktivitetregistreringtype, aktivitet_uuid uuid, auth_criteria_arr aktivitetregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_bruger(brugerregistreringtype, uuid, brugerregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_bruger(bruger_registrering brugerregistreringtype, bruger_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr brugerregistreringtype[] DEFAULT NULL::brugerregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  bruger_registrering_id bigint;
  bruger_attr_egenskaber_obj brugerEgenskaberAttrType;
  
  bruger_tils_gyldighed_obj brugerGyldighedTilsType;
  
  bruger_relationer BrugerRelationType;
  auth_filtered_uuids uuid[];
BEGIN

IF bruger_uuid IS NULL THEN
    LOOP
    bruger_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from bruger WHERE id=bruger_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from bruger WHERE id=bruger_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing bruger with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_bruger (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',bruger_uuid USING ERRCODE='MO500';
END IF;

IF  (bruger_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (bruger_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_bruger.',(bruger_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      bruger (ID)
SELECT
      bruger_uuid
;


/*********************************/
--Insert new registrering

bruger_registrering_id:=nextval('bruger_registrering_id_seq');

INSERT INTO bruger_registrering (
      id,
        bruger_id,
          registrering
        )
SELECT
      bruger_registrering_id,
        bruger_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (bruger_registrering.registrering).livscykluskode,
            (bruger_registrering.registrering).brugerref,
            (bruger_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(bruger_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [bruger]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF bruger_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(bruger_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH bruger_attr_egenskaber_obj IN ARRAY bruger_registrering.attrEgenskaber
  LOOP

    INSERT INTO bruger_attr_egenskaber (
      brugervendtnoegle,
      brugernavn,
      brugertype,
      virkning,
      bruger_registrering_id
    )
    SELECT
     bruger_attr_egenskaber_obj.brugervendtnoegle,
      bruger_attr_egenskaber_obj.brugernavn,
      bruger_attr_egenskaber_obj.brugertype,
      bruger_attr_egenskaber_obj.virkning,
      bruger_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(bruger_registrering.tilsGyldighed, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [gyldighed] for bruger. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF bruger_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(bruger_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH bruger_tils_gyldighed_obj IN ARRAY bruger_registrering.tilsGyldighed
  LOOP

    INSERT INTO bruger_tils_gyldighed (
      virkning,
      gyldighed,
      bruger_registrering_id
    )
    SELECT
      bruger_tils_gyldighed_obj.virkning,
      bruger_tils_gyldighed_obj.gyldighed,
      bruger_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

    INSERT INTO bruger_relation (
      bruger_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      bruger_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(bruger_registrering.relationer) a
  ;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_bruger(array[bruger_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[bruger_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import bruger with uuid [%]. Object does not met stipulated criteria:%',bruger_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN bruger_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_bruger(bruger_registrering brugerregistreringtype, bruger_uuid uuid, auth_criteria_arr brugerregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_dokument(dokumentregistreringtype, uuid, dokumentregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_dokument(dokument_registrering dokumentregistreringtype, dokument_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr dokumentregistreringtype[] DEFAULT NULL::dokumentregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  dokument_registrering_id bigint;
  dokument_attr_egenskaber_obj dokumentEgenskaberAttrType;
  
  dokument_tils_fremdrift_obj dokumentFremdriftTilsType;
  
  dokument_relationer DokumentRelationType;
  dokument_variant_obj DokumentVariantType;
  dokument_variant_egenskab_obj DokumentVariantEgenskaberType;
  dokument_del_obj DokumentDelType;
  dokument_del_egenskaber_obj DokumentDelEgenskaberType;
  dokument_del_relation_obj DokumentDelRelationType;
  dokument_variant_new_id bigint;
  dokument_del_new_id bigint;
  auth_filtered_uuids uuid[];
BEGIN

IF dokument_uuid IS NULL THEN
    LOOP
    dokument_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from dokument WHERE id=dokument_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from dokument WHERE id=dokument_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing dokument with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_dokument (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',dokument_uuid USING ERRCODE='MO500';
END IF;

IF  (dokument_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (dokument_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_dokument.',(dokument_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      dokument (ID)
SELECT
      dokument_uuid
;


/*********************************/
--Insert new registrering

dokument_registrering_id:=nextval('dokument_registrering_id_seq');

INSERT INTO dokument_registrering (
      id,
        dokument_id,
          registrering
        )
SELECT
      dokument_registrering_id,
        dokument_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (dokument_registrering.registrering).livscykluskode,
            (dokument_registrering.registrering).brugerref,
            (dokument_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(dokument_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [dokument]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF dokument_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(dokument_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH dokument_attr_egenskaber_obj IN ARRAY dokument_registrering.attrEgenskaber
  LOOP

    INSERT INTO dokument_attr_egenskaber (
      brugervendtnoegle,
      beskrivelse,
      brevdato,
      kassationskode,
      major,
      minor,
      offentlighedundtaget,
      titel,
      dokumenttype,
      virkning,
      dokument_registrering_id
    )
    SELECT
     dokument_attr_egenskaber_obj.brugervendtnoegle,
      dokument_attr_egenskaber_obj.beskrivelse,
      dokument_attr_egenskaber_obj.brevdato,
      dokument_attr_egenskaber_obj.kassationskode,
      dokument_attr_egenskaber_obj.major,
      dokument_attr_egenskaber_obj.minor,
      dokument_attr_egenskaber_obj.offentlighedundtaget,
      dokument_attr_egenskaber_obj.titel,
      dokument_attr_egenskaber_obj.dokumenttype,
      dokument_attr_egenskaber_obj.virkning,
      dokument_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(dokument_registrering.tilsFremdrift, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [fremdrift] for dokument. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF dokument_registrering.tilsFremdrift IS NOT NULL AND coalesce(array_length(dokument_registrering.tilsFremdrift,1),0)>0 THEN
  FOREACH dokument_tils_fremdrift_obj IN ARRAY dokument_registrering.tilsFremdrift
  LOOP

    INSERT INTO dokument_tils_fremdrift (
      virkning,
      fremdrift,
      dokument_registrering_id
    )
    SELECT
      dokument_tils_fremdrift_obj.virkning,
      dokument_tils_fremdrift_obj.fremdrift,
      dokument_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

    INSERT INTO dokument_relation (
      dokument_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      dokument_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(dokument_registrering.relationer) a
  ;


/*********************************/
--Insert document variants (and parts)

IF dokument_registrering.varianter IS NOT NULL AND coalesce(array_length(dokument_registrering.varianter,1),0)>0 THEN
  

FOREACH dokument_variant_obj IN ARRAY dokument_registrering.varianter
LOOP

dokument_variant_new_id:=nextval('dokument_variant_id_seq'::regclass);

  INSERT INTO dokument_variant (
      id,
        varianttekst,
          dokument_registrering_id
  )
  VALUES
  (
      dokument_variant_new_id,
        dokument_variant_obj.varianttekst,
          dokument_registrering_id
  ); 


  IF dokument_variant_obj.egenskaber IS NOT NULL AND coalesce(array_length(dokument_variant_obj.egenskaber,1),0)>0 THEN

    FOREACH dokument_variant_egenskab_obj IN ARRAY dokument_variant_obj.egenskaber
    LOOP

     INSERT INTO dokument_variant_egenskaber (
      variant_id,
        arkivering, 
          delvisscannet, 
            offentliggoerelse, 
              produktion,
                virkning
      )
      SELECT
      dokument_variant_new_id,  
        dokument_variant_egenskab_obj.arkivering,
          dokument_variant_egenskab_obj.delvisscannet,
            dokument_variant_egenskab_obj.offentliggoerelse,
              dokument_variant_egenskab_obj.produktion,
                dokument_variant_egenskab_obj.virkning
      ;

    END LOOP; --variant_egenskaber
  END IF; --variant_egenskaber


  IF dokument_variant_obj.dele IS NOT NULL AND coalesce(array_length(dokument_variant_obj.dele,1),0)>0 THEN

    FOREACH dokument_del_obj IN ARRAY dokument_variant_obj.dele
    LOOP

    dokument_del_new_id:=nextval('dokument_del_id_seq'::regclass);

  INSERT INTO dokument_del (
    id,
      deltekst,
        variant_id
    )
    VALUES
    (
    dokument_del_new_id,
        dokument_del_obj.deltekst,
          dokument_variant_new_id
    )
    ;

    IF dokument_del_obj.egenskaber IS NOT NULL AND coalesce(array_length(dokument_del_obj.egenskaber,1),0)>0 THEN

    FOREACH dokument_del_egenskaber_obj IN ARRAY dokument_del_obj.egenskaber
    LOOP

    INSERT INTO
    dokument_del_egenskaber (
      del_id,
        indeks, 
          indhold, 
            lokation, 
              mimetype, 
                virkning
    )
    VALUES
    (
      dokument_del_new_id, 
        dokument_del_egenskaber_obj.indeks,
          dokument_del_egenskaber_obj.indhold,
            dokument_del_egenskaber_obj.lokation,
              dokument_del_egenskaber_obj.mimetype,
                dokument_del_egenskaber_obj.virkning
    )
    ;                

    END LOOP;--del_egenskaber
    END IF; --del_egenskaber

    IF dokument_del_obj.relationer IS NOT NULL AND coalesce(array_length(dokument_del_obj.relationer,1),0)>0 THEN

    FOREACH dokument_del_relation_obj IN ARRAY dokument_del_obj.relationer
    LOOP

      INSERT INTO dokument_del_relation (
        del_id,
          virkning,
            rel_maal_uuid, 
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      VALUES
      (
        dokument_del_new_id,
          dokument_del_relation_obj.virkning,
            dokument_del_relation_obj.uuid,
              dokument_del_relation_obj.urn,
                dokument_del_relation_obj.relType,
                  dokument_del_relation_obj.objektType
      )
      ;

    END LOOP;--del_relationer

    END IF; --dokument_del_obj.relationer

    END LOOP; --variant_dele
  END IF; 

 END LOOP; --varianter


END IF; --varianter


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_dokument(array[dokument_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[dokument_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import dokument with uuid [%]. Object does not met stipulated criteria:%',dokument_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN dokument_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_dokument(dokument_registrering dokumentregistreringtype, dokument_uuid uuid, auth_criteria_arr dokumentregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_facet(facetregistreringtype, uuid, facetregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_facet(facet_registrering facetregistreringtype, facet_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr facetregistreringtype[] DEFAULT NULL::facetregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  facet_registrering_id bigint;
  facet_attr_egenskaber_obj facetEgenskaberAttrType;
  
  facet_tils_publiceret_obj facetPubliceretTilsType;
  
  facet_relationer FacetRelationType;
  auth_filtered_uuids uuid[];
BEGIN

IF facet_uuid IS NULL THEN
    LOOP
    facet_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from facet WHERE id=facet_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from facet WHERE id=facet_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing facet with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_facet (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',facet_uuid USING ERRCODE='MO500';
END IF;

IF  (facet_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (facet_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_facet.',(facet_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      facet (ID)
SELECT
      facet_uuid
;


/*********************************/
--Insert new registrering

facet_registrering_id:=nextval('facet_registrering_id_seq');

INSERT INTO facet_registrering (
      id,
        facet_id,
          registrering
        )
SELECT
      facet_registrering_id,
        facet_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (facet_registrering.registrering).livscykluskode,
            (facet_registrering.registrering).brugerref,
            (facet_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(facet_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [facet]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF facet_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(facet_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH facet_attr_egenskaber_obj IN ARRAY facet_registrering.attrEgenskaber
  LOOP

    INSERT INTO facet_attr_egenskaber (
      brugervendtnoegle,
      beskrivelse,
      opbygning,
      ophavsret,
      plan,
      supplement,
      retskilde,
      virkning,
      facet_registrering_id
    )
    SELECT
     facet_attr_egenskaber_obj.brugervendtnoegle,
      facet_attr_egenskaber_obj.beskrivelse,
      facet_attr_egenskaber_obj.opbygning,
      facet_attr_egenskaber_obj.ophavsret,
      facet_attr_egenskaber_obj.plan,
      facet_attr_egenskaber_obj.supplement,
      facet_attr_egenskaber_obj.retskilde,
      facet_attr_egenskaber_obj.virkning,
      facet_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(facet_registrering.tilsPubliceret, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [publiceret] for facet. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF facet_registrering.tilsPubliceret IS NOT NULL AND coalesce(array_length(facet_registrering.tilsPubliceret,1),0)>0 THEN
  FOREACH facet_tils_publiceret_obj IN ARRAY facet_registrering.tilsPubliceret
  LOOP

    INSERT INTO facet_tils_publiceret (
      virkning,
      publiceret,
      facet_registrering_id
    )
    SELECT
      facet_tils_publiceret_obj.virkning,
      facet_tils_publiceret_obj.publiceret,
      facet_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

    INSERT INTO facet_relation (
      facet_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      facet_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(facet_registrering.relationer) a
  ;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_facet(array[facet_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[facet_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import facet with uuid [%]. Object does not met stipulated criteria:%',facet_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN facet_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_facet(facet_registrering facetregistreringtype, facet_uuid uuid, auth_criteria_arr facetregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_indsats(indsatsregistreringtype, uuid, indsatsregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_indsats(indsats_registrering indsatsregistreringtype, indsats_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr indsatsregistreringtype[] DEFAULT NULL::indsatsregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  indsats_registrering_id bigint;
  indsats_attr_egenskaber_obj indsatsEgenskaberAttrType;
  
  indsats_tils_publiceret_obj indsatsPubliceretTilsType;
  indsats_tils_fremdrift_obj indsatsFremdriftTilsType;
  
  indsats_relationer IndsatsRelationType;
  auth_filtered_uuids uuid[];
  indsats_relation_kode indsatsRelationKode;
  indsats_uuid_underscores text;
  indsats_rel_seq_name text;
  indsats_rel_type_cardinality_unlimited indsatsRelationKode[]:=ARRAY['indsatskvalitet'::IndsatsRelationKode,'indsatsaktoer'::IndsatsRelationKode,'samtykke'::IndsatsRelationKode,'indsatssag'::IndsatsRelationKode,'indsatsdokument'::IndsatsRelationKode]::indsatsRelationKode[];
  indsats_rel_type_cardinality_unlimited_present_in_argument indsatsRelationKode[];
BEGIN

IF indsats_uuid IS NULL THEN
    LOOP
    indsats_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from indsats WHERE id=indsats_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from indsats WHERE id=indsats_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing indsats with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_indsats (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',indsats_uuid USING ERRCODE='MO500';
END IF;

IF  (indsats_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (indsats_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_indsats.',(indsats_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      indsats (ID)
SELECT
      indsats_uuid
;


/*********************************/
--Insert new registrering

indsats_registrering_id:=nextval('indsats_registrering_id_seq');

INSERT INTO indsats_registrering (
      id,
        indsats_id,
          registrering
        )
SELECT
      indsats_registrering_id,
        indsats_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (indsats_registrering.registrering).livscykluskode,
            (indsats_registrering.registrering).brugerref,
            (indsats_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(indsats_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [indsats]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF indsats_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(indsats_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH indsats_attr_egenskaber_obj IN ARRAY indsats_registrering.attrEgenskaber
  LOOP

    INSERT INTO indsats_attr_egenskaber (
      brugervendtnoegle,
      beskrivelse,
      starttidspunkt,
      sluttidspunkt,
      virkning,
      indsats_registrering_id
    )
    SELECT
     indsats_attr_egenskaber_obj.brugervendtnoegle,
      indsats_attr_egenskaber_obj.beskrivelse,
      indsats_attr_egenskaber_obj.starttidspunkt,
      indsats_attr_egenskaber_obj.sluttidspunkt,
      indsats_attr_egenskaber_obj.virkning,
      indsats_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(indsats_registrering.tilsPubliceret, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [publiceret] for indsats. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF indsats_registrering.tilsPubliceret IS NOT NULL AND coalesce(array_length(indsats_registrering.tilsPubliceret,1),0)>0 THEN
  FOREACH indsats_tils_publiceret_obj IN ARRAY indsats_registrering.tilsPubliceret
  LOOP

    INSERT INTO indsats_tils_publiceret (
      virkning,
      publiceret,
      indsats_registrering_id
    )
    SELECT
      indsats_tils_publiceret_obj.virkning,
      indsats_tils_publiceret_obj.publiceret,
      indsats_registrering_id;

  END LOOP;
END IF;

--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(indsats_registrering.tilsFremdrift, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [fremdrift] for indsats. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF indsats_registrering.tilsFremdrift IS NOT NULL AND coalesce(array_length(indsats_registrering.tilsFremdrift,1),0)>0 THEN
  FOREACH indsats_tils_fremdrift_obj IN ARRAY indsats_registrering.tilsFremdrift
  LOOP

    INSERT INTO indsats_tils_fremdrift (
      virkning,
      fremdrift,
      indsats_registrering_id
    )
    SELECT
      indsats_tils_fremdrift_obj.virkning,
      indsats_tils_fremdrift_obj.fremdrift,
      indsats_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

IF coalesce(array_length(indsats_registrering.relationer,1),0)>0 THEN

--Create temporary sequences
indsats_uuid_underscores:=replace(indsats_uuid::text, '-', '_');

SELECT array_agg( DISTINCT a.RelType) into indsats_rel_type_cardinality_unlimited_present_in_argument FROM  unnest(indsats_registrering.relationer) a WHERE a.RelType = any (indsats_rel_type_cardinality_unlimited) ;
IF coalesce(array_length(indsats_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH indsats_relation_kode IN ARRAY (indsats_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  indsats_rel_seq_name := 'indsats_' || indsats_relation_kode::text || indsats_uuid_underscores;

  EXECUTE 'CREATE TEMPORARY SEQUENCE ' || indsats_rel_seq_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START 1
  CACHE 1;';

END LOOP;
END IF;

    INSERT INTO indsats_relation (
      indsats_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type,
      rel_index
    )
    SELECT
      indsats_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType,
        CASE WHEN a.relType = any (indsats_rel_type_cardinality_unlimited) THEN --rel_index
        nextval('indsats_' || a.relType::text || indsats_uuid_underscores)
        ELSE 
        NULL
        END
    FROM unnest(indsats_registrering.relationer) a
    ;


--Drop temporary sequences
IF coalesce(array_length(indsats_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH indsats_relation_kode IN ARRAY (indsats_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  indsats_rel_seq_name := 'indsats_' || indsats_relation_kode::text || indsats_uuid_underscores;
  EXECUTE 'DROP  SEQUENCE ' || indsats_rel_seq_name || ';';
END LOOP;
END IF;

END IF;

/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_indsats(array[indsats_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[indsats_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import indsats with uuid [%]. Object does not met stipulated criteria:%',indsats_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN indsats_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_indsats(indsats_registrering indsatsregistreringtype, indsats_uuid uuid, auth_criteria_arr indsatsregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_interessefaellesskab(interessefaellesskabregistreringtype, uuid, interessefaellesskabregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_interessefaellesskab(interessefaellesskab_registrering interessefaellesskabregistreringtype, interessefaellesskab_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr interessefaellesskabregistreringtype[] DEFAULT NULL::interessefaellesskabregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  interessefaellesskab_registrering_id bigint;
  interessefaellesskab_attr_egenskaber_obj interessefaellesskabEgenskaberAttrType;
  
  interessefaellesskab_tils_gyldighed_obj interessefaellesskabGyldighedTilsType;
  
  interessefaellesskab_relationer InteressefaellesskabRelationType;
  auth_filtered_uuids uuid[];
BEGIN

IF interessefaellesskab_uuid IS NULL THEN
    LOOP
    interessefaellesskab_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from interessefaellesskab WHERE id=interessefaellesskab_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from interessefaellesskab WHERE id=interessefaellesskab_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing interessefaellesskab with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_interessefaellesskab (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',interessefaellesskab_uuid USING ERRCODE='MO500';
END IF;

IF  (interessefaellesskab_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (interessefaellesskab_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_interessefaellesskab.',(interessefaellesskab_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      interessefaellesskab (ID)
SELECT
      interessefaellesskab_uuid
;


/*********************************/
--Insert new registrering

interessefaellesskab_registrering_id:=nextval('interessefaellesskab_registrering_id_seq');

INSERT INTO interessefaellesskab_registrering (
      id,
        interessefaellesskab_id,
          registrering
        )
SELECT
      interessefaellesskab_registrering_id,
        interessefaellesskab_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (interessefaellesskab_registrering.registrering).livscykluskode,
            (interessefaellesskab_registrering.registrering).brugerref,
            (interessefaellesskab_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(interessefaellesskab_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [interessefaellesskab]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF interessefaellesskab_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(interessefaellesskab_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH interessefaellesskab_attr_egenskaber_obj IN ARRAY interessefaellesskab_registrering.attrEgenskaber
  LOOP

    INSERT INTO interessefaellesskab_attr_egenskaber (
      brugervendtnoegle,
      interessefaellesskabsnavn,
      interessefaellesskabstype,
      virkning,
      interessefaellesskab_registrering_id
    )
    SELECT
     interessefaellesskab_attr_egenskaber_obj.brugervendtnoegle,
      interessefaellesskab_attr_egenskaber_obj.interessefaellesskabsnavn,
      interessefaellesskab_attr_egenskaber_obj.interessefaellesskabstype,
      interessefaellesskab_attr_egenskaber_obj.virkning,
      interessefaellesskab_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(interessefaellesskab_registrering.tilsGyldighed, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [gyldighed] for interessefaellesskab. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF interessefaellesskab_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(interessefaellesskab_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH interessefaellesskab_tils_gyldighed_obj IN ARRAY interessefaellesskab_registrering.tilsGyldighed
  LOOP

    INSERT INTO interessefaellesskab_tils_gyldighed (
      virkning,
      gyldighed,
      interessefaellesskab_registrering_id
    )
    SELECT
      interessefaellesskab_tils_gyldighed_obj.virkning,
      interessefaellesskab_tils_gyldighed_obj.gyldighed,
      interessefaellesskab_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

    INSERT INTO interessefaellesskab_relation (
      interessefaellesskab_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      interessefaellesskab_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(interessefaellesskab_registrering.relationer) a
  ;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_interessefaellesskab(array[interessefaellesskab_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[interessefaellesskab_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import interessefaellesskab with uuid [%]. Object does not met stipulated criteria:%',interessefaellesskab_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN interessefaellesskab_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_interessefaellesskab(interessefaellesskab_registrering interessefaellesskabregistreringtype, interessefaellesskab_uuid uuid, auth_criteria_arr interessefaellesskabregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_itsystem(itsystemregistreringtype, uuid, itsystemregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_itsystem(itsystem_registrering itsystemregistreringtype, itsystem_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr itsystemregistreringtype[] DEFAULT NULL::itsystemregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  itsystem_registrering_id bigint;
  itsystem_attr_egenskaber_obj itsystemEgenskaberAttrType;
  
  itsystem_tils_gyldighed_obj itsystemGyldighedTilsType;
  
  itsystem_relationer ItsystemRelationType;
  auth_filtered_uuids uuid[];
BEGIN

IF itsystem_uuid IS NULL THEN
    LOOP
    itsystem_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from itsystem WHERE id=itsystem_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from itsystem WHERE id=itsystem_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing itsystem with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_itsystem (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',itsystem_uuid USING ERRCODE='MO500';
END IF;

IF  (itsystem_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (itsystem_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_itsystem.',(itsystem_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      itsystem (ID)
SELECT
      itsystem_uuid
;


/*********************************/
--Insert new registrering

itsystem_registrering_id:=nextval('itsystem_registrering_id_seq');

INSERT INTO itsystem_registrering (
      id,
        itsystem_id,
          registrering
        )
SELECT
      itsystem_registrering_id,
        itsystem_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (itsystem_registrering.registrering).livscykluskode,
            (itsystem_registrering.registrering).brugerref,
            (itsystem_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(itsystem_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [itsystem]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF itsystem_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(itsystem_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH itsystem_attr_egenskaber_obj IN ARRAY itsystem_registrering.attrEgenskaber
  LOOP

    INSERT INTO itsystem_attr_egenskaber (
      brugervendtnoegle,
      itsystemnavn,
      itsystemtype,
      konfigurationreference,
      virkning,
      itsystem_registrering_id
    )
    SELECT
     itsystem_attr_egenskaber_obj.brugervendtnoegle,
      itsystem_attr_egenskaber_obj.itsystemnavn,
      itsystem_attr_egenskaber_obj.itsystemtype,
      itsystem_attr_egenskaber_obj.konfigurationreference,
      itsystem_attr_egenskaber_obj.virkning,
      itsystem_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(itsystem_registrering.tilsGyldighed, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [gyldighed] for itsystem. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF itsystem_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(itsystem_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH itsystem_tils_gyldighed_obj IN ARRAY itsystem_registrering.tilsGyldighed
  LOOP

    INSERT INTO itsystem_tils_gyldighed (
      virkning,
      gyldighed,
      itsystem_registrering_id
    )
    SELECT
      itsystem_tils_gyldighed_obj.virkning,
      itsystem_tils_gyldighed_obj.gyldighed,
      itsystem_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

    INSERT INTO itsystem_relation (
      itsystem_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      itsystem_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(itsystem_registrering.relationer) a
  ;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_itsystem(array[itsystem_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[itsystem_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import itsystem with uuid [%]. Object does not met stipulated criteria:%',itsystem_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN itsystem_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_itsystem(itsystem_registrering itsystemregistreringtype, itsystem_uuid uuid, auth_criteria_arr itsystemregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_klasse(klasseregistreringtype, uuid, klasseregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_klasse(klasse_registrering klasseregistreringtype, klasse_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr klasseregistreringtype[] DEFAULT NULL::klasseregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  klasse_registrering_id bigint;
  klasse_attr_egenskaber_obj klasseEgenskaberAttrType;
  
  klasse_tils_publiceret_obj klassePubliceretTilsType;
  
  klasse_relationer KlasseRelationType;
  klasse_attr_egenskaber_id bigint;
  klasse_attr_egenskaber_soegeord_obj KlasseSoegeordType;
  auth_filtered_uuids uuid[];
BEGIN

IF klasse_uuid IS NULL THEN
    LOOP
    klasse_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from klasse WHERE id=klasse_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from klasse WHERE id=klasse_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing klasse with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_klasse (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',klasse_uuid USING ERRCODE='MO500';
END IF;

IF  (klasse_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (klasse_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_klasse.',(klasse_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      klasse (ID)
SELECT
      klasse_uuid
;


/*********************************/
--Insert new registrering

klasse_registrering_id:=nextval('klasse_registrering_id_seq');

INSERT INTO klasse_registrering (
      id,
        klasse_id,
          registrering
        )
SELECT
      klasse_registrering_id,
        klasse_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (klasse_registrering.registrering).livscykluskode,
            (klasse_registrering.registrering).brugerref,
            (klasse_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(klasse_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [klasse]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF klasse_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(klasse_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH klasse_attr_egenskaber_obj IN ARRAY klasse_registrering.attrEgenskaber
  LOOP

klasse_attr_egenskaber_id:=nextval('klasse_attr_egenskaber_id_seq');
  INSERT INTO klasse_attr_egenskaber (
    id,
    brugervendtnoegle,
    beskrivelse,
    eksempel,
    omfang,
    titel,
    retskilde,
    aendringsnotat,
    virkning,
    klasse_registrering_id
  )
  SELECT
    klasse_attr_egenskaber_id,
   klasse_attr_egenskaber_obj.brugervendtnoegle,
    klasse_attr_egenskaber_obj.beskrivelse,
    klasse_attr_egenskaber_obj.eksempel,
    klasse_attr_egenskaber_obj.omfang,
    klasse_attr_egenskaber_obj.titel,
    klasse_attr_egenskaber_obj.retskilde,
    klasse_attr_egenskaber_obj.aendringsnotat,
    klasse_attr_egenskaber_obj.virkning,
    klasse_registrering_id
  ;

/************/
--Insert Soegeord
  IF klasse_attr_egenskaber_obj.soegeord IS NOT NULL AND coalesce(array_length(klasse_attr_egenskaber_obj.soegeord,1),0)>1  THEN
    FOREACH klasse_attr_egenskaber_soegeord_obj IN ARRAY klasse_attr_egenskaber_obj.soegeord
      LOOP

      IF (klasse_attr_egenskaber_soegeord_obj.soegeordidentifikator IS NOT NULL AND klasse_attr_egenskaber_soegeord_obj.soegeordidentifikator<>'') 
      OR (klasse_attr_egenskaber_soegeord_obj.beskrivelse IS NOT NULL AND klasse_attr_egenskaber_soegeord_obj.beskrivelse<>'' )
      OR (klasse_attr_egenskaber_soegeord_obj.soegeordskategori IS NOT NULL AND klasse_attr_egenskaber_soegeord_obj.soegeordskategori<>'') THEN

      INSERT INTO klasse_attr_egenskaber_soegeord (
        soegeordidentifikator,
        beskrivelse,
        soegeordskategori,
        klasse_attr_egenskaber_id
      )
      SELECT
        klasse_attr_egenskaber_soegeord_obj.soegeordidentifikator,
        klasse_attr_egenskaber_soegeord_obj.beskrivelse,
        klasse_attr_egenskaber_soegeord_obj.soegeordskategori,
        klasse_attr_egenskaber_id
      ;
      END IF;

     END LOOP;
    END IF;
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(klasse_registrering.tilsPubliceret, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [publiceret] for klasse. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF klasse_registrering.tilsPubliceret IS NOT NULL AND coalesce(array_length(klasse_registrering.tilsPubliceret,1),0)>0 THEN
  FOREACH klasse_tils_publiceret_obj IN ARRAY klasse_registrering.tilsPubliceret
  LOOP

    INSERT INTO klasse_tils_publiceret (
      virkning,
      publiceret,
      klasse_registrering_id
    )
    SELECT
      klasse_tils_publiceret_obj.virkning,
      klasse_tils_publiceret_obj.publiceret,
      klasse_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

    INSERT INTO klasse_relation (
      klasse_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      klasse_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(klasse_registrering.relationer) a
  ;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_klasse(array[klasse_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[klasse_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import klasse with uuid [%]. Object does not met stipulated criteria:%',klasse_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN klasse_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_klasse(klasse_registrering klasseregistreringtype, klasse_uuid uuid, auth_criteria_arr klasseregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_klassifikation(klassifikationregistreringtype, uuid, klassifikationregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_klassifikation(klassifikation_registrering klassifikationregistreringtype, klassifikation_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr klassifikationregistreringtype[] DEFAULT NULL::klassifikationregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  klassifikation_registrering_id bigint;
  klassifikation_attr_egenskaber_obj klassifikationEgenskaberAttrType;
  
  klassifikation_tils_publiceret_obj klassifikationPubliceretTilsType;
  
  klassifikation_relationer KlassifikationRelationType;
  auth_filtered_uuids uuid[];
BEGIN

IF klassifikation_uuid IS NULL THEN
    LOOP
    klassifikation_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from klassifikation WHERE id=klassifikation_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from klassifikation WHERE id=klassifikation_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing klassifikation with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_klassifikation (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',klassifikation_uuid USING ERRCODE='MO500';
END IF;

IF  (klassifikation_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (klassifikation_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_klassifikation.',(klassifikation_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      klassifikation (ID)
SELECT
      klassifikation_uuid
;


/*********************************/
--Insert new registrering

klassifikation_registrering_id:=nextval('klassifikation_registrering_id_seq');

INSERT INTO klassifikation_registrering (
      id,
        klassifikation_id,
          registrering
        )
SELECT
      klassifikation_registrering_id,
        klassifikation_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (klassifikation_registrering.registrering).livscykluskode,
            (klassifikation_registrering.registrering).brugerref,
            (klassifikation_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(klassifikation_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [klassifikation]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF klassifikation_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(klassifikation_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH klassifikation_attr_egenskaber_obj IN ARRAY klassifikation_registrering.attrEgenskaber
  LOOP

    INSERT INTO klassifikation_attr_egenskaber (
      brugervendtnoegle,
      beskrivelse,
      kaldenavn,
      ophavsret,
      virkning,
      klassifikation_registrering_id
    )
    SELECT
     klassifikation_attr_egenskaber_obj.brugervendtnoegle,
      klassifikation_attr_egenskaber_obj.beskrivelse,
      klassifikation_attr_egenskaber_obj.kaldenavn,
      klassifikation_attr_egenskaber_obj.ophavsret,
      klassifikation_attr_egenskaber_obj.virkning,
      klassifikation_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(klassifikation_registrering.tilsPubliceret, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [publiceret] for klassifikation. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF klassifikation_registrering.tilsPubliceret IS NOT NULL AND coalesce(array_length(klassifikation_registrering.tilsPubliceret,1),0)>0 THEN
  FOREACH klassifikation_tils_publiceret_obj IN ARRAY klassifikation_registrering.tilsPubliceret
  LOOP

    INSERT INTO klassifikation_tils_publiceret (
      virkning,
      publiceret,
      klassifikation_registrering_id
    )
    SELECT
      klassifikation_tils_publiceret_obj.virkning,
      klassifikation_tils_publiceret_obj.publiceret,
      klassifikation_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

    INSERT INTO klassifikation_relation (
      klassifikation_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      klassifikation_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(klassifikation_registrering.relationer) a
  ;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_klassifikation(array[klassifikation_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[klassifikation_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import klassifikation with uuid [%]. Object does not met stipulated criteria:%',klassifikation_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN klassifikation_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_klassifikation(klassifikation_registrering klassifikationregistreringtype, klassifikation_uuid uuid, auth_criteria_arr klassifikationregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_loghaendelse(loghaendelseregistreringtype, uuid, loghaendelseregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_loghaendelse(loghaendelse_registrering loghaendelseregistreringtype, loghaendelse_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr loghaendelseregistreringtype[] DEFAULT NULL::loghaendelseregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  loghaendelse_registrering_id bigint;
  loghaendelse_attr_egenskaber_obj loghaendelseEgenskaberAttrType;
  
  loghaendelse_tils_gyldighed_obj loghaendelseGyldighedTilsType;
  
  loghaendelse_relationer LoghaendelseRelationType;
  auth_filtered_uuids uuid[];
BEGIN

IF loghaendelse_uuid IS NULL THEN
    LOOP
    loghaendelse_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from loghaendelse WHERE id=loghaendelse_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from loghaendelse WHERE id=loghaendelse_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing loghaendelse with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_loghaendelse (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',loghaendelse_uuid USING ERRCODE='MO500';
END IF;

IF  (loghaendelse_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (loghaendelse_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_loghaendelse.',(loghaendelse_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      loghaendelse (ID)
SELECT
      loghaendelse_uuid
;


/*********************************/
--Insert new registrering

loghaendelse_registrering_id:=nextval('loghaendelse_registrering_id_seq');

INSERT INTO loghaendelse_registrering (
      id,
        loghaendelse_id,
          registrering
        )
SELECT
      loghaendelse_registrering_id,
        loghaendelse_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (loghaendelse_registrering.registrering).livscykluskode,
            (loghaendelse_registrering.registrering).brugerref,
            (loghaendelse_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(loghaendelse_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [loghaendelse]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF loghaendelse_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(loghaendelse_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH loghaendelse_attr_egenskaber_obj IN ARRAY loghaendelse_registrering.attrEgenskaber
  LOOP

    INSERT INTO loghaendelse_attr_egenskaber (
      service,
      klasse,
      tidspunkt,
      operation,
      objekttype,
      returkode,
      returtekst,
      note,
      virkning,
      loghaendelse_registrering_id
    )
    SELECT
     loghaendelse_attr_egenskaber_obj.service,
      loghaendelse_attr_egenskaber_obj.klasse,
      loghaendelse_attr_egenskaber_obj.tidspunkt,
      loghaendelse_attr_egenskaber_obj.operation,
      loghaendelse_attr_egenskaber_obj.objekttype,
      loghaendelse_attr_egenskaber_obj.returkode,
      loghaendelse_attr_egenskaber_obj.returtekst,
      loghaendelse_attr_egenskaber_obj.note,
      loghaendelse_attr_egenskaber_obj.virkning,
      loghaendelse_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(loghaendelse_registrering.tilsGyldighed, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [gyldighed] for loghaendelse. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF loghaendelse_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(loghaendelse_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH loghaendelse_tils_gyldighed_obj IN ARRAY loghaendelse_registrering.tilsGyldighed
  LOOP

    INSERT INTO loghaendelse_tils_gyldighed (
      virkning,
      gyldighed,
      loghaendelse_registrering_id
    )
    SELECT
      loghaendelse_tils_gyldighed_obj.virkning,
      loghaendelse_tils_gyldighed_obj.gyldighed,
      loghaendelse_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

    INSERT INTO loghaendelse_relation (
      loghaendelse_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      loghaendelse_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(loghaendelse_registrering.relationer) a
  ;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_loghaendelse(array[loghaendelse_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[loghaendelse_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import loghaendelse with uuid [%]. Object does not met stipulated criteria:%',loghaendelse_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN loghaendelse_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_loghaendelse(loghaendelse_registrering loghaendelseregistreringtype, loghaendelse_uuid uuid, auth_criteria_arr loghaendelseregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_organisation(organisationregistreringtype, uuid, organisationregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_organisation(organisation_registrering organisationregistreringtype, organisation_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr organisationregistreringtype[] DEFAULT NULL::organisationregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  organisation_registrering_id bigint;
  organisation_attr_egenskaber_obj organisationEgenskaberAttrType;
  
  organisation_tils_gyldighed_obj organisationGyldighedTilsType;
  
  organisation_relationer OrganisationRelationType;
  auth_filtered_uuids uuid[];
BEGIN

IF organisation_uuid IS NULL THEN
    LOOP
    organisation_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from organisation WHERE id=organisation_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from organisation WHERE id=organisation_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing organisation with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_organisation (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',organisation_uuid USING ERRCODE='MO500';
END IF;

IF  (organisation_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (organisation_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_organisation.',(organisation_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      organisation (ID)
SELECT
      organisation_uuid
;


/*********************************/
--Insert new registrering

organisation_registrering_id:=nextval('organisation_registrering_id_seq');

INSERT INTO organisation_registrering (
      id,
        organisation_id,
          registrering
        )
SELECT
      organisation_registrering_id,
        organisation_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (organisation_registrering.registrering).livscykluskode,
            (organisation_registrering.registrering).brugerref,
            (organisation_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(organisation_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [organisation]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF organisation_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(organisation_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH organisation_attr_egenskaber_obj IN ARRAY organisation_registrering.attrEgenskaber
  LOOP

    INSERT INTO organisation_attr_egenskaber (
      brugervendtnoegle,
      organisationsnavn,
      virkning,
      organisation_registrering_id
    )
    SELECT
     organisation_attr_egenskaber_obj.brugervendtnoegle,
      organisation_attr_egenskaber_obj.organisationsnavn,
      organisation_attr_egenskaber_obj.virkning,
      organisation_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(organisation_registrering.tilsGyldighed, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [gyldighed] for organisation. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF organisation_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(organisation_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH organisation_tils_gyldighed_obj IN ARRAY organisation_registrering.tilsGyldighed
  LOOP

    INSERT INTO organisation_tils_gyldighed (
      virkning,
      gyldighed,
      organisation_registrering_id
    )
    SELECT
      organisation_tils_gyldighed_obj.virkning,
      organisation_tils_gyldighed_obj.gyldighed,
      organisation_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

    INSERT INTO organisation_relation (
      organisation_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      organisation_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(organisation_registrering.relationer) a
  ;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_organisation(array[organisation_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[organisation_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import organisation with uuid [%]. Object does not met stipulated criteria:%',organisation_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN organisation_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_organisation(organisation_registrering organisationregistreringtype, organisation_uuid uuid, auth_criteria_arr organisationregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_organisationenhed(organisationenhedregistreringtype, uuid, organisationenhedregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_organisationenhed(organisationenhed_registrering organisationenhedregistreringtype, organisationenhed_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr organisationenhedregistreringtype[] DEFAULT NULL::organisationenhedregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  organisationenhed_registrering_id bigint;
  organisationenhed_attr_egenskaber_obj organisationenhedEgenskaberAttrType;
  
  organisationenhed_tils_gyldighed_obj organisationenhedGyldighedTilsType;
  
  organisationenhed_relationer OrganisationenhedRelationType;
  auth_filtered_uuids uuid[];
BEGIN

IF organisationenhed_uuid IS NULL THEN
    LOOP
    organisationenhed_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from organisationenhed WHERE id=organisationenhed_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from organisationenhed WHERE id=organisationenhed_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing organisationenhed with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_organisationenhed (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',organisationenhed_uuid USING ERRCODE='MO500';
END IF;

IF  (organisationenhed_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (organisationenhed_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_organisationenhed.',(organisationenhed_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      organisationenhed (ID)
SELECT
      organisationenhed_uuid
;


/*********************************/
--Insert new registrering

organisationenhed_registrering_id:=nextval('organisationenhed_registrering_id_seq');

INSERT INTO organisationenhed_registrering (
      id,
        organisationenhed_id,
          registrering
        )
SELECT
      organisationenhed_registrering_id,
        organisationenhed_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (organisationenhed_registrering.registrering).livscykluskode,
            (organisationenhed_registrering.registrering).brugerref,
            (organisationenhed_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(organisationenhed_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [organisationenhed]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF organisationenhed_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(organisationenhed_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH organisationenhed_attr_egenskaber_obj IN ARRAY organisationenhed_registrering.attrEgenskaber
  LOOP

    INSERT INTO organisationenhed_attr_egenskaber (
      brugervendtnoegle,
      enhedsnavn,
      virkning,
      organisationenhed_registrering_id
    )
    SELECT
     organisationenhed_attr_egenskaber_obj.brugervendtnoegle,
      organisationenhed_attr_egenskaber_obj.enhedsnavn,
      organisationenhed_attr_egenskaber_obj.virkning,
      organisationenhed_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(organisationenhed_registrering.tilsGyldighed, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [gyldighed] for organisationenhed. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF organisationenhed_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(organisationenhed_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH organisationenhed_tils_gyldighed_obj IN ARRAY organisationenhed_registrering.tilsGyldighed
  LOOP

    INSERT INTO organisationenhed_tils_gyldighed (
      virkning,
      gyldighed,
      organisationenhed_registrering_id
    )
    SELECT
      organisationenhed_tils_gyldighed_obj.virkning,
      organisationenhed_tils_gyldighed_obj.gyldighed,
      organisationenhed_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

    INSERT INTO organisationenhed_relation (
      organisationenhed_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      organisationenhed_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(organisationenhed_registrering.relationer) a
  ;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationenhed(array[organisationenhed_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[organisationenhed_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import organisationenhed with uuid [%]. Object does not met stipulated criteria:%',organisationenhed_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN organisationenhed_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_organisationenhed(organisationenhed_registrering organisationenhedregistreringtype, organisationenhed_uuid uuid, auth_criteria_arr organisationenhedregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_organisationfunktion(organisationfunktionregistreringtype, uuid, organisationfunktionregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_organisationfunktion(organisationfunktion_registrering organisationfunktionregistreringtype, organisationfunktion_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr organisationfunktionregistreringtype[] DEFAULT NULL::organisationfunktionregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  organisationfunktion_registrering_id bigint;
  organisationfunktion_attr_egenskaber_obj organisationfunktionEgenskaberAttrType;
  
  organisationfunktion_tils_gyldighed_obj organisationfunktionGyldighedTilsType;
  
  organisationfunktion_relationer OrganisationfunktionRelationType;
  auth_filtered_uuids uuid[];
BEGIN

IF organisationfunktion_uuid IS NULL THEN
    LOOP
    organisationfunktion_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from organisationfunktion WHERE id=organisationfunktion_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from organisationfunktion WHERE id=organisationfunktion_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing organisationfunktion with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_organisationfunktion (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',organisationfunktion_uuid USING ERRCODE='MO500';
END IF;

IF  (organisationfunktion_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (organisationfunktion_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_organisationfunktion.',(organisationfunktion_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      organisationfunktion (ID)
SELECT
      organisationfunktion_uuid
;


/*********************************/
--Insert new registrering

organisationfunktion_registrering_id:=nextval('organisationfunktion_registrering_id_seq');

INSERT INTO organisationfunktion_registrering (
      id,
        organisationfunktion_id,
          registrering
        )
SELECT
      organisationfunktion_registrering_id,
        organisationfunktion_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (organisationfunktion_registrering.registrering).livscykluskode,
            (organisationfunktion_registrering.registrering).brugerref,
            (organisationfunktion_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(organisationfunktion_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [organisationfunktion]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF organisationfunktion_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(organisationfunktion_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH organisationfunktion_attr_egenskaber_obj IN ARRAY organisationfunktion_registrering.attrEgenskaber
  LOOP

    INSERT INTO organisationfunktion_attr_egenskaber (
      brugervendtnoegle,
      funktionsnavn,
      virkning,
      organisationfunktion_registrering_id
    )
    SELECT
     organisationfunktion_attr_egenskaber_obj.brugervendtnoegle,
      organisationfunktion_attr_egenskaber_obj.funktionsnavn,
      organisationfunktion_attr_egenskaber_obj.virkning,
      organisationfunktion_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(organisationfunktion_registrering.tilsGyldighed, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [gyldighed] for organisationfunktion. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF organisationfunktion_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(organisationfunktion_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH organisationfunktion_tils_gyldighed_obj IN ARRAY organisationfunktion_registrering.tilsGyldighed
  LOOP

    INSERT INTO organisationfunktion_tils_gyldighed (
      virkning,
      gyldighed,
      organisationfunktion_registrering_id
    )
    SELECT
      organisationfunktion_tils_gyldighed_obj.virkning,
      organisationfunktion_tils_gyldighed_obj.gyldighed,
      organisationfunktion_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

    INSERT INTO organisationfunktion_relation (
      organisationfunktion_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      organisationfunktion_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(organisationfunktion_registrering.relationer) a
  ;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationfunktion(array[organisationfunktion_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[organisationfunktion_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import organisationfunktion with uuid [%]. Object does not met stipulated criteria:%',organisationfunktion_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN organisationfunktion_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_organisationfunktion(organisationfunktion_registrering organisationfunktionregistreringtype, organisationfunktion_uuid uuid, auth_criteria_arr organisationfunktionregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_sag(sagregistreringtype, uuid, sagregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_sag(sag_registrering sagregistreringtype, sag_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr sagregistreringtype[] DEFAULT NULL::sagregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  sag_registrering_id bigint;
  sag_attr_egenskaber_obj sagEgenskaberAttrType;
  
  sag_tils_fremdrift_obj sagFremdriftTilsType;
  
  sag_relationer SagRelationType;
  sag_relation_kode SagRelationKode;
  sag_uuid_underscores text;
  sag_rel_seq_name text;
  sag_rel_type_cardinality_unlimited SagRelationKode[]:=ARRAY['andetarkiv'::SagRelationKode,'andrebehandlere'::SagRelationKode,'sekundaerpart'::SagRelationKode,'andresager'::SagRelationKode,'byggeri'::SagRelationKode,'fredning'::SagRelationKode,'journalpost'::SagRelationKode]::SagRelationKode[];
  auth_filtered_uuids uuid[];
BEGIN

IF sag_uuid IS NULL THEN
    LOOP
    sag_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from sag WHERE id=sag_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from sag WHERE id=sag_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing sag with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_sag (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',sag_uuid USING ERRCODE='MO500';
END IF;

IF  (sag_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (sag_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_sag.',(sag_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      sag (ID)
SELECT
      sag_uuid
;


/*********************************/
--Insert new registrering

sag_registrering_id:=nextval('sag_registrering_id_seq');

INSERT INTO sag_registrering (
      id,
        sag_id,
          registrering
        )
SELECT
      sag_registrering_id,
        sag_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (sag_registrering.registrering).livscykluskode,
            (sag_registrering.registrering).brugerref,
            (sag_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(sag_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [sag]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF sag_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(sag_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH sag_attr_egenskaber_obj IN ARRAY sag_registrering.attrEgenskaber
  LOOP

    INSERT INTO sag_attr_egenskaber (
      brugervendtnoegle,
      afleveret,
      beskrivelse,
      hjemmel,
      kassationskode,
      offentlighedundtaget,
      principiel,
      sagsnummer,
      titel,
      virkning,
      sag_registrering_id
    )
    SELECT
     sag_attr_egenskaber_obj.brugervendtnoegle,
      sag_attr_egenskaber_obj.afleveret,
      sag_attr_egenskaber_obj.beskrivelse,
      sag_attr_egenskaber_obj.hjemmel,
      sag_attr_egenskaber_obj.kassationskode,
      sag_attr_egenskaber_obj.offentlighedundtaget,
      sag_attr_egenskaber_obj.principiel,
      sag_attr_egenskaber_obj.sagsnummer,
      sag_attr_egenskaber_obj.titel,
      sag_attr_egenskaber_obj.virkning,
      sag_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(sag_registrering.tilsFremdrift, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [fremdrift] for sag. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF sag_registrering.tilsFremdrift IS NOT NULL AND coalesce(array_length(sag_registrering.tilsFremdrift,1),0)>0 THEN
  FOREACH sag_tils_fremdrift_obj IN ARRAY sag_registrering.tilsFremdrift
  LOOP

    INSERT INTO sag_tils_fremdrift (
      virkning,
      fremdrift,
      sag_registrering_id
    )
    SELECT
      sag_tils_fremdrift_obj.virkning,
      sag_tils_fremdrift_obj.fremdrift,
      sag_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

IF coalesce(array_length(sag_registrering.relationer,1),0)>0 THEN

--Create temporary sequences
sag_uuid_underscores:=replace(sag_uuid::text, '-', '_');

FOREACH sag_relation_kode IN ARRAY (SELECT array_agg( DISTINCT a.RelType) FROM  unnest(sag_registrering.relationer) a WHERE a.RelType = any (sag_rel_type_cardinality_unlimited))
  LOOP
  sag_rel_seq_name := 'sag_rel_' || sag_relation_kode::text || sag_uuid_underscores;

  EXECUTE 'CREATE TEMPORARY SEQUENCE ' || sag_rel_seq_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START 1
  CACHE 1;';

END LOOP;

    INSERT INTO sag_relation (
      sag_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type,
      rel_index,
      rel_type_spec,
      journal_notat,
      journal_dokument_attr
    )
    SELECT
      sag_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType,
        CASE WHEN a.relType = any (sag_rel_type_cardinality_unlimited) THEN --rel_index
        nextval('sag_rel_' || a.relType::text || sag_uuid_underscores)
        ELSE 
        NULL
        END,
        CASE 
          WHEN a.relType='journalpost' THEN a.relTypeSpec  --rel_type_spec
          ELSE
          NULL
        END,
      CASE 
          WHEN  
            (NOT (a.journalNotat IS NULL)) 
            AND
            (
              (a.journalNotat).titel IS NOT NULL
              OR
              (a.journalNotat).notat IS NOT NULL
              OR
              (a.journalNotat).format IS NOT NULL
            )
           THEN a.journalNotat
           ELSE
           NULL
      END
      ,CASE 
        WHEN ( 
                (NOT a.journalDokumentAttr IS NULL)
                AND
                (
                  (a.journalDokumentAttr).dokumenttitel IS NOT NULL
                  OR
                  (
                    NOT ((a.journalDokumentAttr).offentlighedUndtaget IS NULL)
                    AND
                    (
                      ((a.journalDokumentAttr).offentlighedUndtaget).AlternativTitel IS NOT NULL
                      OR
                      ((a.journalDokumentAttr).offentlighedUndtaget).Hjemmel IS NOT NULL
                    )
                  )
               )
             ) THEN a.journalDokumentAttr
        ELSE
        NULL
      END
    FROM unnest(sag_registrering.relationer) a
    ;


--Drop temporary sequences
FOREACH sag_relation_kode IN ARRAY (SELECT array_agg( DISTINCT a.RelType) FROM  unnest(sag_registrering.relationer) a WHERE a.RelType = any (sag_rel_type_cardinality_unlimited))
  LOOP
  sag_rel_seq_name := 'sag_rel_' || sag_relation_kode::text || sag_uuid_underscores;
  EXECUTE 'DROP  SEQUENCE ' || sag_rel_seq_name || ';';
END LOOP;


END IF;



/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_sag(array[sag_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[sag_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import sag with uuid [%]. Object does not met stipulated criteria:%',sag_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN sag_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_sag(sag_registrering sagregistreringtype, sag_uuid uuid, auth_criteria_arr sagregistreringtype[]) OWNER TO mox;

--
-- Name: as_create_or_import_tilstand(tilstandregistreringtype, uuid, tilstandregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_create_or_import_tilstand(tilstand_registrering tilstandregistreringtype, tilstand_uuid uuid DEFAULT NULL::uuid, auth_criteria_arr tilstandregistreringtype[] DEFAULT NULL::tilstandregistreringtype[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  tilstand_registrering_id bigint;
  tilstand_attr_egenskaber_obj tilstandEgenskaberAttrType;
  
  tilstand_tils_status_obj tilstandStatusTilsType;
  tilstand_tils_publiceret_obj tilstandPubliceretTilsType;
  
  tilstand_relationer TilstandRelationType;
  auth_filtered_uuids uuid[];
  tilstand_relation_kode tilstandRelationKode;
  tilstand_uuid_underscores text;
  tilstand_rel_seq_name text;
  tilstand_rel_type_cardinality_unlimited tilstandRelationKode[]:=ARRAY['tilstandsvaerdi'::TilstandRelationKode,'begrundelse'::TilstandRelationKode,'tilstandskvalitet'::TilstandRelationKode,'tilstandsvurdering'::TilstandRelationKode,'tilstandsaktoer'::TilstandRelationKode,'tilstandsudstyr'::TilstandRelationKode,'samtykke'::TilstandRelationKode,'tilstandsdokument'::TilstandRelationKode]::TilstandRelationKode[];
  tilstand_rel_type_cardinality_unlimited_present_in_argument tilstandRelationKode[];

BEGIN

IF tilstand_uuid IS NULL THEN
    LOOP
    tilstand_uuid:=uuid_generate_v4();
    EXIT WHEN NOT EXISTS (SELECT id from tilstand WHERE id=tilstand_uuid); 
    END LOOP;
END IF;


IF EXISTS (SELECT id from tilstand WHERE id=tilstand_uuid) THEN
  RAISE EXCEPTION 'Error creating or importing tilstand with uuid [%]. If you did not supply the uuid when invoking as_create_or_import_tilstand (i.e. create operation) please try to repeat the invocation/operation, that id collison with randomly generated uuids might in theory occur, albeit very very very rarely.',tilstand_uuid USING ERRCODE='MO500';
END IF;

IF  (tilstand_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode and (tilstand_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode THEN
  RAISE EXCEPTION 'Invalid livscykluskode[%] invoking as_create_or_import_tilstand.',(tilstand_registrering.registrering).livscykluskode USING ERRCODE='MO400';
END IF;



INSERT INTO 
      tilstand (ID)
SELECT
      tilstand_uuid
;


/*********************************/
--Insert new registrering

tilstand_registrering_id:=nextval('tilstand_registrering_id_seq');

INSERT INTO tilstand_registrering (
      id,
        tilstand_id,
          registrering
        )
SELECT
      tilstand_registrering_id,
        tilstand_uuid,
          ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
            (tilstand_registrering.registrering).livscykluskode,
            (tilstand_registrering.registrering).brugerref,
            (tilstand_registrering.registrering).note
              ):: RegistreringBase
;

/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)

 
IF coalesce(array_length(tilstand_registrering.attrEgenskaber, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner pkraevet attribut [egenskaber] for [tilstand]. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;



IF tilstand_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(tilstand_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH tilstand_attr_egenskaber_obj IN ARRAY tilstand_registrering.attrEgenskaber
  LOOP

    INSERT INTO tilstand_attr_egenskaber (
      brugervendtnoegle,
      beskrivelse,
      virkning,
      tilstand_registrering_id
    )
    SELECT
     tilstand_attr_egenskaber_obj.brugervendtnoegle,
      tilstand_attr_egenskaber_obj.beskrivelse,
      tilstand_attr_egenskaber_obj.virkning,
      tilstand_registrering_id
    ;
 

  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(tilstand_registrering.tilsStatus, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [status] for tilstand. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF tilstand_registrering.tilsStatus IS NOT NULL AND coalesce(array_length(tilstand_registrering.tilsStatus,1),0)>0 THEN
  FOREACH tilstand_tils_status_obj IN ARRAY tilstand_registrering.tilsStatus
  LOOP

    INSERT INTO tilstand_tils_status (
      virkning,
      status,
      tilstand_registrering_id
    )
    SELECT
      tilstand_tils_status_obj.virkning,
      tilstand_tils_status_obj.status,
      tilstand_registrering_id;

  END LOOP;
END IF;

--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(tilstand_registrering.tilsPubliceret, 1),0)<1  THEN
  RAISE EXCEPTION 'Savner pkraevet tilstand [publiceret] for tilstand. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF tilstand_registrering.tilsPubliceret IS NOT NULL AND coalesce(array_length(tilstand_registrering.tilsPubliceret,1),0)>0 THEN
  FOREACH tilstand_tils_publiceret_obj IN ARRAY tilstand_registrering.tilsPubliceret
  LOOP

    INSERT INTO tilstand_tils_publiceret (
      virkning,
      publiceret,
      tilstand_registrering_id
    )
    SELECT
      tilstand_tils_publiceret_obj.virkning,
      tilstand_tils_publiceret_obj.publiceret,
      tilstand_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations

IF coalesce(array_length(tilstand_registrering.relationer,1),0)>0 THEN

--Create temporary sequences
tilstand_uuid_underscores:=replace(tilstand_uuid::text, '-', '_');


SELECT array_agg( DISTINCT a.RelType) into tilstand_rel_type_cardinality_unlimited_present_in_argument FROM  unnest(tilstand_registrering.relationer) a WHERE a.RelType = any (tilstand_rel_type_cardinality_unlimited) ;
IF coalesce(array_length(tilstand_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH tilstand_relation_kode IN ARRAY (tilstand_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  tilstand_rel_seq_name := 'tilstand_' || tilstand_relation_kode::text || tilstand_uuid_underscores;

  EXECUTE 'CREATE TEMPORARY SEQUENCE ' || tilstand_rel_seq_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START 1
  CACHE 1;';

END LOOP;
END IF;

    INSERT INTO tilstand_relation (
      tilstand_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type,
      rel_index,
      tilstand_vaerdi_attr
    )
    SELECT
      tilstand_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType,
        CASE WHEN a.relType = any (tilstand_rel_type_cardinality_unlimited) THEN --rel_index
        nextval('tilstand_' || a.relType::text || tilstand_uuid_underscores)
        ELSE 
        NULL
        END,
     CASE
        WHEN a.relType='tilstandsvaerdi' AND
          ( NOT (a.tilstandsVaerdiAttr IS NULL))
          AND 
          (
            (a.tilstandsVaerdiAttr).forventet IS NOT NULL
            OR
            (a.tilstandsVaerdiAttr).nominelVaerdi IS NOT NULL
          ) THEN a.tilstandsVaerdiAttr
        ELSE
        NULL
      END
    FROM unnest(tilstand_registrering.relationer) a
    ;


--Drop temporary sequences
IF coalesce(array_length(tilstand_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH tilstand_relation_kode IN ARRAY (tilstand_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  tilstand_rel_seq_name := 'tilstand_' || tilstand_relation_kode::text || tilstand_uuid_underscores;
  EXECUTE 'DROP  SEQUENCE ' || tilstand_rel_seq_name || ';';
END LOOP;
END IF;

END IF;

/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_tilstand(array[tilstand_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[tilstand_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import tilstand with uuid [%]. Object does not met stipulated criteria:%',tilstand_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/



RETURN tilstand_uuid;

END;
$$;


ALTER FUNCTION actual_state.as_create_or_import_tilstand(tilstand_registrering tilstandregistreringtype, tilstand_uuid uuid, auth_criteria_arr tilstandregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_aktivitet(uuid[], tstzrange, tstzrange, aktivitetregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_aktivitet(aktivitet_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr aktivitetregistreringtype[] DEFAULT NULL::aktivitetregistreringtype[]) RETURNS aktivitettype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result AktivitetType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_aktivitet(aktivitet_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(aktivitet_uuids,1),0) AND auth_filtered_uuids @>aktivitet_uuids) THEN
  RAISE EXCEPTION 'Unable to list aktivitet with uuids [%]. All objects do not fullfill the stipulated criteria:%',aktivitet_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.aktivitetObj) into result
FROM
(
SELECT
ROW(
	a.aktivitet_id,
	array_agg(
		ROW (
			a.registrering,
			a.AktivitetTilsStatusArr,
			a.AktivitetTilsPubliceretArr,
			a.AktivitetAttrEgenskaberArr,
			a.AktivitetRelationArr
		)::AktivitetRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: AktivitetType  aktivitetObj
FROM
(
	SELECT
	a.aktivitet_id,
	a.aktivitet_registrering_id,
	a.registrering,
	a.AktivitetAttrEgenskaberArr,
	a.AktivitetTilsStatusArr,
	a.AktivitetTilsPubliceretArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type,
				b.rel_index,
				b.aktoer_attr 
			):: AktivitetRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.rel_index,b.aktoer_attr,b.virkning
	)) AktivitetRelationArr
	FROM
	(
			SELECT
			a.aktivitet_id,
			a.aktivitet_registrering_id,
			a.registrering,
			a.AktivitetAttrEgenskaberArr,
			a.AktivitetTilsPubliceretArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.status
						) ::AktivitetStatusTilsType
					ELSE NULL
					END
					order by b.status,b.virkning
				)) AktivitetTilsStatusArr		
			FROM
			(
			SELECT
			a.aktivitet_id,
			a.aktivitet_registrering_id,
			a.registrering,
			a.AktivitetAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.publiceret
						) ::AktivitetPubliceretTilsType
					ELSE NULL
					END
					order by b.publiceret,b.virkning
				)) AktivitetTilsPubliceretArr		
			FROM
			(
					SELECT
					a.aktivitet_id,
					a.aktivitet_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.aktivitetnavn,
					 		b.beskrivelse,
					 		b.starttidspunkt,
					 		b.sluttidspunkt,
					 		b.tidsforbrug,
					 		b.formaal,
					   		b.virkning 
							)::AktivitetEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.aktivitetnavn,b.beskrivelse,b.starttidspunkt,b.sluttidspunkt,b.tidsforbrug,b.formaal,b.virkning
					)) AktivitetAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id aktivitet_id,
					b.id aktivitet_registrering_id,
					b.registrering			
					FROM		aktivitet a
					JOIN 		aktivitet_registrering b 	ON b.aktivitet_id=a.id
					WHERE a.id = ANY (aktivitet_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN aktivitet_attr_egenskaber as b ON b.aktivitet_registrering_id=a.aktivitet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.aktivitet_id,
					a.aktivitet_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN aktivitet_tils_publiceret as b ON b.aktivitet_registrering_id=a.aktivitet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.aktivitet_id,
			a.aktivitet_registrering_id,
			a.registrering,
			a.AktivitetAttrEgenskaberArr	
			) as a
			LEFT JOIN aktivitet_tils_status as b ON b.aktivitet_registrering_id=a.aktivitet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.aktivitet_id,
			a.aktivitet_registrering_id,
			a.registrering,
			a.AktivitetAttrEgenskaberArr,
			a.AktivitetTilsPubliceretArr
	) as a
	LEFT JOIN aktivitet_relation b ON b.aktivitet_registrering_id=a.aktivitet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.aktivitet_id,
	a.aktivitet_registrering_id,
	a.registrering,
	a.AktivitetAttrEgenskaberArr,
	a.AktivitetTilsPubliceretArr,
	a.AktivitetTilsStatusArr
) as a
WHERE a.aktivitet_id IS NOT NULL
GROUP BY 
a.aktivitet_id
order by a.aktivitet_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_aktivitet(aktivitet_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr aktivitetregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_bruger(uuid[], tstzrange, tstzrange, brugerregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_bruger(bruger_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr brugerregistreringtype[] DEFAULT NULL::brugerregistreringtype[]) RETURNS brugertype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result BrugerType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_bruger(bruger_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(bruger_uuids,1),0) AND auth_filtered_uuids @>bruger_uuids) THEN
  RAISE EXCEPTION 'Unable to list bruger with uuids [%]. All objects do not fullfill the stipulated criteria:%',bruger_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.brugerObj) into result
FROM
(
SELECT
ROW(
	a.bruger_id,
	array_agg(
		ROW (
			a.registrering,
			a.BrugerTilsGyldighedArr,
			a.BrugerAttrEgenskaberArr,
			a.BrugerRelationArr
		)::BrugerRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: BrugerType  brugerObj
FROM
(
	SELECT
	a.bruger_id,
	a.bruger_registrering_id,
	a.registrering,
	a.BrugerAttrEgenskaberArr,
	a.BrugerTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type 
			):: BrugerRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
	)) BrugerRelationArr
	FROM
	(
			SELECT
			a.bruger_id,
			a.bruger_registrering_id,
			a.registrering,
			a.BrugerAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::BrugerGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) BrugerTilsGyldighedArr		
			FROM
			(
					SELECT
					a.bruger_id,
					a.bruger_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.brugernavn,
					 		b.brugertype,
					   		b.virkning 
							)::BrugerEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.brugernavn,b.brugertype,b.virkning
					)) BrugerAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id bruger_id,
					b.id bruger_registrering_id,
					b.registrering			
					FROM		bruger a
					JOIN 		bruger_registrering b 	ON b.bruger_id=a.id
					WHERE a.id = ANY (bruger_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN bruger_attr_egenskaber as b ON b.bruger_registrering_id=a.bruger_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.bruger_id,
					a.bruger_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN bruger_tils_gyldighed as b ON b.bruger_registrering_id=a.bruger_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.bruger_id,
			a.bruger_registrering_id,
			a.registrering,
			a.BrugerAttrEgenskaberArr
	) as a
	LEFT JOIN bruger_relation b ON b.bruger_registrering_id=a.bruger_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.bruger_id,
	a.bruger_registrering_id,
	a.registrering,
	a.BrugerAttrEgenskaberArr,
	a.BrugerTilsGyldighedArr
) as a
WHERE a.bruger_id IS NOT NULL
GROUP BY 
a.bruger_id
order by a.bruger_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_bruger(bruger_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr brugerregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_dokument(uuid[], tstzrange, tstzrange, dokumentregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_dokument(dokument_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr dokumentregistreringtype[] DEFAULT NULL::dokumentregistreringtype[]) RETURNS dokumenttype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result DokumentType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_dokument(dokument_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(dokument_uuids,1),0) AND auth_filtered_uuids @>dokument_uuids) THEN
  RAISE EXCEPTION 'Unable to list dokument with uuids [%]. All objects do not fullfill the stipulated criteria:%',dokument_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.dokumentObj) into result
FROM
(
SELECT
ROW(
	a.dokument_id,
	array_agg(
		ROW (
			a.registrering,
			a.DokumentTilsFremdriftArr,
			a.DokumentAttrEgenskaberArr,
			a.DokumentRelationArr,
			b.varianter
		)::DokumentRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: DokumentType  dokumentObj
FROM
(
	SELECT
	a.dokument_id,
	a.dokument_registrering_id,
	a.registrering,
	a.DokumentAttrEgenskaberArr,
	a.DokumentTilsFremdriftArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type 
			):: DokumentRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
	)) DokumentRelationArr
	FROM
	(
			SELECT
			a.dokument_id,
			a.dokument_registrering_id,
			a.registrering,
			a.DokumentAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.fremdrift
						) ::DokumentFremdriftTilsType
					ELSE NULL
					END
					order by b.fremdrift,b.virkning
				)) DokumentTilsFremdriftArr		
			FROM
			(
					SELECT
					a.dokument_id,
					a.dokument_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.beskrivelse,
					 		b.brevdato,
					 		b.kassationskode,
					 		b.major,
					 		b.minor,
					 		b.offentlighedundtaget,
					 		b.titel,
					 		b.dokumenttype,
					   		b.virkning 
							)::DokumentEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.beskrivelse,b.brevdato,b.kassationskode,b.major,b.minor,b.offentlighedundtaget,b.titel,b.dokumenttype,b.virkning
					)) DokumentAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id dokument_id,
					b.id dokument_registrering_id,
					b.registrering			
					FROM		dokument a
					JOIN 		dokument_registrering b 	ON b.dokument_id=a.id
					WHERE a.id = ANY (dokument_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN dokument_attr_egenskaber as b ON b.dokument_registrering_id=a.dokument_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.dokument_id,
					a.dokument_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN dokument_tils_fremdrift as b ON b.dokument_registrering_id=a.dokument_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.dokument_id,
			a.dokument_registrering_id,
			a.registrering,
			a.DokumentAttrEgenskaberArr
	) as a
	LEFT JOIN dokument_relation b ON b.dokument_registrering_id=a.dokument_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.dokument_id,
	a.dokument_registrering_id,
	a.registrering,
	a.DokumentAttrEgenskaberArr,
	a.DokumentTilsFremdriftArr
) as a
LEFT JOIN _as_list_dokument_varianter(dokument_uuids,registrering_tstzrange,virkning_tstzrange) b on a.dokument_registrering_id=b.dokument_registrering_id
WHERE a.dokument_id IS NOT NULL
GROUP BY 
a.dokument_id
order by a.dokument_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_dokument(dokument_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr dokumentregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_facet(uuid[], tstzrange, tstzrange, facetregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_facet(facet_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr facetregistreringtype[] DEFAULT NULL::facetregistreringtype[]) RETURNS facettype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result FacetType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_facet(facet_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(facet_uuids,1),0) AND auth_filtered_uuids @>facet_uuids) THEN
  RAISE EXCEPTION 'Unable to list facet with uuids [%]. All objects do not fullfill the stipulated criteria:%',facet_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.facetObj) into result
FROM
(
SELECT
ROW(
	a.facet_id,
	array_agg(
		ROW (
			a.registrering,
			a.FacetTilsPubliceretArr,
			a.FacetAttrEgenskaberArr,
			a.FacetRelationArr
		)::FacetRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: FacetType  facetObj
FROM
(
	SELECT
	a.facet_id,
	a.facet_registrering_id,
	a.registrering,
	a.FacetAttrEgenskaberArr,
	a.FacetTilsPubliceretArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type 
			):: FacetRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
	)) FacetRelationArr
	FROM
	(
			SELECT
			a.facet_id,
			a.facet_registrering_id,
			a.registrering,
			a.FacetAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.publiceret
						) ::FacetPubliceretTilsType
					ELSE NULL
					END
					order by b.publiceret,b.virkning
				)) FacetTilsPubliceretArr		
			FROM
			(
					SELECT
					a.facet_id,
					a.facet_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.beskrivelse,
					 		b.opbygning,
					 		b.ophavsret,
					 		b.plan,
					 		b.supplement,
					 		b.retskilde,
					   		b.virkning 
							)::FacetEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.beskrivelse,b.opbygning,b.ophavsret,b.plan,b.supplement,b.retskilde,b.virkning
					)) FacetAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id facet_id,
					b.id facet_registrering_id,
					b.registrering			
					FROM		facet a
					JOIN 		facet_registrering b 	ON b.facet_id=a.id
					WHERE a.id = ANY (facet_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN facet_attr_egenskaber as b ON b.facet_registrering_id=a.facet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.facet_id,
					a.facet_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN facet_tils_publiceret as b ON b.facet_registrering_id=a.facet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.facet_id,
			a.facet_registrering_id,
			a.registrering,
			a.FacetAttrEgenskaberArr
	) as a
	LEFT JOIN facet_relation b ON b.facet_registrering_id=a.facet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.facet_id,
	a.facet_registrering_id,
	a.registrering,
	a.FacetAttrEgenskaberArr,
	a.FacetTilsPubliceretArr
) as a
WHERE a.facet_id IS NOT NULL
GROUP BY 
a.facet_id
order by a.facet_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_facet(facet_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr facetregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_indsats(uuid[], tstzrange, tstzrange, indsatsregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_indsats(indsats_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr indsatsregistreringtype[] DEFAULT NULL::indsatsregistreringtype[]) RETURNS indsatstype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result IndsatsType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_indsats(indsats_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(indsats_uuids,1),0) AND auth_filtered_uuids @>indsats_uuids) THEN
  RAISE EXCEPTION 'Unable to list indsats with uuids [%]. All objects do not fullfill the stipulated criteria:%',indsats_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.indsatsObj) into result
FROM
(
SELECT
ROW(
	a.indsats_id,
	array_agg(
		ROW (
			a.registrering,
			a.IndsatsTilsPubliceretArr,
			a.IndsatsTilsFremdriftArr,
			a.IndsatsAttrEgenskaberArr,
			a.IndsatsRelationArr
		)::IndsatsRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: IndsatsType  indsatsObj
FROM
(
	SELECT
	a.indsats_id,
	a.indsats_registrering_id,
	a.registrering,
	a.IndsatsAttrEgenskaberArr,
	a.IndsatsTilsPubliceretArr,
	a.IndsatsTilsFremdriftArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type,
 				b.rel_index 
			):: IndsatsRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.rel_index,b.virkning
	)) IndsatsRelationArr
	FROM
	(
			SELECT
			a.indsats_id,
			a.indsats_registrering_id,
			a.registrering,
			a.IndsatsAttrEgenskaberArr,
			a.IndsatsTilsFremdriftArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.publiceret
						) ::IndsatsPubliceretTilsType
					ELSE NULL
					END
					order by b.publiceret,b.virkning
				)) IndsatsTilsPubliceretArr		
			FROM
			(
			SELECT
			a.indsats_id,
			a.indsats_registrering_id,
			a.registrering,
			a.IndsatsAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.fremdrift
						) ::IndsatsFremdriftTilsType
					ELSE NULL
					END
					order by b.fremdrift,b.virkning
				)) IndsatsTilsFremdriftArr		
			FROM
			(
					SELECT
					a.indsats_id,
					a.indsats_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.beskrivelse,
					 		b.starttidspunkt,
					 		b.sluttidspunkt,
					   		b.virkning 
							)::IndsatsEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.beskrivelse,b.starttidspunkt,b.sluttidspunkt,b.virkning
					)) IndsatsAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id indsats_id,
					b.id indsats_registrering_id,
					b.registrering			
					FROM		indsats a
					JOIN 		indsats_registrering b 	ON b.indsats_id=a.id
					WHERE a.id = ANY (indsats_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN indsats_attr_egenskaber as b ON b.indsats_registrering_id=a.indsats_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.indsats_id,
					a.indsats_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN indsats_tils_fremdrift as b ON b.indsats_registrering_id=a.indsats_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.indsats_id,
			a.indsats_registrering_id,
			a.registrering,
			a.IndsatsAttrEgenskaberArr	
			) as a
			LEFT JOIN indsats_tils_publiceret as b ON b.indsats_registrering_id=a.indsats_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.indsats_id,
			a.indsats_registrering_id,
			a.registrering,
			a.IndsatsAttrEgenskaberArr,
			a.IndsatsTilsFremdriftArr
	) as a
	LEFT JOIN indsats_relation b ON b.indsats_registrering_id=a.indsats_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.indsats_id,
	a.indsats_registrering_id,
	a.registrering,
	a.IndsatsAttrEgenskaberArr,
	a.IndsatsTilsFremdriftArr,
	a.IndsatsTilsPubliceretArr
) as a
WHERE a.indsats_id IS NOT NULL
GROUP BY 
a.indsats_id
order by a.indsats_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_indsats(indsats_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr indsatsregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_interessefaellesskab(uuid[], tstzrange, tstzrange, interessefaellesskabregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_interessefaellesskab(interessefaellesskab_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr interessefaellesskabregistreringtype[] DEFAULT NULL::interessefaellesskabregistreringtype[]) RETURNS interessefaellesskabtype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result InteressefaellesskabType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_interessefaellesskab(interessefaellesskab_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(interessefaellesskab_uuids,1),0) AND auth_filtered_uuids @>interessefaellesskab_uuids) THEN
  RAISE EXCEPTION 'Unable to list interessefaellesskab with uuids [%]. All objects do not fullfill the stipulated criteria:%',interessefaellesskab_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.interessefaellesskabObj) into result
FROM
(
SELECT
ROW(
	a.interessefaellesskab_id,
	array_agg(
		ROW (
			a.registrering,
			a.InteressefaellesskabTilsGyldighedArr,
			a.InteressefaellesskabAttrEgenskaberArr,
			a.InteressefaellesskabRelationArr
		)::InteressefaellesskabRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: InteressefaellesskabType  interessefaellesskabObj
FROM
(
	SELECT
	a.interessefaellesskab_id,
	a.interessefaellesskab_registrering_id,
	a.registrering,
	a.InteressefaellesskabAttrEgenskaberArr,
	a.InteressefaellesskabTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type 
			):: InteressefaellesskabRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
	)) InteressefaellesskabRelationArr
	FROM
	(
			SELECT
			a.interessefaellesskab_id,
			a.interessefaellesskab_registrering_id,
			a.registrering,
			a.InteressefaellesskabAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::InteressefaellesskabGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) InteressefaellesskabTilsGyldighedArr		
			FROM
			(
					SELECT
					a.interessefaellesskab_id,
					a.interessefaellesskab_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.interessefaellesskabsnavn,
					 		b.interessefaellesskabstype,
					   		b.virkning 
							)::InteressefaellesskabEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.interessefaellesskabsnavn,b.interessefaellesskabstype,b.virkning
					)) InteressefaellesskabAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id interessefaellesskab_id,
					b.id interessefaellesskab_registrering_id,
					b.registrering			
					FROM		interessefaellesskab a
					JOIN 		interessefaellesskab_registrering b 	ON b.interessefaellesskab_id=a.id
					WHERE a.id = ANY (interessefaellesskab_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN interessefaellesskab_attr_egenskaber as b ON b.interessefaellesskab_registrering_id=a.interessefaellesskab_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.interessefaellesskab_id,
					a.interessefaellesskab_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN interessefaellesskab_tils_gyldighed as b ON b.interessefaellesskab_registrering_id=a.interessefaellesskab_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.interessefaellesskab_id,
			a.interessefaellesskab_registrering_id,
			a.registrering,
			a.InteressefaellesskabAttrEgenskaberArr
	) as a
	LEFT JOIN interessefaellesskab_relation b ON b.interessefaellesskab_registrering_id=a.interessefaellesskab_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.interessefaellesskab_id,
	a.interessefaellesskab_registrering_id,
	a.registrering,
	a.InteressefaellesskabAttrEgenskaberArr,
	a.InteressefaellesskabTilsGyldighedArr
) as a
WHERE a.interessefaellesskab_id IS NOT NULL
GROUP BY 
a.interessefaellesskab_id
order by a.interessefaellesskab_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_interessefaellesskab(interessefaellesskab_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr interessefaellesskabregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_itsystem(uuid[], tstzrange, tstzrange, itsystemregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_itsystem(itsystem_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr itsystemregistreringtype[] DEFAULT NULL::itsystemregistreringtype[]) RETURNS itsystemtype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result ItsystemType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_itsystem(itsystem_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(itsystem_uuids,1),0) AND auth_filtered_uuids @>itsystem_uuids) THEN
  RAISE EXCEPTION 'Unable to list itsystem with uuids [%]. All objects do not fullfill the stipulated criteria:%',itsystem_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.itsystemObj) into result
FROM
(
SELECT
ROW(
	a.itsystem_id,
	array_agg(
		ROW (
			a.registrering,
			a.ItsystemTilsGyldighedArr,
			a.ItsystemAttrEgenskaberArr,
			a.ItsystemRelationArr
		)::ItsystemRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: ItsystemType  itsystemObj
FROM
(
	SELECT
	a.itsystem_id,
	a.itsystem_registrering_id,
	a.registrering,
	a.ItsystemAttrEgenskaberArr,
	a.ItsystemTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type 
			):: ItsystemRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
	)) ItsystemRelationArr
	FROM
	(
			SELECT
			a.itsystem_id,
			a.itsystem_registrering_id,
			a.registrering,
			a.ItsystemAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::ItsystemGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) ItsystemTilsGyldighedArr		
			FROM
			(
					SELECT
					a.itsystem_id,
					a.itsystem_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.itsystemnavn,
					 		b.itsystemtype,
					 		b.konfigurationreference,
					   		b.virkning 
							)::ItsystemEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.itsystemnavn,b.itsystemtype,b.konfigurationreference,b.virkning
					)) ItsystemAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id itsystem_id,
					b.id itsystem_registrering_id,
					b.registrering			
					FROM		itsystem a
					JOIN 		itsystem_registrering b 	ON b.itsystem_id=a.id
					WHERE a.id = ANY (itsystem_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN itsystem_attr_egenskaber as b ON b.itsystem_registrering_id=a.itsystem_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.itsystem_id,
					a.itsystem_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN itsystem_tils_gyldighed as b ON b.itsystem_registrering_id=a.itsystem_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.itsystem_id,
			a.itsystem_registrering_id,
			a.registrering,
			a.ItsystemAttrEgenskaberArr
	) as a
	LEFT JOIN itsystem_relation b ON b.itsystem_registrering_id=a.itsystem_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.itsystem_id,
	a.itsystem_registrering_id,
	a.registrering,
	a.ItsystemAttrEgenskaberArr,
	a.ItsystemTilsGyldighedArr
) as a
WHERE a.itsystem_id IS NOT NULL
GROUP BY 
a.itsystem_id
order by a.itsystem_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_itsystem(itsystem_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr itsystemregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_klasse(uuid[], tstzrange, tstzrange, klasseregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_klasse(klasse_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr klasseregistreringtype[] DEFAULT NULL::klasseregistreringtype[]) RETURNS klassetype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result KlasseType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_klasse(klasse_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(klasse_uuids,1),0) AND auth_filtered_uuids @>klasse_uuids) THEN
  RAISE EXCEPTION 'Unable to list klasse with uuids [%]. All objects do not fullfill the stipulated criteria:%',klasse_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.klasseObj) into result
FROM
(
SELECT
ROW(
	a.klasse_id,
	array_agg(
		ROW (
			a.registrering,
			a.KlasseTilsPubliceretArr,
			a.KlasseAttrEgenskaberArr,
			a.KlasseRelationArr
		)::KlasseRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: KlasseType  klasseObj
FROM
(
	SELECT
	a.klasse_id,
	a.klasse_registrering_id,
	a.registrering,
	a.KlasseAttrEgenskaberArr,
	a.KlasseTilsPubliceretArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type 
			):: KlasseRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
	)) KlasseRelationArr
	FROM
	(
			SELECT
			a.klasse_id,
			a.klasse_registrering_id,
			a.registrering,
			a.KlasseAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.publiceret
						) ::KlassePubliceretTilsType
					ELSE NULL
					END
					order by b.publiceret,b.virkning
				)) KlasseTilsPubliceretArr		
			FROM
			(
					SELECT
					a.klasse_id,
					a.klasse_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN a.attr_id is not null THEN
						ROW(
					 		a.brugervendtnoegle,
					 		a.beskrivelse,
					 		a.eksempel,
					 		a.omfang,
					 		a.titel,
					 		a.retskilde,
					 		a.aendringsnotat,
					 		a.KlasseAttrEgenskaberSoegeordTypeArr,
					   		a.virkning 
						)::KlasseEgenskaberAttrType
						ELSE
						NULL
						END
					order by  a.brugervendtnoegle,a.beskrivelse,a.eksempel,a.omfang,a.titel,a.retskilde,a.aendringsnotat,a.virkning,a.KlasseAttrEgenskaberSoegeordTypeArr
				)) KlasseAttrEgenskaberArr 
				FROM		
				(
						SELECT
						a.klasse_id,
						a.klasse_registrering_id,
						a.registrering,
						b.id attr_id,
						b.brugervendtnoegle,
						b.beskrivelse,
						b.eksempel,
						b.omfang,
						b.titel,
						b.retskilde,
						b.aendringsnotat,
						b.virkning,	
						_remove_nulls_in_array(array_agg(
							CASE 
							WHEN c.id is not null THEN
							ROW(
						 		c.soegeordidentifikator,
						 		c.beskrivelse,
						 		c.soegeordskategori 
							)::KlasseSoegeordType
						ELSE
						NULL
						END
						order by c.soegeordidentifikator,c.beskrivelse,c.soegeordskategori
					)) KlasseAttrEgenskaberSoegeordTypeArr 
					FROM
						(
								SELECT
								a.id klasse_id,
								b.id klasse_registrering_id,
								b.registrering			
								FROM		klasse a
								JOIN 		klasse_registrering b 	ON b.klasse_id=a.id
								WHERE a.id = ANY (klasse_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
							) as a
						LEFT JOIN klasse_attr_egenskaber as b ON b.klasse_registrering_id=a.klasse_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
						LEFT JOIN klasse_attr_egenskaber_soegeord as c ON c.klasse_attr_egenskaber_id=b.id
						GROUP BY 
						a.klasse_id,
						a.klasse_registrering_id,
						a.registrering,
						b.id,
						b.brugervendtnoegle,
						b.beskrivelse,
						b.eksempel,
						b.omfang,
						b.titel,
						b.retskilde,
						b.aendringsnotat,
						b.virkning
				) as a
			GROUP BY 
			a.klasse_id,
			a.klasse_registrering_id,
			a.registrering
			) as a
			LEFT JOIN klasse_tils_publiceret as b ON b.klasse_registrering_id=a.klasse_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.klasse_id,
			a.klasse_registrering_id,
			a.registrering,
			a.KlasseAttrEgenskaberArr
	) as a
	LEFT JOIN klasse_relation b ON b.klasse_registrering_id=a.klasse_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.klasse_id,
	a.klasse_registrering_id,
	a.registrering,
	a.KlasseAttrEgenskaberArr,
	a.KlasseTilsPubliceretArr
) as a
WHERE a.klasse_id IS NOT NULL
GROUP BY 
a.klasse_id
order by a.klasse_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_klasse(klasse_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr klasseregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_klassifikation(uuid[], tstzrange, tstzrange, klassifikationregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_klassifikation(klassifikation_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr klassifikationregistreringtype[] DEFAULT NULL::klassifikationregistreringtype[]) RETURNS klassifikationtype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result KlassifikationType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_klassifikation(klassifikation_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(klassifikation_uuids,1),0) AND auth_filtered_uuids @>klassifikation_uuids) THEN
  RAISE EXCEPTION 'Unable to list klassifikation with uuids [%]. All objects do not fullfill the stipulated criteria:%',klassifikation_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.klassifikationObj) into result
FROM
(
SELECT
ROW(
	a.klassifikation_id,
	array_agg(
		ROW (
			a.registrering,
			a.KlassifikationTilsPubliceretArr,
			a.KlassifikationAttrEgenskaberArr,
			a.KlassifikationRelationArr
		)::KlassifikationRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: KlassifikationType  klassifikationObj
FROM
(
	SELECT
	a.klassifikation_id,
	a.klassifikation_registrering_id,
	a.registrering,
	a.KlassifikationAttrEgenskaberArr,
	a.KlassifikationTilsPubliceretArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type 
			):: KlassifikationRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
	)) KlassifikationRelationArr
	FROM
	(
			SELECT
			a.klassifikation_id,
			a.klassifikation_registrering_id,
			a.registrering,
			a.KlassifikationAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.publiceret
						) ::KlassifikationPubliceretTilsType
					ELSE NULL
					END
					order by b.publiceret,b.virkning
				)) KlassifikationTilsPubliceretArr		
			FROM
			(
					SELECT
					a.klassifikation_id,
					a.klassifikation_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.beskrivelse,
					 		b.kaldenavn,
					 		b.ophavsret,
					   		b.virkning 
							)::KlassifikationEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.beskrivelse,b.kaldenavn,b.ophavsret,b.virkning
					)) KlassifikationAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id klassifikation_id,
					b.id klassifikation_registrering_id,
					b.registrering			
					FROM		klassifikation a
					JOIN 		klassifikation_registrering b 	ON b.klassifikation_id=a.id
					WHERE a.id = ANY (klassifikation_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN klassifikation_attr_egenskaber as b ON b.klassifikation_registrering_id=a.klassifikation_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.klassifikation_id,
					a.klassifikation_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN klassifikation_tils_publiceret as b ON b.klassifikation_registrering_id=a.klassifikation_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.klassifikation_id,
			a.klassifikation_registrering_id,
			a.registrering,
			a.KlassifikationAttrEgenskaberArr
	) as a
	LEFT JOIN klassifikation_relation b ON b.klassifikation_registrering_id=a.klassifikation_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.klassifikation_id,
	a.klassifikation_registrering_id,
	a.registrering,
	a.KlassifikationAttrEgenskaberArr,
	a.KlassifikationTilsPubliceretArr
) as a
WHERE a.klassifikation_id IS NOT NULL
GROUP BY 
a.klassifikation_id
order by a.klassifikation_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_klassifikation(klassifikation_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr klassifikationregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_loghaendelse(uuid[], tstzrange, tstzrange, loghaendelseregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_loghaendelse(loghaendelse_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr loghaendelseregistreringtype[] DEFAULT NULL::loghaendelseregistreringtype[]) RETURNS loghaendelsetype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result LoghaendelseType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_loghaendelse(loghaendelse_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(loghaendelse_uuids,1),0) AND auth_filtered_uuids @>loghaendelse_uuids) THEN
  RAISE EXCEPTION 'Unable to list loghaendelse with uuids [%]. All objects do not fullfill the stipulated criteria:%',loghaendelse_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.loghaendelseObj) into result
FROM
(
SELECT
ROW(
	a.loghaendelse_id,
	array_agg(
		ROW (
			a.registrering,
			a.LoghaendelseTilsGyldighedArr,
			a.LoghaendelseAttrEgenskaberArr,
			a.LoghaendelseRelationArr
		)::LoghaendelseRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: LoghaendelseType  loghaendelseObj
FROM
(
	SELECT
	a.loghaendelse_id,
	a.loghaendelse_registrering_id,
	a.registrering,
	a.LoghaendelseAttrEgenskaberArr,
	a.LoghaendelseTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type 
			):: LoghaendelseRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
	)) LoghaendelseRelationArr
	FROM
	(
			SELECT
			a.loghaendelse_id,
			a.loghaendelse_registrering_id,
			a.registrering,
			a.LoghaendelseAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::LoghaendelseGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) LoghaendelseTilsGyldighedArr		
			FROM
			(
					SELECT
					a.loghaendelse_id,
					a.loghaendelse_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.service,
					 		b.klasse,
					 		b.tidspunkt,
					 		b.operation,
					 		b.objekttype,
					 		b.returkode,
					 		b.returtekst,
					 		b.note,
					   		b.virkning 
							)::LoghaendelseEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.service,b.klasse,b.tidspunkt,b.operation,b.objekttype,b.returkode,b.returtekst,b.note,b.virkning
					)) LoghaendelseAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id loghaendelse_id,
					b.id loghaendelse_registrering_id,
					b.registrering			
					FROM		loghaendelse a
					JOIN 		loghaendelse_registrering b 	ON b.loghaendelse_id=a.id
					WHERE a.id = ANY (loghaendelse_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN loghaendelse_attr_egenskaber as b ON b.loghaendelse_registrering_id=a.loghaendelse_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.loghaendelse_id,
					a.loghaendelse_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN loghaendelse_tils_gyldighed as b ON b.loghaendelse_registrering_id=a.loghaendelse_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.loghaendelse_id,
			a.loghaendelse_registrering_id,
			a.registrering,
			a.LoghaendelseAttrEgenskaberArr
	) as a
	LEFT JOIN loghaendelse_relation b ON b.loghaendelse_registrering_id=a.loghaendelse_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.loghaendelse_id,
	a.loghaendelse_registrering_id,
	a.registrering,
	a.LoghaendelseAttrEgenskaberArr,
	a.LoghaendelseTilsGyldighedArr
) as a
WHERE a.loghaendelse_id IS NOT NULL
GROUP BY 
a.loghaendelse_id
order by a.loghaendelse_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_loghaendelse(loghaendelse_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr loghaendelseregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_organisation(uuid[], tstzrange, tstzrange, organisationregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_organisation(organisation_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr organisationregistreringtype[] DEFAULT NULL::organisationregistreringtype[]) RETURNS organisationtype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result OrganisationType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisation(organisation_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(organisation_uuids,1),0) AND auth_filtered_uuids @>organisation_uuids) THEN
  RAISE EXCEPTION 'Unable to list organisation with uuids [%]. All objects do not fullfill the stipulated criteria:%',organisation_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.organisationObj) into result
FROM
(
SELECT
ROW(
	a.organisation_id,
	array_agg(
		ROW (
			a.registrering,
			a.OrganisationTilsGyldighedArr,
			a.OrganisationAttrEgenskaberArr,
			a.OrganisationRelationArr
		)::OrganisationRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: OrganisationType  organisationObj
FROM
(
	SELECT
	a.organisation_id,
	a.organisation_registrering_id,
	a.registrering,
	a.OrganisationAttrEgenskaberArr,
	a.OrganisationTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type 
			):: OrganisationRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
	)) OrganisationRelationArr
	FROM
	(
			SELECT
			a.organisation_id,
			a.organisation_registrering_id,
			a.registrering,
			a.OrganisationAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::OrganisationGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) OrganisationTilsGyldighedArr		
			FROM
			(
					SELECT
					a.organisation_id,
					a.organisation_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.organisationsnavn,
					   		b.virkning 
							)::OrganisationEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.organisationsnavn,b.virkning
					)) OrganisationAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id organisation_id,
					b.id organisation_registrering_id,
					b.registrering			
					FROM		organisation a
					JOIN 		organisation_registrering b 	ON b.organisation_id=a.id
					WHERE a.id = ANY (organisation_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN organisation_attr_egenskaber as b ON b.organisation_registrering_id=a.organisation_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.organisation_id,
					a.organisation_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN organisation_tils_gyldighed as b ON b.organisation_registrering_id=a.organisation_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.organisation_id,
			a.organisation_registrering_id,
			a.registrering,
			a.OrganisationAttrEgenskaberArr
	) as a
	LEFT JOIN organisation_relation b ON b.organisation_registrering_id=a.organisation_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.organisation_id,
	a.organisation_registrering_id,
	a.registrering,
	a.OrganisationAttrEgenskaberArr,
	a.OrganisationTilsGyldighedArr
) as a
WHERE a.organisation_id IS NOT NULL
GROUP BY 
a.organisation_id
order by a.organisation_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_organisation(organisation_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr organisationregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_organisationenhed(uuid[], tstzrange, tstzrange, organisationenhedregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_organisationenhed(organisationenhed_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr organisationenhedregistreringtype[] DEFAULT NULL::organisationenhedregistreringtype[]) RETURNS organisationenhedtype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result OrganisationenhedType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationenhed(organisationenhed_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(organisationenhed_uuids,1),0) AND auth_filtered_uuids @>organisationenhed_uuids) THEN
  RAISE EXCEPTION 'Unable to list organisationenhed with uuids [%]. All objects do not fullfill the stipulated criteria:%',organisationenhed_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.organisationenhedObj) into result
FROM
(
SELECT
ROW(
	a.organisationenhed_id,
	array_agg(
		ROW (
			a.registrering,
			a.OrganisationenhedTilsGyldighedArr,
			a.OrganisationenhedAttrEgenskaberArr,
			a.OrganisationenhedRelationArr
		)::OrganisationenhedRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: OrganisationenhedType  organisationenhedObj
FROM
(
	SELECT
	a.organisationenhed_id,
	a.organisationenhed_registrering_id,
	a.registrering,
	a.OrganisationenhedAttrEgenskaberArr,
	a.OrganisationenhedTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type 
			):: OrganisationenhedRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
	)) OrganisationenhedRelationArr
	FROM
	(
			SELECT
			a.organisationenhed_id,
			a.organisationenhed_registrering_id,
			a.registrering,
			a.OrganisationenhedAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::OrganisationenhedGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) OrganisationenhedTilsGyldighedArr		
			FROM
			(
					SELECT
					a.organisationenhed_id,
					a.organisationenhed_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.enhedsnavn,
					   		b.virkning 
							)::OrganisationenhedEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.enhedsnavn,b.virkning
					)) OrganisationenhedAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id organisationenhed_id,
					b.id organisationenhed_registrering_id,
					b.registrering			
					FROM		organisationenhed a
					JOIN 		organisationenhed_registrering b 	ON b.organisationenhed_id=a.id
					WHERE a.id = ANY (organisationenhed_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN organisationenhed_attr_egenskaber as b ON b.organisationenhed_registrering_id=a.organisationenhed_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.organisationenhed_id,
					a.organisationenhed_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN organisationenhed_tils_gyldighed as b ON b.organisationenhed_registrering_id=a.organisationenhed_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.organisationenhed_id,
			a.organisationenhed_registrering_id,
			a.registrering,
			a.OrganisationenhedAttrEgenskaberArr
	) as a
	LEFT JOIN organisationenhed_relation b ON b.organisationenhed_registrering_id=a.organisationenhed_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.organisationenhed_id,
	a.organisationenhed_registrering_id,
	a.registrering,
	a.OrganisationenhedAttrEgenskaberArr,
	a.OrganisationenhedTilsGyldighedArr
) as a
WHERE a.organisationenhed_id IS NOT NULL
GROUP BY 
a.organisationenhed_id
order by a.organisationenhed_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_organisationenhed(organisationenhed_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr organisationenhedregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_organisationfunktion(uuid[], tstzrange, tstzrange, organisationfunktionregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_organisationfunktion(organisationfunktion_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr organisationfunktionregistreringtype[] DEFAULT NULL::organisationfunktionregistreringtype[]) RETURNS organisationfunktiontype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result OrganisationfunktionType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationfunktion(organisationfunktion_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(organisationfunktion_uuids,1),0) AND auth_filtered_uuids @>organisationfunktion_uuids) THEN
  RAISE EXCEPTION 'Unable to list organisationfunktion with uuids [%]. All objects do not fullfill the stipulated criteria:%',organisationfunktion_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.organisationfunktionObj) into result
FROM
(
SELECT
ROW(
	a.organisationfunktion_id,
	array_agg(
		ROW (
			a.registrering,
			a.OrganisationfunktionTilsGyldighedArr,
			a.OrganisationfunktionAttrEgenskaberArr,
			a.OrganisationfunktionRelationArr
		)::OrganisationfunktionRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: OrganisationfunktionType  organisationfunktionObj
FROM
(
	SELECT
	a.organisationfunktion_id,
	a.organisationfunktion_registrering_id,
	a.registrering,
	a.OrganisationfunktionAttrEgenskaberArr,
	a.OrganisationfunktionTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type 
			):: OrganisationfunktionRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
	)) OrganisationfunktionRelationArr
	FROM
	(
			SELECT
			a.organisationfunktion_id,
			a.organisationfunktion_registrering_id,
			a.registrering,
			a.OrganisationfunktionAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::OrganisationfunktionGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) OrganisationfunktionTilsGyldighedArr		
			FROM
			(
					SELECT
					a.organisationfunktion_id,
					a.organisationfunktion_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.funktionsnavn,
					   		b.virkning 
							)::OrganisationfunktionEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.funktionsnavn,b.virkning
					)) OrganisationfunktionAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id organisationfunktion_id,
					b.id organisationfunktion_registrering_id,
					b.registrering			
					FROM		organisationfunktion a
					JOIN 		organisationfunktion_registrering b 	ON b.organisationfunktion_id=a.id
					WHERE a.id = ANY (organisationfunktion_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN organisationfunktion_attr_egenskaber as b ON b.organisationfunktion_registrering_id=a.organisationfunktion_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.organisationfunktion_id,
					a.organisationfunktion_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN organisationfunktion_tils_gyldighed as b ON b.organisationfunktion_registrering_id=a.organisationfunktion_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.organisationfunktion_id,
			a.organisationfunktion_registrering_id,
			a.registrering,
			a.OrganisationfunktionAttrEgenskaberArr
	) as a
	LEFT JOIN organisationfunktion_relation b ON b.organisationfunktion_registrering_id=a.organisationfunktion_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.organisationfunktion_id,
	a.organisationfunktion_registrering_id,
	a.registrering,
	a.OrganisationfunktionAttrEgenskaberArr,
	a.OrganisationfunktionTilsGyldighedArr
) as a
WHERE a.organisationfunktion_id IS NOT NULL
GROUP BY 
a.organisationfunktion_id
order by a.organisationfunktion_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_organisationfunktion(organisationfunktion_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr organisationfunktionregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_sag(uuid[], tstzrange, tstzrange, sagregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_sag(sag_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr sagregistreringtype[] DEFAULT NULL::sagregistreringtype[]) RETURNS sagtype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result SagType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_sag(sag_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(sag_uuids,1),0) AND auth_filtered_uuids @>sag_uuids) THEN
  RAISE EXCEPTION 'Unable to list sag with uuids [%]. All objects do not fullfill the stipulated criteria:%',sag_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.sagObj) into result
FROM
(
SELECT
ROW(
	a.sag_id,
	array_agg(
		ROW (
			a.registrering,
			a.SagTilsFremdriftArr,
			a.SagAttrEgenskaberArr,
			a.SagRelationArr
		)::SagRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: SagType  sagObj
FROM
(
	SELECT
	a.sag_id,
	a.sag_registrering_id,
	a.registrering,
	a.SagAttrEgenskaberArr,
	a.SagTilsFremdriftArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type,
				b.rel_index,
				b.rel_type_spec,
				b.journal_notat,
				b.journal_dokument_attr
			):: SagRelationType
		ELSE
		NULL
		END
		order by b.rel_type,b.rel_index,b.rel_maal_uuid,b.rel_maal_urn,b.objekt_type,b.rel_type_spec,b.journal_notat,b.journal_dokument_attr,b.virkning
	)) SagRelationArr
	FROM
	(
			SELECT
			a.sag_id,
			a.sag_registrering_id,
			a.registrering,
			a.SagAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.fremdrift
						) ::SagFremdriftTilsType
					ELSE NULL
					END
					order by b.fremdrift,b.virkning
				)) SagTilsFremdriftArr		
			FROM
			(
					SELECT
					a.sag_id,
					a.sag_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.afleveret,
					 		b.beskrivelse,
					 		b.hjemmel,
					 		b.kassationskode,
					 		b.offentlighedundtaget,
					 		b.principiel,
					 		b.sagsnummer,
					 		b.titel,
					   		b.virkning 
							)::SagEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.afleveret,b.beskrivelse,b.hjemmel,b.kassationskode,b.offentlighedundtaget,b.principiel,b.sagsnummer,b.titel,b.virkning
					)) SagAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id sag_id,
					b.id sag_registrering_id,
					b.registrering			
					FROM		sag a
					JOIN 		sag_registrering b 	ON b.sag_id=a.id
					WHERE a.id = ANY (sag_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN sag_attr_egenskaber as b ON b.sag_registrering_id=a.sag_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.sag_id,
					a.sag_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN sag_tils_fremdrift as b ON b.sag_registrering_id=a.sag_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.sag_id,
			a.sag_registrering_id,
			a.registrering,
			a.SagAttrEgenskaberArr
	) as a
	LEFT JOIN sag_relation b ON b.sag_registrering_id=a.sag_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.sag_id,
	a.sag_registrering_id,
	a.registrering,
	a.SagAttrEgenskaberArr,
	a.SagTilsFremdriftArr
) as a
WHERE a.sag_id IS NOT NULL
GROUP BY 
a.sag_id
order by a.sag_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_sag(sag_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr sagregistreringtype[]) OWNER TO mox;

--
-- Name: as_list_tilstand(uuid[], tstzrange, tstzrange, tilstandregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_list_tilstand(tilstand_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr tilstandregistreringtype[] DEFAULT NULL::tilstandregistreringtype[]) RETURNS tilstandtype[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	auth_filtered_uuids uuid[];
	result TilstandType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_tilstand(tilstand_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(tilstand_uuids,1),0) AND auth_filtered_uuids @>tilstand_uuids) THEN
  RAISE EXCEPTION 'Unable to list tilstand with uuids [%]. All objects do not fullfill the stipulated criteria:%',tilstand_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg( x.tilstandObj) into result
FROM
(
SELECT
ROW(
	a.tilstand_id,
	array_agg(
		ROW (
			a.registrering,
			a.TilstandTilsStatusArr,
			a.TilstandTilsPubliceretArr,
			a.TilstandAttrEgenskaberArr,
			a.TilstandRelationArr
		)::TilstandRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: TilstandType  tilstandObj
FROM
(
	SELECT
	a.tilstand_id,
	a.tilstand_registrering_id,
	a.registrering,
	a.TilstandAttrEgenskaberArr,
	a.TilstandTilsStatusArr,
	a.TilstandTilsPubliceretArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type,
 				b.rel_index,
				b.tilstand_vaerdi_attr  
			):: TilstandRelationType
		ELSE
		NULL
		END
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.rel_index,b.tilstand_vaerdi_attr,b.virkning
	)) TilstandRelationArr
	FROM
	(
			SELECT
			a.tilstand_id,
			a.tilstand_registrering_id,
			a.registrering,
			a.TilstandAttrEgenskaberArr,
			a.TilstandTilsPubliceretArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.status
						) ::TilstandStatusTilsType
					ELSE NULL
					END
					order by b.status,b.virkning
				)) TilstandTilsStatusArr		
			FROM
			(
			SELECT
			a.tilstand_id,
			a.tilstand_registrering_id,
			a.registrering,
			a.TilstandAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.publiceret
						) ::TilstandPubliceretTilsType
					ELSE NULL
					END
					order by b.publiceret,b.virkning
				)) TilstandTilsPubliceretArr		
			FROM
			(
					SELECT
					a.tilstand_id,
					a.tilstand_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE 
						WHEN b.id is not null THEN
						ROW(
					 		b.brugervendtnoegle,
					 		b.beskrivelse,
					   		b.virkning 
							)::TilstandEgenskaberAttrType
						ELSE
						NULL
						END
						order by b.brugervendtnoegle,b.beskrivelse,b.virkning
					)) TilstandAttrEgenskaberArr 
					FROM
					(
					SELECT
					a.id tilstand_id,
					b.id tilstand_registrering_id,
					b.registrering			
					FROM		tilstand a
					JOIN 		tilstand_registrering b 	ON b.tilstand_id=a.id
					WHERE a.id = ANY (tilstand_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN tilstand_attr_egenskaber as b ON b.tilstand_registrering_id=a.tilstand_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
					GROUP BY 
					a.tilstand_id,
					a.tilstand_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN tilstand_tils_publiceret as b ON b.tilstand_registrering_id=a.tilstand_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.tilstand_id,
			a.tilstand_registrering_id,
			a.registrering,
			a.TilstandAttrEgenskaberArr	
			) as a
			LEFT JOIN tilstand_tils_status as b ON b.tilstand_registrering_id=a.tilstand_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.tilstand_id,
			a.tilstand_registrering_id,
			a.registrering,
			a.TilstandAttrEgenskaberArr,
			a.TilstandTilsPubliceretArr
	) as a
	LEFT JOIN tilstand_relation b ON b.tilstand_registrering_id=a.tilstand_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.tilstand_id,
	a.tilstand_registrering_id,
	a.registrering,
	a.TilstandAttrEgenskaberArr,
	a.TilstandTilsPubliceretArr,
	a.TilstandTilsStatusArr
) as a
WHERE a.tilstand_id IS NOT NULL
GROUP BY 
a.tilstand_id
order by a.tilstand_id
) as x
;



RETURN result;

END;
$$;


ALTER FUNCTION actual_state.as_list_tilstand(tilstand_uuids uuid[], registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr tilstandregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_aktivitet(uuid, tstzrange, tstzrange, aktivitetregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_aktivitet(aktivitet_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr aktivitetregistreringtype[] DEFAULT NULL::aktivitetregistreringtype[]) RETURNS aktivitettype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr AktivitetType[];
BEGIN  
resArr:= as_list_aktivitet(ARRAY[aktivitet_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_aktivitet(aktivitet_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr aktivitetregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_bruger(uuid, tstzrange, tstzrange, brugerregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_bruger(bruger_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr brugerregistreringtype[] DEFAULT NULL::brugerregistreringtype[]) RETURNS brugertype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr BrugerType[];
BEGIN  
resArr:= as_list_bruger(ARRAY[bruger_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_bruger(bruger_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr brugerregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_dokument(uuid, tstzrange, tstzrange, dokumentregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_dokument(dokument_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr dokumentregistreringtype[] DEFAULT NULL::dokumentregistreringtype[]) RETURNS dokumenttype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr DokumentType[];
BEGIN  
resArr:= as_list_dokument(ARRAY[dokument_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_dokument(dokument_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr dokumentregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_facet(uuid, tstzrange, tstzrange, facetregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_facet(facet_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr facetregistreringtype[] DEFAULT NULL::facetregistreringtype[]) RETURNS facettype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr FacetType[];
BEGIN  
resArr:= as_list_facet(ARRAY[facet_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_facet(facet_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr facetregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_indsats(uuid, tstzrange, tstzrange, indsatsregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_indsats(indsats_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr indsatsregistreringtype[] DEFAULT NULL::indsatsregistreringtype[]) RETURNS indsatstype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr IndsatsType[];
BEGIN  
resArr:= as_list_indsats(ARRAY[indsats_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_indsats(indsats_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr indsatsregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_interessefaellesskab(uuid, tstzrange, tstzrange, interessefaellesskabregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_interessefaellesskab(interessefaellesskab_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr interessefaellesskabregistreringtype[] DEFAULT NULL::interessefaellesskabregistreringtype[]) RETURNS interessefaellesskabtype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr InteressefaellesskabType[];
BEGIN  
resArr:= as_list_interessefaellesskab(ARRAY[interessefaellesskab_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_interessefaellesskab(interessefaellesskab_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr interessefaellesskabregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_itsystem(uuid, tstzrange, tstzrange, itsystemregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_itsystem(itsystem_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr itsystemregistreringtype[] DEFAULT NULL::itsystemregistreringtype[]) RETURNS itsystemtype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr ItsystemType[];
BEGIN  
resArr:= as_list_itsystem(ARRAY[itsystem_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_itsystem(itsystem_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr itsystemregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_klasse(uuid, tstzrange, tstzrange, klasseregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_klasse(klasse_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr klasseregistreringtype[] DEFAULT NULL::klasseregistreringtype[]) RETURNS klassetype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr KlasseType[];
BEGIN  
resArr:= as_list_klasse(ARRAY[klasse_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_klasse(klasse_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr klasseregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_klassifikation(uuid, tstzrange, tstzrange, klassifikationregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_klassifikation(klassifikation_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr klassifikationregistreringtype[] DEFAULT NULL::klassifikationregistreringtype[]) RETURNS klassifikationtype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr KlassifikationType[];
BEGIN  
resArr:= as_list_klassifikation(ARRAY[klassifikation_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_klassifikation(klassifikation_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr klassifikationregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_loghaendelse(uuid, tstzrange, tstzrange, loghaendelseregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_loghaendelse(loghaendelse_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr loghaendelseregistreringtype[] DEFAULT NULL::loghaendelseregistreringtype[]) RETURNS loghaendelsetype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr LoghaendelseType[];
BEGIN  
resArr:= as_list_loghaendelse(ARRAY[loghaendelse_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_loghaendelse(loghaendelse_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr loghaendelseregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_organisation(uuid, tstzrange, tstzrange, organisationregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_organisation(organisation_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr organisationregistreringtype[] DEFAULT NULL::organisationregistreringtype[]) RETURNS organisationtype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr OrganisationType[];
BEGIN  
resArr:= as_list_organisation(ARRAY[organisation_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_organisation(organisation_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr organisationregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_organisationenhed(uuid, tstzrange, tstzrange, organisationenhedregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_organisationenhed(organisationenhed_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr organisationenhedregistreringtype[] DEFAULT NULL::organisationenhedregistreringtype[]) RETURNS organisationenhedtype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr OrganisationenhedType[];
BEGIN  
resArr:= as_list_organisationenhed(ARRAY[organisationenhed_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_organisationenhed(organisationenhed_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr organisationenhedregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_organisationfunktion(uuid, tstzrange, tstzrange, organisationfunktionregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_organisationfunktion(organisationfunktion_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr organisationfunktionregistreringtype[] DEFAULT NULL::organisationfunktionregistreringtype[]) RETURNS organisationfunktiontype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr OrganisationfunktionType[];
BEGIN  
resArr:= as_list_organisationfunktion(ARRAY[organisationfunktion_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_organisationfunktion(organisationfunktion_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr organisationfunktionregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_sag(uuid, tstzrange, tstzrange, sagregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_sag(sag_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr sagregistreringtype[] DEFAULT NULL::sagregistreringtype[]) RETURNS sagtype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr SagType[];
BEGIN  
resArr:= as_list_sag(ARRAY[sag_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_sag(sag_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr sagregistreringtype[]) OWNER TO mox;

--
-- Name: as_read_tilstand(uuid, tstzrange, tstzrange, tilstandregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_read_tilstand(tilstand_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr tilstandregistreringtype[] DEFAULT NULL::tilstandregistreringtype[]) RETURNS tilstandtype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	resArr TilstandType[];
BEGIN  
resArr:= as_list_tilstand(ARRAY[tilstand_uuid],registrering_tstzrange,virkning_tstzrange,auth_criteria_arr);
IF resArr is not null and coalesce(array_length(resArr,1),0)=1 THEN
	RETURN resArr[1];
ELSE
	RETURN null;
END IF;

END;
$$;


ALTER FUNCTION actual_state.as_read_tilstand(tilstand_uuid uuid, registrering_tstzrange tstzrange, virkning_tstzrange tstzrange, auth_criteria_arr tilstandregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_aktivitet(integer, uuid, aktivitetregistreringtype, tstzrange, integer, text[], uuid[], text[], aktivitetregistreringtype[], aktivitetegenskaberattrtype[], aktivitetegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_aktivitet(firstresult integer, aktivitet_uuid uuid, registreringobj aktivitetregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr aktivitetregistreringtype[] DEFAULT NULL::aktivitetregistreringtype[], search_operator_greater_than_or_equal_attr_egenskaber aktivitetegenskaberattrtype[] DEFAULT NULL::aktivitetegenskaberattrtype[], search_operator_less_than_or_equal_attr_egenskaber aktivitetegenskaberattrtype[] DEFAULT NULL::aktivitetegenskaberattrtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	aktivitet_candidates uuid[];
	aktivitet_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj AktivitetEgenskaberAttrType;
	
  	tilsStatusTypeObj AktivitetStatusTilsType;
  	tilsPubliceretTypeObj AktivitetPubliceretTilsType;
	relationTypeObj AktivitetRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

aktivitet_candidates_is_initialized := false;

IF aktivitet_uuid is not NULL THEN
	aktivitet_candidates:= ARRAY[aktivitet_uuid];
	aktivitet_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		aktivitet_candidates:=array(
				SELECT DISTINCT
				b.aktivitet_id 
				FROM
				aktivitet a
				JOIN aktivitet_registrering b on b.aktivitet_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'aktivitet_candidates_is_initialized step 1:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 1:%',aktivitet_candidates;
--/****************************//


--RAISE NOTICE 'aktivitet_candidates_is_initialized step 2:%',aktivitet_candidates_is_initialized;
--RAISE NOTICE 'aktivitet_candidates step 2:%',aktivitet_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_aktivitet: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(aktivitet_candidates,1),0)>0 OR NOT aktivitet_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_attr_egenskaber a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.aktivitetnavn IS NULL
					OR 
					a.aktivitetnavn ILIKE attrEgenskaberTypeObj.aktivitetnavn --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.starttidspunkt IS NULL
					OR 
					a.starttidspunkt = attrEgenskaberTypeObj.starttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.sluttidspunkt IS NULL
					OR 
					a.sluttidspunkt = attrEgenskaberTypeObj.sluttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.tidsforbrug IS NULL
					OR 
					a.tidsforbrug = attrEgenskaberTypeObj.tidsforbrug 
				)
				AND
				(
					attrEgenskaberTypeObj.formaal IS NULL
					OR 
					a.formaal ILIKE attrEgenskaberTypeObj.formaal --case insensitive 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

			);
			

			aktivitet_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'aktivitet_candidates_is_initialized step 3:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 3:%',aktivitet_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		aktivitet_candidates:=array( 

			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_attr_egenskaber a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
						a.aktivitetnavn ILIKE anyAttrValue OR
						a.beskrivelse ILIKE anyAttrValue OR
									a.starttidspunkt::text ilike anyAttrValue OR
									a.sluttidspunkt::text ilike anyAttrValue OR
									a.tidsforbrug::text ilike anyAttrValue OR
						a.formaal ILIKE anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )


		);

	aktivitet_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Status
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsStatus IS NULL THEN
	--RAISE DEBUG 'as_search_aktivitet: skipping filtration on tilsStatus';
ELSE
	IF (coalesce(array_length(aktivitet_candidates,1),0)>0 OR aktivitet_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsStatusTypeObj IN ARRAY registreringObj.tilsStatus
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_tils_status a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
			WHERE
				(
					tilsStatusTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsStatusTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsStatusTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsStatusTypeObj.virkning).AktoerRef IS NULL OR (tilsStatusTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsStatusTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsStatusTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsStatusTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsStatusTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsStatusTypeObj.virkning) IS NULL OR (tilsStatusTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsStatusTypeObj.status IS NULL
					OR
					tilsStatusTypeObj.status = a.status
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

	);
			

			aktivitet_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_aktivitet: skipping filtration on tilsPubliceret';
ELSE
	IF (coalesce(array_length(aktivitet_candidates,1),0)>0 OR aktivitet_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_tils_publiceret a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
			WHERE
				(
					tilsPubliceretTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsPubliceretTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsPubliceretTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).AktoerRef IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsPubliceretTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsPubliceretTypeObj.virkning) IS NULL OR (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

	);
			

			aktivitet_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer AktivitetRelationType[]
*/


--RAISE DEBUG 'aktivitet_candidates_is_initialized step 4:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 4:%',aktivitet_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_aktivitet: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(aktivitet_candidates,1),0)>0 OR NOT aktivitet_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_relation a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
				(
 					relationTypeObj.indeks IS NULL
 					OR
 					relationTypeObj.indeks = a.rel_index
 				)
				AND
				(
					relationTypeObj.aktoerAttr IS NULL
					OR
					(
						(
							(relationTypeObj.aktoerAttr).obligatorisk IS NULL
							OR
							(relationTypeObj.aktoerAttr).obligatorisk = (a.aktoer_attr).obligatorisk					
						)
						AND
						(
							(relationTypeObj.aktoerAttr).accepteret IS NULL
							OR
							(relationTypeObj.aktoerAttr).accepteret = (a.aktoer_attr).accepteret
						)
						AND
						(
							(relationTypeObj.aktoerAttr).repraesentation_uuid IS NULL
							OR
							(relationTypeObj.aktoerAttr).repraesentation_uuid = (a.aktoer_attr).repraesentation_uuid
						)
						AND
						(
							(relationTypeObj.aktoerAttr).repraesentation_urn IS NULL
							OR
							(relationTypeObj.aktoerAttr).repraesentation_urn = (a.aktoer_attr).repraesentation_urn
						)
					)
				) 
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

	);
			
			aktivitet_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_relation a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
			WHERE
			(
				anyuuid = a.rel_maal_uuid
			OR  
				((NOT (a.aktoer_attr IS NULL)) AND anyuuid = (a.aktoer_attr).repraesentation_uuid )
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )


			);

	aktivitet_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_relation a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
			WHERE
			(
				anyurn = a.rel_maal_urn
				OR 
				((NOT (a.aktoer_attr IS NULL)) AND anyurn = (a.aktoer_attr).repraesentation_urn)
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )


			);

	aktivitet_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 --/**********************************************************//
--Filtration using operator 'greather than or equal': Egenskaber
--/**********************************************************//
IF coalesce(array_length(search_operator_greater_than_or_equal_attr_egenskaber,1),0)>0 THEN
	IF (coalesce(array_length(aktivitet_candidates,1),0)>0 OR NOT aktivitet_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY search_operator_greater_than_or_equal_attr_egenskaber
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_attr_egenskaber a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle >= attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.aktivitetnavn IS NULL
					OR 
					a.aktivitetnavn >= attrEgenskaberTypeObj.aktivitetnavn 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse >= attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.starttidspunkt IS NULL
					OR 
					a.starttidspunkt >= attrEgenskaberTypeObj.starttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.sluttidspunkt IS NULL
					OR 
					a.sluttidspunkt >= attrEgenskaberTypeObj.sluttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.tidsforbrug IS NULL
					OR 
					a.tidsforbrug >= attrEgenskaberTypeObj.tidsforbrug 
				)
				AND
				(
					attrEgenskaberTypeObj.formaal IS NULL
					OR 
					a.formaal >= attrEgenskaberTypeObj.formaal 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

			);
			

			aktivitet_candidates_is_initialized:=true;
			
			
			END LOOP;
		END IF;	
	END IF;

--RAISE DEBUG 'aktivitet_candidates_is_initialized step 3:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 3:%',aktivitet_candidates;

 --/**********************************************************//
--Filtration using operator 'less than or equal': Egenskaber
--/**********************************************************//
IF coalesce(array_length(search_operator_less_than_or_equal_attr_egenskaber,1),0)>0 THEN
	IF (coalesce(array_length(aktivitet_candidates,1),0)>0 OR NOT aktivitet_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY search_operator_less_than_or_equal_attr_egenskaber
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_attr_egenskaber a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle <= attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.aktivitetnavn IS NULL
					OR 
					a.aktivitetnavn <= attrEgenskaberTypeObj.aktivitetnavn 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse <= attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.starttidspunkt IS NULL
					OR 
					a.starttidspunkt <= attrEgenskaberTypeObj.starttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.sluttidspunkt IS NULL
					OR 
					a.sluttidspunkt <= attrEgenskaberTypeObj.sluttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.tidsforbrug IS NULL
					OR 
					a.tidsforbrug <= attrEgenskaberTypeObj.tidsforbrug 
				)
				AND
				(
					attrEgenskaberTypeObj.formaal IS NULL
					OR 
					a.formaal <= attrEgenskaberTypeObj.formaal 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

			);
			

			aktivitet_candidates_is_initialized:=true;
			
			
			END LOOP;
		END IF;	
	END IF;

--RAISE DEBUG 'aktivitet_candidates_is_initialized step 3:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 3:%',aktivitet_candidates;

--/**********************//



--RAISE DEBUG 'aktivitet_candidates_is_initialized step 5:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 5:%',aktivitet_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT aktivitet_candidates_is_initialized THEN 
		aktivitet_candidates:=array(
		SELECT DISTINCT
			aktivitet_id
		FROM
			aktivitet_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

		)
		;

		aktivitet_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT aktivitet_candidates_is_initialized THEN
	--No filters applied!
	aktivitet_candidates:=array(
		SELECT DISTINCT id FROM aktivitet a LIMIT maxResults
	);
ELSE
	aktivitet_candidates:=array(
		SELECT DISTINCT id FROM unnest(aktivitet_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'aktivitet_candidates_is_initialized step 6:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 6:%',aktivitet_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_aktivitet(aktivitet_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_aktivitet(firstresult integer, aktivitet_uuid uuid, registreringobj aktivitetregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr aktivitetregistreringtype[], search_operator_greater_than_or_equal_attr_egenskaber aktivitetegenskaberattrtype[], search_operator_less_than_or_equal_attr_egenskaber aktivitetegenskaberattrtype[]) OWNER TO mox;

--
-- Name: as_search_bruger(integer, uuid, brugerregistreringtype, tstzrange, integer, text[], uuid[], text[], brugerregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_bruger(firstresult integer, bruger_uuid uuid, registreringobj brugerregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr brugerregistreringtype[] DEFAULT NULL::brugerregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	bruger_candidates uuid[];
	bruger_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj BrugerEgenskaberAttrType;
	
  	tilsGyldighedTypeObj BrugerGyldighedTilsType;
	relationTypeObj BrugerRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

bruger_candidates_is_initialized := false;

IF bruger_uuid is not NULL THEN
	bruger_candidates:= ARRAY[bruger_uuid];
	bruger_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		bruger_candidates:=array(
				SELECT DISTINCT
				b.bruger_id 
				FROM
				bruger a
				JOIN bruger_registrering b on b.bruger_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'bruger_candidates_is_initialized step 1:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 1:%',bruger_candidates;
--/****************************//


--RAISE NOTICE 'bruger_candidates_is_initialized step 2:%',bruger_candidates_is_initialized;
--RAISE NOTICE 'bruger_candidates step 2:%',bruger_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_bruger: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(bruger_candidates,1),0)>0 OR NOT bruger_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			bruger_candidates:=array(
			SELECT DISTINCT
			b.bruger_id 
			FROM  bruger_attr_egenskaber a
			JOIN bruger_registrering b on a.bruger_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.brugernavn IS NULL
					OR 
					a.brugernavn ILIKE attrEgenskaberTypeObj.brugernavn --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.brugertype IS NULL
					OR 
					a.brugertype ILIKE attrEgenskaberTypeObj.brugertype --case insensitive 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )

			);
			

			bruger_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'bruger_candidates_is_initialized step 3:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 3:%',bruger_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		bruger_candidates:=array( 

			SELECT DISTINCT
			b.bruger_id 
			FROM  bruger_attr_egenskaber a
			JOIN bruger_registrering b on a.bruger_registrering_id=b.id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
						a.brugernavn ILIKE anyAttrValue OR
						a.brugertype ILIKE anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )


		);

	bruger_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_bruger: skipping filtration on tilsGyldighed';
ELSE
	IF (coalesce(array_length(bruger_candidates,1),0)>0 OR bruger_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			bruger_candidates:=array(
			SELECT DISTINCT
			b.bruger_id 
			FROM  bruger_tils_gyldighed a
			JOIN bruger_registrering b on a.bruger_registrering_id=b.id
			WHERE
				(
					tilsGyldighedTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsGyldighedTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )

	);
			

			bruger_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer BrugerRelationType[]
*/


--RAISE DEBUG 'bruger_candidates_is_initialized step 4:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 4:%',bruger_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_bruger: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(bruger_candidates,1),0)>0 OR NOT bruger_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			bruger_candidates:=array(
			SELECT DISTINCT
			b.bruger_id 
			FROM  bruger_relation a
			JOIN bruger_registrering b on a.bruger_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )

	);
			
			bruger_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		bruger_candidates:=array(
			SELECT DISTINCT
			b.bruger_id 
			FROM  bruger_relation a
			JOIN bruger_registrering b on a.bruger_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )


			);

	bruger_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		bruger_candidates:=array(
			SELECT DISTINCT
			b.bruger_id 
			FROM  bruger_relation a
			JOIN bruger_registrering b on a.bruger_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )


			);

	bruger_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 



--RAISE DEBUG 'bruger_candidates_is_initialized step 5:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 5:%',bruger_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT bruger_candidates_is_initialized THEN 
		bruger_candidates:=array(
		SELECT DISTINCT
			bruger_id
		FROM
			bruger_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )

		)
		;

		bruger_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT bruger_candidates_is_initialized THEN
	--No filters applied!
	bruger_candidates:=array(
		SELECT DISTINCT id FROM bruger a LIMIT maxResults
	);
ELSE
	bruger_candidates:=array(
		SELECT DISTINCT id FROM unnest(bruger_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'bruger_candidates_is_initialized step 6:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 6:%',bruger_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_bruger(bruger_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_bruger(firstresult integer, bruger_uuid uuid, registreringobj brugerregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr brugerregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_dokument(integer, uuid, dokumentregistreringtype, tstzrange, integer, text[], uuid[], text[], dokumentregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_dokument(firstresult integer, dokument_uuid uuid, registreringobj dokumentregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr dokumentregistreringtype[] DEFAULT NULL::dokumentregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	dokument_candidates uuid[];
	dokument_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj DokumentEgenskaberAttrType;
	
  	tilsFremdriftTypeObj DokumentFremdriftTilsType;
	relationTypeObj DokumentRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	variantTypeObj DokumentVariantType;
	variantEgenskaberTypeObj DokumentVariantEgenskaberType;
	delTypeObj DokumentDelType;
	delEgenskaberTypeObj DokumentDelEgenskaberType;
	delRelationTypeObj DokumentdelRelationType;
	variant_candidates_ids bigint[];
	variant_candidates_is_initialized boolean;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

dokument_candidates_is_initialized := false;

IF dokument_uuid is not NULL THEN
	dokument_candidates:= ARRAY[dokument_uuid];
	dokument_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		dokument_candidates:=array(
				SELECT DISTINCT
				b.dokument_id 
				FROM
				dokument a
				JOIN dokument_registrering b on b.dokument_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'dokument_candidates_is_initialized step 1:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 1:%',dokument_candidates;
--/****************************//


--RAISE NOTICE 'dokument_candidates_is_initialized step 2:%',dokument_candidates_is_initialized;
--RAISE NOTICE 'dokument_candidates step 2:%',dokument_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_dokument: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(dokument_candidates,1),0)>0 OR NOT dokument_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
			FROM  dokument_attr_egenskaber a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.brevdato IS NULL
					OR 
					a.brevdato = attrEgenskaberTypeObj.brevdato 
				)
				AND
				(
					attrEgenskaberTypeObj.kassationskode IS NULL
					OR 
					a.kassationskode ILIKE attrEgenskaberTypeObj.kassationskode --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.major IS NULL
					OR 
					a.major = attrEgenskaberTypeObj.major 
				)
				AND
				(
					attrEgenskaberTypeObj.minor IS NULL
					OR 
					a.minor = attrEgenskaberTypeObj.minor 
				)
				AND
				(
					attrEgenskaberTypeObj.offentlighedundtaget IS NULL
					OR
						(
							(
								(attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel IS NULL
								OR
								(a.offentlighedundtaget).AlternativTitel ILIKE (attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel 
							)
							AND
							(
								(attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel IS NULL
								OR
								(a.offentlighedundtaget).Hjemmel ILIKE (attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel
							)
						) 
				)
				AND
				(
					attrEgenskaberTypeObj.titel IS NULL
					OR 
					a.titel ILIKE attrEgenskaberTypeObj.titel --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.dokumenttype IS NULL
					OR 
					a.dokumenttype ILIKE attrEgenskaberTypeObj.dokumenttype --case insensitive 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

			);
			

			dokument_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'dokument_candidates_is_initialized step 3:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 3:%',dokument_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		dokument_candidates:=array( 

			SELECT DISTINCT
			b.dokument_id 
			FROM  dokument_registrering b 
			LEFT JOIN dokument_attr_egenskaber a on a.dokument_registrering_id=b.id and (virkningSoeg IS NULL or virkningSoeg && (a.virkning).TimePeriod )
			LEFT JOIN dokument_variant c on c.dokument_registrering_id=b.id 
			LEFT JOIN dokument_del f on f.variant_id=c.id
			LEFT JOIN dokument_del_egenskaber d on d.del_id = f.id and (virkningSoeg IS NULL or virkningSoeg && (d.virkning).TimePeriod )
			LEFT JOIN dokument_variant_egenskaber e on e.variant_id = c.id and (virkningSoeg IS NULL or virkningSoeg && (e.virkning).TimePeriod )
			WHERE
			(
				(
					a.brugervendtnoegle ILIKE anyAttrValue OR
						a.beskrivelse ILIKE anyAttrValue OR
									a.brevdato::text ilike anyAttrValue OR
						a.kassationskode ILIKE anyAttrValue OR
									a.major::text ilike anyAttrValue OR
									a.minor::text ilike anyAttrValue OR
									(a.offentlighedundtaget).Hjemmel ilike anyAttrValue OR (a.offentlighedundtaget).AlternativTitel ilike anyAttrValue OR
						a.titel ILIKE anyAttrValue OR
						a.dokumenttype ILIKE anyAttrValue
				)
				OR
				(
					( c.varianttekst ilike anyAttrValue and e.id is not null) --varianttekst handled like it is logically part of variant egenskaber
				)
				OR
				(
					( f.deltekst ilike anyAttrValue and d.id is not null ) --deltekst handled like it is logically part of del egenskaber
					OR
					d.indeks::text = anyAttrValue
					OR
					d.indhold ILIKE anyAttrValue
					OR
					d.lokation ILIKE anyAttrValue
					OR
					d.mimetype ILIKE anyAttrValue
				)
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )


		);

	dokument_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Fremdrift
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsFremdrift IS NULL THEN
	--RAISE DEBUG 'as_search_dokument: skipping filtration on tilsFremdrift';
ELSE
	IF (coalesce(array_length(dokument_candidates,1),0)>0 OR dokument_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsFremdriftTypeObj IN ARRAY registreringObj.tilsFremdrift
		LOOP
			dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
			FROM  dokument_tils_fremdrift a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id
			WHERE
				(
					tilsFremdriftTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsFremdriftTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsFremdriftTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsFremdriftTypeObj.virkning).AktoerRef IS NULL OR (tilsFremdriftTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsFremdriftTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsFremdriftTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsFremdriftTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsFremdriftTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsFremdriftTypeObj.virkning) IS NULL OR (tilsFremdriftTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsFremdriftTypeObj.fremdrift IS NULL
					OR
					tilsFremdriftTypeObj.fremdrift = a.fremdrift
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

	);
			

			dokument_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer DokumentRelationType[]
*/


--RAISE DEBUG 'dokument_candidates_is_initialized step 4:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 4:%',dokument_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_dokument: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(dokument_candidates,1),0)>0 OR NOT dokument_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
			FROM  dokument_relation a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

	);
			
			dokument_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
 			FROM dokument_registrering b  
 			LEFT JOIN dokument_relation a on a.dokument_registrering_id=b.id and (virkningSoeg IS NULL or (virkningSoeg && (a.virkning).TimePeriod) )
 			LEFT JOIN dokument_variant c on c.dokument_registrering_id=b.id
 			LEFT JOIN dokument_del d on d.variant_id=c.id 
 			LEFT JOIN dokument_del_relation e on d.id=e.del_id and (virkningSoeg IS NULL or (virkningSoeg && (e.virkning).TimePeriod) )
  			WHERE
 			(anyuuid = a.rel_maal_uuid OR anyuuid = e.rel_maal_uuid)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )


			);

	dokument_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
 			FROM dokument_registrering b  
 			LEFT JOIN dokument_relation a on a.dokument_registrering_id=b.id and (virkningSoeg IS NULL or virkningSoeg && (a.virkning).TimePeriod )
 			LEFT JOIN dokument_variant c on c.dokument_registrering_id=b.id
 			LEFT JOIN dokument_del d on d.variant_id=c.id
 			LEFT JOIN dokument_del_relation e on d.id=e.del_id and (virkningSoeg IS NULL or virkningSoeg && (e.virkning).TimePeriod)
  			WHERE
 			(anyurn = a.rel_maal_urn OR anyurn = e.rel_maal_urn)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )


			);

	dokument_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

--/**********************************************************//
--Filtration on variants and document parts (dele)
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).varianter IS NULL THEN
	--RAISE DEBUG 'as_search_dokument: skipping filtration on relationer';
ELSE
		IF (registreringObj).varianter IS NOT NULL AND coalesce(array_length(registreringObj.varianter,1),0)>0  THEN
		FOREACH variantTypeObj IN ARRAY registreringObj.varianter
		LOOP

		variant_candidates_ids=array[]::bigint[];
		variant_candidates_is_initialized:=false;

		IF (coalesce(array_length(dokument_candidates,1),0)>0 OR NOT dokument_candidates_is_initialized) THEN 

		--HACK: As variant_name logically can be said to be part of variant egenskaber (regarding virkning), we'll force a filter on variant egenskaber if needed
		IF coalesce(array_length(variantTypeObj.egenskaber,1),0)=0 AND variantTypeObj.varianttekst IS NOT NULL THEN
			variantTypeObj.egenskaber:=ARRAY[ROW(null,null,null,null,null)::DokumentVariantEgenskaberType]::DokumentVariantEgenskaberType[];
		END IF;

		IF coalesce(array_length(variantTypeObj.egenskaber,1),0)>0 THEN
		
		FOREACH variantEgenskaberTypeObj in ARRAY variantTypeObj.egenskaber
		LOOP

		IF (coalesce(array_length(variant_candidates_ids,1),0)>0 OR not variant_candidates_is_initialized) THEN

			IF  variantTypeObj.varianttekst IS NOT NULL OR
				(
					(NOT (variantEgenskaberTypeObj.arkivering IS NULL))
					OR
					(NOT (variantEgenskaberTypeObj.delvisscannet IS NULL))
					OR
					(NOT (variantEgenskaberTypeObj.offentliggoerelse IS NULL))
					OR
					(NOT (variantEgenskaberTypeObj.produktion IS NULL))
				)
			 THEN --test if there is any data availiable for variant to filter on
			

			--part for searching on variant + egenskaber
			variant_candidates_ids:=array(
			SELECT DISTINCT
			a.id
			FROM  dokument_variant a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id
			JOIN dokument_variant_egenskaber c on c.variant_id=a.id  --we require the presence egenskaber (variant name is logically part of it)
			WHERE
			(
				variantTypeObj.varianttekst IS NULL
				OR
				a.varianttekst ilike variantTypeObj.varianttekst
			)
			AND
			(
				(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (c.virkning).TimePeriod
				)
			)
			AND
			(
				(
				variantEgenskaberTypeObj.virkning IS NULL
				OR 
				(variantEgenskaberTypeObj.virkning).TimePeriod && (c.virkning).TimePeriod 
				)
			)
			AND
				(
				variantEgenskaberTypeObj.virkning IS NULL
				OR
					(
						(
								(variantEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (c.virkning).AktoerRef = (variantEgenskaberTypeObj.virkning).AktoerRef
						)
						AND
						(
								(variantEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (variantEgenskaberTypeObj.virkning).AktoerTypeKode=(c.virkning).AktoerTypeKode
						)
						AND
						(
								(variantEgenskaberTypeObj.virkning).NoteTekst IS NULL OR (c.virkning).NoteTekst ilike (variantEgenskaberTypeObj.virkning).NoteTekst
						)
					)
				)
			AND
			(
				
				(
					variantEgenskaberTypeObj.arkivering IS NULL
					OR
					variantEgenskaberTypeObj.arkivering = c.arkivering
				)
				AND
				(
					variantEgenskaberTypeObj.delvisscannet IS NULL
					OR
					variantEgenskaberTypeObj.delvisscannet = c.delvisscannet
				)
				AND
				(
					variantEgenskaberTypeObj.offentliggoerelse IS NULL 
					OR
					variantEgenskaberTypeObj.offentliggoerelse = c.offentliggoerelse
				)
				AND
				(
					variantEgenskaberTypeObj.produktion IS NULL  
					OR
					variantEgenskaberTypeObj.produktion = c.produktion
				)
				
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

			AND ( (NOT variant_candidates_is_initialized) OR a.id = ANY (variant_candidates_ids) )
			);

			variant_candidates_is_initialized:=true;

			END IF; --any variant candidates left

			END IF; --variant filter criterium exists
			END LOOP; --variant egenskaber

			
			END IF;--variantTypeObj.egenskaber exists  

			/**************    Dokument Dele        ******************/

			IF coalesce(array_length(variantTypeObj.dele,1),0)>0 THEN
			
			FOREACH delTypeObj IN ARRAY variantTypeObj.dele 
			LOOP

			--HACK: As del_name logically can be said to be part of del egenskaber (regarding virkning), we'll force a filter on del egenskaber if needed
			IF coalesce(array_length(delTypeObj.egenskaber,1),0)=0 AND delTypeObj.deltekst IS NOT NULL THEN
				delTypeObj.egenskaber:=ARRAY[ROW(null,null,null,null,null)::DokumentDelEgenskaberType]::DokumentDelEgenskaberType[];
			END IF;


			/**************    Dokument Del Egenskaber    ******************/

			IF coalesce(array_length(delTypeObj.egenskaber,1),0)>0 THEN 
			
			FOREACH delEgenskaberTypeObj IN ARRAY delTypeObj.egenskaber
			LOOP
			
			IF delTypeObj.deltekst IS NOT NULL  	
			OR (NOT delEgenskaberTypeObj.indeks IS NULL)
			OR delEgenskaberTypeObj.indhold IS NOT NULL
			OR delEgenskaberTypeObj.lokation IS NOT NULL
			OR delEgenskaberTypeObj.mimetype IS NOT NULL
			THEN 

			IF (coalesce(array_length(variant_candidates_ids,1),0)>0 OR not variant_candidates_is_initialized) THEN

			variant_candidates_ids:=array(
			SELECT DISTINCT
			a.id
			FROM  dokument_variant a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id
			JOIN dokument_del c on c.variant_id=a.id
			JOIN dokument_del_egenskaber d on d.del_id=c.id --we require the presence egenskaber (del name is logically part of it)
		
			WHERE
			(
				delTypeObj.deltekst IS NULL
				OR
				c.deltekst ilike delTypeObj.deltekst
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (d.virkning).TimePeriod
			)
			AND
			(
				delEgenskaberTypeObj.virkning IS NULL --NOTICE only looking at first del egenskaber object throughout
				OR 
				(delEgenskaberTypeObj.virkning).TimePeriod && (d.virkning).TimePeriod 
			)
			AND
			(
				delEgenskaberTypeObj.virkning IS NULL
				OR
					(
						(
								(delEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (d.virkning).AktoerRef = (delEgenskaberTypeObj.virkning).AktoerRef
						)
						AND
						(
								(delEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (delEgenskaberTypeObj.virkning).AktoerTypeKode=(d.virkning).AktoerTypeKode
						)
						AND
						(
								(delEgenskaberTypeObj.virkning).NoteTekst IS NULL OR (d.virkning).NoteTekst ilike (delEgenskaberTypeObj.virkning).NoteTekst
						)
					)
			)
			AND
			(
				(
					(
						delEgenskaberTypeObj.indeks IS NULL  
						OR
						delEgenskaberTypeObj.indeks = d.indeks
					)
					AND
					(
						delEgenskaberTypeObj.indhold IS NULL  
						OR
						d.indhold ilike delEgenskaberTypeObj.indhold  
					)
					AND
					(
						delEgenskaberTypeObj.lokation IS NULL 
						OR
						d.lokation ilike delEgenskaberTypeObj.lokation 
					)
					AND
					(
						delEgenskaberTypeObj.mimetype IS NULL 
						OR
						d.mimetype ilike delEgenskaberTypeObj.mimetype
					)
				)
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

			AND ( (NOT variant_candidates_is_initialized) OR a.id = ANY (variant_candidates_ids) )
			);

			variant_candidates_is_initialized:=true;
			END IF; --any variant candidates left
			END IF; --del egenskaber not empty
			END LOOP; --loop del egenskaber
			END IF; -- del egenskaber exists

			/**************    Dokument Del Relationer    ******************/

			IF coalesce(array_length(delTypeObj.relationer,1),0)>0 THEN 
			
			FOREACH delRelationTypeObj IN ARRAY delTypeObj.relationer
			LOOP

			IF (coalesce(array_length(variant_candidates_ids,1),0)>0 OR not variant_candidates_is_initialized) THEN

			variant_candidates_ids:=array(
			SELECT DISTINCT
			a.id
			FROM  dokument_variant a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id
			JOIN dokument_del c on c.variant_id=a.id
			JOIN dokument_del_relation d on d.del_id=c.id
			WHERE
			(
				delTypeObj.deltekst IS NULL
				OR
				c.deltekst ilike delTypeObj.deltekst
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (d.virkning).TimePeriod
			)
			AND
			(
				delRelationTypeObj.virkning IS NULL 
				OR 
				(delRelationTypeObj.virkning).TimePeriod && (d.virkning).TimePeriod 
			)
			AND
			(
				delRelationTypeObj.virkning IS NULL
				OR
					(
						(
								(delRelationTypeObj.virkning).AktoerRef IS NULL OR (d.virkning).AktoerRef = (delRelationTypeObj.virkning).AktoerRef
						)
						AND
						(
								(delRelationTypeObj.virkning).AktoerTypeKode IS NULL OR (delRelationTypeObj.virkning).AktoerTypeKode=(d.virkning).AktoerTypeKode
						)
						AND
						(
								(delRelationTypeObj.virkning).NoteTekst IS NULL OR (d.virkning).NoteTekst ilike (delRelationTypeObj.virkning).NoteTekst
						)
					)
			)
			AND
			(	
				delRelationTypeObj.relType IS NULL
				OR
				delRelationTypeObj.relType = d.rel_type
			)
			AND
			(
				delRelationTypeObj.uuid IS NULL
				OR
				delRelationTypeObj.uuid = d.rel_maal_uuid	
			)
			AND
			(
				delRelationTypeObj.objektType IS NULL
				OR
				delRelationTypeObj.objektType = d.objekt_type
			)
			AND
			(
				delRelationTypeObj.urn IS NULL
				OR
				delRelationTypeObj.urn = d.rel_maal_urn
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

			AND ( (NOT variant_candidates_is_initialized) OR a.id = ANY (variant_candidates_ids) )
			);
			
			variant_candidates_is_initialized:=true;

			END IF; --any variant candidates left

			END LOOP; --loop del relationer
			END IF; --end if del relationer exists

			END LOOP; --loop del
			END IF;--dele exists


			
			IF variant_candidates_is_initialized THEN
			--We'll then translate the collected variant ids into document ids (please notice that the resulting uuids are already a subset of dokument_candidates)

			dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
			FROM  dokument_variant a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id
			WHERE
			a.id = ANY (variant_candidates_ids)
			AND
			( (NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )
			);

			dokument_candidates_is_initialized:=true;
			
			END IF; --variant_candidates_is_initialized

			END IF; --no doc candidates - skipping ahead;
			END LOOP; --FOREACH variantTypeObj
		
		END IF; --varianter exists
	END IF; --array registreringObj.varianter exists 



--RAISE DEBUG 'dokument_candidates_is_initialized step 5:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 5:%',dokument_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT dokument_candidates_is_initialized THEN 
		dokument_candidates:=array(
		SELECT DISTINCT
			dokument_id
		FROM
			dokument_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

		)
		;

		dokument_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT dokument_candidates_is_initialized THEN
	--No filters applied!
	dokument_candidates:=array(
		SELECT DISTINCT id FROM dokument a LIMIT maxResults
	);
ELSE
	dokument_candidates:=array(
		SELECT DISTINCT id FROM unnest(dokument_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'dokument_candidates_is_initialized step 6:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 6:%',dokument_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_dokument(dokument_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_dokument(firstresult integer, dokument_uuid uuid, registreringobj dokumentregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr dokumentregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_facet(integer, uuid, facetregistreringtype, tstzrange, integer, text[], uuid[], text[], facetregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_facet(firstresult integer, facet_uuid uuid, registreringobj facetregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr facetregistreringtype[] DEFAULT NULL::facetregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	facet_candidates uuid[];
	facet_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj FacetEgenskaberAttrType;
	
  	tilsPubliceretTypeObj FacetPubliceretTilsType;
	relationTypeObj FacetRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

facet_candidates_is_initialized := false;

IF facet_uuid is not NULL THEN
	facet_candidates:= ARRAY[facet_uuid];
	facet_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		facet_candidates:=array(
				SELECT DISTINCT
				b.facet_id 
				FROM
				facet a
				JOIN facet_registrering b on b.facet_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'facet_candidates_is_initialized step 1:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 1:%',facet_candidates;
--/****************************//


--RAISE NOTICE 'facet_candidates_is_initialized step 2:%',facet_candidates_is_initialized;
--RAISE NOTICE 'facet_candidates step 2:%',facet_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_facet: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(facet_candidates,1),0)>0 OR NOT facet_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			facet_candidates:=array(
			SELECT DISTINCT
			b.facet_id 
			FROM  facet_attr_egenskaber a
			JOIN facet_registrering b on a.facet_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.opbygning IS NULL
					OR 
					a.opbygning ILIKE attrEgenskaberTypeObj.opbygning --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.ophavsret IS NULL
					OR 
					a.ophavsret ILIKE attrEgenskaberTypeObj.ophavsret --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.plan IS NULL
					OR 
					a.plan ILIKE attrEgenskaberTypeObj.plan --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.supplement IS NULL
					OR 
					a.supplement ILIKE attrEgenskaberTypeObj.supplement --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.retskilde IS NULL
					OR 
					a.retskilde ILIKE attrEgenskaberTypeObj.retskilde --case insensitive 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )

			);
			

			facet_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'facet_candidates_is_initialized step 3:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 3:%',facet_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		facet_candidates:=array( 

			SELECT DISTINCT
			b.facet_id 
			FROM  facet_attr_egenskaber a
			JOIN facet_registrering b on a.facet_registrering_id=b.id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
						a.beskrivelse ILIKE anyAttrValue OR
						a.opbygning ILIKE anyAttrValue OR
						a.ophavsret ILIKE anyAttrValue OR
						a.plan ILIKE anyAttrValue OR
						a.supplement ILIKE anyAttrValue OR
						a.retskilde ILIKE anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )


		);

	facet_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_facet: skipping filtration on tilsPubliceret';
ELSE
	IF (coalesce(array_length(facet_candidates,1),0)>0 OR facet_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			facet_candidates:=array(
			SELECT DISTINCT
			b.facet_id 
			FROM  facet_tils_publiceret a
			JOIN facet_registrering b on a.facet_registrering_id=b.id
			WHERE
				(
					tilsPubliceretTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsPubliceretTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsPubliceretTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).AktoerRef IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsPubliceretTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsPubliceretTypeObj.virkning) IS NULL OR (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )

	);
			

			facet_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer FacetRelationType[]
*/


--RAISE DEBUG 'facet_candidates_is_initialized step 4:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 4:%',facet_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_facet: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(facet_candidates,1),0)>0 OR NOT facet_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			facet_candidates:=array(
			SELECT DISTINCT
			b.facet_id 
			FROM  facet_relation a
			JOIN facet_registrering b on a.facet_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )

	);
			
			facet_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		facet_candidates:=array(
			SELECT DISTINCT
			b.facet_id 
			FROM  facet_relation a
			JOIN facet_registrering b on a.facet_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )


			);

	facet_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		facet_candidates:=array(
			SELECT DISTINCT
			b.facet_id 
			FROM  facet_relation a
			JOIN facet_registrering b on a.facet_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )


			);

	facet_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 



--RAISE DEBUG 'facet_candidates_is_initialized step 5:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 5:%',facet_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT facet_candidates_is_initialized THEN 
		facet_candidates:=array(
		SELECT DISTINCT
			facet_id
		FROM
			facet_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )

		)
		;

		facet_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT facet_candidates_is_initialized THEN
	--No filters applied!
	facet_candidates:=array(
		SELECT DISTINCT id FROM facet a LIMIT maxResults
	);
ELSE
	facet_candidates:=array(
		SELECT DISTINCT id FROM unnest(facet_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'facet_candidates_is_initialized step 6:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 6:%',facet_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_facet(facet_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_facet(firstresult integer, facet_uuid uuid, registreringobj facetregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr facetregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_indsats(integer, uuid, indsatsregistreringtype, tstzrange, integer, text[], uuid[], text[], indsatsregistreringtype[], indsatsegenskaberattrtype[], indsatsegenskaberattrtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_indsats(firstresult integer, indsats_uuid uuid, registreringobj indsatsregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr indsatsregistreringtype[] DEFAULT NULL::indsatsregistreringtype[], search_operator_greater_than_or_equal_attr_egenskaber indsatsegenskaberattrtype[] DEFAULT NULL::indsatsegenskaberattrtype[], search_operator_less_than_or_equal_attr_egenskaber indsatsegenskaberattrtype[] DEFAULT NULL::indsatsegenskaberattrtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	indsats_candidates uuid[];
	indsats_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj IndsatsEgenskaberAttrType;
	
  	tilsPubliceretTypeObj IndsatsPubliceretTilsType;
  	tilsFremdriftTypeObj IndsatsFremdriftTilsType;
	relationTypeObj IndsatsRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

indsats_candidates_is_initialized := false;

IF indsats_uuid is not NULL THEN
	indsats_candidates:= ARRAY[indsats_uuid];
	indsats_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		indsats_candidates:=array(
				SELECT DISTINCT
				b.indsats_id 
				FROM
				indsats a
				JOIN indsats_registrering b on b.indsats_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'indsats_candidates_is_initialized step 1:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 1:%',indsats_candidates;
--/****************************//


--RAISE NOTICE 'indsats_candidates_is_initialized step 2:%',indsats_candidates_is_initialized;
--RAISE NOTICE 'indsats_candidates step 2:%',indsats_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_indsats: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(indsats_candidates,1),0)>0 OR NOT indsats_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_attr_egenskaber a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.starttidspunkt IS NULL
					OR 
					a.starttidspunkt = attrEgenskaberTypeObj.starttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.sluttidspunkt IS NULL
					OR 
					a.sluttidspunkt = attrEgenskaberTypeObj.sluttidspunkt 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

			);
			

			indsats_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'indsats_candidates_is_initialized step 3:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 3:%',indsats_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		indsats_candidates:=array( 

			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_attr_egenskaber a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
						a.beskrivelse ILIKE anyAttrValue OR
									a.starttidspunkt::text ilike anyAttrValue OR
									a.sluttidspunkt::text ilike anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )


		);

	indsats_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_indsats: skipping filtration on tilsPubliceret';
ELSE
	IF (coalesce(array_length(indsats_candidates,1),0)>0 OR indsats_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_tils_publiceret a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id
			WHERE
				(
					tilsPubliceretTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsPubliceretTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsPubliceretTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).AktoerRef IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsPubliceretTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsPubliceretTypeObj.virkning) IS NULL OR (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

	);
			

			indsats_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************************************************//
--Filtration on state: Fremdrift
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsFremdrift IS NULL THEN
	--RAISE DEBUG 'as_search_indsats: skipping filtration on tilsFremdrift';
ELSE
	IF (coalesce(array_length(indsats_candidates,1),0)>0 OR indsats_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsFremdriftTypeObj IN ARRAY registreringObj.tilsFremdrift
		LOOP
			indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_tils_fremdrift a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id
			WHERE
				(
					tilsFremdriftTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsFremdriftTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsFremdriftTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsFremdriftTypeObj.virkning).AktoerRef IS NULL OR (tilsFremdriftTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsFremdriftTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsFremdriftTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsFremdriftTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsFremdriftTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsFremdriftTypeObj.virkning) IS NULL OR (tilsFremdriftTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsFremdriftTypeObj.fremdrift IS NULL
					OR
					tilsFremdriftTypeObj.fremdrift = a.fremdrift
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

	);
			

			indsats_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer IndsatsRelationType[]
*/


--RAISE DEBUG 'indsats_candidates_is_initialized step 4:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 4:%',indsats_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_indsats: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(indsats_candidates,1),0)>0 OR NOT indsats_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_relation a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
				(
 					relationTypeObj.indeks IS NULL
 					OR
 					relationTypeObj.indeks = a.rel_index
 				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

	);
			
			indsats_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_relation a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )


			);

	indsats_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_relation a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )


			);

	indsats_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 --/**********************************************************//
--Filtration using operator 'greather than or equal': Egenskaber
--/**********************************************************//
IF coalesce(array_length(search_operator_greater_than_or_equal_attr_egenskaber,1),0)>0 THEN
	IF (coalesce(array_length(indsats_candidates,1),0)>0 OR NOT indsats_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY search_operator_greater_than_or_equal_attr_egenskaber
		LOOP

indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_attr_egenskaber a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle >= attrEgenskaberTypeObj.brugervendtnoegle  
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse >= attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.starttidspunkt IS NULL
					OR 
					a.starttidspunkt >= attrEgenskaberTypeObj.starttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.sluttidspunkt IS NULL
					OR 
					a.sluttidspunkt >= attrEgenskaberTypeObj.sluttidspunkt 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

			);
			

			indsats_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

 

--/**********************//

 --/**********************************************************//
--Filtration using operator 'less than or equal': Egenskaber
--/**********************************************************//
IF coalesce(array_length(search_operator_less_than_or_equal_attr_egenskaber,1),0)>0 THEN
	IF (coalesce(array_length(indsats_candidates,1),0)>0 OR NOT indsats_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY search_operator_less_than_or_equal_attr_egenskaber
		LOOP

indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_attr_egenskaber a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle <= attrEgenskaberTypeObj.brugervendtnoegle  
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse <= attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.starttidspunkt IS NULL
					OR 
					a.starttidspunkt <= attrEgenskaberTypeObj.starttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.sluttidspunkt IS NULL
					OR 
					a.sluttidspunkt <= attrEgenskaberTypeObj.sluttidspunkt 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

			);
			

			indsats_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

 

--/**********************//


--RAISE DEBUG 'indsats_candidates_is_initialized step 5:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 5:%',indsats_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT indsats_candidates_is_initialized THEN 
		indsats_candidates:=array(
		SELECT DISTINCT
			indsats_id
		FROM
			indsats_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

		)
		;

		indsats_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT indsats_candidates_is_initialized THEN
	--No filters applied!
	indsats_candidates:=array(
		SELECT DISTINCT id FROM indsats a LIMIT maxResults
	);
ELSE
	indsats_candidates:=array(
		SELECT DISTINCT id FROM unnest(indsats_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'indsats_candidates_is_initialized step 6:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 6:%',indsats_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_indsats(indsats_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_indsats(firstresult integer, indsats_uuid uuid, registreringobj indsatsregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr indsatsregistreringtype[], search_operator_greater_than_or_equal_attr_egenskaber indsatsegenskaberattrtype[], search_operator_less_than_or_equal_attr_egenskaber indsatsegenskaberattrtype[]) OWNER TO mox;

--
-- Name: as_search_interessefaellesskab(integer, uuid, interessefaellesskabregistreringtype, tstzrange, integer, text[], uuid[], text[], interessefaellesskabregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_interessefaellesskab(firstresult integer, interessefaellesskab_uuid uuid, registreringobj interessefaellesskabregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr interessefaellesskabregistreringtype[] DEFAULT NULL::interessefaellesskabregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	interessefaellesskab_candidates uuid[];
	interessefaellesskab_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj InteressefaellesskabEgenskaberAttrType;
	
  	tilsGyldighedTypeObj InteressefaellesskabGyldighedTilsType;
	relationTypeObj InteressefaellesskabRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

interessefaellesskab_candidates_is_initialized := false;

IF interessefaellesskab_uuid is not NULL THEN
	interessefaellesskab_candidates:= ARRAY[interessefaellesskab_uuid];
	interessefaellesskab_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		interessefaellesskab_candidates:=array(
				SELECT DISTINCT
				b.interessefaellesskab_id 
				FROM
				interessefaellesskab a
				JOIN interessefaellesskab_registrering b on b.interessefaellesskab_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 1:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 1:%',interessefaellesskab_candidates;
--/****************************//


--RAISE NOTICE 'interessefaellesskab_candidates_is_initialized step 2:%',interessefaellesskab_candidates_is_initialized;
--RAISE NOTICE 'interessefaellesskab_candidates step 2:%',interessefaellesskab_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_interessefaellesskab: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(interessefaellesskab_candidates,1),0)>0 OR NOT interessefaellesskab_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			interessefaellesskab_candidates:=array(
			SELECT DISTINCT
			b.interessefaellesskab_id 
			FROM  interessefaellesskab_attr_egenskaber a
			JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.interessefaellesskabsnavn IS NULL
					OR 
					a.interessefaellesskabsnavn ILIKE attrEgenskaberTypeObj.interessefaellesskabsnavn --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.interessefaellesskabstype IS NULL
					OR 
					a.interessefaellesskabstype ILIKE attrEgenskaberTypeObj.interessefaellesskabstype --case insensitive 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )

			);
			

			interessefaellesskab_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 3:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 3:%',interessefaellesskab_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		interessefaellesskab_candidates:=array( 

			SELECT DISTINCT
			b.interessefaellesskab_id 
			FROM  interessefaellesskab_attr_egenskaber a
			JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
						a.interessefaellesskabsnavn ILIKE anyAttrValue OR
						a.interessefaellesskabstype ILIKE anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )


		);

	interessefaellesskab_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_interessefaellesskab: skipping filtration on tilsGyldighed';
ELSE
	IF (coalesce(array_length(interessefaellesskab_candidates,1),0)>0 OR interessefaellesskab_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			interessefaellesskab_candidates:=array(
			SELECT DISTINCT
			b.interessefaellesskab_id 
			FROM  interessefaellesskab_tils_gyldighed a
			JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id
			WHERE
				(
					tilsGyldighedTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsGyldighedTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )

	);
			

			interessefaellesskab_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer InteressefaellesskabRelationType[]
*/


--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 4:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 4:%',interessefaellesskab_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_interessefaellesskab: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(interessefaellesskab_candidates,1),0)>0 OR NOT interessefaellesskab_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			interessefaellesskab_candidates:=array(
			SELECT DISTINCT
			b.interessefaellesskab_id 
			FROM  interessefaellesskab_relation a
			JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )

	);
			
			interessefaellesskab_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		interessefaellesskab_candidates:=array(
			SELECT DISTINCT
			b.interessefaellesskab_id 
			FROM  interessefaellesskab_relation a
			JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )


			);

	interessefaellesskab_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		interessefaellesskab_candidates:=array(
			SELECT DISTINCT
			b.interessefaellesskab_id 
			FROM  interessefaellesskab_relation a
			JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )


			);

	interessefaellesskab_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 



--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 5:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 5:%',interessefaellesskab_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT interessefaellesskab_candidates_is_initialized THEN 
		interessefaellesskab_candidates:=array(
		SELECT DISTINCT
			interessefaellesskab_id
		FROM
			interessefaellesskab_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )

		)
		;

		interessefaellesskab_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT interessefaellesskab_candidates_is_initialized THEN
	--No filters applied!
	interessefaellesskab_candidates:=array(
		SELECT DISTINCT id FROM interessefaellesskab a LIMIT maxResults
	);
ELSE
	interessefaellesskab_candidates:=array(
		SELECT DISTINCT id FROM unnest(interessefaellesskab_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 6:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 6:%',interessefaellesskab_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_interessefaellesskab(interessefaellesskab_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_interessefaellesskab(firstresult integer, interessefaellesskab_uuid uuid, registreringobj interessefaellesskabregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr interessefaellesskabregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_itsystem(integer, uuid, itsystemregistreringtype, tstzrange, integer, text[], uuid[], text[], itsystemregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_itsystem(firstresult integer, itsystem_uuid uuid, registreringobj itsystemregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr itsystemregistreringtype[] DEFAULT NULL::itsystemregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	itsystem_candidates uuid[];
	itsystem_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj ItsystemEgenskaberAttrType;
	
  	tilsGyldighedTypeObj ItsystemGyldighedTilsType;
	relationTypeObj ItsystemRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

itsystem_candidates_is_initialized := false;

IF itsystem_uuid is not NULL THEN
	itsystem_candidates:= ARRAY[itsystem_uuid];
	itsystem_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		itsystem_candidates:=array(
				SELECT DISTINCT
				b.itsystem_id 
				FROM
				itsystem a
				JOIN itsystem_registrering b on b.itsystem_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'itsystem_candidates_is_initialized step 1:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 1:%',itsystem_candidates;
--/****************************//


--RAISE NOTICE 'itsystem_candidates_is_initialized step 2:%',itsystem_candidates_is_initialized;
--RAISE NOTICE 'itsystem_candidates step 2:%',itsystem_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_itsystem: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(itsystem_candidates,1),0)>0 OR NOT itsystem_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			itsystem_candidates:=array(
			SELECT DISTINCT
			b.itsystem_id 
			FROM  itsystem_attr_egenskaber a
			JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.itsystemnavn IS NULL
					OR 
					a.itsystemnavn ILIKE attrEgenskaberTypeObj.itsystemnavn --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.itsystemtype IS NULL
					OR 
					a.itsystemtype ILIKE attrEgenskaberTypeObj.itsystemtype --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.konfigurationreference IS NULL
					OR
					_as_search_match_array(attrEgenskaberTypeObj.konfigurationreference,a.konfigurationreference) 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )

			);
			

			itsystem_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'itsystem_candidates_is_initialized step 3:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 3:%',itsystem_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		itsystem_candidates:=array( 

			SELECT DISTINCT
			b.itsystem_id 
			FROM  itsystem_attr_egenskaber a
			JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
						a.itsystemnavn ILIKE anyAttrValue OR
						a.itsystemtype ILIKE anyAttrValue OR
							  _as_search_ilike_array(anyAttrValue,a.konfigurationreference)
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )


		);

	itsystem_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_itsystem: skipping filtration on tilsGyldighed';
ELSE
	IF (coalesce(array_length(itsystem_candidates,1),0)>0 OR itsystem_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			itsystem_candidates:=array(
			SELECT DISTINCT
			b.itsystem_id 
			FROM  itsystem_tils_gyldighed a
			JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id
			WHERE
				(
					tilsGyldighedTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsGyldighedTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )

	);
			

			itsystem_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer ItsystemRelationType[]
*/


--RAISE DEBUG 'itsystem_candidates_is_initialized step 4:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 4:%',itsystem_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_itsystem: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(itsystem_candidates,1),0)>0 OR NOT itsystem_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			itsystem_candidates:=array(
			SELECT DISTINCT
			b.itsystem_id 
			FROM  itsystem_relation a
			JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )

	);
			
			itsystem_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		itsystem_candidates:=array(
			SELECT DISTINCT
			b.itsystem_id 
			FROM  itsystem_relation a
			JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )


			);

	itsystem_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		itsystem_candidates:=array(
			SELECT DISTINCT
			b.itsystem_id 
			FROM  itsystem_relation a
			JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )


			);

	itsystem_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 



--RAISE DEBUG 'itsystem_candidates_is_initialized step 5:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 5:%',itsystem_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT itsystem_candidates_is_initialized THEN 
		itsystem_candidates:=array(
		SELECT DISTINCT
			itsystem_id
		FROM
			itsystem_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )

		)
		;

		itsystem_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT itsystem_candidates_is_initialized THEN
	--No filters applied!
	itsystem_candidates:=array(
		SELECT DISTINCT id FROM itsystem a LIMIT maxResults
	);
ELSE
	itsystem_candidates:=array(
		SELECT DISTINCT id FROM unnest(itsystem_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'itsystem_candidates_is_initialized step 6:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 6:%',itsystem_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_itsystem(itsystem_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_itsystem(firstresult integer, itsystem_uuid uuid, registreringobj itsystemregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr itsystemregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_klasse(integer, uuid, klasseregistreringtype, tstzrange, integer, text[], uuid[], text[], klasseregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_klasse(firstresult integer, klasse_uuid uuid, registreringobj klasseregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr klasseregistreringtype[] DEFAULT NULL::klasseregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	klasse_candidates uuid[];
	klasse_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj KlasseEgenskaberAttrType;
	
  	tilsPubliceretTypeObj KlassePubliceretTilsType;
	relationTypeObj KlasseRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
	manipulatedAttrEgenskaberArr KlasseEgenskaberAttrType[]:='{}';
	soegeordObj KlasseSoegeordType;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

klasse_candidates_is_initialized := false;

IF klasse_uuid is not NULL THEN
	klasse_candidates:= ARRAY[klasse_uuid];
	klasse_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		klasse_candidates:=array(
				SELECT DISTINCT
				b.klasse_id 
				FROM
				klasse a
				JOIN klasse_registrering b on b.klasse_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'klasse_candidates_is_initialized step 1:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 1:%',klasse_candidates;
--/****************************//


--RAISE NOTICE 'klasse_candidates_is_initialized step 2:%',klasse_candidates_is_initialized;
--RAISE NOTICE 'klasse_candidates step 2:%',klasse_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_klasse: skipping filtration on attrEgenskaber';
ELSE

--To help facilitate the comparrison efforts (while diverging at a minimum form the templated db-kode, 
--we'll manipulate the attrEgenskaber array so to make sure that every object only has 1 sogeord element - duplicating the parent elements in attrEgenskaber as needed  )

FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
LOOP
	IF  (attrEgenskaberTypeObj).soegeord IS NULL OR coalesce(array_length((attrEgenskaberTypeObj).soegeord,1),0)<2 THEN
	manipulatedAttrEgenskaberArr:=array_append(manipulatedAttrEgenskaberArr,attrEgenskaberTypeObj); --The element only has 0 or 1 soegeord element, s no manipulations is needed.
	ELSE
		FOREACH soegeordObj IN ARRAY (attrEgenskaberTypeObj).soegeord
		LOOP
			manipulatedAttrEgenskaberArr:=array_append(manipulatedAttrEgenskaberArr,
				ROW (
					attrEgenskaberTypeObj.brugervendtnoegle,
					attrEgenskaberTypeObj.beskrivelse,
					attrEgenskaberTypeObj.eksempel,
					attrEgenskaberTypeObj.omfang,
					attrEgenskaberTypeObj.titel,
					attrEgenskaberTypeObj.retskilde,
					attrEgenskaberTypeObj.aendringsnotat,
					ARRAY[soegeordObj]::KlasseSoegeordType[], --NOTICE: Only 1 element in array
					attrEgenskaberTypeObj.virkning
					)::KlasseEgenskaberAttrType
				);
		END LOOP;
	END IF;
END LOOP;


	IF (coalesce(array_length(klasse_candidates,1),0)>0 OR NOT klasse_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY manipulatedAttrEgenskaberArr
		LOOP
			klasse_candidates:=array(
			SELECT DISTINCT
			b.klasse_id 
			FROM  klasse_attr_egenskaber a
			JOIN klasse_registrering b on a.klasse_registrering_id=b.id
			LEFT JOIN klasse_attr_egenskaber_soegeord c on a.id=c.klasse_attr_egenskaber_id
			WHERE
				(
					attrEgenskaberTypeObj.virkning IS NULL
					OR
					(
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.eksempel IS NULL
					OR 
					a.eksempel ILIKE attrEgenskaberTypeObj.eksempel --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.omfang IS NULL
					OR 
					a.omfang ILIKE attrEgenskaberTypeObj.omfang --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.titel IS NULL
					OR 
					a.titel ILIKE attrEgenskaberTypeObj.titel --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.retskilde IS NULL
					OR 
					a.retskilde ILIKE attrEgenskaberTypeObj.retskilde --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.aendringsnotat IS NULL
					OR 
					a.aendringsnotat ILIKE attrEgenskaberTypeObj.aendringsnotat --case insensitive 
				)
				AND
				(
					(attrEgenskaberTypeObj.soegeord IS NULL OR array_length(attrEgenskaberTypeObj.soegeord,1)=0)
					OR
					(
						(
							(attrEgenskaberTypeObj.soegeord[1]).soegeordidentifikator IS NULL
							OR
							c.soegeordidentifikator ILIKE (attrEgenskaberTypeObj.soegeord[1]).soegeordidentifikator  
						)
						AND
						(
							(attrEgenskaberTypeObj.soegeord[1]).beskrivelse IS NULL
							OR
							c.beskrivelse ILIKE (attrEgenskaberTypeObj.soegeord[1]).beskrivelse  
						)		
						AND
						(
							(attrEgenskaberTypeObj.soegeord[1]).soegeordskategori IS NULL
							OR
							c.soegeordskategori ILIKE (attrEgenskaberTypeObj.soegeord[1]).soegeordskategori  
						)
					)
				)
				AND
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )

			);
			

			klasse_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'klasse_candidates_is_initialized step 3:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 3:%',klasse_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		klasse_candidates:=array( 

			SELECT DISTINCT
			b.klasse_id 
			FROM  klasse_attr_egenskaber a
			JOIN klasse_registrering b on a.klasse_registrering_id=b.id
			LEFT JOIN klasse_attr_egenskaber_soegeord c on a.id=c.klasse_attr_egenskaber_id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
						a.beskrivelse ILIKE anyAttrValue OR
						a.eksempel ILIKE anyAttrValue OR
						a.omfang ILIKE anyAttrValue OR
						a.titel ILIKE anyAttrValue OR
						a.retskilde ILIKE anyAttrValue OR
						a.aendringsnotat ILIKE anyAttrValue
				OR 
				c.soegeordidentifikator ILIKE anyAttrValue
				OR 
				c.beskrivelse ILIKE anyAttrValue
				OR
				c.soegeordskategori ILIKE anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )


		);

	klasse_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_klasse: skipping filtration on tilsPubliceret';
ELSE
	IF (coalesce(array_length(klasse_candidates,1),0)>0 OR klasse_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			klasse_candidates:=array(
			SELECT DISTINCT
			b.klasse_id 
			FROM  klasse_tils_publiceret a
			JOIN klasse_registrering b on a.klasse_registrering_id=b.id
			WHERE
				(
					tilsPubliceretTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsPubliceretTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsPubliceretTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).AktoerRef IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsPubliceretTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsPubliceretTypeObj.virkning) IS NULL OR (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )

	);
			

			klasse_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer KlasseRelationType[]
*/


--RAISE DEBUG 'klasse_candidates_is_initialized step 4:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 4:%',klasse_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_klasse: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(klasse_candidates,1),0)>0 OR NOT klasse_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			klasse_candidates:=array(
			SELECT DISTINCT
			b.klasse_id 
			FROM  klasse_relation a
			JOIN klasse_registrering b on a.klasse_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )

	);
			
			klasse_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		klasse_candidates:=array(
			SELECT DISTINCT
			b.klasse_id 
			FROM  klasse_relation a
			JOIN klasse_registrering b on a.klasse_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )


			);

	klasse_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		klasse_candidates:=array(
			SELECT DISTINCT
			b.klasse_id 
			FROM  klasse_relation a
			JOIN klasse_registrering b on a.klasse_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )


			);

	klasse_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 



--RAISE DEBUG 'klasse_candidates_is_initialized step 5:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 5:%',klasse_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT klasse_candidates_is_initialized THEN 
		klasse_candidates:=array(
		SELECT DISTINCT
			klasse_id
		FROM
			klasse_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )

		)
		;

		klasse_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT klasse_candidates_is_initialized THEN
	--No filters applied!
	klasse_candidates:=array(
		SELECT DISTINCT id FROM klasse a LIMIT maxResults
	);
ELSE
	klasse_candidates:=array(
		SELECT DISTINCT id FROM unnest(klasse_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'klasse_candidates_is_initialized step 6:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 6:%',klasse_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_klasse(klasse_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_klasse(firstresult integer, klasse_uuid uuid, registreringobj klasseregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr klasseregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_klassifikation(integer, uuid, klassifikationregistreringtype, tstzrange, integer, text[], uuid[], text[], klassifikationregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_klassifikation(firstresult integer, klassifikation_uuid uuid, registreringobj klassifikationregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr klassifikationregistreringtype[] DEFAULT NULL::klassifikationregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	klassifikation_candidates uuid[];
	klassifikation_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj KlassifikationEgenskaberAttrType;
	
  	tilsPubliceretTypeObj KlassifikationPubliceretTilsType;
	relationTypeObj KlassifikationRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

klassifikation_candidates_is_initialized := false;

IF klassifikation_uuid is not NULL THEN
	klassifikation_candidates:= ARRAY[klassifikation_uuid];
	klassifikation_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		klassifikation_candidates:=array(
				SELECT DISTINCT
				b.klassifikation_id 
				FROM
				klassifikation a
				JOIN klassifikation_registrering b on b.klassifikation_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'klassifikation_candidates_is_initialized step 1:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 1:%',klassifikation_candidates;
--/****************************//


--RAISE NOTICE 'klassifikation_candidates_is_initialized step 2:%',klassifikation_candidates_is_initialized;
--RAISE NOTICE 'klassifikation_candidates step 2:%',klassifikation_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_klassifikation: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(klassifikation_candidates,1),0)>0 OR NOT klassifikation_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			klassifikation_candidates:=array(
			SELECT DISTINCT
			b.klassifikation_id 
			FROM  klassifikation_attr_egenskaber a
			JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.kaldenavn IS NULL
					OR 
					a.kaldenavn ILIKE attrEgenskaberTypeObj.kaldenavn --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.ophavsret IS NULL
					OR 
					a.ophavsret ILIKE attrEgenskaberTypeObj.ophavsret --case insensitive 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )

			);
			

			klassifikation_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'klassifikation_candidates_is_initialized step 3:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 3:%',klassifikation_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		klassifikation_candidates:=array( 

			SELECT DISTINCT
			b.klassifikation_id 
			FROM  klassifikation_attr_egenskaber a
			JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
						a.beskrivelse ILIKE anyAttrValue OR
						a.kaldenavn ILIKE anyAttrValue OR
						a.ophavsret ILIKE anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )


		);

	klassifikation_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_klassifikation: skipping filtration on tilsPubliceret';
ELSE
	IF (coalesce(array_length(klassifikation_candidates,1),0)>0 OR klassifikation_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			klassifikation_candidates:=array(
			SELECT DISTINCT
			b.klassifikation_id 
			FROM  klassifikation_tils_publiceret a
			JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id
			WHERE
				(
					tilsPubliceretTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsPubliceretTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsPubliceretTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).AktoerRef IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsPubliceretTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsPubliceretTypeObj.virkning) IS NULL OR (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )

	);
			

			klassifikation_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer KlassifikationRelationType[]
*/


--RAISE DEBUG 'klassifikation_candidates_is_initialized step 4:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 4:%',klassifikation_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_klassifikation: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(klassifikation_candidates,1),0)>0 OR NOT klassifikation_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			klassifikation_candidates:=array(
			SELECT DISTINCT
			b.klassifikation_id 
			FROM  klassifikation_relation a
			JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )

	);
			
			klassifikation_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		klassifikation_candidates:=array(
			SELECT DISTINCT
			b.klassifikation_id 
			FROM  klassifikation_relation a
			JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )


			);

	klassifikation_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		klassifikation_candidates:=array(
			SELECT DISTINCT
			b.klassifikation_id 
			FROM  klassifikation_relation a
			JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )


			);

	klassifikation_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 



--RAISE DEBUG 'klassifikation_candidates_is_initialized step 5:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 5:%',klassifikation_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT klassifikation_candidates_is_initialized THEN 
		klassifikation_candidates:=array(
		SELECT DISTINCT
			klassifikation_id
		FROM
			klassifikation_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )

		)
		;

		klassifikation_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT klassifikation_candidates_is_initialized THEN
	--No filters applied!
	klassifikation_candidates:=array(
		SELECT DISTINCT id FROM klassifikation a LIMIT maxResults
	);
ELSE
	klassifikation_candidates:=array(
		SELECT DISTINCT id FROM unnest(klassifikation_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'klassifikation_candidates_is_initialized step 6:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 6:%',klassifikation_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_klassifikation(klassifikation_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_klassifikation(firstresult integer, klassifikation_uuid uuid, registreringobj klassifikationregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr klassifikationregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_loghaendelse(integer, uuid, loghaendelseregistreringtype, tstzrange, integer, text[], uuid[], text[], loghaendelseregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_loghaendelse(firstresult integer, loghaendelse_uuid uuid, registreringobj loghaendelseregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr loghaendelseregistreringtype[] DEFAULT NULL::loghaendelseregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	loghaendelse_candidates uuid[];
	loghaendelse_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj LoghaendelseEgenskaberAttrType;
	
  	tilsGyldighedTypeObj LoghaendelseGyldighedTilsType;
	relationTypeObj LoghaendelseRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

loghaendelse_candidates_is_initialized := false;

IF loghaendelse_uuid is not NULL THEN
	loghaendelse_candidates:= ARRAY[loghaendelse_uuid];
	loghaendelse_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		loghaendelse_candidates:=array(
				SELECT DISTINCT
				b.loghaendelse_id 
				FROM
				loghaendelse a
				JOIN loghaendelse_registrering b on b.loghaendelse_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 1:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 1:%',loghaendelse_candidates;
--/****************************//


--RAISE NOTICE 'loghaendelse_candidates_is_initialized step 2:%',loghaendelse_candidates_is_initialized;
--RAISE NOTICE 'loghaendelse_candidates step 2:%',loghaendelse_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_loghaendelse: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(loghaendelse_candidates,1),0)>0 OR NOT loghaendelse_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			loghaendelse_candidates:=array(
			SELECT DISTINCT
			b.loghaendelse_id 
			FROM  loghaendelse_attr_egenskaber a
			JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.service IS NULL
					OR 
					a.service ILIKE attrEgenskaberTypeObj.service --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.klasse IS NULL
					OR 
					a.klasse ILIKE attrEgenskaberTypeObj.klasse --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.tidspunkt IS NULL
					OR 
					a.tidspunkt ILIKE attrEgenskaberTypeObj.tidspunkt --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.operation IS NULL
					OR 
					a.operation ILIKE attrEgenskaberTypeObj.operation --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.objekttype IS NULL
					OR 
					a.objekttype ILIKE attrEgenskaberTypeObj.objekttype --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.returkode IS NULL
					OR 
					a.returkode ILIKE attrEgenskaberTypeObj.returkode --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.returtekst IS NULL
					OR 
					a.returtekst ILIKE attrEgenskaberTypeObj.returtekst --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.note IS NULL
					OR 
					a.note ILIKE attrEgenskaberTypeObj.note --case insensitive 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )

			);
			

			loghaendelse_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 3:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 3:%',loghaendelse_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		loghaendelse_candidates:=array( 

			SELECT DISTINCT
			b.loghaendelse_id 
			FROM  loghaendelse_attr_egenskaber a
			JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id
			WHERE
			(
						a.service ILIKE anyAttrValue OR
						a.klasse ILIKE anyAttrValue OR
						a.tidspunkt ILIKE anyAttrValue OR
						a.operation ILIKE anyAttrValue OR
						a.objekttype ILIKE anyAttrValue OR
						a.returkode ILIKE anyAttrValue OR
						a.returtekst ILIKE anyAttrValue OR
						a.note ILIKE anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )


		);

	loghaendelse_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_loghaendelse: skipping filtration on tilsGyldighed';
ELSE
	IF (coalesce(array_length(loghaendelse_candidates,1),0)>0 OR loghaendelse_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			loghaendelse_candidates:=array(
			SELECT DISTINCT
			b.loghaendelse_id 
			FROM  loghaendelse_tils_gyldighed a
			JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id
			WHERE
				(
					tilsGyldighedTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsGyldighedTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )

	);
			

			loghaendelse_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer LoghaendelseRelationType[]
*/


--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 4:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 4:%',loghaendelse_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_loghaendelse: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(loghaendelse_candidates,1),0)>0 OR NOT loghaendelse_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			loghaendelse_candidates:=array(
			SELECT DISTINCT
			b.loghaendelse_id 
			FROM  loghaendelse_relation a
			JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )

	);
			
			loghaendelse_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		loghaendelse_candidates:=array(
			SELECT DISTINCT
			b.loghaendelse_id 
			FROM  loghaendelse_relation a
			JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )


			);

	loghaendelse_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		loghaendelse_candidates:=array(
			SELECT DISTINCT
			b.loghaendelse_id 
			FROM  loghaendelse_relation a
			JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )


			);

	loghaendelse_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 



--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 5:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 5:%',loghaendelse_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT loghaendelse_candidates_is_initialized THEN 
		loghaendelse_candidates:=array(
		SELECT DISTINCT
			loghaendelse_id
		FROM
			loghaendelse_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )

		)
		;

		loghaendelse_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT loghaendelse_candidates_is_initialized THEN
	--No filters applied!
	loghaendelse_candidates:=array(
		SELECT DISTINCT id FROM loghaendelse a LIMIT maxResults
	);
ELSE
	loghaendelse_candidates:=array(
		SELECT DISTINCT id FROM unnest(loghaendelse_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 6:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 6:%',loghaendelse_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_loghaendelse(loghaendelse_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_loghaendelse(firstresult integer, loghaendelse_uuid uuid, registreringobj loghaendelseregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr loghaendelseregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_organisation(integer, uuid, organisationregistreringtype, tstzrange, integer, text[], uuid[], text[], organisationregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_organisation(firstresult integer, organisation_uuid uuid, registreringobj organisationregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr organisationregistreringtype[] DEFAULT NULL::organisationregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	organisation_candidates uuid[];
	organisation_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj OrganisationEgenskaberAttrType;
	
  	tilsGyldighedTypeObj OrganisationGyldighedTilsType;
	relationTypeObj OrganisationRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

organisation_candidates_is_initialized := false;

IF organisation_uuid is not NULL THEN
	organisation_candidates:= ARRAY[organisation_uuid];
	organisation_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		organisation_candidates:=array(
				SELECT DISTINCT
				b.organisation_id 
				FROM
				organisation a
				JOIN organisation_registrering b on b.organisation_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'organisation_candidates_is_initialized step 1:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 1:%',organisation_candidates;
--/****************************//


--RAISE NOTICE 'organisation_candidates_is_initialized step 2:%',organisation_candidates_is_initialized;
--RAISE NOTICE 'organisation_candidates step 2:%',organisation_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_organisation: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(organisation_candidates,1),0)>0 OR NOT organisation_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			organisation_candidates:=array(
			SELECT DISTINCT
			b.organisation_id 
			FROM  organisation_attr_egenskaber a
			JOIN organisation_registrering b on a.organisation_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.organisationsnavn IS NULL
					OR 
					a.organisationsnavn ILIKE attrEgenskaberTypeObj.organisationsnavn --case insensitive 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )

			);
			

			organisation_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'organisation_candidates_is_initialized step 3:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 3:%',organisation_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		organisation_candidates:=array( 

			SELECT DISTINCT
			b.organisation_id 
			FROM  organisation_attr_egenskaber a
			JOIN organisation_registrering b on a.organisation_registrering_id=b.id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
						a.organisationsnavn ILIKE anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )


		);

	organisation_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_organisation: skipping filtration on tilsGyldighed';
ELSE
	IF (coalesce(array_length(organisation_candidates,1),0)>0 OR organisation_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			organisation_candidates:=array(
			SELECT DISTINCT
			b.organisation_id 
			FROM  organisation_tils_gyldighed a
			JOIN organisation_registrering b on a.organisation_registrering_id=b.id
			WHERE
				(
					tilsGyldighedTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsGyldighedTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )

	);
			

			organisation_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer OrganisationRelationType[]
*/


--RAISE DEBUG 'organisation_candidates_is_initialized step 4:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 4:%',organisation_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_organisation: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(organisation_candidates,1),0)>0 OR NOT organisation_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			organisation_candidates:=array(
			SELECT DISTINCT
			b.organisation_id 
			FROM  organisation_relation a
			JOIN organisation_registrering b on a.organisation_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )

	);
			
			organisation_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		organisation_candidates:=array(
			SELECT DISTINCT
			b.organisation_id 
			FROM  organisation_relation a
			JOIN organisation_registrering b on a.organisation_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )


			);

	organisation_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		organisation_candidates:=array(
			SELECT DISTINCT
			b.organisation_id 
			FROM  organisation_relation a
			JOIN organisation_registrering b on a.organisation_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )


			);

	organisation_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 



--RAISE DEBUG 'organisation_candidates_is_initialized step 5:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 5:%',organisation_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT organisation_candidates_is_initialized THEN 
		organisation_candidates:=array(
		SELECT DISTINCT
			organisation_id
		FROM
			organisation_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )

		)
		;

		organisation_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT organisation_candidates_is_initialized THEN
	--No filters applied!
	organisation_candidates:=array(
		SELECT DISTINCT id FROM organisation a LIMIT maxResults
	);
ELSE
	organisation_candidates:=array(
		SELECT DISTINCT id FROM unnest(organisation_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'organisation_candidates_is_initialized step 6:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 6:%',organisation_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisation(organisation_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_organisation(firstresult integer, organisation_uuid uuid, registreringobj organisationregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr organisationregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_organisationenhed(integer, uuid, organisationenhedregistreringtype, tstzrange, integer, text[], uuid[], text[], organisationenhedregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_organisationenhed(firstresult integer, organisationenhed_uuid uuid, registreringobj organisationenhedregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr organisationenhedregistreringtype[] DEFAULT NULL::organisationenhedregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	organisationenhed_candidates uuid[];
	organisationenhed_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj OrganisationenhedEgenskaberAttrType;
	
  	tilsGyldighedTypeObj OrganisationenhedGyldighedTilsType;
	relationTypeObj OrganisationenhedRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

organisationenhed_candidates_is_initialized := false;

IF organisationenhed_uuid is not NULL THEN
	organisationenhed_candidates:= ARRAY[organisationenhed_uuid];
	organisationenhed_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		organisationenhed_candidates:=array(
				SELECT DISTINCT
				b.organisationenhed_id 
				FROM
				organisationenhed a
				JOIN organisationenhed_registrering b on b.organisationenhed_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 1:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 1:%',organisationenhed_candidates;
--/****************************//


--RAISE NOTICE 'organisationenhed_candidates_is_initialized step 2:%',organisationenhed_candidates_is_initialized;
--RAISE NOTICE 'organisationenhed_candidates step 2:%',organisationenhed_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_organisationenhed: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(organisationenhed_candidates,1),0)>0 OR NOT organisationenhed_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			organisationenhed_candidates:=array(
			SELECT DISTINCT
			b.organisationenhed_id 
			FROM  organisationenhed_attr_egenskaber a
			JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.enhedsnavn IS NULL
					OR 
					a.enhedsnavn ILIKE attrEgenskaberTypeObj.enhedsnavn --case insensitive 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )

			);
			

			organisationenhed_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 3:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 3:%',organisationenhed_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		organisationenhed_candidates:=array( 

			SELECT DISTINCT
			b.organisationenhed_id 
			FROM  organisationenhed_attr_egenskaber a
			JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
						a.enhedsnavn ILIKE anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )


		);

	organisationenhed_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_organisationenhed: skipping filtration on tilsGyldighed';
ELSE
	IF (coalesce(array_length(organisationenhed_candidates,1),0)>0 OR organisationenhed_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			organisationenhed_candidates:=array(
			SELECT DISTINCT
			b.organisationenhed_id 
			FROM  organisationenhed_tils_gyldighed a
			JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id
			WHERE
				(
					tilsGyldighedTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsGyldighedTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )

	);
			

			organisationenhed_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer OrganisationenhedRelationType[]
*/


--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 4:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 4:%',organisationenhed_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_organisationenhed: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(organisationenhed_candidates,1),0)>0 OR NOT organisationenhed_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			organisationenhed_candidates:=array(
			SELECT DISTINCT
			b.organisationenhed_id 
			FROM  organisationenhed_relation a
			JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )

	);
			
			organisationenhed_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		organisationenhed_candidates:=array(
			SELECT DISTINCT
			b.organisationenhed_id 
			FROM  organisationenhed_relation a
			JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )


			);

	organisationenhed_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		organisationenhed_candidates:=array(
			SELECT DISTINCT
			b.organisationenhed_id 
			FROM  organisationenhed_relation a
			JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )


			);

	organisationenhed_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 



--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 5:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 5:%',organisationenhed_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT organisationenhed_candidates_is_initialized THEN 
		organisationenhed_candidates:=array(
		SELECT DISTINCT
			organisationenhed_id
		FROM
			organisationenhed_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )

		)
		;

		organisationenhed_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT organisationenhed_candidates_is_initialized THEN
	--No filters applied!
	organisationenhed_candidates:=array(
		SELECT DISTINCT id FROM organisationenhed a LIMIT maxResults
	);
ELSE
	organisationenhed_candidates:=array(
		SELECT DISTINCT id FROM unnest(organisationenhed_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 6:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 6:%',organisationenhed_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationenhed(organisationenhed_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_organisationenhed(firstresult integer, organisationenhed_uuid uuid, registreringobj organisationenhedregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr organisationenhedregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_organisationfunktion(integer, uuid, organisationfunktionregistreringtype, tstzrange, integer, text[], uuid[], text[], organisationfunktionregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_organisationfunktion(firstresult integer, organisationfunktion_uuid uuid, registreringobj organisationfunktionregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr organisationfunktionregistreringtype[] DEFAULT NULL::organisationfunktionregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	organisationfunktion_candidates uuid[];
	organisationfunktion_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj OrganisationfunktionEgenskaberAttrType;
	
  	tilsGyldighedTypeObj OrganisationfunktionGyldighedTilsType;
	relationTypeObj OrganisationfunktionRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

organisationfunktion_candidates_is_initialized := false;

IF organisationfunktion_uuid is not NULL THEN
	organisationfunktion_candidates:= ARRAY[organisationfunktion_uuid];
	organisationfunktion_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		organisationfunktion_candidates:=array(
				SELECT DISTINCT
				b.organisationfunktion_id 
				FROM
				organisationfunktion a
				JOIN organisationfunktion_registrering b on b.organisationfunktion_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 1:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 1:%',organisationfunktion_candidates;
--/****************************//


--RAISE NOTICE 'organisationfunktion_candidates_is_initialized step 2:%',organisationfunktion_candidates_is_initialized;
--RAISE NOTICE 'organisationfunktion_candidates step 2:%',organisationfunktion_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_organisationfunktion: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(organisationfunktion_candidates,1),0)>0 OR NOT organisationfunktion_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			organisationfunktion_candidates:=array(
			SELECT DISTINCT
			b.organisationfunktion_id 
			FROM  organisationfunktion_attr_egenskaber a
			JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.funktionsnavn IS NULL
					OR 
					a.funktionsnavn ILIKE attrEgenskaberTypeObj.funktionsnavn --case insensitive 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )

			);
			

			organisationfunktion_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 3:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 3:%',organisationfunktion_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		organisationfunktion_candidates:=array( 

			SELECT DISTINCT
			b.organisationfunktion_id 
			FROM  organisationfunktion_attr_egenskaber a
			JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
						a.funktionsnavn ILIKE anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )


		);

	organisationfunktion_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_organisationfunktion: skipping filtration on tilsGyldighed';
ELSE
	IF (coalesce(array_length(organisationfunktion_candidates,1),0)>0 OR organisationfunktion_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			organisationfunktion_candidates:=array(
			SELECT DISTINCT
			b.organisationfunktion_id 
			FROM  organisationfunktion_tils_gyldighed a
			JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id
			WHERE
				(
					tilsGyldighedTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsGyldighedTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )

	);
			

			organisationfunktion_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer OrganisationfunktionRelationType[]
*/


--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 4:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 4:%',organisationfunktion_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_organisationfunktion: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(organisationfunktion_candidates,1),0)>0 OR NOT organisationfunktion_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			organisationfunktion_candidates:=array(
			SELECT DISTINCT
			b.organisationfunktion_id 
			FROM  organisationfunktion_relation a
			JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )

	);
			
			organisationfunktion_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		organisationfunktion_candidates:=array(
			SELECT DISTINCT
			b.organisationfunktion_id 
			FROM  organisationfunktion_relation a
			JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )


			);

	organisationfunktion_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		organisationfunktion_candidates:=array(
			SELECT DISTINCT
			b.organisationfunktion_id 
			FROM  organisationfunktion_relation a
			JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )


			);

	organisationfunktion_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 



--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 5:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 5:%',organisationfunktion_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT organisationfunktion_candidates_is_initialized THEN 
		organisationfunktion_candidates:=array(
		SELECT DISTINCT
			organisationfunktion_id
		FROM
			organisationfunktion_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )

		)
		;

		organisationfunktion_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT organisationfunktion_candidates_is_initialized THEN
	--No filters applied!
	organisationfunktion_candidates:=array(
		SELECT DISTINCT id FROM organisationfunktion a LIMIT maxResults
	);
ELSE
	organisationfunktion_candidates:=array(
		SELECT DISTINCT id FROM unnest(organisationfunktion_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 6:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 6:%',organisationfunktion_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationfunktion(organisationfunktion_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_organisationfunktion(firstresult integer, organisationfunktion_uuid uuid, registreringobj organisationfunktionregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr organisationfunktionregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_sag(integer, uuid, sagregistreringtype, tstzrange, integer, text[], uuid[], text[], sagregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_sag(firstresult integer, sag_uuid uuid, registreringobj sagregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr sagregistreringtype[] DEFAULT NULL::sagregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	sag_candidates uuid[];
	sag_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj SagEgenskaberAttrType;
	
  	tilsFremdriftTypeObj SagFremdriftTilsType;
	relationTypeObj SagRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

sag_candidates_is_initialized := false;

IF sag_uuid is not NULL THEN
	sag_candidates:= ARRAY[sag_uuid];
	sag_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		sag_candidates:=array(
				SELECT DISTINCT
				b.sag_id 
				FROM
				sag a
				JOIN sag_registrering b on b.sag_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'sag_candidates_is_initialized step 1:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 1:%',sag_candidates;
--/****************************//


--RAISE NOTICE 'sag_candidates_is_initialized step 2:%',sag_candidates_is_initialized;
--RAISE NOTICE 'sag_candidates step 2:%',sag_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_sag: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(sag_candidates,1),0)>0 OR NOT sag_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			sag_candidates:=array(
			SELECT DISTINCT
			b.sag_id 
			FROM  sag_attr_egenskaber a
			JOIN sag_registrering b on a.sag_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.afleveret IS NULL
					OR 
					a.afleveret = attrEgenskaberTypeObj.afleveret 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.hjemmel IS NULL
					OR 
					a.hjemmel ILIKE attrEgenskaberTypeObj.hjemmel --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.kassationskode IS NULL
					OR 
					a.kassationskode ILIKE attrEgenskaberTypeObj.kassationskode --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.offentlighedundtaget IS NULL
					OR
						(
							(
								(attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel IS NULL
								OR
								(a.offentlighedundtaget).AlternativTitel ILIKE (attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel 
							)
							AND
							(
								(attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel IS NULL
								OR
								(a.offentlighedundtaget).Hjemmel ILIKE (attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel
							)
						) 
				)
				AND
				(
					attrEgenskaberTypeObj.principiel IS NULL
					OR 
					a.principiel = attrEgenskaberTypeObj.principiel 
				)
				AND
				(
					attrEgenskaberTypeObj.sagsnummer IS NULL
					OR 
					a.sagsnummer ILIKE attrEgenskaberTypeObj.sagsnummer --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.titel IS NULL
					OR 
					a.titel ILIKE attrEgenskaberTypeObj.titel --case insensitive 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )

			);
			

			sag_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'sag_candidates_is_initialized step 3:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 3:%',sag_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		sag_candidates:=array( 

			SELECT DISTINCT
			b.sag_id 
			FROM  sag_attr_egenskaber a
			JOIN sag_registrering b on a.sag_registrering_id=b.id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
								
						a.beskrivelse ILIKE anyAttrValue OR
						a.hjemmel ILIKE anyAttrValue OR
						a.kassationskode ILIKE anyAttrValue OR
									(a.offentlighedundtaget).Hjemmel ilike anyAttrValue OR (a.offentlighedundtaget).AlternativTitel ilike anyAttrValue OR
								
						a.sagsnummer ILIKE anyAttrValue OR
						a.titel ILIKE anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )


		);

	sag_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Fremdrift
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsFremdrift IS NULL THEN
	--RAISE DEBUG 'as_search_sag: skipping filtration on tilsFremdrift';
ELSE
	IF (coalesce(array_length(sag_candidates,1),0)>0 OR sag_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsFremdriftTypeObj IN ARRAY registreringObj.tilsFremdrift
		LOOP
			sag_candidates:=array(
			SELECT DISTINCT
			b.sag_id 
			FROM  sag_tils_fremdrift a
			JOIN sag_registrering b on a.sag_registrering_id=b.id
			WHERE
				(
					tilsFremdriftTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsFremdriftTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsFremdriftTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsFremdriftTypeObj.virkning).AktoerRef IS NULL OR (tilsFremdriftTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsFremdriftTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsFremdriftTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsFremdriftTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsFremdriftTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsFremdriftTypeObj.virkning) IS NULL OR (tilsFremdriftTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsFremdriftTypeObj.fremdrift IS NULL
					OR
					tilsFremdriftTypeObj.fremdrift = a.fremdrift
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )

	);
			

			sag_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer SagRelationType[]
*/


--RAISE DEBUG 'sag_candidates_is_initialized step 4:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 4:%',sag_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_sag: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(sag_candidates,1),0)>0 OR NOT sag_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			sag_candidates:=array(
			SELECT DISTINCT
			b.sag_id 
			FROM  sag_relation a
			JOIN sag_registrering b on a.sag_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
				(
					relationTypeObj.indeks IS NULL
					OR
					relationTypeObj.indeks = a.rel_index
				)
				AND
				(
					relationTypeObj.relTypeSpec IS NULL
					OR
					relationTypeObj.relTypeSpec = rel_type_spec
				)
				AND
				(
					relationTypeObj.journalNotat IS NULL
					OR
					(
						(
							(relationTypeObj.journalNotat).titel IS NULL
							OR
						 	(a.journal_notat).titel ILIKE (relationTypeObj.journalNotat).titel
						)
						AND
						(
							(relationTypeObj.journalNotat).notat IS NULL
							OR
						 	(a.journal_notat).notat ILIKE (relationTypeObj.journalNotat).notat
						)
						AND
						(
							(relationTypeObj.journalNotat).format IS NULL
							OR
						 	(a.journal_notat).format ILIKE (relationTypeObj.journalNotat).format
						)
					)
				)
				AND
				(
					relationTypeObj.journalDokumentAttr IS NULL
					OR
					(
						(
							(relationTypeObj.journalDokumentAttr).dokumenttitel IS NULL
							OR
							(a.journal_dokument_attr).dokumenttitel ILIKE (relationTypeObj.journalDokumentAttr).dokumenttitel
						)
						AND
						(
							(relationTypeObj.journalDokumentAttr).offentlighedundtaget IS NULL
							OR
								(
									(
										((relationTypeObj.journalDokumentAttr).offentlighedundtaget).AlternativTitel IS NULL
										OR
										((a.journal_dokument_attr).offentlighedundtaget).AlternativTitel ILIKE ((relationTypeObj.journalDokumentAttr).offentlighedundtaget).AlternativTitel 
									)
									AND
									(
										((relationTypeObj.journalDokumentAttr).offentlighedundtaget).Hjemmel IS NULL
										OR
										((a.journal_dokument_attr).offentlighedundtaget).Hjemmel ILIKE ((relationTypeObj.journalDokumentAttr).offentlighedundtaget).Hjemmel
									)
								)
						)
					)
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )

	);
			
			sag_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		sag_candidates:=array(
			SELECT DISTINCT
			b.sag_id 
			FROM  sag_relation a
			JOIN sag_registrering b on a.sag_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )


			);

	sag_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		sag_candidates:=array(
			SELECT DISTINCT
			b.sag_id 
			FROM  sag_relation a
			JOIN sag_registrering b on a.sag_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )


			);

	sag_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 



--RAISE DEBUG 'sag_candidates_is_initialized step 5:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 5:%',sag_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT sag_candidates_is_initialized THEN 
		sag_candidates:=array(
		SELECT DISTINCT
			sag_id
		FROM
			sag_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )

		)
		;

		sag_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT sag_candidates_is_initialized THEN
	--No filters applied!
	sag_candidates:=array(
		SELECT DISTINCT id FROM sag a LIMIT maxResults
	);
ELSE
	sag_candidates:=array(
		SELECT DISTINCT id FROM unnest(sag_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'sag_candidates_is_initialized step 6:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 6:%',sag_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_sag(sag_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_sag(firstresult integer, sag_uuid uuid, registreringobj sagregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr sagregistreringtype[]) OWNER TO mox;

--
-- Name: as_search_tilstand(integer, uuid, tilstandregistreringtype, tstzrange, integer, text[], uuid[], text[], tilstandregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_search_tilstand(firstresult integer, tilstand_uuid uuid, registreringobj tilstandregistreringtype, virkningsoeg tstzrange, maxresults integer DEFAULT 2147483647, anyattrvaluearr text[] DEFAULT '{}'::text[], anyuuidarr uuid[] DEFAULT '{}'::uuid[], anyurnarr text[] DEFAULT '{}'::text[], auth_criteria_arr tilstandregistreringtype[] DEFAULT NULL::tilstandregistreringtype[]) RETURNS uuid[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	tilstand_candidates uuid[];
	tilstand_candidates_is_initialized boolean;
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj TilstandEgenskaberAttrType;
	
  	tilsStatusTypeObj TilstandStatusTilsType;
  	tilsPubliceretTypeObj TilstandPubliceretTilsType;
	relationTypeObj TilstandRelationType;
	anyAttrValue text;
	anyuuid uuid;
	anyurn text;
	auth_filtered_uuids uuid[];
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

tilstand_candidates_is_initialized := false;

IF tilstand_uuid is not NULL THEN
	tilstand_candidates:= ARRAY[tilstand_uuid];
	tilstand_candidates_is_initialized:=true;
	IF registreringObj IS NULL THEN
	--RAISE DEBUG 'no registreringObj'
	ELSE	
		tilstand_candidates:=array(
				SELECT DISTINCT
				b.tilstand_id 
				FROM
				tilstand a
				JOIN tilstand_registrering b on b.tilstand_id=a.id
				WHERE
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )

		);		
	END IF;
	
END IF;


--RAISE DEBUG 'tilstand_candidates_is_initialized step 1:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 1:%',tilstand_candidates;
--/****************************//


--RAISE NOTICE 'tilstand_candidates_is_initialized step 2:%',tilstand_candidates_is_initialized;
--RAISE NOTICE 'tilstand_candidates step 2:%',tilstand_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_tilstand: skipping filtration on attrEgenskaber';
ELSE
	IF (coalesce(array_length(tilstand_candidates,1),0)>0 OR NOT tilstand_candidates_is_initialized) THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_attr_egenskaber a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
			WHERE
				(
					(
						attrEgenskaberTypeObj.virkning IS NULL 
						OR
						(
							(
								(
							 		(attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
								)
								OR
								(
									(attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
								)
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
							)
							AND
							(
									(attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
							)
						)
					)
				)
				AND
				(
					(NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive 
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )

			);
			

			tilstand_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'tilstand_candidates_is_initialized step 3:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 3:%',tilstand_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

	FOREACH anyAttrValue IN ARRAY anyAttrValueArr
	LOOP
		tilstand_candidates:=array( 

			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_attr_egenskaber a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
			WHERE
			(
						a.brugervendtnoegle ILIKE anyAttrValue OR
						a.beskrivelse ILIKE anyAttrValue
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )


		);

	tilstand_candidates_is_initialized:=true;

	END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Status
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsStatus IS NULL THEN
	--RAISE DEBUG 'as_search_tilstand: skipping filtration on tilsStatus';
ELSE
	IF (coalesce(array_length(tilstand_candidates,1),0)>0 OR tilstand_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsStatusTypeObj IN ARRAY registreringObj.tilsStatus
		LOOP
			tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_tils_status a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
			WHERE
				(
					tilsStatusTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsStatusTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsStatusTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsStatusTypeObj.virkning).AktoerRef IS NULL OR (tilsStatusTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsStatusTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsStatusTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsStatusTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsStatusTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsStatusTypeObj.virkning) IS NULL OR (tilsStatusTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsStatusTypeObj.status IS NULL
					OR
					tilsStatusTypeObj.status = a.status
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )

	);
			

			tilstand_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_tilstand: skipping filtration on tilsPubliceret';
ELSE
	IF (coalesce(array_length(tilstand_candidates,1),0)>0 OR tilstand_candidates_is_initialized IS FALSE ) THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_tils_publiceret a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
			WHERE
				(
					tilsPubliceretTypeObj.virkning IS NULL
					OR
					(
						(
					 		(tilsPubliceretTypeObj.virkning).TimePeriod IS NULL 
							OR
							(tilsPubliceretTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).AktoerRef IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(tilsPubliceretTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsPubliceretTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT ((tilsPubliceretTypeObj.virkning) IS NULL OR (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )

	);
			

			tilstand_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;

/*
--relationer TilstandRelationType[]
*/


--RAISE DEBUG 'tilstand_candidates_is_initialized step 4:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 4:%',tilstand_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
	--RAISE DEBUG 'as_search_tilstand: skipping filtration on relationer';
ELSE
	IF (coalesce(array_length(tilstand_candidates,1),0)>0 OR NOT tilstand_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_relation a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
			WHERE
				(
					relationTypeObj.virkning IS NULL
					OR
					(
						(
						 	(relationTypeObj.virkning).TimePeriod IS NULL 
							OR
							(relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
						)
						AND
						(
								(relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
						)
						AND
						(
								(relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
						)
						AND
						(
								(relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
						)
					)
				)
				AND
				(
					(NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
					OR
					(
						virkningSoeg IS NULL
						OR
						virkningSoeg && (a.virkning).TimePeriod
					)
				)
				AND
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND
				(
 					relationTypeObj.indeks IS NULL
 					OR
 					relationTypeObj.indeks = a.rel_index
 				)
				AND
				(
				relationTypeObj.tilstandsVaerdiAttr IS NULL
				OR
				(
					(
						(relationTypeObj.tilstandsVaerdiAttr).nominelVaerdi IS NULL
						OR
						(a.tilstand_vaerdi_attr).nominelVaerdi ILIKE (relationTypeObj.tilstandsVaerdiAttr).nominelVaerdi
					)
					AND
					(
						(relationTypeObj.tilstandsVaerdiAttr).forventet IS NULL
						OR
						(a.tilstand_vaerdi_attr).forventet = (relationTypeObj.tilstandsVaerdiAttr).forventet
					)
		
				)
				)
				AND
						(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )

	);
			
			tilstand_candidates_is_initialized:=true;
			

		END LOOP;
	END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

	FOREACH anyuuid IN ARRAY anyuuidArr
	LOOP
		tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_relation a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
			WHERE
			anyuuid = a.rel_maal_uuid
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )


			);

	tilstand_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

	FOREACH anyurn IN ARRAY anyurnArr
	LOOP
		tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_relation a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
			WHERE
			anyurn = a.rel_maal_urn
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (a.virkning).TimePeriod
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )


			);

	tilstand_candidates_is_initialized:=true;
	END LOOP;
END IF;

--/**********************//

 



--RAISE DEBUG 'tilstand_candidates_is_initialized step 5:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 5:%',tilstand_candidates;

IF registreringObj IS NULL THEN
	--RAISE DEBUG 'registreringObj IS NULL';
ELSE
	IF NOT tilstand_candidates_is_initialized THEN 
		tilstand_candidates:=array(
		SELECT DISTINCT
			tilstand_id
		FROM
			tilstand_registrering b
		WHERE
				(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		( (NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )

		)
		;

		tilstand_candidates_is_initialized:=true;
	END IF;
END IF;


IF NOT tilstand_candidates_is_initialized THEN
	--No filters applied!
	tilstand_candidates:=array(
		SELECT DISTINCT id FROM tilstand a LIMIT maxResults
	);
ELSE
	tilstand_candidates:=array(
		SELECT DISTINCT id FROM unnest(tilstand_candidates) as a(id) LIMIT maxResults
		);
END IF;

--RAISE DEBUG 'tilstand_candidates_is_initialized step 6:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 6:%',tilstand_candidates;


										 
/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_tilstand(tilstand_candidates,auth_criteria_arr); 
/*********************/


return auth_filtered_uuids;


END;
$$;


ALTER FUNCTION actual_state.as_search_tilstand(firstresult integer, tilstand_uuid uuid, registreringobj tilstandregistreringtype, virkningsoeg tstzrange, maxresults integer, anyattrvaluearr text[], anyuuidarr uuid[], anyurnarr text[], auth_criteria_arr tilstandregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_aktivitet(uuid, uuid, text, livscykluskode, aktivitetegenskaberattrtype[], aktivitetstatustilstype[], aktivitetpublicerettilstype[], aktivitetrelationtype[], timestamp with time zone, aktivitetregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_aktivitet(aktivitet_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber aktivitetegenskaberattrtype[], tilsstatus aktivitetstatustilstype[], tilspubliceret aktivitetpublicerettilstype[], relationer aktivitetrelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr aktivitetregistreringtype[] DEFAULT NULL::aktivitetregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_aktivitet AktivitetType;
  read_prev_aktivitet AktivitetType;
  read_new_aktivitet_reg AktivitetRegistreringType;
  read_prev_aktivitet_reg AktivitetRegistreringType;
  new_aktivitet_registrering aktivitet_registrering;
  prev_aktivitet_registrering aktivitet_registrering;
  aktivitet_relation_navn AktivitetRelationKode;
  attrEgenskaberObj AktivitetEgenskaberAttrType;
  auth_filtered_uuids uuid[];
  rel_type_max_index_prev_rev int;
  rel_type_max_index_arr _aktivitetRelationMaxIndex[];
  aktivitet_rel_type_cardinality_unlimited aktivitetRelationKode[]:=ARRAY['udfoererklasse'::AktivitetRelationKode,'deltagerklasse'::AktivitetRelationKode,'objektklasse'::AktivitetRelationKode,'resultatklasse'::AktivitetRelationKode,'grundlagklasse'::AktivitetRelationKode,'facilitetklasse'::AktivitetRelationKode,'adresse'::AktivitetRelationKode,'geoobjekt'::AktivitetRelationKode,'position'::AktivitetRelationKode,'facilitet'::AktivitetRelationKode,'lokale'::AktivitetRelationKode,'aktivitetdokument'::AktivitetRelationKode,'aktivitetgrundlag'::AktivitetRelationKode,'aktivitetresultat'::AktivitetRelationKode,'udfoerer'::AktivitetRelationKode,'deltager'::AktivitetRelationKode]::aktivitetRelationKode[];
  aktivitet_uuid_underscores text;
  aktivitet_rel_seq_name text;
  aktivitet_rel_type_cardinality_unlimited_present_in_argument aktivitetRelationKode[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from aktivitet a join aktivitet_registrering b on b.aktivitet_id=a.id  where a.id=aktivitet_uuid) THEN
   RAISE EXCEPTION 'Unable to update aktivitet with uuid [%], being unable to find any previous registrations.',aktivitet_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM aktivitet a
WHERE a.id=aktivitet_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_aktivitet(array[aktivitet_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[aktivitet_uuid]) THEN
  RAISE EXCEPTION 'Unable to update aktivitet with uuid [%]. Object does not met stipulated criteria:%',aktivitet_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_aktivitet_registrering := _as_create_aktivitet_registrering(aktivitet_uuid,livscykluskode, brugerref, note);
prev_aktivitet_registrering := _as_get_prev_aktivitet_registrering(new_aktivitet_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_aktivitet_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update aktivitet with uuid [%], as the aktivitet seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',aktivitet_uuid,lostUpdatePreventionTZ,LOWER((prev_aktivitet_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;



--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, with index values not included in this update. Please notice that for the logic to work,
  --  it is very important that the index sequences start with the max value for index of the same type in the previous registration

  --Ad 1)

--build array with the max index values of the different types of relations of the previous registration
SELECT array_agg(rel_type_max_index)::_aktivitetRelationMaxIndex[] into rel_type_max_index_arr
FROM
(
  SELECT
  (ROW(rel_type,coalesce(max(rel_index),0))::_aktivitetRelationMaxIndex) rel_type_max_index  
  FROM aktivitet_relation a
  where a.aktivitet_registrering_id=prev_aktivitet_registrering.id
  and a.rel_type = any (aktivitet_rel_type_cardinality_unlimited)
  group by rel_type
) as a
;


--Create temporary sequences
aktivitet_uuid_underscores:=replace(aktivitet_uuid::text, '-', '_');

SELECT array_agg( DISTINCT a.RelType) into aktivitet_rel_type_cardinality_unlimited_present_in_argument FROM  unnest(relationer) a WHERE a.RelType = any (aktivitet_rel_type_cardinality_unlimited) ;
IF coalesce(array_length(aktivitet_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH aktivitet_relation_navn IN ARRAY (aktivitet_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  aktivitet_rel_seq_name := 'aktivitet_' || aktivitet_relation_navn::text || aktivitet_uuid_underscores;

  rel_type_max_index_prev_rev:=null;

  SELECT 
    a.indeks into rel_type_max_index_prev_rev
  FROM
    unnest(rel_type_max_index_arr) a(relType,indeks)
  WHERE
    a.relType=aktivitet_relation_navn
  ;
  
  IF rel_type_max_index_prev_rev IS NULL THEN
    rel_type_max_index_prev_rev:=0;
  END IF;

  EXECUTE 'CREATE TEMPORARY SEQUENCE ' || aktivitet_rel_seq_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START ' ||  (rel_type_max_index_prev_rev+1)::text ||'
  CACHE 1;';

END LOOP;
END IF;

      INSERT INTO aktivitet_relation (
        aktivitet_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type,
                    rel_index,
                      aktoer_attr
      )
      SELECT
        new_aktivitet_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType,
                    CASE 
                    WHEN a.relType = any (aktivitet_rel_type_cardinality_unlimited) THEN
                      CASE WHEN a.indeks IS NULL OR b.id IS NULL THEN --for new relations and relations with index given that is not found in prev registrering, we'll assign new index values 
                        nextval('aktivitet_' || a.relType::text || aktivitet_uuid_underscores)
                      ELSE
                        a.indeks
                      END
                    ELSE
                    NULL
                    END,
                    CASE 
                  WHEN a.relType =('udfoerer'::AktivitetRelationKode)  OR rel_type=('deltager'::AktivitetRelationKode) OR rel_type=('ansvarlig'::AktivitetRelationKode) 
                  AND NOT (a.aktoerAttr IS NULL)
                  AND (
                    (a.aktoerAttr).obligatorisk IS NOT NULL
                    OR
                    (a.aktoerAttr).accepteret IS NOT NULL
                    OR
                      (
                        (a.aktoerAttr).repraesentation_uuid IS NOT NULL
                        OR
                        ((a.aktoerAttr).repraesentation_urn IS NOT NULL AND (a.aktoerAttr).repraesentation_urn<>'')
                      )
                    ) 
                  THEN a.aktoerAttr
                  ELSE
                  NULL
                END
      FROM unnest(relationer) as a
      LEFT JOIN aktivitet_relation b on a.relType = any (aktivitet_rel_type_cardinality_unlimited) and b.aktivitet_registrering_id=prev_aktivitet_registrering.id and a.relType=b.rel_type and a.indeks=b.rel_index
    ;


--Drop temporary sequences
IF coalesce(array_length(aktivitet_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH aktivitet_relation_navn IN ARRAY (aktivitet_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  aktivitet_rel_seq_name := 'aktivitet_' || aktivitet_relation_navn::text || aktivitet_uuid_underscores;
  EXECUTE 'DROP  SEQUENCE ' || aktivitet_rel_seq_name || ';';
END LOOP;
END IF;

  --Ad 2)

  /**********************/
  -- 0..1 relations 
  --Please notice, that for 0..1 relations for aktivitet, we're ignoring index here, and handling it the same way, that is done for other object types (like Facet, Klasse etc). That is, you only make changes for the virkningsperiod that you explicitly specify (unless you delete all relations) 

  FOREACH aktivitet_relation_navn in array ARRAY['aktivitetstype'::AktivitetRelationKode,'emne'::AktivitetRelationKode,'foelsomhedklasse'::AktivitetRelationKode,'ansvarligklasse'::AktivitetRelationKode,'rekvirentklasse'::AktivitetRelationKode,'ansvarlig'::AktivitetRelationKode,'tilhoerer'::AktivitetRelationKode]::AktivitetRelationKode[]
  LOOP

    INSERT INTO aktivitet_relation (
        aktivitet_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type,
                    rel_index,
                      aktoer_attr

      )
    SELECT 
        new_aktivitet_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type,
                    NULL,--a.rel_index, rel_index is not to be used for 0..1 relations     
                      a.aktoer_attr
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM aktivitet_relation b
      WHERE 
            b.aktivitet_registrering_id=new_aktivitet_registrering.id
            and
            b.rel_type=aktivitet_relation_navn
    ) d
    JOIN aktivitet_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.aktivitet_registrering_id=prev_aktivitet_registrering.id 
          and a.rel_type=aktivitet_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations
  
      INSERT INTO aktivitet_relation (
            aktivitet_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type,
                        rel_index,
                          aktoer_attr
          )
      SELECT 
            new_aktivitet_registrering.id,
              a.virkning,
                a.rel_maal_uuid,
                  a.rel_maal_urn,
                    a.rel_type,
                      a.objekt_type,
                        a.rel_index,
                          a.aktoer_attr
      FROM aktivitet_relation a
      LEFT JOIN aktivitet_relation b on b.aktivitet_registrering_id=new_aktivitet_registrering.id and b.rel_type=a.rel_type and b.rel_index=a.rel_index
      WHERE a.aktivitet_registrering_id=prev_aktivitet_registrering.id 
      and a.rel_type = any (aktivitet_rel_type_cardinality_unlimited)
      and b.id is null --don't transfer relations of prev. registrering, if the index was specified in data given to the/this update-function
      ;

/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsStatus IS NOT NULL AND coalesce(array_length(tilsStatus,1),0)=0 THEN
--raise debug 'Skipping [Status] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --aktivitet_tils_status
  /********************************************/

  --Ad 1)

  INSERT INTO aktivitet_tils_status (
          virkning,
            status,
              aktivitet_registrering_id
  ) 
  SELECT
          a.virkning,
            a.status,
              new_aktivitet_registrering.id
  FROM
  unnest(tilsStatus) as a
  ;
   

  --Ad 2

  INSERT INTO aktivitet_tils_status (
          virkning,
            status,
              aktivitet_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.status,
              new_aktivitet_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the aktivitet_tils_status of the new registrering to pass to _subtract_tstzrange_arr on the aktivitet_tils_status of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM aktivitet_tils_status b
      WHERE 
            b.aktivitet_registrering_id=new_aktivitet_registrering.id
  ) d
    JOIN aktivitet_tils_status a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.aktivitet_registrering_id=prev_aktivitet_registrering.id     
  ;


/**********************/

END IF;



IF tilsPubliceret IS NOT NULL AND coalesce(array_length(tilsPubliceret,1),0)=0 THEN
--raise debug 'Skipping [Publiceret] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --aktivitet_tils_publiceret
  /********************************************/

  --Ad 1)

  INSERT INTO aktivitet_tils_publiceret (
          virkning,
            publiceret,
              aktivitet_registrering_id
  ) 
  SELECT
          a.virkning,
            a.publiceret,
              new_aktivitet_registrering.id
  FROM
  unnest(tilsPubliceret) as a
  ;
   

  --Ad 2

  INSERT INTO aktivitet_tils_publiceret (
          virkning,
            publiceret,
              aktivitet_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.publiceret,
              new_aktivitet_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the aktivitet_tils_publiceret of the new registrering to pass to _subtract_tstzrange_arr on the aktivitet_tils_publiceret of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM aktivitet_tils_publiceret b
      WHERE 
            b.aktivitet_registrering_id=new_aktivitet_registrering.id
  ) d
    JOIN aktivitet_tils_publiceret a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.aktivitet_registrering_id=prev_aktivitet_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--aktivitet_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrAktivitetObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.aktivitetnavn,a.beskrivelse,a.starttidspunkt,a.sluttidspunkt,a.tidsforbrug,a.formaal, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update aktivitet with uuid [%], as the aktivitet have overlapping virknings in the given egenskaber array :%',aktivitet_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).aktivitetnavn is null OR 
   (attrEgenskaberObj).beskrivelse is null OR 
   (attrEgenskaberObj).starttidspunkt is null OR 
   (attrEgenskaberObj).sluttidspunkt is null OR 
   (attrEgenskaberObj).tidsforbrug is null OR 
   (attrEgenskaberObj).formaal is null 
  THEN

  INSERT INTO
  aktivitet_attr_egenskaber
  (
    brugervendtnoegle,aktivitetnavn,beskrivelse,starttidspunkt,sluttidspunkt,tidsforbrug,formaal
    ,virkning
    ,aktivitet_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.aktivitetnavn,a.aktivitetnavn),
    coalesce(attrEgenskaberObj.beskrivelse,a.beskrivelse),
    CASE WHEN ((attrEgenskaberObj.starttidspunkt).cleared) THEN NULL 
        ELSE coalesce((attrEgenskaberObj.starttidspunkt).value,a.starttidspunkt)
        END,
    CASE WHEN ((attrEgenskaberObj.sluttidspunkt).cleared) THEN NULL 
        ELSE coalesce((attrEgenskaberObj.sluttidspunkt).value,a.sluttidspunkt)
        END,
    CASE WHEN ((attrEgenskaberObj.tidsforbrug).cleared) THEN NULL 
        ELSE coalesce((attrEgenskaberObj.tidsforbrug).value,a.tidsforbrug)
        END,
    coalesce(attrEgenskaberObj.formaal,a.formaal),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_aktivitet_registrering.id
  FROM aktivitet_attr_egenskaber a
  WHERE
    a.aktivitet_registrering_id=prev_aktivitet_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  aktivitet_attr_egenskaber
  (
    brugervendtnoegle,aktivitetnavn,beskrivelse,starttidspunkt,sluttidspunkt,tidsforbrug,formaal
    ,virkning
    ,aktivitet_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.aktivitetnavn, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.starttidspunkt, 
    attrEgenskaberObj.sluttidspunkt, 
    attrEgenskaberObj.tidsforbrug, 
    attrEgenskaberObj.formaal,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_aktivitet_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the aktivitet_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM aktivitet_attr_egenskaber b
      WHERE 
       b.aktivitet_registrering_id=new_aktivitet_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    aktivitet_attr_egenskaber
    (
    brugervendtnoegle,aktivitetnavn,beskrivelse,starttidspunkt,sluttidspunkt,tidsforbrug,formaal
    ,virkning
    ,aktivitet_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.aktivitetnavn, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.starttidspunkt, 
    attrEgenskaberObj.sluttidspunkt, 
    attrEgenskaberObj.tidsforbrug, 
    attrEgenskaberObj.formaal,
    attrEgenskaberObj.virkning,
    new_aktivitet_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO aktivitet_attr_egenskaber (
    brugervendtnoegle,aktivitetnavn,beskrivelse,starttidspunkt,sluttidspunkt,tidsforbrug,formaal
    ,virkning
    ,aktivitet_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.aktivitetnavn,
      a.beskrivelse,
      a.starttidspunkt,
      a.sluttidspunkt,
      a.tidsforbrug,
      a.formaal,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_aktivitet_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the aktivitet_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the aktivitet_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM aktivitet_attr_egenskaber b
    WHERE 
          b.aktivitet_registrering_id=new_aktivitet_registrering.id
) d
  JOIN aktivitet_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.aktivitet_registrering_id=prev_aktivitet_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_aktivitet:=as_read_aktivitet(aktivitet_uuid, (new_aktivitet_registrering.registrering).timeperiod,null);
read_prev_aktivitet:=as_read_aktivitet(aktivitet_uuid, (prev_aktivitet_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_aktivitet.registrering[1].registrering).TimePeriod)=lower((new_aktivitet_registrering.registrering).TimePeriod) AND lower((read_prev_aktivitet.registrering[1].registrering).TimePeriod)=lower((prev_aktivitet_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating aktivitet with id [%]: The ordering of as_list_aktivitet should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',aktivitet_uuid,to_json(new_aktivitet_registrering),to_json(read_new_aktivitet.registrering[1].registrering),to_json(prev_aktivitet_registrering),to_json(prev_new_aktivitet.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_aktivitet_reg:=ROW(
ROW(null,(read_new_aktivitet.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_aktivitet.registrering[1]).tilsStatus ,
(read_new_aktivitet.registrering[1]).tilsPubliceret ,
(read_new_aktivitet.registrering[1]).attrEgenskaber ,
(read_new_aktivitet.registrering[1]).relationer 
)::aktivitetRegistreringType
;

read_prev_aktivitet_reg:=ROW(
ROW(null,(read_prev_aktivitet.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_aktivitet.registrering[1]).tilsStatus ,
(read_prev_aktivitet.registrering[1]).tilsPubliceret ,
(read_prev_aktivitet.registrering[1]).attrEgenskaber ,
(read_prev_aktivitet.registrering[1]).relationer 
)::aktivitetRegistreringType
;


IF read_prev_aktivitet_reg=read_new_aktivitet_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_aktivitet_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_aktivitet_reg);
  RAISE EXCEPTION 'Aborted updating aktivitet with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',aktivitet_uuid,to_json(read_new_aktivitet_reg),to_json(read_prev_aktivitet_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_aktivitet_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_aktivitet(aktivitet_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber aktivitetegenskaberattrtype[], tilsstatus aktivitetstatustilstype[], tilspubliceret aktivitetpublicerettilstype[], relationer aktivitetrelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr aktivitetregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_bruger(uuid, uuid, text, livscykluskode, brugeregenskaberattrtype[], brugergyldighedtilstype[], brugerrelationtype[], timestamp with time zone, brugerregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_bruger(bruger_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber brugeregenskaberattrtype[], tilsgyldighed brugergyldighedtilstype[], relationer brugerrelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr brugerregistreringtype[] DEFAULT NULL::brugerregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_bruger BrugerType;
  read_prev_bruger BrugerType;
  read_new_bruger_reg BrugerRegistreringType;
  read_prev_bruger_reg BrugerRegistreringType;
  new_bruger_registrering bruger_registrering;
  prev_bruger_registrering bruger_registrering;
  bruger_relation_navn BrugerRelationKode;
  attrEgenskaberObj BrugerEgenskaberAttrType;
  auth_filtered_uuids uuid[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from bruger a join bruger_registrering b on b.bruger_id=a.id  where a.id=bruger_uuid) THEN
   RAISE EXCEPTION 'Unable to update bruger with uuid [%], being unable to find any previous registrations.',bruger_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM bruger a
WHERE a.id=bruger_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_bruger(array[bruger_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[bruger_uuid]) THEN
  RAISE EXCEPTION 'Unable to update bruger with uuid [%]. Object does not met stipulated criteria:%',bruger_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_bruger_registrering := _as_create_bruger_registrering(bruger_uuid,livscykluskode, brugerref, note);
prev_bruger_registrering := _as_get_prev_bruger_registrering(new_bruger_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_bruger_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update bruger with uuid [%], as the bruger seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',bruger_uuid,lostUpdatePreventionTZ,LOWER((prev_bruger_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  --Ad 1)



      INSERT INTO bruger_relation (
        bruger_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      SELECT
        new_bruger_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
      FROM unnest(relationer) as a
    ;

   
  --Ad 2)

  /**********************/
  -- 0..1 relations 
   

  FOREACH bruger_relation_navn in array  ARRAY['tilhoerer'::BrugerRelationKode]::BrugerRelationKode[]
  LOOP

    INSERT INTO bruger_relation (
        bruger_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
    SELECT 
        new_bruger_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM bruger_relation b
      WHERE 
            b.bruger_registrering_id=new_bruger_registrering.id
            and
            b.rel_type=bruger_relation_navn
    ) d
    JOIN bruger_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.bruger_registrering_id=prev_bruger_registrering.id 
          and a.rel_type=bruger_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations

  --We only have to check if there are any of the relations with the given name present in the new registration, otherwise copy the ones from the previous registration


  FOREACH bruger_relation_navn in array ARRAY['adresser'::BrugerRelationKode,'brugertyper'::BrugerRelationKode,'opgaver'::BrugerRelationKode,'tilknyttedeenheder'::BrugerRelationKode,'tilknyttedefunktioner'::BrugerRelationKode,'tilknyttedeinteressefaellesskaber'::BrugerRelationKode,'tilknyttedeorganisationer'::BrugerRelationKode,'tilknyttedepersoner'::BrugerRelationKode,'tilknyttedeitsystemer'::BrugerRelationKode]::BrugerRelationKode[]
  LOOP

    IF NOT EXISTS  (SELECT 1 FROM bruger_relation WHERE bruger_registrering_id=new_bruger_registrering.id and rel_type=bruger_relation_navn) THEN

      INSERT INTO bruger_relation (
            bruger_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
          )
      SELECT 
            new_bruger_registrering.id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
      FROM bruger_relation
      WHERE bruger_registrering_id=prev_bruger_registrering.id 
      and rel_type=bruger_relation_navn 
      ;

    END IF;
              
  END LOOP;


/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed,1),0)=0 THEN
--raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --bruger_tils_gyldighed
  /********************************************/

  --Ad 1)

  INSERT INTO bruger_tils_gyldighed (
          virkning,
            gyldighed,
              bruger_registrering_id
  ) 
  SELECT
          a.virkning,
            a.gyldighed,
              new_bruger_registrering.id
  FROM
  unnest(tilsGyldighed) as a
  ;
   

  --Ad 2

  INSERT INTO bruger_tils_gyldighed (
          virkning,
            gyldighed,
              bruger_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.gyldighed,
              new_bruger_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the bruger_tils_gyldighed of the new registrering to pass to _subtract_tstzrange_arr on the bruger_tils_gyldighed of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM bruger_tils_gyldighed b
      WHERE 
            b.bruger_registrering_id=new_bruger_registrering.id
  ) d
    JOIN bruger_tils_gyldighed a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.bruger_registrering_id=prev_bruger_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--bruger_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrBrugerObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.brugernavn,a.brugertype, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update bruger with uuid [%], as the bruger have overlapping virknings in the given egenskaber array :%',bruger_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).brugernavn is null OR 
   (attrEgenskaberObj).brugertype is null 
  THEN

  INSERT INTO
  bruger_attr_egenskaber
  (
    brugervendtnoegle,brugernavn,brugertype
    ,virkning
    ,bruger_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.brugernavn,a.brugernavn),
    coalesce(attrEgenskaberObj.brugertype,a.brugertype),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_bruger_registrering.id
  FROM bruger_attr_egenskaber a
  WHERE
    a.bruger_registrering_id=prev_bruger_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  bruger_attr_egenskaber
  (
    brugervendtnoegle,brugernavn,brugertype
    ,virkning
    ,bruger_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.brugernavn, 
    attrEgenskaberObj.brugertype,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_bruger_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the bruger_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM bruger_attr_egenskaber b
      WHERE 
       b.bruger_registrering_id=new_bruger_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    bruger_attr_egenskaber
    (
    brugervendtnoegle,brugernavn,brugertype
    ,virkning
    ,bruger_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.brugernavn, 
    attrEgenskaberObj.brugertype,
    attrEgenskaberObj.virkning,
    new_bruger_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO bruger_attr_egenskaber (
    brugervendtnoegle,brugernavn,brugertype
    ,virkning
    ,bruger_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.brugernavn,
      a.brugertype,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_bruger_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the bruger_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the bruger_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM bruger_attr_egenskaber b
    WHERE 
          b.bruger_registrering_id=new_bruger_registrering.id
) d
  JOIN bruger_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.bruger_registrering_id=prev_bruger_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_bruger:=as_read_bruger(bruger_uuid, (new_bruger_registrering.registrering).timeperiod,null);
read_prev_bruger:=as_read_bruger(bruger_uuid, (prev_bruger_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_bruger.registrering[1].registrering).TimePeriod)=lower((new_bruger_registrering.registrering).TimePeriod) AND lower((read_prev_bruger.registrering[1].registrering).TimePeriod)=lower((prev_bruger_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating bruger with id [%]: The ordering of as_list_bruger should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',bruger_uuid,to_json(new_bruger_registrering),to_json(read_new_bruger.registrering[1].registrering),to_json(prev_bruger_registrering),to_json(prev_new_bruger.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_bruger_reg:=ROW(
ROW(null,(read_new_bruger.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_bruger.registrering[1]).tilsGyldighed ,
(read_new_bruger.registrering[1]).attrEgenskaber ,
(read_new_bruger.registrering[1]).relationer 
)::brugerRegistreringType
;

read_prev_bruger_reg:=ROW(
ROW(null,(read_prev_bruger.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_bruger.registrering[1]).tilsGyldighed ,
(read_prev_bruger.registrering[1]).attrEgenskaber ,
(read_prev_bruger.registrering[1]).relationer 
)::brugerRegistreringType
;


IF read_prev_bruger_reg=read_new_bruger_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_bruger_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_bruger_reg);
  RAISE EXCEPTION 'Aborted updating bruger with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',bruger_uuid,to_json(read_new_bruger_reg),to_json(read_prev_bruger_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_bruger_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_bruger(bruger_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber brugeregenskaberattrtype[], tilsgyldighed brugergyldighedtilstype[], relationer brugerrelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr brugerregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_dokument(uuid, uuid, text, livscykluskode, dokumentegenskaberattrtype[], dokumentfremdrifttilstype[], dokumentrelationtype[], dokumentvarianttype[], timestamp with time zone, dokumentregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_dokument(dokument_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber dokumentegenskaberattrtype[], tilsfremdrift dokumentfremdrifttilstype[], relationer dokumentrelationtype[], varianter dokumentvarianttype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr dokumentregistreringtype[] DEFAULT NULL::dokumentregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_dokument DokumentType;
  read_prev_dokument DokumentType;
  read_new_dokument_reg DokumentRegistreringType;
  read_prev_dokument_reg DokumentRegistreringType;
  new_dokument_registrering dokument_registrering;
  prev_dokument_registrering dokument_registrering;
  dokument_relation_navn DokumentRelationKode;
  attrEgenskaberObj DokumentEgenskaberAttrType;
  auth_filtered_uuids uuid[];
  dokument_variant_obj DokumentVariantType;
  dokument_variant_egenskab_obj DokumentVariantEgenskaberType;
  dokument_del_obj DokumentDelType;
  dokument_del_egenskaber_obj DokumentDelEgenskaberType;
  dokument_del_relation_obj DokumentDelRelationType;
  dokument_variant_new_id bigint;
  dokument_del_new_id bigint;
  dokument_variant_egenskaber_expl_deleted text[]:=array[]::text[];
  dokument_variant_dele_all_expl_deleted text[]:=array[]::text[];
  dokument_variant_del_egenskaber_deleted _DokumentVariantDelKey[]:=array[]::_DokumentVariantDelKey[];
  dokument_variant_del_relationer_deleted _DokumentVariantDelKey[]:=array[]::_DokumentVariantDelKey[];
  dokument_variants_prev_reg_arr text[];
  dokument_variant_egenskaber_prev_reg_varianttekst text;
  dokument_variant_id bigint;
  dokument_variant_del_prev_reg_arr _DokumentVariantDelKey[];
  dokument_variant_del_prev_reg _DokumentVariantDelKey;
  dokument_del_id bigint;
  dokument_variant_del_prev_reg_rel_transfer _DokumentVariantDelKey[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from dokument a join dokument_registrering b on b.dokument_id=a.id  where a.id=dokument_uuid) THEN
   RAISE EXCEPTION 'Unable to update dokument with uuid [%], being unable to find any previous registrations.',dokument_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM dokument a
WHERE a.id=dokument_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_dokument(array[dokument_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[dokument_uuid]) THEN
  RAISE EXCEPTION 'Unable to update dokument with uuid [%]. Object does not met stipulated criteria:%',dokument_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_dokument_registrering := _as_create_dokument_registrering(dokument_uuid,livscykluskode, brugerref, note);
prev_dokument_registrering := _as_get_prev_dokument_registrering(new_dokument_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_dokument_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update dokument with uuid [%], as the dokument seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',dokument_uuid,lostUpdatePreventionTZ,LOWER((prev_dokument_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  --Ad 1)



      INSERT INTO dokument_relation (
        dokument_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      SELECT
        new_dokument_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
      FROM unnest(relationer) as a
    ;

   
  --Ad 2)

  /**********************/
  -- 0..1 relations 
   

  FOREACH dokument_relation_navn in array  ARRAY['nyrevision'::DokumentRelationKode,'primaerklasse'::DokumentRelationKode,'ejer'::DokumentRelationKode,'ansvarlig'::DokumentRelationKode,'primaerbehandler'::DokumentRelationKode,'fordelttil'::DokumentRelationKode]::DokumentRelationKode[]
  LOOP

    INSERT INTO dokument_relation (
        dokument_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
    SELECT 
        new_dokument_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM dokument_relation b
      WHERE 
            b.dokument_registrering_id=new_dokument_registrering.id
            and
            b.rel_type=dokument_relation_navn
    ) d
    JOIN dokument_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.dokument_registrering_id=prev_dokument_registrering.id 
          and a.rel_type=dokument_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations

  --We only have to check if there are any of the relations with the given name present in the new registration, otherwise copy the ones from the previous registration


  FOREACH dokument_relation_navn in array ARRAY['arkiver'::DokumentRelationKode,'besvarelser'::DokumentRelationKode,'udgangspunkter'::DokumentRelationKode,'kommentarer'::DokumentRelationKode,'bilag'::DokumentRelationKode,'andredokumenter'::DokumentRelationKode,'andreklasser'::DokumentRelationKode,'andrebehandlere'::DokumentRelationKode,'parter'::DokumentRelationKode,'kopiparter'::DokumentRelationKode,'tilknyttedesager'::DokumentRelationKode]::DokumentRelationKode[]
  LOOP

    IF NOT EXISTS  (SELECT 1 FROM dokument_relation WHERE dokument_registrering_id=new_dokument_registrering.id and rel_type=dokument_relation_navn) THEN

      INSERT INTO dokument_relation (
            dokument_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
          )
      SELECT 
            new_dokument_registrering.id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
      FROM dokument_relation
      WHERE dokument_registrering_id=prev_dokument_registrering.id 
      and rel_type=dokument_relation_navn 
      ;

    END IF;
              
  END LOOP;


/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsFremdrift IS NOT NULL AND coalesce(array_length(tilsFremdrift,1),0)=0 THEN
--raise debug 'Skipping [Fremdrift] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --dokument_tils_fremdrift
  /********************************************/

  --Ad 1)

  INSERT INTO dokument_tils_fremdrift (
          virkning,
            fremdrift,
              dokument_registrering_id
  ) 
  SELECT
          a.virkning,
            a.fremdrift,
              new_dokument_registrering.id
  FROM
  unnest(tilsFremdrift) as a
  ;
   

  --Ad 2

  INSERT INTO dokument_tils_fremdrift (
          virkning,
            fremdrift,
              dokument_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.fremdrift,
              new_dokument_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the dokument_tils_fremdrift of the new registrering to pass to _subtract_tstzrange_arr on the dokument_tils_fremdrift of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM dokument_tils_fremdrift b
      WHERE 
            b.dokument_registrering_id=new_dokument_registrering.id
  ) d
    JOIN dokument_tils_fremdrift a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.dokument_registrering_id=prev_dokument_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--dokument_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrDokumentObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.beskrivelse,a.brevdato,a.kassationskode,a.major,a.minor,a.offentlighedundtaget,a.titel,a.dokumenttype, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update dokument with uuid [%], as the dokument have overlapping virknings in the given egenskaber array :%',dokument_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).beskrivelse is null OR 
   (attrEgenskaberObj).brevdato is null OR 
   (attrEgenskaberObj).kassationskode is null OR 
   (attrEgenskaberObj).major is null OR 
   (attrEgenskaberObj).minor is null OR 
   (attrEgenskaberObj).offentlighedundtaget is null OR 
   (attrEgenskaberObj).titel is null OR 
   (attrEgenskaberObj).dokumenttype is null 
  THEN

  INSERT INTO
  dokument_attr_egenskaber
  (
    brugervendtnoegle,beskrivelse,brevdato,kassationskode,major,minor,offentlighedundtaget,titel,dokumenttype
    ,virkning
    ,dokument_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.beskrivelse,a.beskrivelse), 
    CASE WHEN (attrEgenskaberObj.brevdato).cleared THEN NULL 
    ELSE coalesce((attrEgenskaberObj.brevdato).value,a.brevdato)
    END,
    coalesce(attrEgenskaberObj.kassationskode,a.kassationskode), 
    CASE WHEN (attrEgenskaberObj.major).cleared THEN NULL 
    ELSE coalesce((attrEgenskaberObj.major).value,a.major)
    END, 
    CASE WHEN (attrEgenskaberObj.minor).cleared THEN NULL 
    ELSE coalesce((attrEgenskaberObj.minor).value,a.minor)
    END,
    coalesce(attrEgenskaberObj.offentlighedundtaget,a.offentlighedundtaget),
    coalesce(attrEgenskaberObj.titel,a.titel),
    coalesce(attrEgenskaberObj.dokumenttype,a.dokumenttype),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_dokument_registrering.id
  FROM dokument_attr_egenskaber a
  WHERE
    a.dokument_registrering_id=prev_dokument_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  dokument_attr_egenskaber
  (
    brugervendtnoegle,beskrivelse,brevdato,kassationskode,major,minor,offentlighedundtaget,titel,dokumenttype
    ,virkning
    ,dokument_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.brevdato, 
    attrEgenskaberObj.kassationskode, 
    attrEgenskaberObj.major, 
    attrEgenskaberObj.minor, 
    attrEgenskaberObj.offentlighedundtaget, 
    attrEgenskaberObj.titel, 
    attrEgenskaberObj.dokumenttype,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_dokument_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the dokument_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM dokument_attr_egenskaber b
      WHERE 
       b.dokument_registrering_id=new_dokument_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    dokument_attr_egenskaber
    (
    brugervendtnoegle,beskrivelse,brevdato,kassationskode,major,minor,offentlighedundtaget,titel,dokumenttype
    ,virkning
    ,dokument_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.brevdato, 
    attrEgenskaberObj.kassationskode, 
    attrEgenskaberObj.major, 
    attrEgenskaberObj.minor, 
    attrEgenskaberObj.offentlighedundtaget, 
    attrEgenskaberObj.titel, 
    attrEgenskaberObj.dokumenttype,
    attrEgenskaberObj.virkning,
    new_dokument_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO dokument_attr_egenskaber (
    brugervendtnoegle,beskrivelse,brevdato,kassationskode,major,minor,offentlighedundtaget,titel,dokumenttype
    ,virkning
    ,dokument_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.beskrivelse,
      a.brevdato,
      a.kassationskode,
      a.major,
      a.minor,
      a.offentlighedundtaget,
      a.titel,
      a.dokumenttype,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_dokument_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the dokument_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the dokument_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM dokument_attr_egenskaber b
    WHERE 
          b.dokument_registrering_id=new_dokument_registrering.id
) d
  JOIN dokument_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.dokument_registrering_id=prev_dokument_registrering.id     
;





END IF;

/******************************************************************/
--Handling document variants and document parts

--check if the update explicitly clears all the doc variants (and parts) by explicitly giving an empty array, if so - no variant will be included in the new reg. 
IF varianter IS NOT NULL AND coalesce(array_length(varianter,1),0)=0 THEN
  --raise notice 'Skipping insertion of doc variants (and parts), as an empty array was given explicitly';
ELSE

--Check if any variants was given in the new update - otherwise we'll skip ahead to transfering the old variants
IF varianter IS NOT NULL AND coalesce(array_length(varianter,1),0)>0 THEN
  
FOREACH dokument_variant_obj IN ARRAY varianter
LOOP

dokument_variant_new_id:=_ensure_document_variant_exists_and_get(new_dokument_registrering.id,dokument_variant_obj.varianttekst);

--handle variant egenskaber
IF dokument_variant_obj.egenskaber IS NOT NULL AND coalesce(array_length(dokument_variant_obj.egenskaber,1),0)=0 THEN
dokument_variant_egenskaber_expl_deleted:=array_append(dokument_variant_egenskaber_expl_deleted, dokument_variant_obj.varianttekst);
ELSE 


IF dokument_variant_obj.egenskaber IS NOT NULL AND coalesce(array_length(dokument_variant_obj.egenskaber,1),0)>0 THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(dokument_variant_obj.egenskaber) a
  JOIN  unnest(dokument_variant_obj.egenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.arkivering,a.delvisscannet,a.offentliggoerelse,a.produktion, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update dokument with uuid [%], as the given dokument variant [%] have overlapping virknings in the given egenskaber array :%',dokument_uuid,dokument_variant_obj.varianttekst,to_json(dokument_variant_obj.egenskaber)  USING ERRCODE = 22000;

  END IF;


FOREACH dokument_variant_egenskab_obj IN ARRAY dokument_variant_obj.egenskaber
  LOOP

   IF (dokument_variant_egenskab_obj).arkivering is null OR 
   (dokument_variant_egenskab_obj).delvisscannet is null OR 
   (dokument_variant_egenskab_obj).offentliggoerelse is null OR 
   (dokument_variant_egenskab_obj).produktion is null 
  THEN


  INSERT INTO dokument_variant_egenskaber(
    variant_id,
        arkivering, 
          delvisscannet, 
            offentliggoerelse, 
              produktion,
                virkning
      )
  SELECT
    dokument_variant_new_id, 
        CASE WHEN (dokument_variant_egenskab_obj.arkivering).cleared THEN NULL 
        ELSE coalesce((dokument_variant_egenskab_obj.arkivering).value,a.arkivering)
        END, 
          CASE WHEN (dokument_variant_egenskab_obj.delvisscannet).cleared THEN NULL 
          ELSE coalesce((dokument_variant_egenskab_obj.delvisscannet).value,a.delvisscannet)
          END,
            CASE WHEN (dokument_variant_egenskab_obj.offentliggoerelse).cleared THEN NULL 
            ELSE coalesce((dokument_variant_egenskab_obj.offentliggoerelse).value,a.offentliggoerelse)
            END,
              CASE WHEN (dokument_variant_egenskab_obj.produktion).cleared THEN NULL 
              ELSE coalesce((dokument_variant_egenskab_obj.produktion).value,a.produktion)
              END,
                ROW (
                  (a.virkning).TimePeriod * (dokument_variant_egenskab_obj.virkning).TimePeriod,
                  (dokument_variant_egenskab_obj.virkning).AktoerRef,
                  (dokument_variant_egenskab_obj.virkning).AktoerTypeKode,
                  (dokument_variant_egenskab_obj.virkning).NoteTekst
                )::Virkning
  FROM dokument_variant_egenskaber a
  JOIN dokument_variant b on a.variant_id=b.id
  WHERE
    b.dokument_registrering_id=prev_dokument_registrering.id 
    and b.varianttekst=dokument_variant_obj.varianttekst
    and (a.virkning).TimePeriod && (dokument_variant_egenskab_obj.virkning).TimePeriod
  ;


  --For any periods within the virkning of the dokument_variant_egenskab_obj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  dokument_variant_egenskaber
  (
    variant_id,
      arkivering, 
        delvisscannet, 
          offentliggoerelse, 
            produktion,
              virkning
  )
  SELECT 
    dokument_variant_new_id,
      dokument_variant_egenskab_obj.arkivering, 
        dokument_variant_egenskab_obj.delvisscannet, 
          dokument_variant_egenskab_obj.offentliggoerelse, 
            dokument_variant_egenskab_obj.produktion,
              ROW (
                   b.tz_range_leftover,
                  (dokument_variant_egenskab_obj.virkning).AktoerRef,
                  (dokument_variant_egenskab_obj.virkning).AktoerTypeKode,
                  (dokument_variant_egenskab_obj.virkning).NoteTekst
              )::Virkning
  FROM
  (
  --build an array of the timeperiod of the virkning of the dokument variant egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM dokument_variant_egenskaber b
      WHERE 
       b.variant_id=dokument_variant_new_id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((dokument_variant_egenskab_obj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;
  ELSE 

   --insert attrEgenskaberObj raw (if there were no null-valued fields) 

   INSERT INTO
    dokument_variant_egenskaber (
      variant_id,
        arkivering, 
          delvisscannet, 
            offentliggoerelse, 
              produktion,
                virkning
    )
    VALUES ( 
      dokument_variant_new_id,
        dokument_variant_egenskab_obj.arkivering, 
          dokument_variant_egenskab_obj.delvisscannet, 
            dokument_variant_egenskab_obj.offentliggoerelse, 
              dokument_variant_egenskab_obj.produktion,
                dokument_variant_egenskab_obj.virkning
    );

  END IF; --else block: null elements present in -dokument_variant_obj.egenskab obj

  END LOOP; --dokument_variant_obj.egenskaber


END IF; --variant egenskaber given.

END IF; --else block: explicit empty array of variant egenskaber given


--handle variant dele
IF dokument_variant_obj.dele IS NOT NULL AND coalesce(array_length(dokument_variant_obj.dele,1),0)=0 THEN

dokument_variant_dele_all_expl_deleted :=array_append(dokument_variant_dele_all_expl_deleted, dokument_variant_obj.varianttekst);

ELSE

IF dokument_variant_obj.dele IS NOT NULL AND coalesce(array_length(dokument_variant_obj.dele,1),0)>0 THEN


FOREACH dokument_del_obj IN ARRAY dokument_variant_obj.dele
    LOOP

    dokument_del_new_id:=_ensure_document_del_exists_and_get(new_dokument_registrering.id, dokument_variant_new_id, dokument_del_obj.deltekst);

    IF dokument_del_obj.egenskaber IS NOT NULL AND coalesce(array_length(dokument_del_obj.egenskaber,1),0)=0 THEN
    dokument_variant_del_egenskaber_deleted:=array_append(dokument_variant_del_egenskaber_deleted,ROW( dokument_variant_obj.varianttekst, dokument_del_obj.deltekst)::_DokumentVariantDelKey);
    ELSE

    IF dokument_del_obj.egenskaber IS NOT NULL AND coalesce(array_length(dokument_del_obj.egenskaber,1),0)>0 THEN  

    --Input validation: 
    --Verify that there is no overlap in virkning in the array given
    IF EXISTS (
      SELECT
      a.*
      FROM unnest(dokument_del_obj.egenskaber) a
      JOIN  unnest(dokument_del_obj.egenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
      GROUP BY a.indeks,a.indhold,a.lokation,a.mimetype, a.virkning
      HAVING COUNT(*)>1
    ) THEN
    RAISE EXCEPTION 'Unable to update dokument with uuid [%], as the dokument variant [%] have del [%] with overlapping virknings in the given egenskaber array :%',dokument_uuid,dokument_variant_obj.varianttekst,dokument_del_obj.deltekst,to_json(dokument_del_obj.egenskaber)  USING ERRCODE = 22000;
    END IF;



  FOREACH dokument_del_egenskaber_obj in array dokument_del_obj.egenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (dokument_del_egenskaber_obj).indeks is null OR 
   (dokument_del_egenskaber_obj).indhold is null OR 
   (dokument_del_egenskaber_obj).lokation is null OR 
   (dokument_del_egenskaber_obj).mimetype is null 
  THEN

  INSERT INTO
  dokument_del_egenskaber
  (
    del_id,
      indeks,
        indhold,
          lokation,
            mimetype,
              virkning
  )
  SELECT 
    dokument_del_new_id, 
      CASE WHEN (dokument_del_egenskaber_obj.indeks).cleared THEN NULL 
      ELSE coalesce((dokument_del_egenskaber_obj.indeks).value,a.indeks)
      END, 
        coalesce(dokument_del_egenskaber_obj.indhold,a.indhold), 
          coalesce(dokument_del_egenskaber_obj.lokation,a.lokation), 
            coalesce(dokument_del_egenskaber_obj.mimetype,a.mimetype),
              ROW (
                (a.virkning).TimePeriod * (dokument_del_egenskaber_obj.virkning).TimePeriod,
                (dokument_del_egenskaber_obj.virkning).AktoerRef,
                (dokument_del_egenskaber_obj.virkning).AktoerTypeKode,
                (dokument_del_egenskaber_obj.virkning).NoteTekst
              )::Virkning
  FROM dokument_del_egenskaber a
  JOIN dokument_del b on a.del_id=b.id
  JOIN dokument_variant c on b.variant_id=c.id
  WHERE
    c.dokument_registrering_id=prev_dokument_registrering.id 
    and c.varianttekst=dokument_variant_obj.varianttekst
    and b.deltekst=dokument_del_obj.deltekst
    and (a.virkning).TimePeriod && (dokument_del_egenskaber_obj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the dokument_del_egenskaber_obj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  dokument_del_egenskaber
  (
    del_id,
      indeks,
        indhold,
          lokation,
            mimetype,
              virkning
  )
  SELECT 
    dokument_del_new_id,
      dokument_del_egenskaber_obj.indeks, 
        dokument_del_egenskaber_obj.indhold, 
          dokument_del_egenskaber_obj.lokation, 
            dokument_del_egenskaber_obj.mimetype,
              ROW (
                   b.tz_range_leftover,
                  (dokument_del_egenskaber_obj.virkning).AktoerRef,
                  (dokument_del_egenskaber_obj.virkning).AktoerTypeKode,
                  (dokument_del_egenskaber_obj.virkning).NoteTekst
              )::Virkning
  FROM
  (
  --build an array of the timeperiod of the virkning of the relevant dokument_del_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM dokument_del_egenskaber b
      JOIN dokument_del c on b.del_id=c.id
      JOIN dokument_variant d on c.variant_id=d.id
      WHERE 
      d.dokument_registrering_id=new_dokument_registrering.id
      and d.varianttekst=dokument_variant_obj.varianttekst
      and c.deltekst=dokument_del_obj.deltekst
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((dokument_del_egenskaber_obj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;
  ELSE
     --insert dokument_del_egenskaber_obj raw (if there were no null-valued fields)

  INSERT INTO
  dokument_del_egenskaber
  (
    del_id,
      indeks,
        indhold,
          lokation,
            mimetype,
              virkning
  )
  SELECT 
    dokument_del_new_id,
      dokument_del_egenskaber_obj.indeks, 
        dokument_del_egenskaber_obj.indhold, 
          dokument_del_egenskaber_obj.lokation, 
            dokument_del_egenskaber_obj.mimetype,
              dokument_del_egenskaber_obj.virkning
  ;

  END IF; --else block: null field in del egenskaber obj pesent

  END LOOP;
    END IF; --del obj has egenskaber given.

    END IF; --else block: explicit empty array of variant del egenskaber given

     IF dokument_del_obj.relationer IS NOT NULL AND coalesce(array_length(dokument_del_obj.relationer,1),0)=0 THEN
     dokument_variant_del_relationer_deleted:=array_append(dokument_variant_del_relationer_deleted,ROW( dokument_variant_obj.varianttekst, dokument_del_obj.deltekst)::_DokumentVariantDelKey);
    
    ELSE


    INSERT INTO dokument_del_relation(
        del_id, 
          virkning, 
            rel_maal_uuid, 
              rel_maal_urn, 
                rel_type, 
                  objekt_type
        )
    SELECT
        dokument_del_new_id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
    FROM unnest(dokument_del_obj.relationer) a(relType,virkning,uuid,urn,objektType)
    ;

    END IF; --explicit empty array of variant del relationer given

    END LOOP; --dokument_variant_obj.dele


END IF; --dokument dele present



END IF; --else block: explicit empty array of variant dele given





END LOOP;

END IF; --variants given with this update.


/****************************************************/
--carry over any variant egenskaber of the prev. registration, unless explicitly deleted - where there is room acording to virkning


SELECT array_agg(varianttekst) into dokument_variants_prev_reg_arr
FROM
dokument_variant a
WHERE a.dokument_registrering_id=prev_dokument_registrering.id
and a.varianttekst not in (select varianttekst from unnest(dokument_variant_egenskaber_expl_deleted) b(varianttekst) )
;

IF dokument_variants_prev_reg_arr IS NOT NULL AND coalesce(array_length(dokument_variants_prev_reg_arr,1),0)>0 THEN

FOREACH dokument_variant_egenskaber_prev_reg_varianttekst IN ARRAY dokument_variants_prev_reg_arr
LOOP 


dokument_variant_id:=_ensure_document_variant_exists_and_get(new_dokument_registrering.id,dokument_variant_egenskaber_prev_reg_varianttekst);

INSERT INTO
    dokument_variant_egenskaber (
      variant_id,
        arkivering, 
          delvisscannet, 
            offentliggoerelse, 
              produktion,
                virkning 
    )
SELECT
      dokument_variant_id,
        a.arkivering,
          a.delvisscannet,
            a.offentliggoerelse,
              a.produktion,               
                ROW(
                  c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
                ) :: virkning
FROM
(
 --build an array of the timeperiod of the virkning of the dokument_variant_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the dokumentvariant_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM dokument_variant_egenskaber b
    WHERE 
    b.variant_id=dokument_variant_id

) d
  JOIN dokument_variant_egenskaber a ON true  
  JOIN dokument_variant e ON a.variant_id = e.id
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE e.dokument_registrering_id=prev_dokument_registrering.id    
  and e.varianttekst=dokument_variant_egenskaber_prev_reg_varianttekst 
;

END LOOP; --loop dokument_variant_egenskaber_prev_reg_varianttekst
END IF;-- not null dokument_variants_prev_reg_arr


/****************************************************/
--carry over any variant del egenskaber of the prev. registration, unless explicitly deleted -  where there is room acording to virkning

  SELECT array_agg(row(a.varianttekst,a.deltekst)::_DokumentVariantDelKey) into dokument_variant_del_prev_reg_arr
  FROM
  (
  SELECT a.varianttekst,b.deltekst
  FROM
  dokument_variant a
  join dokument_del b on b.variant_id=a.id
  LEFT join unnest(dokument_variant_del_egenskaber_deleted) c(varianttekst,deltekst) on a.varianttekst=c.varianttekst and b.deltekst=c.deltekst
  LEFT JOIN unnest(dokument_variant_dele_all_expl_deleted) d(varianttekst) on d.varianttekst = a.varianttekst
  WHERE a.dokument_registrering_id=prev_dokument_registrering.id
  and d.varianttekst is null
  and (c.varianttekst is null and c.deltekst is null)
  group by a.varianttekst,b.deltekst
 ) as a
;
 

if dokument_variant_del_prev_reg_arr IS NOT NULL and coalesce(array_length(dokument_variant_del_prev_reg_arr,1),0)>0 THEN

  FOREACH dokument_variant_del_prev_reg in ARRAY dokument_variant_del_prev_reg_arr
  LOOP

  dokument_del_id:=_ensure_document_variant_and_del_exists_and_get_del(new_dokument_registrering.id,dokument_variant_del_prev_reg.varianttekst,dokument_variant_del_prev_reg.deltekst);

  INSERT INTO dokument_del_egenskaber (
      del_id,
        indeks,
          indhold,
            lokation,
              mimetype,
                virkning
    )
  SELECT
      dokument_del_id,
        a.indeks,
          a.indhold,
            a.lokation,
              a.mimetype,
                ROW(
                  c.tz_range_leftover,
                    (a.virkning).AktoerRef,
                    (a.virkning).AktoerTypeKode,
                    (a.virkning).NoteTekst
                ) :: virkning
  FROM
  (
   --build an array of the timeperiod of the virkning of the dokument_del_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the relevant dokument_del_egenskaber of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM dokument_del_egenskaber b
      JOIN dokument_del c on b.del_id=c.id
      JOIN dokument_variant d on c.variant_id=d.id
      WHERE 
            d.dokument_registrering_id=new_dokument_registrering.id
            AND d.varianttekst=dokument_variant_del_prev_reg.varianttekst
            AND c.deltekst=dokument_variant_del_prev_reg.deltekst
  ) d
    JOIN dokument_del_egenskaber a ON true  
    JOIN dokument_del b on a.del_id=b.id
    JOIN dokument_variant e on b.variant_id=e.id
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE e.dokument_registrering_id=prev_dokument_registrering.id    
    AND e.varianttekst=dokument_variant_del_prev_reg.varianttekst
    AND b.deltekst=dokument_variant_del_prev_reg.deltekst
  ;

  END LOOP;


END IF; --dokument_variant_del_prev_reg_arr not empty




/****************************************************/
--carry over any document part relations of the prev. relation if a) they were not explicitly cleared and b)no document part relations is already present for the variant del.



--3) Transfer relations of prev reg.

--Identify the variant + del combos that should have relations carried over
SELECT array_agg(ROW(e.varianttekst,e.deltekst)::_DokumentVariantDelKey) into dokument_variant_del_prev_reg_rel_transfer
FROM
(
  SELECT
  c.varianttekst,b.deltekst
  FROM dokument_del_relation a 
  JOIN dokument_del b on a.del_id=b.id
  JOIN dokument_variant c on b.variant_id=c.id
  LEFT JOIN unnest(dokument_variant_del_relationer_deleted) d(varianttekst,deltekst) on d.varianttekst=c.varianttekst and d.deltekst=b.deltekst
  WHERE c.dokument_registrering_id=prev_dokument_registrering.id
  AND ( d.varianttekst IS NULL AND d.deltekst IS NULL) 
  EXCEPT
  SELECT
  c.varianttekst,b.deltekst
  FROM dokument_del_relation a 
  JOIN dokument_del b on a.del_id=b.id
  JOIN dokument_variant c on b.variant_id=c.id
  WHERE c.dokument_registrering_id=new_dokument_registrering.id
) as e
;




-- Make sure that part + variants are in place 
IF dokument_variant_del_prev_reg_rel_transfer IS NOT NULL AND coalesce(array_length(dokument_variant_del_prev_reg_rel_transfer,1),0)>0 THEN
  FOREACH dokument_variant_del_prev_reg IN array dokument_variant_del_prev_reg_rel_transfer
  LOOP
     dokument_del_id:=_ensure_document_variant_and_del_exists_and_get_del(new_dokument_registrering.id,dokument_variant_del_prev_reg.varianttekst , dokument_variant_del_prev_reg.deltekst);

--transfer relations of prev reg.
INSERT INTO dokument_del_relation(
    del_id, 
      virkning, 
        rel_maal_uuid, 
          rel_maal_urn, 
            rel_type, 
              objekt_type
    )
SELECT
    dokument_del_id,
      a.virkning,
        a.rel_maal_uuid,
          a.rel_maal_urn,
            a.rel_type,
              a.objekt_type
FROM dokument_del_relation a 
JOIN dokument_del b on a.del_id=b.id
JOIN dokument_variant c on b.variant_id=c.id
WHERE c.dokument_registrering_id=prev_dokument_registrering.id
AND c.varianttekst=dokument_variant_del_prev_reg.varianttekst
AND b.deltekst=dokument_variant_del_prev_reg.deltekst
;

END LOOP;

END IF; --block: there are relations to transfer
END IF; --else block for skip on empty array for variants.


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_dokument:=as_read_dokument(dokument_uuid, (new_dokument_registrering.registrering).timeperiod,null);
read_prev_dokument:=as_read_dokument(dokument_uuid, (prev_dokument_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_dokument.registrering[1].registrering).TimePeriod)=lower((new_dokument_registrering.registrering).TimePeriod) AND lower((read_prev_dokument.registrering[1].registrering).TimePeriod)=lower((prev_dokument_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating dokument with id [%]: The ordering of as_list_dokument should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',dokument_uuid,to_json(new_dokument_registrering),to_json(read_new_dokument.registrering[1].registrering),to_json(prev_dokument_registrering),to_json(prev_new_dokument.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_dokument_reg:=ROW(
ROW(null,(read_new_dokument.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_dokument.registrering[1]).tilsFremdrift ,
(read_new_dokument.registrering[1]).attrEgenskaber ,
(read_new_dokument.registrering[1]).relationer,
(read_new_dokument.registrering[1]).varianter 
)::dokumentRegistreringType
;

read_prev_dokument_reg:=ROW(
ROW(null,(read_prev_dokument.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_dokument.registrering[1]).tilsFremdrift ,
(read_prev_dokument.registrering[1]).attrEgenskaber ,
(read_prev_dokument.registrering[1]).relationer,
(read_prev_dokument.registrering[1]).varianter
)::dokumentRegistreringType
;


IF read_prev_dokument_reg=read_new_dokument_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_dokument_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_dokument_reg);
  RAISE EXCEPTION 'Aborted updating dokument with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',dokument_uuid,to_json(read_new_dokument_reg),to_json(read_prev_dokument_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_dokument_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_dokument(dokument_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber dokumentegenskaberattrtype[], tilsfremdrift dokumentfremdrifttilstype[], relationer dokumentrelationtype[], varianter dokumentvarianttype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr dokumentregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_facet(uuid, uuid, text, livscykluskode, facetegenskaberattrtype[], facetpublicerettilstype[], facetrelationtype[], timestamp with time zone, facetregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_facet(facet_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber facetegenskaberattrtype[], tilspubliceret facetpublicerettilstype[], relationer facetrelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr facetregistreringtype[] DEFAULT NULL::facetregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_facet FacetType;
  read_prev_facet FacetType;
  read_new_facet_reg FacetRegistreringType;
  read_prev_facet_reg FacetRegistreringType;
  new_facet_registrering facet_registrering;
  prev_facet_registrering facet_registrering;
  facet_relation_navn FacetRelationKode;
  attrEgenskaberObj FacetEgenskaberAttrType;
  auth_filtered_uuids uuid[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from facet a join facet_registrering b on b.facet_id=a.id  where a.id=facet_uuid) THEN
   RAISE EXCEPTION 'Unable to update facet with uuid [%], being unable to find any previous registrations.',facet_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM facet a
WHERE a.id=facet_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_facet(array[facet_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[facet_uuid]) THEN
  RAISE EXCEPTION 'Unable to update facet with uuid [%]. Object does not met stipulated criteria:%',facet_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_facet_registrering := _as_create_facet_registrering(facet_uuid,livscykluskode, brugerref, note);
prev_facet_registrering := _as_get_prev_facet_registrering(new_facet_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_facet_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update facet with uuid [%], as the facet seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',facet_uuid,lostUpdatePreventionTZ,LOWER((prev_facet_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  --Ad 1)



      INSERT INTO facet_relation (
        facet_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      SELECT
        new_facet_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
      FROM unnest(relationer) as a
    ;

   
  --Ad 2)

  /**********************/
  -- 0..1 relations 
   

  FOREACH facet_relation_navn in array  ARRAY['ansvarlig'::FacetRelationKode,'ejer'::FacetRelationKode,'facettilhoerer'::FacetRelationKode]::FacetRelationKode[]
  LOOP

    INSERT INTO facet_relation (
        facet_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
    SELECT 
        new_facet_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM facet_relation b
      WHERE 
            b.facet_registrering_id=new_facet_registrering.id
            and
            b.rel_type=facet_relation_navn
    ) d
    JOIN facet_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.facet_registrering_id=prev_facet_registrering.id 
          and a.rel_type=facet_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations

  --We only have to check if there are any of the relations with the given name present in the new registration, otherwise copy the ones from the previous registration


  FOREACH facet_relation_navn in array ARRAY['redaktoerer'::FacetRelationKode]::FacetRelationKode[]
  LOOP

    IF NOT EXISTS  (SELECT 1 FROM facet_relation WHERE facet_registrering_id=new_facet_registrering.id and rel_type=facet_relation_navn) THEN

      INSERT INTO facet_relation (
            facet_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
          )
      SELECT 
            new_facet_registrering.id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
      FROM facet_relation
      WHERE facet_registrering_id=prev_facet_registrering.id 
      and rel_type=facet_relation_navn 
      ;

    END IF;
              
  END LOOP;


/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsPubliceret IS NOT NULL AND coalesce(array_length(tilsPubliceret,1),0)=0 THEN
--raise debug 'Skipping [Publiceret] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --facet_tils_publiceret
  /********************************************/

  --Ad 1)

  INSERT INTO facet_tils_publiceret (
          virkning,
            publiceret,
              facet_registrering_id
  ) 
  SELECT
          a.virkning,
            a.publiceret,
              new_facet_registrering.id
  FROM
  unnest(tilsPubliceret) as a
  ;
   

  --Ad 2

  INSERT INTO facet_tils_publiceret (
          virkning,
            publiceret,
              facet_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.publiceret,
              new_facet_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the facet_tils_publiceret of the new registrering to pass to _subtract_tstzrange_arr on the facet_tils_publiceret of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM facet_tils_publiceret b
      WHERE 
            b.facet_registrering_id=new_facet_registrering.id
  ) d
    JOIN facet_tils_publiceret a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.facet_registrering_id=prev_facet_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--facet_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrFacetObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.beskrivelse,a.opbygning,a.ophavsret,a.plan,a.supplement,a.retskilde, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update facet with uuid [%], as the facet have overlapping virknings in the given egenskaber array :%',facet_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).beskrivelse is null OR 
   (attrEgenskaberObj).opbygning is null OR 
   (attrEgenskaberObj).ophavsret is null OR 
   (attrEgenskaberObj).plan is null OR 
   (attrEgenskaberObj).supplement is null OR 
   (attrEgenskaberObj).retskilde is null 
  THEN

  INSERT INTO
  facet_attr_egenskaber
  (
    brugervendtnoegle,beskrivelse,opbygning,ophavsret,plan,supplement,retskilde
    ,virkning
    ,facet_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.beskrivelse,a.beskrivelse),
    coalesce(attrEgenskaberObj.opbygning,a.opbygning),
    coalesce(attrEgenskaberObj.ophavsret,a.ophavsret),
    coalesce(attrEgenskaberObj.plan,a.plan),
    coalesce(attrEgenskaberObj.supplement,a.supplement),
    coalesce(attrEgenskaberObj.retskilde,a.retskilde),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_facet_registrering.id
  FROM facet_attr_egenskaber a
  WHERE
    a.facet_registrering_id=prev_facet_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  facet_attr_egenskaber
  (
    brugervendtnoegle,beskrivelse,opbygning,ophavsret,plan,supplement,retskilde
    ,virkning
    ,facet_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.opbygning, 
    attrEgenskaberObj.ophavsret, 
    attrEgenskaberObj.plan, 
    attrEgenskaberObj.supplement, 
    attrEgenskaberObj.retskilde,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_facet_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the facet_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM facet_attr_egenskaber b
      WHERE 
       b.facet_registrering_id=new_facet_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    facet_attr_egenskaber
    (
    brugervendtnoegle,beskrivelse,opbygning,ophavsret,plan,supplement,retskilde
    ,virkning
    ,facet_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.opbygning, 
    attrEgenskaberObj.ophavsret, 
    attrEgenskaberObj.plan, 
    attrEgenskaberObj.supplement, 
    attrEgenskaberObj.retskilde,
    attrEgenskaberObj.virkning,
    new_facet_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO facet_attr_egenskaber (
    brugervendtnoegle,beskrivelse,opbygning,ophavsret,plan,supplement,retskilde
    ,virkning
    ,facet_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.beskrivelse,
      a.opbygning,
      a.ophavsret,
      a.plan,
      a.supplement,
      a.retskilde,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_facet_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the facet_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the facet_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM facet_attr_egenskaber b
    WHERE 
          b.facet_registrering_id=new_facet_registrering.id
) d
  JOIN facet_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.facet_registrering_id=prev_facet_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_facet:=as_read_facet(facet_uuid, (new_facet_registrering.registrering).timeperiod,null);
read_prev_facet:=as_read_facet(facet_uuid, (prev_facet_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_facet.registrering[1].registrering).TimePeriod)=lower((new_facet_registrering.registrering).TimePeriod) AND lower((read_prev_facet.registrering[1].registrering).TimePeriod)=lower((prev_facet_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating facet with id [%]: The ordering of as_list_facet should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',facet_uuid,to_json(new_facet_registrering),to_json(read_new_facet.registrering[1].registrering),to_json(prev_facet_registrering),to_json(prev_new_facet.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_facet_reg:=ROW(
ROW(null,(read_new_facet.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_facet.registrering[1]).tilsPubliceret ,
(read_new_facet.registrering[1]).attrEgenskaber ,
(read_new_facet.registrering[1]).relationer 
)::facetRegistreringType
;

read_prev_facet_reg:=ROW(
ROW(null,(read_prev_facet.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_facet.registrering[1]).tilsPubliceret ,
(read_prev_facet.registrering[1]).attrEgenskaber ,
(read_prev_facet.registrering[1]).relationer 
)::facetRegistreringType
;


IF read_prev_facet_reg=read_new_facet_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_facet_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_facet_reg);
  RAISE EXCEPTION 'Aborted updating facet with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',facet_uuid,to_json(read_new_facet_reg),to_json(read_prev_facet_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_facet_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_facet(facet_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber facetegenskaberattrtype[], tilspubliceret facetpublicerettilstype[], relationer facetrelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr facetregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_indsats(uuid, uuid, text, livscykluskode, indsatsegenskaberattrtype[], indsatspublicerettilstype[], indsatsfremdrifttilstype[], indsatsrelationtype[], timestamp with time zone, indsatsregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_indsats(indsats_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber indsatsegenskaberattrtype[], tilspubliceret indsatspublicerettilstype[], tilsfremdrift indsatsfremdrifttilstype[], relationer indsatsrelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr indsatsregistreringtype[] DEFAULT NULL::indsatsregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_indsats IndsatsType;
  read_prev_indsats IndsatsType;
  read_new_indsats_reg IndsatsRegistreringType;
  read_prev_indsats_reg IndsatsRegistreringType;
  new_indsats_registrering indsats_registrering;
  prev_indsats_registrering indsats_registrering;
  indsats_relation_navn IndsatsRelationKode;
  attrEgenskaberObj IndsatsEgenskaberAttrType;
  auth_filtered_uuids uuid[];
  rel_type_max_index_prev_rev int;
  rel_type_max_index_arr _indsatsRelationMaxIndex[];
  indsats_rel_type_cardinality_unlimited indsatsRelationKode[]:=ARRAY['indsatskvalitet'::IndsatsRelationKode,'indsatsaktoer'::IndsatsRelationKode,'samtykke'::IndsatsRelationKode,'indsatssag'::IndsatsRelationKode,'indsatsdokument'::IndsatsRelationKode];
  indsats_uuid_underscores text;
  indsats_rel_seq_name text;
  indsats_rel_type_cardinality_unlimited_present_in_argument IndsatsRelationKode[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from indsats a join indsats_registrering b on b.indsats_id=a.id  where a.id=indsats_uuid) THEN
   RAISE EXCEPTION 'Unable to update indsats with uuid [%], being unable to find any previous registrations.',indsats_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM indsats a
WHERE a.id=indsats_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_indsats(array[indsats_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[indsats_uuid]) THEN
  RAISE EXCEPTION 'Unable to update indsats with uuid [%]. Object does not met stipulated criteria:%',indsats_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_indsats_registrering := _as_create_indsats_registrering(indsats_uuid,livscykluskode, brugerref, note);
prev_indsats_registrering := _as_get_prev_indsats_registrering(new_indsats_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_indsats_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update indsats with uuid [%], as the indsats seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',indsats_uuid,lostUpdatePreventionTZ,LOWER((prev_indsats_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;



--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, with index values not included in this update. Please notice that for the logic to work,
  --  it is very important that the index sequences start with the max value for index of the same type in the previous registration

  --Ad 1)

--build array with the max index values of the different types of relations of the previous registration
SELECT array_agg(rel_type_max_index)::_indsatsRelationMaxIndex[] into rel_type_max_index_arr
FROM
(
  SELECT
  (ROW(rel_type,coalesce(max(rel_index),0))::_indsatsRelationMaxIndex) rel_type_max_index  
  FROM indsats_relation a
  where a.indsats_registrering_id=prev_indsats_registrering.id
  and a.rel_type = any (indsats_rel_type_cardinality_unlimited)
  group by rel_type
) as a
;


--Create temporary sequences
indsats_uuid_underscores:=replace(indsats_uuid::text, '-', '_');

SELECT array_agg( DISTINCT a.RelType) into indsats_rel_type_cardinality_unlimited_present_in_argument FROM  unnest(relationer) a WHERE a.RelType = any (indsats_rel_type_cardinality_unlimited) ;
IF coalesce(array_length(indsats_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH indsats_relation_navn IN ARRAY (indsats_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  indsats_rel_seq_name := 'indsats_' || indsats_relation_navn::text || indsats_uuid_underscores;

  rel_type_max_index_prev_rev:=null;

  SELECT 
    a.indeks into rel_type_max_index_prev_rev
  FROM
    unnest(rel_type_max_index_arr) a(relType,indeks)
  WHERE
    a.relType=indsats_relation_navn
  ;
  
  IF rel_type_max_index_prev_rev IS NULL THEN
    rel_type_max_index_prev_rev:=0;
  END IF;

  EXECUTE 'CREATE TEMPORARY SEQUENCE ' || indsats_rel_seq_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START ' ||  (rel_type_max_index_prev_rev+1)::text ||'
  CACHE 1;';

END LOOP;
END IF;

      INSERT INTO indsats_relation (
        indsats_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type,
                    rel_index
      )
      SELECT
        new_indsats_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType,
                    CASE 
                    WHEN a.relType = any (indsats_rel_type_cardinality_unlimited) THEN
                      CASE WHEN a.indeks IS NULL OR b.id IS NULL THEN --for new relations and relations with index given that is not found in prev registrering, we'll assign new index values 
                        nextval('indsats_' || a.relType::text || indsats_uuid_underscores)
                      ELSE
                        a.indeks
                      END
                    ELSE
                    NULL
                    END
      FROM unnest(relationer) as a
      LEFT JOIN indsats_relation b on a.relType = any (indsats_rel_type_cardinality_unlimited) and b.indsats_registrering_id=prev_indsats_registrering.id and a.relType=b.rel_type and a.indeks=b.rel_index
    ;


--Drop temporary sequences
IF coalesce(array_length(indsats_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH indsats_relation_navn IN ARRAY (indsats_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  indsats_rel_seq_name := 'indsats_' || indsats_relation_navn::text || indsats_uuid_underscores;
  EXECUTE 'DROP  SEQUENCE ' || indsats_rel_seq_name || ';';
END LOOP;
END IF;

  --Ad 2)

  /**********************/
  -- 0..1 relations 
  --Please notice, that for 0..1 relations for indsats, we're ignoring index here, and handling it the same way, that is done for other object types (like Facet, Klasse etc). That is, you only make changes for the virkningsperiod that you explicitly specify (unless you delete all relations) 

  FOREACH indsats_relation_navn in array ARRAY['indsatstype'::IndsatsRelationKode,'indsatsmodtager'::IndsatsRelationKode]::IndsatsRelationKode[]
  LOOP

    INSERT INTO indsats_relation (
        indsats_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type,
                    rel_index          
      )
    SELECT 
        new_indsats_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type,
                    NULL--a.rel_index, rel_index is not to be used for 0..1 relations        
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM indsats_relation b
      WHERE 
            b.indsats_registrering_id=new_indsats_registrering.id
            and
            b.rel_type=indsats_relation_navn
    ) d
    JOIN indsats_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.indsats_registrering_id=prev_indsats_registrering.id 
          and a.rel_type=indsats_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations
  
      INSERT INTO indsats_relation (
            indsats_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type,
                        rel_index
          )
      SELECT 
            new_indsats_registrering.id,
              a.virkning,
                a.rel_maal_uuid,
                  a.rel_maal_urn,
                    a.rel_type,
                      a.objekt_type,
                        a.rel_index
      FROM indsats_relation a
      LEFT JOIN indsats_relation b on b.indsats_registrering_id=new_indsats_registrering.id and b.rel_type=a.rel_type and b.rel_index=a.rel_index
      WHERE a.indsats_registrering_id=prev_indsats_registrering.id 
      and a.rel_type = any (indsats_rel_type_cardinality_unlimited)
      and b.id is null --don't transfer relations of prev. registrering, if the index was specified in data given to the/this update-function
      ;

/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsPubliceret IS NOT NULL AND coalesce(array_length(tilsPubliceret,1),0)=0 THEN
--raise debug 'Skipping [Publiceret] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --indsats_tils_publiceret
  /********************************************/

  --Ad 1)

  INSERT INTO indsats_tils_publiceret (
          virkning,
            publiceret,
              indsats_registrering_id
  ) 
  SELECT
          a.virkning,
            a.publiceret,
              new_indsats_registrering.id
  FROM
  unnest(tilsPubliceret) as a
  ;
   

  --Ad 2

  INSERT INTO indsats_tils_publiceret (
          virkning,
            publiceret,
              indsats_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.publiceret,
              new_indsats_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the indsats_tils_publiceret of the new registrering to pass to _subtract_tstzrange_arr on the indsats_tils_publiceret of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM indsats_tils_publiceret b
      WHERE 
            b.indsats_registrering_id=new_indsats_registrering.id
  ) d
    JOIN indsats_tils_publiceret a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.indsats_registrering_id=prev_indsats_registrering.id     
  ;


/**********************/

END IF;



IF tilsFremdrift IS NOT NULL AND coalesce(array_length(tilsFremdrift,1),0)=0 THEN
--raise debug 'Skipping [Fremdrift] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --indsats_tils_fremdrift
  /********************************************/

  --Ad 1)

  INSERT INTO indsats_tils_fremdrift (
          virkning,
            fremdrift,
              indsats_registrering_id
  ) 
  SELECT
          a.virkning,
            a.fremdrift,
              new_indsats_registrering.id
  FROM
  unnest(tilsFremdrift) as a
  ;
   

  --Ad 2

  INSERT INTO indsats_tils_fremdrift (
          virkning,
            fremdrift,
              indsats_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.fremdrift,
              new_indsats_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the indsats_tils_fremdrift of the new registrering to pass to _subtract_tstzrange_arr on the indsats_tils_fremdrift of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM indsats_tils_fremdrift b
      WHERE 
            b.indsats_registrering_id=new_indsats_registrering.id
  ) d
    JOIN indsats_tils_fremdrift a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.indsats_registrering_id=prev_indsats_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--indsats_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrIndsatsObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.beskrivelse,a.starttidspunkt,a.sluttidspunkt, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update indsats with uuid [%], as the indsats have overlapping virknings in the given egenskaber array :%',indsats_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).beskrivelse is null OR 
   (attrEgenskaberObj).starttidspunkt is null OR 
   (attrEgenskaberObj).sluttidspunkt is null 
  THEN

  INSERT INTO
  indsats_attr_egenskaber
  (
    brugervendtnoegle,beskrivelse,starttidspunkt,sluttidspunkt
    ,virkning
    ,indsats_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.beskrivelse,a.beskrivelse),
    CASE WHEN ((attrEgenskaberObj.starttidspunkt).cleared) THEN NULL 
        ELSE coalesce((attrEgenskaberObj.starttidspunkt).value,a.starttidspunkt)
        END,
    CASE WHEN ((attrEgenskaberObj.sluttidspunkt).cleared) THEN NULL 
        ELSE coalesce((attrEgenskaberObj.sluttidspunkt).value,a.sluttidspunkt)
        END,
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_indsats_registrering.id
  FROM indsats_attr_egenskaber a
  WHERE
    a.indsats_registrering_id=prev_indsats_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  indsats_attr_egenskaber
  (
    brugervendtnoegle,beskrivelse,starttidspunkt,sluttidspunkt
    ,virkning
    ,indsats_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.starttidspunkt, 
    attrEgenskaberObj.sluttidspunkt,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_indsats_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the indsats_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM indsats_attr_egenskaber b
      WHERE 
       b.indsats_registrering_id=new_indsats_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    indsats_attr_egenskaber
    (
    brugervendtnoegle,beskrivelse,starttidspunkt,sluttidspunkt
    ,virkning
    ,indsats_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.starttidspunkt, 
    attrEgenskaberObj.sluttidspunkt,
    attrEgenskaberObj.virkning,
    new_indsats_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO indsats_attr_egenskaber (
    brugervendtnoegle,beskrivelse,starttidspunkt,sluttidspunkt
    ,virkning
    ,indsats_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.beskrivelse,
      a.starttidspunkt,
      a.sluttidspunkt,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_indsats_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the indsats_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the indsats_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM indsats_attr_egenskaber b
    WHERE 
          b.indsats_registrering_id=new_indsats_registrering.id
) d
  JOIN indsats_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.indsats_registrering_id=prev_indsats_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_indsats:=as_read_indsats(indsats_uuid, (new_indsats_registrering.registrering).timeperiod,null);
read_prev_indsats:=as_read_indsats(indsats_uuid, (prev_indsats_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_indsats.registrering[1].registrering).TimePeriod)=lower((new_indsats_registrering.registrering).TimePeriod) AND lower((read_prev_indsats.registrering[1].registrering).TimePeriod)=lower((prev_indsats_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating indsats with id [%]: The ordering of as_list_indsats should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',indsats_uuid,to_json(new_indsats_registrering),to_json(read_new_indsats.registrering[1].registrering),to_json(prev_indsats_registrering),to_json(prev_new_indsats.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_indsats_reg:=ROW(
ROW(null,(read_new_indsats.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_indsats.registrering[1]).tilsPubliceret ,
(read_new_indsats.registrering[1]).tilsFremdrift ,
(read_new_indsats.registrering[1]).attrEgenskaber ,
(read_new_indsats.registrering[1]).relationer 
)::indsatsRegistreringType
;

read_prev_indsats_reg:=ROW(
ROW(null,(read_prev_indsats.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_indsats.registrering[1]).tilsPubliceret ,
(read_prev_indsats.registrering[1]).tilsFremdrift ,
(read_prev_indsats.registrering[1]).attrEgenskaber ,
(read_prev_indsats.registrering[1]).relationer 
)::indsatsRegistreringType
;


IF read_prev_indsats_reg=read_new_indsats_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_indsats_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_indsats_reg);
  RAISE EXCEPTION 'Aborted updating indsats with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',indsats_uuid,to_json(read_new_indsats_reg),to_json(read_prev_indsats_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_indsats_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_indsats(indsats_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber indsatsegenskaberattrtype[], tilspubliceret indsatspublicerettilstype[], tilsfremdrift indsatsfremdrifttilstype[], relationer indsatsrelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr indsatsregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_interessefaellesskab(uuid, uuid, text, livscykluskode, interessefaellesskabegenskaberattrtype[], interessefaellesskabgyldighedtilstype[], interessefaellesskabrelationtype[], timestamp with time zone, interessefaellesskabregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_interessefaellesskab(interessefaellesskab_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber interessefaellesskabegenskaberattrtype[], tilsgyldighed interessefaellesskabgyldighedtilstype[], relationer interessefaellesskabrelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr interessefaellesskabregistreringtype[] DEFAULT NULL::interessefaellesskabregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_interessefaellesskab InteressefaellesskabType;
  read_prev_interessefaellesskab InteressefaellesskabType;
  read_new_interessefaellesskab_reg InteressefaellesskabRegistreringType;
  read_prev_interessefaellesskab_reg InteressefaellesskabRegistreringType;
  new_interessefaellesskab_registrering interessefaellesskab_registrering;
  prev_interessefaellesskab_registrering interessefaellesskab_registrering;
  interessefaellesskab_relation_navn InteressefaellesskabRelationKode;
  attrEgenskaberObj InteressefaellesskabEgenskaberAttrType;
  auth_filtered_uuids uuid[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from interessefaellesskab a join interessefaellesskab_registrering b on b.interessefaellesskab_id=a.id  where a.id=interessefaellesskab_uuid) THEN
   RAISE EXCEPTION 'Unable to update interessefaellesskab with uuid [%], being unable to find any previous registrations.',interessefaellesskab_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM interessefaellesskab a
WHERE a.id=interessefaellesskab_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_interessefaellesskab(array[interessefaellesskab_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[interessefaellesskab_uuid]) THEN
  RAISE EXCEPTION 'Unable to update interessefaellesskab with uuid [%]. Object does not met stipulated criteria:%',interessefaellesskab_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_interessefaellesskab_registrering := _as_create_interessefaellesskab_registrering(interessefaellesskab_uuid,livscykluskode, brugerref, note);
prev_interessefaellesskab_registrering := _as_get_prev_interessefaellesskab_registrering(new_interessefaellesskab_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_interessefaellesskab_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update interessefaellesskab with uuid [%], as the interessefaellesskab seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',interessefaellesskab_uuid,lostUpdatePreventionTZ,LOWER((prev_interessefaellesskab_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  --Ad 1)



      INSERT INTO interessefaellesskab_relation (
        interessefaellesskab_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      SELECT
        new_interessefaellesskab_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
      FROM unnest(relationer) as a
    ;

   
  --Ad 2)

  /**********************/
  -- 0..1 relations 
   

  FOREACH interessefaellesskab_relation_navn in array  ARRAY['branche'::InteressefaellesskabRelationKode,'interessefaellesskabstype'::InteressefaellesskabRelationKode,'overordnet'::InteressefaellesskabRelationKode,'tilhoerer'::InteressefaellesskabRelationKode]::InteressefaellesskabRelationKode[]
  LOOP

    INSERT INTO interessefaellesskab_relation (
        interessefaellesskab_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
    SELECT 
        new_interessefaellesskab_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM interessefaellesskab_relation b
      WHERE 
            b.interessefaellesskab_registrering_id=new_interessefaellesskab_registrering.id
            and
            b.rel_type=interessefaellesskab_relation_navn
    ) d
    JOIN interessefaellesskab_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.interessefaellesskab_registrering_id=prev_interessefaellesskab_registrering.id 
          and a.rel_type=interessefaellesskab_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations

  --We only have to check if there are any of the relations with the given name present in the new registration, otherwise copy the ones from the previous registration


  FOREACH interessefaellesskab_relation_navn in array ARRAY['adresser'::InteressefaellesskabRelationKode,'opgaver'::InteressefaellesskabRelationKode,'tilknyttedebrugere'::InteressefaellesskabRelationKode,'tilknyttedeenheder'::InteressefaellesskabRelationKode,'tilknyttedefunktioner'::InteressefaellesskabRelationKode,'tilknyttedeinteressefaellesskaber'::InteressefaellesskabRelationKode,'tilknyttedeorganisationer'::InteressefaellesskabRelationKode,'tilknyttedepersoner'::InteressefaellesskabRelationKode,'tilknyttedeitsystemer'::InteressefaellesskabRelationKode]::InteressefaellesskabRelationKode[]
  LOOP

    IF NOT EXISTS  (SELECT 1 FROM interessefaellesskab_relation WHERE interessefaellesskab_registrering_id=new_interessefaellesskab_registrering.id and rel_type=interessefaellesskab_relation_navn) THEN

      INSERT INTO interessefaellesskab_relation (
            interessefaellesskab_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
          )
      SELECT 
            new_interessefaellesskab_registrering.id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
      FROM interessefaellesskab_relation
      WHERE interessefaellesskab_registrering_id=prev_interessefaellesskab_registrering.id 
      and rel_type=interessefaellesskab_relation_navn 
      ;

    END IF;
              
  END LOOP;


/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed,1),0)=0 THEN
--raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --interessefaellesskab_tils_gyldighed
  /********************************************/

  --Ad 1)

  INSERT INTO interessefaellesskab_tils_gyldighed (
          virkning,
            gyldighed,
              interessefaellesskab_registrering_id
  ) 
  SELECT
          a.virkning,
            a.gyldighed,
              new_interessefaellesskab_registrering.id
  FROM
  unnest(tilsGyldighed) as a
  ;
   

  --Ad 2

  INSERT INTO interessefaellesskab_tils_gyldighed (
          virkning,
            gyldighed,
              interessefaellesskab_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.gyldighed,
              new_interessefaellesskab_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the interessefaellesskab_tils_gyldighed of the new registrering to pass to _subtract_tstzrange_arr on the interessefaellesskab_tils_gyldighed of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM interessefaellesskab_tils_gyldighed b
      WHERE 
            b.interessefaellesskab_registrering_id=new_interessefaellesskab_registrering.id
  ) d
    JOIN interessefaellesskab_tils_gyldighed a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.interessefaellesskab_registrering_id=prev_interessefaellesskab_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--interessefaellesskab_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrInteressefaellesskabObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.interessefaellesskabsnavn,a.interessefaellesskabstype, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update interessefaellesskab with uuid [%], as the interessefaellesskab have overlapping virknings in the given egenskaber array :%',interessefaellesskab_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).interessefaellesskabsnavn is null OR 
   (attrEgenskaberObj).interessefaellesskabstype is null 
  THEN

  INSERT INTO
  interessefaellesskab_attr_egenskaber
  (
    brugervendtnoegle,interessefaellesskabsnavn,interessefaellesskabstype
    ,virkning
    ,interessefaellesskab_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.interessefaellesskabsnavn,a.interessefaellesskabsnavn),
    coalesce(attrEgenskaberObj.interessefaellesskabstype,a.interessefaellesskabstype),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_interessefaellesskab_registrering.id
  FROM interessefaellesskab_attr_egenskaber a
  WHERE
    a.interessefaellesskab_registrering_id=prev_interessefaellesskab_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  interessefaellesskab_attr_egenskaber
  (
    brugervendtnoegle,interessefaellesskabsnavn,interessefaellesskabstype
    ,virkning
    ,interessefaellesskab_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.interessefaellesskabsnavn, 
    attrEgenskaberObj.interessefaellesskabstype,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_interessefaellesskab_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the interessefaellesskab_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM interessefaellesskab_attr_egenskaber b
      WHERE 
       b.interessefaellesskab_registrering_id=new_interessefaellesskab_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    interessefaellesskab_attr_egenskaber
    (
    brugervendtnoegle,interessefaellesskabsnavn,interessefaellesskabstype
    ,virkning
    ,interessefaellesskab_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.interessefaellesskabsnavn, 
    attrEgenskaberObj.interessefaellesskabstype,
    attrEgenskaberObj.virkning,
    new_interessefaellesskab_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO interessefaellesskab_attr_egenskaber (
    brugervendtnoegle,interessefaellesskabsnavn,interessefaellesskabstype
    ,virkning
    ,interessefaellesskab_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.interessefaellesskabsnavn,
      a.interessefaellesskabstype,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_interessefaellesskab_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the interessefaellesskab_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the interessefaellesskab_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM interessefaellesskab_attr_egenskaber b
    WHERE 
          b.interessefaellesskab_registrering_id=new_interessefaellesskab_registrering.id
) d
  JOIN interessefaellesskab_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.interessefaellesskab_registrering_id=prev_interessefaellesskab_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_interessefaellesskab:=as_read_interessefaellesskab(interessefaellesskab_uuid, (new_interessefaellesskab_registrering.registrering).timeperiod,null);
read_prev_interessefaellesskab:=as_read_interessefaellesskab(interessefaellesskab_uuid, (prev_interessefaellesskab_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_interessefaellesskab.registrering[1].registrering).TimePeriod)=lower((new_interessefaellesskab_registrering.registrering).TimePeriod) AND lower((read_prev_interessefaellesskab.registrering[1].registrering).TimePeriod)=lower((prev_interessefaellesskab_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating interessefaellesskab with id [%]: The ordering of as_list_interessefaellesskab should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',interessefaellesskab_uuid,to_json(new_interessefaellesskab_registrering),to_json(read_new_interessefaellesskab.registrering[1].registrering),to_json(prev_interessefaellesskab_registrering),to_json(prev_new_interessefaellesskab.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_interessefaellesskab_reg:=ROW(
ROW(null,(read_new_interessefaellesskab.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_interessefaellesskab.registrering[1]).tilsGyldighed ,
(read_new_interessefaellesskab.registrering[1]).attrEgenskaber ,
(read_new_interessefaellesskab.registrering[1]).relationer 
)::interessefaellesskabRegistreringType
;

read_prev_interessefaellesskab_reg:=ROW(
ROW(null,(read_prev_interessefaellesskab.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_interessefaellesskab.registrering[1]).tilsGyldighed ,
(read_prev_interessefaellesskab.registrering[1]).attrEgenskaber ,
(read_prev_interessefaellesskab.registrering[1]).relationer 
)::interessefaellesskabRegistreringType
;


IF read_prev_interessefaellesskab_reg=read_new_interessefaellesskab_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_interessefaellesskab_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_interessefaellesskab_reg);
  RAISE EXCEPTION 'Aborted updating interessefaellesskab with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',interessefaellesskab_uuid,to_json(read_new_interessefaellesskab_reg),to_json(read_prev_interessefaellesskab_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_interessefaellesskab_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_interessefaellesskab(interessefaellesskab_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber interessefaellesskabegenskaberattrtype[], tilsgyldighed interessefaellesskabgyldighedtilstype[], relationer interessefaellesskabrelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr interessefaellesskabregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_itsystem(uuid, uuid, text, livscykluskode, itsystemegenskaberattrtype[], itsystemgyldighedtilstype[], itsystemrelationtype[], timestamp with time zone, itsystemregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_itsystem(itsystem_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber itsystemegenskaberattrtype[], tilsgyldighed itsystemgyldighedtilstype[], relationer itsystemrelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr itsystemregistreringtype[] DEFAULT NULL::itsystemregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_itsystem ItsystemType;
  read_prev_itsystem ItsystemType;
  read_new_itsystem_reg ItsystemRegistreringType;
  read_prev_itsystem_reg ItsystemRegistreringType;
  new_itsystem_registrering itsystem_registrering;
  prev_itsystem_registrering itsystem_registrering;
  itsystem_relation_navn ItsystemRelationKode;
  attrEgenskaberObj ItsystemEgenskaberAttrType;
  auth_filtered_uuids uuid[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from itsystem a join itsystem_registrering b on b.itsystem_id=a.id  where a.id=itsystem_uuid) THEN
   RAISE EXCEPTION 'Unable to update itsystem with uuid [%], being unable to find any previous registrations.',itsystem_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM itsystem a
WHERE a.id=itsystem_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_itsystem(array[itsystem_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[itsystem_uuid]) THEN
  RAISE EXCEPTION 'Unable to update itsystem with uuid [%]. Object does not met stipulated criteria:%',itsystem_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_itsystem_registrering := _as_create_itsystem_registrering(itsystem_uuid,livscykluskode, brugerref, note);
prev_itsystem_registrering := _as_get_prev_itsystem_registrering(new_itsystem_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_itsystem_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update itsystem with uuid [%], as the itsystem seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',itsystem_uuid,lostUpdatePreventionTZ,LOWER((prev_itsystem_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  --Ad 1)



      INSERT INTO itsystem_relation (
        itsystem_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      SELECT
        new_itsystem_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
      FROM unnest(relationer) as a
    ;

   
  --Ad 2)

  /**********************/
  -- 0..1 relations 
   

  FOREACH itsystem_relation_navn in array  ARRAY['tilhoerer'::ItsystemRelationKode]::ItsystemRelationKode[]
  LOOP

    INSERT INTO itsystem_relation (
        itsystem_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
    SELECT 
        new_itsystem_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM itsystem_relation b
      WHERE 
            b.itsystem_registrering_id=new_itsystem_registrering.id
            and
            b.rel_type=itsystem_relation_navn
    ) d
    JOIN itsystem_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.itsystem_registrering_id=prev_itsystem_registrering.id 
          and a.rel_type=itsystem_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations

  --We only have to check if there are any of the relations with the given name present in the new registration, otherwise copy the ones from the previous registration


  FOREACH itsystem_relation_navn in array ARRAY['tilknyttedeorganisationer'::ItsystemRelationKode,'tilknyttedeenheder'::ItsystemRelationKode,'tilknyttedefunktioner'::ItsystemRelationKode,'tilknyttedebrugere'::ItsystemRelationKode,'tilknyttedeinteressefaellesskaber'::ItsystemRelationKode,'tilknyttedeitsystemer'::ItsystemRelationKode,'tilknyttedepersoner'::ItsystemRelationKode,'systemtyper'::ItsystemRelationKode,'opgaver'::ItsystemRelationKode,'adresser'::ItsystemRelationKode]::ItsystemRelationKode[]
  LOOP

    IF NOT EXISTS  (SELECT 1 FROM itsystem_relation WHERE itsystem_registrering_id=new_itsystem_registrering.id and rel_type=itsystem_relation_navn) THEN

      INSERT INTO itsystem_relation (
            itsystem_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
          )
      SELECT 
            new_itsystem_registrering.id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
      FROM itsystem_relation
      WHERE itsystem_registrering_id=prev_itsystem_registrering.id 
      and rel_type=itsystem_relation_navn 
      ;

    END IF;
              
  END LOOP;


/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed,1),0)=0 THEN
--raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --itsystem_tils_gyldighed
  /********************************************/

  --Ad 1)

  INSERT INTO itsystem_tils_gyldighed (
          virkning,
            gyldighed,
              itsystem_registrering_id
  ) 
  SELECT
          a.virkning,
            a.gyldighed,
              new_itsystem_registrering.id
  FROM
  unnest(tilsGyldighed) as a
  ;
   

  --Ad 2

  INSERT INTO itsystem_tils_gyldighed (
          virkning,
            gyldighed,
              itsystem_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.gyldighed,
              new_itsystem_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the itsystem_tils_gyldighed of the new registrering to pass to _subtract_tstzrange_arr on the itsystem_tils_gyldighed of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM itsystem_tils_gyldighed b
      WHERE 
            b.itsystem_registrering_id=new_itsystem_registrering.id
  ) d
    JOIN itsystem_tils_gyldighed a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.itsystem_registrering_id=prev_itsystem_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--itsystem_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrItsystemObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.itsystemnavn,a.itsystemtype,a.konfigurationreference, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update itsystem with uuid [%], as the itsystem have overlapping virknings in the given egenskaber array :%',itsystem_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).itsystemnavn is null OR 
   (attrEgenskaberObj).itsystemtype is null OR 
   (attrEgenskaberObj).konfigurationreference is null 
  THEN

  INSERT INTO
  itsystem_attr_egenskaber
  (
    brugervendtnoegle,itsystemnavn,itsystemtype,konfigurationreference
    ,virkning
    ,itsystem_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.itsystemnavn,a.itsystemnavn),
    coalesce(attrEgenskaberObj.itsystemtype,a.itsystemtype),
    coalesce(attrEgenskaberObj.konfigurationreference,a.konfigurationreference),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_itsystem_registrering.id
  FROM itsystem_attr_egenskaber a
  WHERE
    a.itsystem_registrering_id=prev_itsystem_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  itsystem_attr_egenskaber
  (
    brugervendtnoegle,itsystemnavn,itsystemtype,konfigurationreference
    ,virkning
    ,itsystem_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.itsystemnavn, 
    attrEgenskaberObj.itsystemtype, 
    attrEgenskaberObj.konfigurationreference,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_itsystem_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the itsystem_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM itsystem_attr_egenskaber b
      WHERE 
       b.itsystem_registrering_id=new_itsystem_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    itsystem_attr_egenskaber
    (
    brugervendtnoegle,itsystemnavn,itsystemtype,konfigurationreference
    ,virkning
    ,itsystem_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.itsystemnavn, 
    attrEgenskaberObj.itsystemtype, 
    attrEgenskaberObj.konfigurationreference,
    attrEgenskaberObj.virkning,
    new_itsystem_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO itsystem_attr_egenskaber (
    brugervendtnoegle,itsystemnavn,itsystemtype,konfigurationreference
    ,virkning
    ,itsystem_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.itsystemnavn,
      a.itsystemtype,
      a.konfigurationreference,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_itsystem_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the itsystem_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the itsystem_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM itsystem_attr_egenskaber b
    WHERE 
          b.itsystem_registrering_id=new_itsystem_registrering.id
) d
  JOIN itsystem_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.itsystem_registrering_id=prev_itsystem_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_itsystem:=as_read_itsystem(itsystem_uuid, (new_itsystem_registrering.registrering).timeperiod,null);
read_prev_itsystem:=as_read_itsystem(itsystem_uuid, (prev_itsystem_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_itsystem.registrering[1].registrering).TimePeriod)=lower((new_itsystem_registrering.registrering).TimePeriod) AND lower((read_prev_itsystem.registrering[1].registrering).TimePeriod)=lower((prev_itsystem_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating itsystem with id [%]: The ordering of as_list_itsystem should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',itsystem_uuid,to_json(new_itsystem_registrering),to_json(read_new_itsystem.registrering[1].registrering),to_json(prev_itsystem_registrering),to_json(prev_new_itsystem.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_itsystem_reg:=ROW(
ROW(null,(read_new_itsystem.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_itsystem.registrering[1]).tilsGyldighed ,
(read_new_itsystem.registrering[1]).attrEgenskaber ,
(read_new_itsystem.registrering[1]).relationer 
)::itsystemRegistreringType
;

read_prev_itsystem_reg:=ROW(
ROW(null,(read_prev_itsystem.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_itsystem.registrering[1]).tilsGyldighed ,
(read_prev_itsystem.registrering[1]).attrEgenskaber ,
(read_prev_itsystem.registrering[1]).relationer 
)::itsystemRegistreringType
;


IF read_prev_itsystem_reg=read_new_itsystem_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_itsystem_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_itsystem_reg);
  RAISE EXCEPTION 'Aborted updating itsystem with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',itsystem_uuid,to_json(read_new_itsystem_reg),to_json(read_prev_itsystem_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_itsystem_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_itsystem(itsystem_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber itsystemegenskaberattrtype[], tilsgyldighed itsystemgyldighedtilstype[], relationer itsystemrelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr itsystemregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_klasse(uuid, uuid, text, livscykluskode, klasseegenskaberattrtype[], klassepublicerettilstype[], klasserelationtype[], timestamp with time zone, klasseregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_klasse(klasse_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber klasseegenskaberattrtype[], tilspubliceret klassepublicerettilstype[], relationer klasserelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr klasseregistreringtype[] DEFAULT NULL::klasseregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_klasse KlasseType;
  read_prev_klasse KlasseType;
  read_new_klasse_reg KlasseRegistreringType;
  read_prev_klasse_reg KlasseRegistreringType;
  new_klasse_registrering klasse_registrering;
  prev_klasse_registrering klasse_registrering;
  klasse_relation_navn KlasseRelationKode;
  attrEgenskaberObj KlasseEgenskaberAttrType;
  new_id_klasse_attr_egenskaber bigint;
  klasseSoegeordObj KlasseSoegeordType;
  auth_filtered_uuids uuid[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from klasse a join klasse_registrering b on b.klasse_id=a.id  where a.id=klasse_uuid) THEN
   RAISE EXCEPTION 'Unable to update klasse with uuid [%], being unable to find any previous registrations.',klasse_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM klasse a
WHERE a.id=klasse_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_klasse(array[klasse_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[klasse_uuid]) THEN
  RAISE EXCEPTION 'Unable to update klasse with uuid [%]. Object does not met stipulated criteria:%',klasse_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_klasse_registrering := _as_create_klasse_registrering(klasse_uuid,livscykluskode, brugerref, note);
prev_klasse_registrering := _as_get_prev_klasse_registrering(new_klasse_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_klasse_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update klasse with uuid [%], as the klasse seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',klasse_uuid,lostUpdatePreventionTZ,LOWER((prev_klasse_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  --Ad 1)



      INSERT INTO klasse_relation (
        klasse_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      SELECT
        new_klasse_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
      FROM unnest(relationer) as a
    ;

   
  --Ad 2)

  /**********************/
  -- 0..1 relations 
   

  FOREACH klasse_relation_navn in array  ARRAY['ejer'::KlasseRelationKode,'ansvarlig'::KlasseRelationKode,'overordnetklasse'::KlasseRelationKode,'facet'::KlasseRelationKode]::KlasseRelationKode[]
  LOOP

    INSERT INTO klasse_relation (
        klasse_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
    SELECT 
        new_klasse_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM klasse_relation b
      WHERE 
            b.klasse_registrering_id=new_klasse_registrering.id
            and
            b.rel_type=klasse_relation_navn
    ) d
    JOIN klasse_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.klasse_registrering_id=prev_klasse_registrering.id 
          and a.rel_type=klasse_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations

  --We only have to check if there are any of the relations with the given name present in the new registration, otherwise copy the ones from the previous registration


  FOREACH klasse_relation_navn in array ARRAY['redaktoerer'::KlasseRelationKode,'sideordnede'::KlasseRelationKode,'mapninger'::KlasseRelationKode,'tilfoejelser'::KlasseRelationKode,'erstatter'::KlasseRelationKode,'lovligekombinationer'::KlasseRelationKode]::KlasseRelationKode[]
  LOOP

    IF NOT EXISTS  (SELECT 1 FROM klasse_relation WHERE klasse_registrering_id=new_klasse_registrering.id and rel_type=klasse_relation_navn) THEN

      INSERT INTO klasse_relation (
            klasse_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
          )
      SELECT 
            new_klasse_registrering.id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
      FROM klasse_relation
      WHERE klasse_registrering_id=prev_klasse_registrering.id 
      and rel_type=klasse_relation_navn 
      ;

    END IF;
              
  END LOOP;


/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsPubliceret IS NOT NULL AND coalesce(array_length(tilsPubliceret,1),0)=0 THEN
--raise debug 'Skipping [Publiceret] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --klasse_tils_publiceret
  /********************************************/

  --Ad 1)

  INSERT INTO klasse_tils_publiceret (
          virkning,
            publiceret,
              klasse_registrering_id
  ) 
  SELECT
          a.virkning,
            a.publiceret,
              new_klasse_registrering.id
  FROM
  unnest(tilsPubliceret) as a
  ;
   

  --Ad 2

  INSERT INTO klasse_tils_publiceret (
          virkning,
            publiceret,
              klasse_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.publiceret,
              new_klasse_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the klasse_tils_publiceret of the new registrering to pass to _subtract_tstzrange_arr on the klasse_tils_publiceret of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM klasse_tils_publiceret b
      WHERE 
            b.klasse_registrering_id=new_klasse_registrering.id
  ) d
    JOIN klasse_tils_publiceret a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.klasse_registrering_id=prev_klasse_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--klasse_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrKlasseObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.beskrivelse,a.eksempel,a.omfang,a.titel,a.retskilde,a.aendringsnotat, a.virkning, a.soegeord
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update klasse with uuid [%], as the klasse have overlapping virknings in the given egenskaber array :%',klasse_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).beskrivelse is null OR 
   (attrEgenskaberObj).eksempel is null OR 
   (attrEgenskaberObj).omfang is null OR 
   (attrEgenskaberObj).titel is null OR 
   (attrEgenskaberObj).retskilde is null OR 
   (attrEgenskaberObj).aendringsnotat is null 
  THEN

WITH inserted_merged_attr_egenskaber AS (
  INSERT INTO
  klasse_attr_egenskaber
  (
    id,brugervendtnoegle,beskrivelse,eksempel,omfang,titel,retskilde,aendringsnotat
    ,virkning
    ,klasse_registrering_id
  )
  SELECT 
    nextval('klasse_attr_egenskaber_id_seq'),
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.beskrivelse,a.beskrivelse),
    coalesce(attrEgenskaberObj.eksempel,a.eksempel),
    coalesce(attrEgenskaberObj.omfang,a.omfang),
    coalesce(attrEgenskaberObj.titel,a.titel),
    coalesce(attrEgenskaberObj.retskilde,a.retskilde),
    coalesce(attrEgenskaberObj.aendringsnotat,a.aendringsnotat),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_klasse_registrering.id
  FROM klasse_attr_egenskaber a
  WHERE
    a.klasse_registrering_id=prev_klasse_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
    RETURNING id new_id,(virkning).TimePeriod merged_timeperiod
)
INSERT INTO 
klasse_attr_egenskaber_soegeord 
(soegeordidentifikator,beskrivelse,soegeordskategori,klasse_attr_egenskaber_id)
SELECT
  coalesce(b.soegeordidentifikator,c.soegeordidentifikator), --please notice that this is not a merge - one of the joins on b or c will fail.
  coalesce(b.beskrivelse,c.beskrivelse),--please notice that this is not a merge - one of the joins on b or c will fail.
  coalesce(b.soegeordskategori,c.soegeordskategori),--please notice that this is not a merge - one of the joins on b or c will fail.
  a.new_id
FROM inserted_merged_attr_egenskaber a
LEFT JOIN unnest(attrEgenskaberObj.soegeord) as b(soegeordidentifikator,beskrivelse,soegeordskategori) on attrEgenskaberObj.soegeord IS NOT NULL
LEFT JOIN klasse_attr_egenskaber as b2 on attrEgenskaberObj.soegeord IS NULL and b2.klasse_registrering_id=prev_klasse_registrering.id and (b2.virkning).TimePeriod @> a.merged_timeperiod --Please notice, that this will max hit exactly one row - the row that the new id was merged with
LEFT JOIN klasse_attr_egenskaber_soegeord as c on attrEgenskaberObj.soegeord IS NULL AND c.klasse_attr_egenskaber_id = b2.id
WHERE 
  (
    (attrEgenskaberObj.soegeord IS NULL and c.id is not null) --there is sogeord of merged egenskab
    or
    coalesce(array_length(attrEgenskaberObj.soegeord,1),0)>0   --soegeord is defined in array 
  )
  and
  (NOT (attrEgenskaberObj.soegeord IS NOT NULL AND array_length(attrEgenskaberObj.soegeord,1)=0)) --if the array is empty, no sogeord should be inserted  

;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

WITH inserted_attr_egenskaber AS (
  INSERT INTO
  klasse_attr_egenskaber
  (
    id,brugervendtnoegle,beskrivelse,eksempel,omfang,titel,retskilde,aendringsnotat
    ,virkning
    ,klasse_registrering_id
  )
  SELECT 
    nextval('klasse_attr_egenskaber_id_seq'),
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.eksempel, 
    attrEgenskaberObj.omfang, 
    attrEgenskaberObj.titel, 
    attrEgenskaberObj.retskilde, 
    attrEgenskaberObj.aendringsnotat,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_klasse_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the klasse_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM klasse_attr_egenskaber b
      WHERE 
       b.klasse_registrering_id=new_klasse_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  RETURNING id
  )
INSERT INTO 
klasse_attr_egenskaber_soegeord 
(soegeordidentifikator,beskrivelse,soegeordskategori,klasse_attr_egenskaber_id)
SELECT
a.soegeordidentifikator,a.beskrivelse,a.soegeordskategori,b.id
FROM
unnest(attrEgenskaberObj.soegeord) as a(soegeordidentifikator,beskrivelse,soegeordskategori)
JOIN inserted_attr_egenskaber b on true
;



  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    new_id_klasse_attr_egenskaber:=nextval('klasse_attr_egenskaber_id_seq');

    INSERT INTO
    klasse_attr_egenskaber
    (
    id,brugervendtnoegle,beskrivelse,eksempel,omfang,titel,retskilde,aendringsnotat
    ,virkning
    ,klasse_registrering_id
    )
    VALUES ( 
    new_id_klasse_attr_egenskaber,
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.eksempel, 
    attrEgenskaberObj.omfang, 
    attrEgenskaberObj.titel, 
    attrEgenskaberObj.retskilde, 
    attrEgenskaberObj.aendringsnotat,
    attrEgenskaberObj.virkning,
    new_klasse_registrering.id
    )
    ;
   
    IF attrEgenskaberObj.soegeord IS NOT NULL THEN
    INSERT INTO klasse_attr_egenskaber_soegeord( 
          soegeordidentifikator,
          beskrivelse,
          soegeordskategori,
          klasse_attr_egenskaber_id
          )
    SELECT
    a.soegeordidentifikator,
    a.beskrivelse,
    a.soegeordskategori,
    new_id_klasse_attr_egenskaber
    FROM
    unnest(attrEgenskaberObj.soegeord) as a(soegeordidentifikator,beskrivelse,soegeordskategori)
    ;
    END IF;


  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)


WITH copied_attr_egenskaber AS (
INSERT INTO klasse_attr_egenskaber (
    id,brugervendtnoegle,beskrivelse,eksempel,omfang,titel,retskilde,aendringsnotat
    ,virkning
    ,klasse_registrering_id
)
SELECT
      nextval('klasse_attr_egenskaber_id_seq'),
      a.brugervendtnoegle,
      a.beskrivelse,
      a.eksempel,
      a.omfang,
      a.titel,
      a.retskilde,
      a.aendringsnotat,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_klasse_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the klasse_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the klasse_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM klasse_attr_egenskaber b
    WHERE 
          b.klasse_registrering_id=new_klasse_registrering.id
) d
  JOIN klasse_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.klasse_registrering_id=prev_klasse_registrering.id 
  RETURNING id new_id,(virkning).TimePeriod  
)
INSERT INTO 
klasse_attr_egenskaber_soegeord 
(soegeordidentifikator,beskrivelse,soegeordskategori,klasse_attr_egenskaber_id)
SELECT
b.soegeordidentifikator,b.beskrivelse,b.soegeordskategori,a.new_id
FROM copied_attr_egenskaber a
JOIN klasse_attr_egenskaber a2 on a2.klasse_registrering_id=prev_klasse_registrering.id and (a2.virkning).TimePeriod @> a.TimePeriod --this will hit exactly one row - that is, the row that we copied. 
JOIN klasse_attr_egenskaber_soegeord b on a2.id=b.klasse_attr_egenskaber_id   
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_klasse:=as_read_klasse(klasse_uuid, (new_klasse_registrering.registrering).timeperiod,null);
read_prev_klasse:=as_read_klasse(klasse_uuid, (prev_klasse_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_klasse.registrering[1].registrering).TimePeriod)=lower((new_klasse_registrering.registrering).TimePeriod) AND lower((read_prev_klasse.registrering[1].registrering).TimePeriod)=lower((prev_klasse_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating klasse with id [%]: The ordering of as_list_klasse should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',klasse_uuid,to_json(new_klasse_registrering),to_json(read_new_klasse.registrering[1].registrering),to_json(prev_klasse_registrering),to_json(prev_new_klasse.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_klasse_reg:=ROW(
ROW(null,(read_new_klasse.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_klasse.registrering[1]).tilsPubliceret ,
(read_new_klasse.registrering[1]).attrEgenskaber ,
(read_new_klasse.registrering[1]).relationer 
)::klasseRegistreringType
;

read_prev_klasse_reg:=ROW(
ROW(null,(read_prev_klasse.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_klasse.registrering[1]).tilsPubliceret ,
(read_prev_klasse.registrering[1]).attrEgenskaber ,
(read_prev_klasse.registrering[1]).relationer 
)::klasseRegistreringType
;


IF read_prev_klasse_reg=read_new_klasse_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_klasse_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_klasse_reg);
  RAISE EXCEPTION 'Aborted updating klasse with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',klasse_uuid,to_json(read_new_klasse_reg),to_json(read_prev_klasse_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_klasse_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_klasse(klasse_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber klasseegenskaberattrtype[], tilspubliceret klassepublicerettilstype[], relationer klasserelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr klasseregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_klassifikation(uuid, uuid, text, livscykluskode, klassifikationegenskaberattrtype[], klassifikationpublicerettilstype[], klassifikationrelationtype[], timestamp with time zone, klassifikationregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_klassifikation(klassifikation_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber klassifikationegenskaberattrtype[], tilspubliceret klassifikationpublicerettilstype[], relationer klassifikationrelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr klassifikationregistreringtype[] DEFAULT NULL::klassifikationregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_klassifikation KlassifikationType;
  read_prev_klassifikation KlassifikationType;
  read_new_klassifikation_reg KlassifikationRegistreringType;
  read_prev_klassifikation_reg KlassifikationRegistreringType;
  new_klassifikation_registrering klassifikation_registrering;
  prev_klassifikation_registrering klassifikation_registrering;
  klassifikation_relation_navn KlassifikationRelationKode;
  attrEgenskaberObj KlassifikationEgenskaberAttrType;
  auth_filtered_uuids uuid[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from klassifikation a join klassifikation_registrering b on b.klassifikation_id=a.id  where a.id=klassifikation_uuid) THEN
   RAISE EXCEPTION 'Unable to update klassifikation with uuid [%], being unable to find any previous registrations.',klassifikation_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM klassifikation a
WHERE a.id=klassifikation_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_klassifikation(array[klassifikation_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[klassifikation_uuid]) THEN
  RAISE EXCEPTION 'Unable to update klassifikation with uuid [%]. Object does not met stipulated criteria:%',klassifikation_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_klassifikation_registrering := _as_create_klassifikation_registrering(klassifikation_uuid,livscykluskode, brugerref, note);
prev_klassifikation_registrering := _as_get_prev_klassifikation_registrering(new_klassifikation_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_klassifikation_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update klassifikation with uuid [%], as the klassifikation seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',klassifikation_uuid,lostUpdatePreventionTZ,LOWER((prev_klassifikation_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  --Ad 1)



      INSERT INTO klassifikation_relation (
        klassifikation_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      SELECT
        new_klassifikation_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
      FROM unnest(relationer) as a
    ;

   
  --Ad 2)

  /**********************/
  -- 0..1 relations 
   

  FOREACH klassifikation_relation_navn in array  ARRAY['ansvarlig'::KlassifikationRelationKode,'ejer'::KlassifikationRelationKode]::KlassifikationRelationKode[]
  LOOP

    INSERT INTO klassifikation_relation (
        klassifikation_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
    SELECT 
        new_klassifikation_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM klassifikation_relation b
      WHERE 
            b.klassifikation_registrering_id=new_klassifikation_registrering.id
            and
            b.rel_type=klassifikation_relation_navn
    ) d
    JOIN klassifikation_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.klassifikation_registrering_id=prev_klassifikation_registrering.id 
          and a.rel_type=klassifikation_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations

  --We only have to check if there are any of the relations with the given name present in the new registration, otherwise copy the ones from the previous registration


  FOREACH klassifikation_relation_navn in array ARRAY[]::KlassifikationRelationKode[]
  LOOP

    IF NOT EXISTS  (SELECT 1 FROM klassifikation_relation WHERE klassifikation_registrering_id=new_klassifikation_registrering.id and rel_type=klassifikation_relation_navn) THEN

      INSERT INTO klassifikation_relation (
            klassifikation_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
          )
      SELECT 
            new_klassifikation_registrering.id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
      FROM klassifikation_relation
      WHERE klassifikation_registrering_id=prev_klassifikation_registrering.id 
      and rel_type=klassifikation_relation_navn 
      ;

    END IF;
              
  END LOOP;


/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsPubliceret IS NOT NULL AND coalesce(array_length(tilsPubliceret,1),0)=0 THEN
--raise debug 'Skipping [Publiceret] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --klassifikation_tils_publiceret
  /********************************************/

  --Ad 1)

  INSERT INTO klassifikation_tils_publiceret (
          virkning,
            publiceret,
              klassifikation_registrering_id
  ) 
  SELECT
          a.virkning,
            a.publiceret,
              new_klassifikation_registrering.id
  FROM
  unnest(tilsPubliceret) as a
  ;
   

  --Ad 2

  INSERT INTO klassifikation_tils_publiceret (
          virkning,
            publiceret,
              klassifikation_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.publiceret,
              new_klassifikation_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the klassifikation_tils_publiceret of the new registrering to pass to _subtract_tstzrange_arr on the klassifikation_tils_publiceret of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM klassifikation_tils_publiceret b
      WHERE 
            b.klassifikation_registrering_id=new_klassifikation_registrering.id
  ) d
    JOIN klassifikation_tils_publiceret a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.klassifikation_registrering_id=prev_klassifikation_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--klassifikation_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrKlassifikationObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.beskrivelse,a.kaldenavn,a.ophavsret, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update klassifikation with uuid [%], as the klassifikation have overlapping virknings in the given egenskaber array :%',klassifikation_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).beskrivelse is null OR 
   (attrEgenskaberObj).kaldenavn is null OR 
   (attrEgenskaberObj).ophavsret is null 
  THEN

  INSERT INTO
  klassifikation_attr_egenskaber
  (
    brugervendtnoegle,beskrivelse,kaldenavn,ophavsret
    ,virkning
    ,klassifikation_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.beskrivelse,a.beskrivelse),
    coalesce(attrEgenskaberObj.kaldenavn,a.kaldenavn),
    coalesce(attrEgenskaberObj.ophavsret,a.ophavsret),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_klassifikation_registrering.id
  FROM klassifikation_attr_egenskaber a
  WHERE
    a.klassifikation_registrering_id=prev_klassifikation_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  klassifikation_attr_egenskaber
  (
    brugervendtnoegle,beskrivelse,kaldenavn,ophavsret
    ,virkning
    ,klassifikation_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.kaldenavn, 
    attrEgenskaberObj.ophavsret,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_klassifikation_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the klassifikation_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM klassifikation_attr_egenskaber b
      WHERE 
       b.klassifikation_registrering_id=new_klassifikation_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    klassifikation_attr_egenskaber
    (
    brugervendtnoegle,beskrivelse,kaldenavn,ophavsret
    ,virkning
    ,klassifikation_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.kaldenavn, 
    attrEgenskaberObj.ophavsret,
    attrEgenskaberObj.virkning,
    new_klassifikation_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO klassifikation_attr_egenskaber (
    brugervendtnoegle,beskrivelse,kaldenavn,ophavsret
    ,virkning
    ,klassifikation_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.beskrivelse,
      a.kaldenavn,
      a.ophavsret,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_klassifikation_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the klassifikation_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the klassifikation_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM klassifikation_attr_egenskaber b
    WHERE 
          b.klassifikation_registrering_id=new_klassifikation_registrering.id
) d
  JOIN klassifikation_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.klassifikation_registrering_id=prev_klassifikation_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_klassifikation:=as_read_klassifikation(klassifikation_uuid, (new_klassifikation_registrering.registrering).timeperiod,null);
read_prev_klassifikation:=as_read_klassifikation(klassifikation_uuid, (prev_klassifikation_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_klassifikation.registrering[1].registrering).TimePeriod)=lower((new_klassifikation_registrering.registrering).TimePeriod) AND lower((read_prev_klassifikation.registrering[1].registrering).TimePeriod)=lower((prev_klassifikation_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating klassifikation with id [%]: The ordering of as_list_klassifikation should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',klassifikation_uuid,to_json(new_klassifikation_registrering),to_json(read_new_klassifikation.registrering[1].registrering),to_json(prev_klassifikation_registrering),to_json(prev_new_klassifikation.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_klassifikation_reg:=ROW(
ROW(null,(read_new_klassifikation.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_klassifikation.registrering[1]).tilsPubliceret ,
(read_new_klassifikation.registrering[1]).attrEgenskaber ,
(read_new_klassifikation.registrering[1]).relationer 
)::klassifikationRegistreringType
;

read_prev_klassifikation_reg:=ROW(
ROW(null,(read_prev_klassifikation.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_klassifikation.registrering[1]).tilsPubliceret ,
(read_prev_klassifikation.registrering[1]).attrEgenskaber ,
(read_prev_klassifikation.registrering[1]).relationer 
)::klassifikationRegistreringType
;


IF read_prev_klassifikation_reg=read_new_klassifikation_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_klassifikation_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_klassifikation_reg);
  RAISE EXCEPTION 'Aborted updating klassifikation with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',klassifikation_uuid,to_json(read_new_klassifikation_reg),to_json(read_prev_klassifikation_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_klassifikation_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_klassifikation(klassifikation_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber klassifikationegenskaberattrtype[], tilspubliceret klassifikationpublicerettilstype[], relationer klassifikationrelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr klassifikationregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_loghaendelse(uuid, uuid, text, livscykluskode, loghaendelseegenskaberattrtype[], loghaendelsegyldighedtilstype[], loghaendelserelationtype[], timestamp with time zone, loghaendelseregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_loghaendelse(loghaendelse_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber loghaendelseegenskaberattrtype[], tilsgyldighed loghaendelsegyldighedtilstype[], relationer loghaendelserelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr loghaendelseregistreringtype[] DEFAULT NULL::loghaendelseregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_loghaendelse LoghaendelseType;
  read_prev_loghaendelse LoghaendelseType;
  read_new_loghaendelse_reg LoghaendelseRegistreringType;
  read_prev_loghaendelse_reg LoghaendelseRegistreringType;
  new_loghaendelse_registrering loghaendelse_registrering;
  prev_loghaendelse_registrering loghaendelse_registrering;
  loghaendelse_relation_navn LoghaendelseRelationKode;
  attrEgenskaberObj LoghaendelseEgenskaberAttrType;
  auth_filtered_uuids uuid[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from loghaendelse a join loghaendelse_registrering b on b.loghaendelse_id=a.id  where a.id=loghaendelse_uuid) THEN
   RAISE EXCEPTION 'Unable to update loghaendelse with uuid [%], being unable to find any previous registrations.',loghaendelse_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM loghaendelse a
WHERE a.id=loghaendelse_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_loghaendelse(array[loghaendelse_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[loghaendelse_uuid]) THEN
  RAISE EXCEPTION 'Unable to update loghaendelse with uuid [%]. Object does not met stipulated criteria:%',loghaendelse_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_loghaendelse_registrering := _as_create_loghaendelse_registrering(loghaendelse_uuid,livscykluskode, brugerref, note);
prev_loghaendelse_registrering := _as_get_prev_loghaendelse_registrering(new_loghaendelse_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_loghaendelse_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update loghaendelse with uuid [%], as the loghaendelse seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',loghaendelse_uuid,lostUpdatePreventionTZ,LOWER((prev_loghaendelse_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  --Ad 1)



      INSERT INTO loghaendelse_relation (
        loghaendelse_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      SELECT
        new_loghaendelse_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
      FROM unnest(relationer) as a
    ;

   
  --Ad 2)

  /**********************/
  -- 0..1 relations 
   

  FOREACH loghaendelse_relation_navn in array  ARRAY['objekt'::LoghaendelseRelationKode,'bruger'::LoghaendelseRelationKode,'brugerrolle'::LoghaendelseRelationKode]::LoghaendelseRelationKode[]
  LOOP

    INSERT INTO loghaendelse_relation (
        loghaendelse_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
    SELECT 
        new_loghaendelse_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM loghaendelse_relation b
      WHERE 
            b.loghaendelse_registrering_id=new_loghaendelse_registrering.id
            and
            b.rel_type=loghaendelse_relation_navn
    ) d
    JOIN loghaendelse_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.loghaendelse_registrering_id=prev_loghaendelse_registrering.id 
          and a.rel_type=loghaendelse_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations

  --We only have to check if there are any of the relations with the given name present in the new registration, otherwise copy the ones from the previous registration


  FOREACH loghaendelse_relation_navn in array ARRAY[]::LoghaendelseRelationKode[]
  LOOP

    IF NOT EXISTS  (SELECT 1 FROM loghaendelse_relation WHERE loghaendelse_registrering_id=new_loghaendelse_registrering.id and rel_type=loghaendelse_relation_navn) THEN

      INSERT INTO loghaendelse_relation (
            loghaendelse_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
          )
      SELECT 
            new_loghaendelse_registrering.id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
      FROM loghaendelse_relation
      WHERE loghaendelse_registrering_id=prev_loghaendelse_registrering.id 
      and rel_type=loghaendelse_relation_navn 
      ;

    END IF;
              
  END LOOP;


/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed,1),0)=0 THEN
--raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --loghaendelse_tils_gyldighed
  /********************************************/

  --Ad 1)

  INSERT INTO loghaendelse_tils_gyldighed (
          virkning,
            gyldighed,
              loghaendelse_registrering_id
  ) 
  SELECT
          a.virkning,
            a.gyldighed,
              new_loghaendelse_registrering.id
  FROM
  unnest(tilsGyldighed) as a
  ;
   

  --Ad 2

  INSERT INTO loghaendelse_tils_gyldighed (
          virkning,
            gyldighed,
              loghaendelse_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.gyldighed,
              new_loghaendelse_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the loghaendelse_tils_gyldighed of the new registrering to pass to _subtract_tstzrange_arr on the loghaendelse_tils_gyldighed of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM loghaendelse_tils_gyldighed b
      WHERE 
            b.loghaendelse_registrering_id=new_loghaendelse_registrering.id
  ) d
    JOIN loghaendelse_tils_gyldighed a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.loghaendelse_registrering_id=prev_loghaendelse_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--loghaendelse_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrLoghaendelseObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.service,a.klasse,a.tidspunkt,a.operation,a.objekttype,a.returkode,a.returtekst,a.note, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update loghaendelse with uuid [%], as the loghaendelse have overlapping virknings in the given egenskaber array :%',loghaendelse_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).service is null OR 
   (attrEgenskaberObj).klasse is null OR 
   (attrEgenskaberObj).tidspunkt is null OR 
   (attrEgenskaberObj).operation is null OR 
   (attrEgenskaberObj).objekttype is null OR 
   (attrEgenskaberObj).returkode is null OR 
   (attrEgenskaberObj).returtekst is null OR 
   (attrEgenskaberObj).note is null 
  THEN

  INSERT INTO
  loghaendelse_attr_egenskaber
  (
    service,klasse,tidspunkt,operation,objekttype,returkode,returtekst,note
    ,virkning
    ,loghaendelse_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.service,a.service),
    coalesce(attrEgenskaberObj.klasse,a.klasse),
    coalesce(attrEgenskaberObj.tidspunkt,a.tidspunkt),
    coalesce(attrEgenskaberObj.operation,a.operation),
    coalesce(attrEgenskaberObj.objekttype,a.objekttype),
    coalesce(attrEgenskaberObj.returkode,a.returkode),
    coalesce(attrEgenskaberObj.returtekst,a.returtekst),
    coalesce(attrEgenskaberObj.note,a.note),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_loghaendelse_registrering.id
  FROM loghaendelse_attr_egenskaber a
  WHERE
    a.loghaendelse_registrering_id=prev_loghaendelse_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  loghaendelse_attr_egenskaber
  (
    service,klasse,tidspunkt,operation,objekttype,returkode,returtekst,note
    ,virkning
    ,loghaendelse_registrering_id
  )
  SELECT 
    attrEgenskaberObj.service, 
    attrEgenskaberObj.klasse, 
    attrEgenskaberObj.tidspunkt, 
    attrEgenskaberObj.operation, 
    attrEgenskaberObj.objekttype, 
    attrEgenskaberObj.returkode, 
    attrEgenskaberObj.returtekst, 
    attrEgenskaberObj.note,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_loghaendelse_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the loghaendelse_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM loghaendelse_attr_egenskaber b
      WHERE 
       b.loghaendelse_registrering_id=new_loghaendelse_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    loghaendelse_attr_egenskaber
    (
    service,klasse,tidspunkt,operation,objekttype,returkode,returtekst,note
    ,virkning
    ,loghaendelse_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.service, 
    attrEgenskaberObj.klasse, 
    attrEgenskaberObj.tidspunkt, 
    attrEgenskaberObj.operation, 
    attrEgenskaberObj.objekttype, 
    attrEgenskaberObj.returkode, 
    attrEgenskaberObj.returtekst, 
    attrEgenskaberObj.note,
    attrEgenskaberObj.virkning,
    new_loghaendelse_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO loghaendelse_attr_egenskaber (
    service,klasse,tidspunkt,operation,objekttype,returkode,returtekst,note
    ,virkning
    ,loghaendelse_registrering_id
)
SELECT
      a.service,
      a.klasse,
      a.tidspunkt,
      a.operation,
      a.objekttype,
      a.returkode,
      a.returtekst,
      a.note,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_loghaendelse_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the loghaendelse_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the loghaendelse_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM loghaendelse_attr_egenskaber b
    WHERE 
          b.loghaendelse_registrering_id=new_loghaendelse_registrering.id
) d
  JOIN loghaendelse_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.loghaendelse_registrering_id=prev_loghaendelse_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_loghaendelse:=as_read_loghaendelse(loghaendelse_uuid, (new_loghaendelse_registrering.registrering).timeperiod,null);
read_prev_loghaendelse:=as_read_loghaendelse(loghaendelse_uuid, (prev_loghaendelse_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_loghaendelse.registrering[1].registrering).TimePeriod)=lower((new_loghaendelse_registrering.registrering).TimePeriod) AND lower((read_prev_loghaendelse.registrering[1].registrering).TimePeriod)=lower((prev_loghaendelse_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating loghaendelse with id [%]: The ordering of as_list_loghaendelse should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',loghaendelse_uuid,to_json(new_loghaendelse_registrering),to_json(read_new_loghaendelse.registrering[1].registrering),to_json(prev_loghaendelse_registrering),to_json(prev_new_loghaendelse.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_loghaendelse_reg:=ROW(
ROW(null,(read_new_loghaendelse.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_loghaendelse.registrering[1]).tilsGyldighed ,
(read_new_loghaendelse.registrering[1]).attrEgenskaber ,
(read_new_loghaendelse.registrering[1]).relationer 
)::loghaendelseRegistreringType
;

read_prev_loghaendelse_reg:=ROW(
ROW(null,(read_prev_loghaendelse.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_loghaendelse.registrering[1]).tilsGyldighed ,
(read_prev_loghaendelse.registrering[1]).attrEgenskaber ,
(read_prev_loghaendelse.registrering[1]).relationer 
)::loghaendelseRegistreringType
;


IF read_prev_loghaendelse_reg=read_new_loghaendelse_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_loghaendelse_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_loghaendelse_reg);
  RAISE EXCEPTION 'Aborted updating loghaendelse with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',loghaendelse_uuid,to_json(read_new_loghaendelse_reg),to_json(read_prev_loghaendelse_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_loghaendelse_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_loghaendelse(loghaendelse_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber loghaendelseegenskaberattrtype[], tilsgyldighed loghaendelsegyldighedtilstype[], relationer loghaendelserelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr loghaendelseregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_organisation(uuid, uuid, text, livscykluskode, organisationegenskaberattrtype[], organisationgyldighedtilstype[], organisationrelationtype[], timestamp with time zone, organisationregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_organisation(organisation_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber organisationegenskaberattrtype[], tilsgyldighed organisationgyldighedtilstype[], relationer organisationrelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr organisationregistreringtype[] DEFAULT NULL::organisationregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_organisation OrganisationType;
  read_prev_organisation OrganisationType;
  read_new_organisation_reg OrganisationRegistreringType;
  read_prev_organisation_reg OrganisationRegistreringType;
  new_organisation_registrering organisation_registrering;
  prev_organisation_registrering organisation_registrering;
  organisation_relation_navn OrganisationRelationKode;
  attrEgenskaberObj OrganisationEgenskaberAttrType;
  auth_filtered_uuids uuid[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from organisation a join organisation_registrering b on b.organisation_id=a.id  where a.id=organisation_uuid) THEN
   RAISE EXCEPTION 'Unable to update organisation with uuid [%], being unable to find any previous registrations.',organisation_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM organisation a
WHERE a.id=organisation_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisation(array[organisation_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[organisation_uuid]) THEN
  RAISE EXCEPTION 'Unable to update organisation with uuid [%]. Object does not met stipulated criteria:%',organisation_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_organisation_registrering := _as_create_organisation_registrering(organisation_uuid,livscykluskode, brugerref, note);
prev_organisation_registrering := _as_get_prev_organisation_registrering(new_organisation_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_organisation_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update organisation with uuid [%], as the organisation seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',organisation_uuid,lostUpdatePreventionTZ,LOWER((prev_organisation_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  --Ad 1)



      INSERT INTO organisation_relation (
        organisation_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      SELECT
        new_organisation_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
      FROM unnest(relationer) as a
    ;

   
  --Ad 2)

  /**********************/
  -- 0..1 relations 
   

  FOREACH organisation_relation_navn in array  ARRAY['branche'::OrganisationRelationKode,'myndighed'::OrganisationRelationKode,'myndighedstype'::OrganisationRelationKode,'overordnet'::OrganisationRelationKode,'produktionsenhed'::OrganisationRelationKode,'skatteenhed'::OrganisationRelationKode,'tilhoerer'::OrganisationRelationKode,'virksomhed'::OrganisationRelationKode,'virksomhedstype'::OrganisationRelationKode]::OrganisationRelationKode[]
  LOOP

    INSERT INTO organisation_relation (
        organisation_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
    SELECT 
        new_organisation_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM organisation_relation b
      WHERE 
            b.organisation_registrering_id=new_organisation_registrering.id
            and
            b.rel_type=organisation_relation_navn
    ) d
    JOIN organisation_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.organisation_registrering_id=prev_organisation_registrering.id 
          and a.rel_type=organisation_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations

  --We only have to check if there are any of the relations with the given name present in the new registration, otherwise copy the ones from the previous registration


  FOREACH organisation_relation_navn in array ARRAY['adresser'::OrganisationRelationKode,'ansatte'::OrganisationRelationKode,'opgaver'::OrganisationRelationKode,'tilknyttedebrugere'::OrganisationRelationKode,'tilknyttedeenheder'::OrganisationRelationKode,'tilknyttedefunktioner'::OrganisationRelationKode,'tilknyttedeinteressefaellesskaber'::OrganisationRelationKode,'tilknyttedeorganisationer'::OrganisationRelationKode,'tilknyttedepersoner'::OrganisationRelationKode,'tilknyttedeitsystemer'::OrganisationRelationKode]::OrganisationRelationKode[]
  LOOP

    IF NOT EXISTS  (SELECT 1 FROM organisation_relation WHERE organisation_registrering_id=new_organisation_registrering.id and rel_type=organisation_relation_navn) THEN

      INSERT INTO organisation_relation (
            organisation_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
          )
      SELECT 
            new_organisation_registrering.id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
      FROM organisation_relation
      WHERE organisation_registrering_id=prev_organisation_registrering.id 
      and rel_type=organisation_relation_navn 
      ;

    END IF;
              
  END LOOP;


/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed,1),0)=0 THEN
--raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --organisation_tils_gyldighed
  /********************************************/

  --Ad 1)

  INSERT INTO organisation_tils_gyldighed (
          virkning,
            gyldighed,
              organisation_registrering_id
  ) 
  SELECT
          a.virkning,
            a.gyldighed,
              new_organisation_registrering.id
  FROM
  unnest(tilsGyldighed) as a
  ;
   

  --Ad 2

  INSERT INTO organisation_tils_gyldighed (
          virkning,
            gyldighed,
              organisation_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.gyldighed,
              new_organisation_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the organisation_tils_gyldighed of the new registrering to pass to _subtract_tstzrange_arr on the organisation_tils_gyldighed of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM organisation_tils_gyldighed b
      WHERE 
            b.organisation_registrering_id=new_organisation_registrering.id
  ) d
    JOIN organisation_tils_gyldighed a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.organisation_registrering_id=prev_organisation_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--organisation_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrOrganisationObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.organisationsnavn, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update organisation with uuid [%], as the organisation have overlapping virknings in the given egenskaber array :%',organisation_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).organisationsnavn is null 
  THEN

  INSERT INTO
  organisation_attr_egenskaber
  (
    brugervendtnoegle,organisationsnavn
    ,virkning
    ,organisation_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.organisationsnavn,a.organisationsnavn),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_organisation_registrering.id
  FROM organisation_attr_egenskaber a
  WHERE
    a.organisation_registrering_id=prev_organisation_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  organisation_attr_egenskaber
  (
    brugervendtnoegle,organisationsnavn
    ,virkning
    ,organisation_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.organisationsnavn,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_organisation_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the organisation_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM organisation_attr_egenskaber b
      WHERE 
       b.organisation_registrering_id=new_organisation_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    organisation_attr_egenskaber
    (
    brugervendtnoegle,organisationsnavn
    ,virkning
    ,organisation_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.organisationsnavn,
    attrEgenskaberObj.virkning,
    new_organisation_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO organisation_attr_egenskaber (
    brugervendtnoegle,organisationsnavn
    ,virkning
    ,organisation_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.organisationsnavn,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_organisation_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the organisation_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the organisation_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM organisation_attr_egenskaber b
    WHERE 
          b.organisation_registrering_id=new_organisation_registrering.id
) d
  JOIN organisation_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.organisation_registrering_id=prev_organisation_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_organisation:=as_read_organisation(organisation_uuid, (new_organisation_registrering.registrering).timeperiod,null);
read_prev_organisation:=as_read_organisation(organisation_uuid, (prev_organisation_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_organisation.registrering[1].registrering).TimePeriod)=lower((new_organisation_registrering.registrering).TimePeriod) AND lower((read_prev_organisation.registrering[1].registrering).TimePeriod)=lower((prev_organisation_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating organisation with id [%]: The ordering of as_list_organisation should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',organisation_uuid,to_json(new_organisation_registrering),to_json(read_new_organisation.registrering[1].registrering),to_json(prev_organisation_registrering),to_json(prev_new_organisation.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_organisation_reg:=ROW(
ROW(null,(read_new_organisation.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_organisation.registrering[1]).tilsGyldighed ,
(read_new_organisation.registrering[1]).attrEgenskaber ,
(read_new_organisation.registrering[1]).relationer 
)::organisationRegistreringType
;

read_prev_organisation_reg:=ROW(
ROW(null,(read_prev_organisation.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_organisation.registrering[1]).tilsGyldighed ,
(read_prev_organisation.registrering[1]).attrEgenskaber ,
(read_prev_organisation.registrering[1]).relationer 
)::organisationRegistreringType
;


IF read_prev_organisation_reg=read_new_organisation_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_organisation_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_organisation_reg);
  RAISE EXCEPTION 'Aborted updating organisation with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',organisation_uuid,to_json(read_new_organisation_reg),to_json(read_prev_organisation_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_organisation_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_organisation(organisation_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber organisationegenskaberattrtype[], tilsgyldighed organisationgyldighedtilstype[], relationer organisationrelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr organisationregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_organisationenhed(uuid, uuid, text, livscykluskode, organisationenhedegenskaberattrtype[], organisationenhedgyldighedtilstype[], organisationenhedrelationtype[], timestamp with time zone, organisationenhedregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_organisationenhed(organisationenhed_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber organisationenhedegenskaberattrtype[], tilsgyldighed organisationenhedgyldighedtilstype[], relationer organisationenhedrelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr organisationenhedregistreringtype[] DEFAULT NULL::organisationenhedregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_organisationenhed OrganisationenhedType;
  read_prev_organisationenhed OrganisationenhedType;
  read_new_organisationenhed_reg OrganisationenhedRegistreringType;
  read_prev_organisationenhed_reg OrganisationenhedRegistreringType;
  new_organisationenhed_registrering organisationenhed_registrering;
  prev_organisationenhed_registrering organisationenhed_registrering;
  organisationenhed_relation_navn OrganisationenhedRelationKode;
  attrEgenskaberObj OrganisationenhedEgenskaberAttrType;
  auth_filtered_uuids uuid[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from organisationenhed a join organisationenhed_registrering b on b.organisationenhed_id=a.id  where a.id=organisationenhed_uuid) THEN
   RAISE EXCEPTION 'Unable to update organisationenhed with uuid [%], being unable to find any previous registrations.',organisationenhed_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM organisationenhed a
WHERE a.id=organisationenhed_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationenhed(array[organisationenhed_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[organisationenhed_uuid]) THEN
  RAISE EXCEPTION 'Unable to update organisationenhed with uuid [%]. Object does not met stipulated criteria:%',organisationenhed_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_organisationenhed_registrering := _as_create_organisationenhed_registrering(organisationenhed_uuid,livscykluskode, brugerref, note);
prev_organisationenhed_registrering := _as_get_prev_organisationenhed_registrering(new_organisationenhed_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_organisationenhed_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update organisationenhed with uuid [%], as the organisationenhed seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',organisationenhed_uuid,lostUpdatePreventionTZ,LOWER((prev_organisationenhed_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  --Ad 1)



      INSERT INTO organisationenhed_relation (
        organisationenhed_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      SELECT
        new_organisationenhed_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
      FROM unnest(relationer) as a
    ;

   
  --Ad 2)

  /**********************/
  -- 0..1 relations 
   

  FOREACH organisationenhed_relation_navn in array  ARRAY['branche'::OrganisationenhedRelationKode,'enhedstype'::OrganisationenhedRelationKode,'overordnet'::OrganisationenhedRelationKode,'produktionsenhed'::OrganisationenhedRelationKode,'skatteenhed'::OrganisationenhedRelationKode,'tilhoerer'::OrganisationenhedRelationKode]::OrganisationenhedRelationKode[]
  LOOP

    INSERT INTO organisationenhed_relation (
        organisationenhed_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
    SELECT 
        new_organisationenhed_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM organisationenhed_relation b
      WHERE 
            b.organisationenhed_registrering_id=new_organisationenhed_registrering.id
            and
            b.rel_type=organisationenhed_relation_navn
    ) d
    JOIN organisationenhed_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.organisationenhed_registrering_id=prev_organisationenhed_registrering.id 
          and a.rel_type=organisationenhed_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations

  --We only have to check if there are any of the relations with the given name present in the new registration, otherwise copy the ones from the previous registration


  FOREACH organisationenhed_relation_navn in array ARRAY['adresser'::OrganisationenhedRelationKode,'ansatte'::OrganisationenhedRelationKode,'opgaver'::OrganisationenhedRelationKode,'tilknyttedebrugere'::OrganisationenhedRelationKode,'tilknyttedeenheder'::OrganisationenhedRelationKode,'tilknyttedefunktioner'::OrganisationenhedRelationKode,'tilknyttedeinteressefaellesskaber'::OrganisationenhedRelationKode,'tilknyttedeorganisationer'::OrganisationenhedRelationKode,'tilknyttedepersoner'::OrganisationenhedRelationKode,'tilknyttedeitsystemer'::OrganisationenhedRelationKode]::OrganisationenhedRelationKode[]
  LOOP

    IF NOT EXISTS  (SELECT 1 FROM organisationenhed_relation WHERE organisationenhed_registrering_id=new_organisationenhed_registrering.id and rel_type=organisationenhed_relation_navn) THEN

      INSERT INTO organisationenhed_relation (
            organisationenhed_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
          )
      SELECT 
            new_organisationenhed_registrering.id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
      FROM organisationenhed_relation
      WHERE organisationenhed_registrering_id=prev_organisationenhed_registrering.id 
      and rel_type=organisationenhed_relation_navn 
      ;

    END IF;
              
  END LOOP;


/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed,1),0)=0 THEN
--raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --organisationenhed_tils_gyldighed
  /********************************************/

  --Ad 1)

  INSERT INTO organisationenhed_tils_gyldighed (
          virkning,
            gyldighed,
              organisationenhed_registrering_id
  ) 
  SELECT
          a.virkning,
            a.gyldighed,
              new_organisationenhed_registrering.id
  FROM
  unnest(tilsGyldighed) as a
  ;
   

  --Ad 2

  INSERT INTO organisationenhed_tils_gyldighed (
          virkning,
            gyldighed,
              organisationenhed_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.gyldighed,
              new_organisationenhed_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the organisationenhed_tils_gyldighed of the new registrering to pass to _subtract_tstzrange_arr on the organisationenhed_tils_gyldighed of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM organisationenhed_tils_gyldighed b
      WHERE 
            b.organisationenhed_registrering_id=new_organisationenhed_registrering.id
  ) d
    JOIN organisationenhed_tils_gyldighed a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.organisationenhed_registrering_id=prev_organisationenhed_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--organisationenhed_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrOrganisationenhedObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.enhedsnavn, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update organisationenhed with uuid [%], as the organisationenhed have overlapping virknings in the given egenskaber array :%',organisationenhed_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).enhedsnavn is null 
  THEN

  INSERT INTO
  organisationenhed_attr_egenskaber
  (
    brugervendtnoegle,enhedsnavn
    ,virkning
    ,organisationenhed_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.enhedsnavn,a.enhedsnavn),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_organisationenhed_registrering.id
  FROM organisationenhed_attr_egenskaber a
  WHERE
    a.organisationenhed_registrering_id=prev_organisationenhed_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  organisationenhed_attr_egenskaber
  (
    brugervendtnoegle,enhedsnavn
    ,virkning
    ,organisationenhed_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.enhedsnavn,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_organisationenhed_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the organisationenhed_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM organisationenhed_attr_egenskaber b
      WHERE 
       b.organisationenhed_registrering_id=new_organisationenhed_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    organisationenhed_attr_egenskaber
    (
    brugervendtnoegle,enhedsnavn
    ,virkning
    ,organisationenhed_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.enhedsnavn,
    attrEgenskaberObj.virkning,
    new_organisationenhed_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO organisationenhed_attr_egenskaber (
    brugervendtnoegle,enhedsnavn
    ,virkning
    ,organisationenhed_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.enhedsnavn,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_organisationenhed_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the organisationenhed_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the organisationenhed_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM organisationenhed_attr_egenskaber b
    WHERE 
          b.organisationenhed_registrering_id=new_organisationenhed_registrering.id
) d
  JOIN organisationenhed_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.organisationenhed_registrering_id=prev_organisationenhed_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_organisationenhed:=as_read_organisationenhed(organisationenhed_uuid, (new_organisationenhed_registrering.registrering).timeperiod,null);
read_prev_organisationenhed:=as_read_organisationenhed(organisationenhed_uuid, (prev_organisationenhed_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_organisationenhed.registrering[1].registrering).TimePeriod)=lower((new_organisationenhed_registrering.registrering).TimePeriod) AND lower((read_prev_organisationenhed.registrering[1].registrering).TimePeriod)=lower((prev_organisationenhed_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating organisationenhed with id [%]: The ordering of as_list_organisationenhed should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',organisationenhed_uuid,to_json(new_organisationenhed_registrering),to_json(read_new_organisationenhed.registrering[1].registrering),to_json(prev_organisationenhed_registrering),to_json(prev_new_organisationenhed.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_organisationenhed_reg:=ROW(
ROW(null,(read_new_organisationenhed.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_organisationenhed.registrering[1]).tilsGyldighed ,
(read_new_organisationenhed.registrering[1]).attrEgenskaber ,
(read_new_organisationenhed.registrering[1]).relationer 
)::organisationenhedRegistreringType
;

read_prev_organisationenhed_reg:=ROW(
ROW(null,(read_prev_organisationenhed.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_organisationenhed.registrering[1]).tilsGyldighed ,
(read_prev_organisationenhed.registrering[1]).attrEgenskaber ,
(read_prev_organisationenhed.registrering[1]).relationer 
)::organisationenhedRegistreringType
;


IF read_prev_organisationenhed_reg=read_new_organisationenhed_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_organisationenhed_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_organisationenhed_reg);
  RAISE EXCEPTION 'Aborted updating organisationenhed with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',organisationenhed_uuid,to_json(read_new_organisationenhed_reg),to_json(read_prev_organisationenhed_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_organisationenhed_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_organisationenhed(organisationenhed_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber organisationenhedegenskaberattrtype[], tilsgyldighed organisationenhedgyldighedtilstype[], relationer organisationenhedrelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr organisationenhedregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_organisationfunktion(uuid, uuid, text, livscykluskode, organisationfunktionegenskaberattrtype[], organisationfunktiongyldighedtilstype[], organisationfunktionrelationtype[], timestamp with time zone, organisationfunktionregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_organisationfunktion(organisationfunktion_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber organisationfunktionegenskaberattrtype[], tilsgyldighed organisationfunktiongyldighedtilstype[], relationer organisationfunktionrelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr organisationfunktionregistreringtype[] DEFAULT NULL::organisationfunktionregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_organisationfunktion OrganisationfunktionType;
  read_prev_organisationfunktion OrganisationfunktionType;
  read_new_organisationfunktion_reg OrganisationfunktionRegistreringType;
  read_prev_organisationfunktion_reg OrganisationfunktionRegistreringType;
  new_organisationfunktion_registrering organisationfunktion_registrering;
  prev_organisationfunktion_registrering organisationfunktion_registrering;
  organisationfunktion_relation_navn OrganisationfunktionRelationKode;
  attrEgenskaberObj OrganisationfunktionEgenskaberAttrType;
  auth_filtered_uuids uuid[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from organisationfunktion a join organisationfunktion_registrering b on b.organisationfunktion_id=a.id  where a.id=organisationfunktion_uuid) THEN
   RAISE EXCEPTION 'Unable to update organisationfunktion with uuid [%], being unable to find any previous registrations.',organisationfunktion_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM organisationfunktion a
WHERE a.id=organisationfunktion_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationfunktion(array[organisationfunktion_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[organisationfunktion_uuid]) THEN
  RAISE EXCEPTION 'Unable to update organisationfunktion with uuid [%]. Object does not met stipulated criteria:%',organisationfunktion_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_organisationfunktion_registrering := _as_create_organisationfunktion_registrering(organisationfunktion_uuid,livscykluskode, brugerref, note);
prev_organisationfunktion_registrering := _as_get_prev_organisationfunktion_registrering(new_organisationfunktion_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_organisationfunktion_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update organisationfunktion with uuid [%], as the organisationfunktion seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',organisationfunktion_uuid,lostUpdatePreventionTZ,LOWER((prev_organisationfunktion_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  --Ad 1)



      INSERT INTO organisationfunktion_relation (
        organisationfunktion_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      SELECT
        new_organisationfunktion_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
      FROM unnest(relationer) as a
    ;

   
  --Ad 2)

  /**********************/
  -- 0..1 relations 
   

  FOREACH organisationfunktion_relation_navn in array  ARRAY['organisatoriskfunktionstype'::OrganisationfunktionRelationKode]::OrganisationfunktionRelationKode[]
  LOOP

    INSERT INTO organisationfunktion_relation (
        organisationfunktion_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
    SELECT 
        new_organisationfunktion_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM organisationfunktion_relation b
      WHERE 
            b.organisationfunktion_registrering_id=new_organisationfunktion_registrering.id
            and
            b.rel_type=organisationfunktion_relation_navn
    ) d
    JOIN organisationfunktion_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.organisationfunktion_registrering_id=prev_organisationfunktion_registrering.id 
          and a.rel_type=organisationfunktion_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations

  --We only have to check if there are any of the relations with the given name present in the new registration, otherwise copy the ones from the previous registration


  FOREACH organisationfunktion_relation_navn in array ARRAY['adresser'::OrganisationfunktionRelationKode,'opgaver'::OrganisationfunktionRelationKode,'tilknyttedebrugere'::OrganisationfunktionRelationKode,'tilknyttedeenheder'::OrganisationfunktionRelationKode,'tilknyttedeorganisationer'::OrganisationfunktionRelationKode,'tilknyttedeitsystemer'::OrganisationfunktionRelationKode,'tilknyttedeinteressefaellesskaber'::OrganisationfunktionRelationKode,'tilknyttedepersoner'::OrganisationfunktionRelationKode]::OrganisationfunktionRelationKode[]
  LOOP

    IF NOT EXISTS  (SELECT 1 FROM organisationfunktion_relation WHERE organisationfunktion_registrering_id=new_organisationfunktion_registrering.id and rel_type=organisationfunktion_relation_navn) THEN

      INSERT INTO organisationfunktion_relation (
            organisationfunktion_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
          )
      SELECT 
            new_organisationfunktion_registrering.id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type
      FROM organisationfunktion_relation
      WHERE organisationfunktion_registrering_id=prev_organisationfunktion_registrering.id 
      and rel_type=organisationfunktion_relation_navn 
      ;

    END IF;
              
  END LOOP;


/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed,1),0)=0 THEN
--raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --organisationfunktion_tils_gyldighed
  /********************************************/

  --Ad 1)

  INSERT INTO organisationfunktion_tils_gyldighed (
          virkning,
            gyldighed,
              organisationfunktion_registrering_id
  ) 
  SELECT
          a.virkning,
            a.gyldighed,
              new_organisationfunktion_registrering.id
  FROM
  unnest(tilsGyldighed) as a
  ;
   

  --Ad 2

  INSERT INTO organisationfunktion_tils_gyldighed (
          virkning,
            gyldighed,
              organisationfunktion_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.gyldighed,
              new_organisationfunktion_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the organisationfunktion_tils_gyldighed of the new registrering to pass to _subtract_tstzrange_arr on the organisationfunktion_tils_gyldighed of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM organisationfunktion_tils_gyldighed b
      WHERE 
            b.organisationfunktion_registrering_id=new_organisationfunktion_registrering.id
  ) d
    JOIN organisationfunktion_tils_gyldighed a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.organisationfunktion_registrering_id=prev_organisationfunktion_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--organisationfunktion_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrOrganisationfunktionObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.funktionsnavn, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update organisationfunktion with uuid [%], as the organisationfunktion have overlapping virknings in the given egenskaber array :%',organisationfunktion_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).funktionsnavn is null 
  THEN

  INSERT INTO
  organisationfunktion_attr_egenskaber
  (
    brugervendtnoegle,funktionsnavn
    ,virkning
    ,organisationfunktion_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.funktionsnavn,a.funktionsnavn),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_organisationfunktion_registrering.id
  FROM organisationfunktion_attr_egenskaber a
  WHERE
    a.organisationfunktion_registrering_id=prev_organisationfunktion_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  organisationfunktion_attr_egenskaber
  (
    brugervendtnoegle,funktionsnavn
    ,virkning
    ,organisationfunktion_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.funktionsnavn,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_organisationfunktion_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the organisationfunktion_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM organisationfunktion_attr_egenskaber b
      WHERE 
       b.organisationfunktion_registrering_id=new_organisationfunktion_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    organisationfunktion_attr_egenskaber
    (
    brugervendtnoegle,funktionsnavn
    ,virkning
    ,organisationfunktion_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.funktionsnavn,
    attrEgenskaberObj.virkning,
    new_organisationfunktion_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO organisationfunktion_attr_egenskaber (
    brugervendtnoegle,funktionsnavn
    ,virkning
    ,organisationfunktion_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.funktionsnavn,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_organisationfunktion_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the organisationfunktion_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the organisationfunktion_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM organisationfunktion_attr_egenskaber b
    WHERE 
          b.organisationfunktion_registrering_id=new_organisationfunktion_registrering.id
) d
  JOIN organisationfunktion_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.organisationfunktion_registrering_id=prev_organisationfunktion_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_organisationfunktion:=as_read_organisationfunktion(organisationfunktion_uuid, (new_organisationfunktion_registrering.registrering).timeperiod,null);
read_prev_organisationfunktion:=as_read_organisationfunktion(organisationfunktion_uuid, (prev_organisationfunktion_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_organisationfunktion.registrering[1].registrering).TimePeriod)=lower((new_organisationfunktion_registrering.registrering).TimePeriod) AND lower((read_prev_organisationfunktion.registrering[1].registrering).TimePeriod)=lower((prev_organisationfunktion_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating organisationfunktion with id [%]: The ordering of as_list_organisationfunktion should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',organisationfunktion_uuid,to_json(new_organisationfunktion_registrering),to_json(read_new_organisationfunktion.registrering[1].registrering),to_json(prev_organisationfunktion_registrering),to_json(prev_new_organisationfunktion.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_organisationfunktion_reg:=ROW(
ROW(null,(read_new_organisationfunktion.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_organisationfunktion.registrering[1]).tilsGyldighed ,
(read_new_organisationfunktion.registrering[1]).attrEgenskaber ,
(read_new_organisationfunktion.registrering[1]).relationer 
)::organisationfunktionRegistreringType
;

read_prev_organisationfunktion_reg:=ROW(
ROW(null,(read_prev_organisationfunktion.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_organisationfunktion.registrering[1]).tilsGyldighed ,
(read_prev_organisationfunktion.registrering[1]).attrEgenskaber ,
(read_prev_organisationfunktion.registrering[1]).relationer 
)::organisationfunktionRegistreringType
;


IF read_prev_organisationfunktion_reg=read_new_organisationfunktion_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_organisationfunktion_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_organisationfunktion_reg);
  RAISE EXCEPTION 'Aborted updating organisationfunktion with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',organisationfunktion_uuid,to_json(read_new_organisationfunktion_reg),to_json(read_prev_organisationfunktion_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_organisationfunktion_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_organisationfunktion(organisationfunktion_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber organisationfunktionegenskaberattrtype[], tilsgyldighed organisationfunktiongyldighedtilstype[], relationer organisationfunktionrelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr organisationfunktionregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_sag(uuid, uuid, text, livscykluskode, sagegenskaberattrtype[], sagfremdrifttilstype[], sagrelationtype[], timestamp with time zone, sagregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_sag(sag_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber sagegenskaberattrtype[], tilsfremdrift sagfremdrifttilstype[], relationer sagrelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr sagregistreringtype[] DEFAULT NULL::sagregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_sag SagType;
  read_prev_sag SagType;
  read_new_sag_reg SagRegistreringType;
  read_prev_sag_reg SagRegistreringType;
  new_sag_registrering sag_registrering;
  prev_sag_registrering sag_registrering;
  sag_relation_navn SagRelationKode;
  attrEgenskaberObj SagEgenskaberAttrType;
  auth_filtered_uuids uuid[];
  rel_type_max_index_prev_rev int;
  rel_type_max_index_arr _SagRelationMaxIndex[];
  sag_rel_type_cardinality_unlimited SagRelationKode[]:=ARRAY['andetarkiv'::SagRelationKode,'andrebehandlere'::SagRelationKode,'sekundaerpart'::SagRelationKode,'andresager'::SagRelationKode,'byggeri'::SagRelationKode,'fredning'::SagRelationKode,'journalpost'::SagRelationKode]::SagRelationKode[];
  sag_uuid_underscores text;
  sag_rel_seq_name text;

BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from sag a join sag_registrering b on b.sag_id=a.id  where a.id=sag_uuid) THEN
   RAISE EXCEPTION 'Unable to update sag with uuid [%], being unable to find any previous registrations.',sag_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM sag a
WHERE a.id=sag_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_sag(array[sag_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[sag_uuid]) THEN
  RAISE EXCEPTION 'Unable to update sag with uuid [%]. Object does not met stipulated criteria:%',sag_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_sag_registrering := _as_create_sag_registrering(sag_uuid,livscykluskode, brugerref, note);
prev_sag_registrering := _as_get_prev_sag_registrering(new_sag_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_sag_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update sag with uuid [%], as the sag seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',sag_uuid,lostUpdatePreventionTZ,LOWER((prev_sag_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, with index values not included in this update. Please notice that for the logic to work,
  --  it is very important that the index sequences start with the max value for index of the same type in the previous registration

  --Ad 1)

--build array with the max index values of the different types of relations of the previous registration
SELECT array_agg(rel_type_max_index)::_SagRelationMaxIndex[] into rel_type_max_index_arr
FROM
(
  SELECT
  (ROW(rel_type,coalesce(max(rel_index),0))::_SagRelationMaxIndex) rel_type_max_index  
  FROM sag_relation a
  where a.sag_registrering_id=prev_sag_registrering.id
  and a.rel_type = any (sag_rel_type_cardinality_unlimited)
  group by rel_type
) as a
;


--Create temporary sequences
sag_uuid_underscores:=replace(sag_uuid::text, '-', '_');

FOREACH sag_relation_navn IN ARRAY (SELECT array_agg( DISTINCT a.RelType) FROM  unnest(relationer) a WHERE a.RelType = any (sag_rel_type_cardinality_unlimited))
  LOOP
  sag_rel_seq_name := 'sag_rel_' || sag_relation_navn::text || sag_uuid_underscores;

  rel_type_max_index_prev_rev:=null;

  SELECT 
    a.indeks into rel_type_max_index_prev_rev
  FROM
    unnest(rel_type_max_index_arr) a(relType,indeks)
  WHERE
    a.relType=sag_relation_navn
  ;
  
  IF rel_type_max_index_prev_rev IS NULL THEN
    rel_type_max_index_prev_rev:=0;
  END IF;

  EXECUTE 'CREATE TEMPORARY SEQUENCE ' || sag_rel_seq_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START ' ||  (rel_type_max_index_prev_rev+1)::text ||'
  CACHE 1;';

END LOOP;

      INSERT INTO sag_relation (
        sag_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type,
                    rel_index,
                      rel_type_spec,
                        journal_notat,
                          journal_dokument_attr
      )
      SELECT
        new_sag_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType,
                    CASE 
                    WHEN a.relType = any (sag_rel_type_cardinality_unlimited) THEN
                      CASE WHEN a.indeks IS NULL OR b.id IS NULL THEN --for new relations and relations with index given that is not found in prev registrering, we'll assign new index values 
                        nextval('sag_rel_' || a.relType::text || sag_uuid_underscores)
                      ELSE
                        a.indeks
                      END
                    ELSE
                    NULL
                    END,
                      CASE 
                        WHEN a.relType='journalpost' THEN a.relTypeSpec
                        ELSE
                        NULL
                      END,
                        CASE 
                          WHEN  
                            (NOT (a.journalNotat IS NULL)) 
                            AND
                            (
                              (a.journalNotat).titel IS NOT NULL
                              OR
                              (a.journalNotat).notat IS NOT NULL
                              OR
                              (a.journalNotat).format IS NOT NULL
                            )
                           THEN a.journalNotat
                          ELSE
                           NULL
                        END
                          ,CASE 
                            WHEN ( 
                                    (NOT a.journalDokumentAttr IS NULL)
                                    AND
                                    (
                                      (a.journalDokumentAttr).dokumenttitel IS NOT NULL
                                      OR
                                      (
                                        NOT ((a.journalDokumentAttr).offentlighedUndtaget IS NULL)
                                        AND
                                        (
                                          ((a.journalDokumentAttr).offentlighedUndtaget).AlternativTitel IS NOT NULL
                                          OR
                                          ((a.journalDokumentAttr).offentlighedUndtaget).Hjemmel IS NOT NULL
                                        )
                                      )
                                   )
                                 ) THEN a.journalDokumentAttr
                            ELSE
                            NULL
                          END
      FROM unnest(relationer) as a
      LEFT JOIN sag_relation b on a.relType = any (sag_rel_type_cardinality_unlimited) and b.sag_registrering_id=prev_sag_registrering.id and a.relType=b.rel_type and a.indeks=b.rel_index
    ;


--Drop temporary sequences
FOREACH sag_relation_navn IN ARRAY (SELECT array_agg( DISTINCT a.RelType) FROM  unnest(relationer) a WHERE a.RelType = any (sag_rel_type_cardinality_unlimited))
  LOOP
  sag_rel_seq_name := 'sag_rel_' || sag_relation_navn::text || sag_uuid_underscores;
  EXECUTE 'DROP  SEQUENCE ' || sag_rel_seq_name || ';';
END LOOP;


  --Ad 2)

  /**********************/
  -- 0..1 relations 
  --Please notice, that for 0..1 relations for Sag, we're ignoring index here, and handling it the same way, that is done for other object types (like Facet, Klasse etc). That is, you only make changes for the virkningsperiod that you explicitly specify (unless you delete all relations) 

  FOREACH sag_relation_navn in array  ARRAY['behandlingarkiv'::SagRelationKode,'afleveringsarkiv'::SagRelationKode,'primaerklasse'::SagRelationKode,'opgaveklasse'::SagRelationKode,'handlingsklasse'::SagRelationKode,'kontoklasse'::SagRelationKode,'sikkerhedsklasse'::SagRelationKode,'foelsomhedsklasse'::SagRelationKode,'indsatsklasse'::SagRelationKode,'ydelsesklasse'::SagRelationKode,'ejer'::SagRelationKode,'ansvarlig'::SagRelationKode,'primaerbehandler'::SagRelationKode,'udlaanttil'::SagRelationKode,'primaerpart'::SagRelationKode,'ydelsesmodtager'::SagRelationKode,'oversag'::SagRelationKode,'praecedens'::SagRelationKode,'afgiftsobjekt'::SagRelationKode,'ejendomsskat'::SagRelationKode]::SagRelationKode[]
  LOOP

    INSERT INTO sag_relation (
        sag_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type,
                    rel_index,
                      rel_type_spec,
                        journal_notat,
                          journal_dokument_attr

      )
    SELECT 
        new_sag_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type,
                    NULL,--a.rel_index, rel_index is not to be used for 0..1 relations
                      a.rel_type_spec,
                        a.journal_notat,
                          a.journal_dokument_attr
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM sag_relation b
      WHERE 
            b.sag_registrering_id=new_sag_registrering.id
            and
            b.rel_type=sag_relation_navn
    ) d
    JOIN sag_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.sag_registrering_id=prev_sag_registrering.id 
          and a.rel_type=sag_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations
  
      INSERT INTO sag_relation (
            sag_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type,
                        rel_index,
                          rel_type_spec,
                            journal_notat,
                              journal_dokument_attr
          )
      SELECT 
            new_sag_registrering.id,
              a.virkning,
                a.rel_maal_uuid,
                  a.rel_maal_urn,
                    a.rel_type,
                      a.objekt_type,
                        a.rel_index,
                          a.rel_type_spec,
                            a.journal_notat,
                              a.journal_dokument_attr
      FROM sag_relation a
      LEFT JOIN sag_relation b on b.sag_registrering_id=new_sag_registrering.id and b.rel_type=a.rel_type and b.rel_index=a.rel_index
      WHERE a.sag_registrering_id=prev_sag_registrering.id 
      and a.rel_type = any (sag_rel_type_cardinality_unlimited)
      and b.id is null --don't transfer relations of prev. registrering, if the index was specified in data given to the/this update-function
      ;

/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsFremdrift IS NOT NULL AND coalesce(array_length(tilsFremdrift,1),0)=0 THEN
--raise debug 'Skipping [Fremdrift] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --sag_tils_fremdrift
  /********************************************/

  --Ad 1)

  INSERT INTO sag_tils_fremdrift (
          virkning,
            fremdrift,
              sag_registrering_id
  ) 
  SELECT
          a.virkning,
            a.fremdrift,
              new_sag_registrering.id
  FROM
  unnest(tilsFremdrift) as a
  ;
   

  --Ad 2

  INSERT INTO sag_tils_fremdrift (
          virkning,
            fremdrift,
              sag_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.fremdrift,
              new_sag_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the sag_tils_fremdrift of the new registrering to pass to _subtract_tstzrange_arr on the sag_tils_fremdrift of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM sag_tils_fremdrift b
      WHERE 
            b.sag_registrering_id=new_sag_registrering.id
  ) d
    JOIN sag_tils_fremdrift a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.sag_registrering_id=prev_sag_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--sag_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrSagObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.afleveret,a.beskrivelse,a.hjemmel,a.kassationskode,a.offentlighedundtaget,a.principiel,a.sagsnummer,a.titel, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update sag with uuid [%], as the sag have overlapping virknings in the given egenskaber array :%',sag_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).afleveret is null OR 
   (attrEgenskaberObj).beskrivelse is null OR 
   (attrEgenskaberObj).hjemmel is null OR 
   (attrEgenskaberObj).kassationskode is null OR 
   (attrEgenskaberObj).offentlighedundtaget is null OR 
   (attrEgenskaberObj).principiel is null OR 
   (attrEgenskaberObj).sagsnummer is null OR 
   (attrEgenskaberObj).titel is null 
  THEN

  INSERT INTO
  sag_attr_egenskaber
  (
    brugervendtnoegle,afleveret,beskrivelse,hjemmel,kassationskode,offentlighedundtaget,principiel,sagsnummer,titel
    ,virkning
    ,sag_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle), 
    CASE WHEN (attrEgenskaberObj.afleveret).cleared THEN NULL 
    ELSE coalesce((attrEgenskaberObj.afleveret).value,a.afleveret)
    END,
    coalesce(attrEgenskaberObj.beskrivelse,a.beskrivelse),
    coalesce(attrEgenskaberObj.hjemmel,a.hjemmel),
    coalesce(attrEgenskaberObj.kassationskode,a.kassationskode),
    coalesce(attrEgenskaberObj.offentlighedundtaget,a.offentlighedundtaget), 
    CASE WHEN (attrEgenskaberObj.principiel).cleared THEN NULL 
    ELSE coalesce((attrEgenskaberObj.principiel).value,a.principiel)
    END,
    coalesce(attrEgenskaberObj.sagsnummer,a.sagsnummer),
    coalesce(attrEgenskaberObj.titel,a.titel),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_sag_registrering.id
  FROM sag_attr_egenskaber a
  WHERE
    a.sag_registrering_id=prev_sag_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  sag_attr_egenskaber
  (
    brugervendtnoegle,afleveret,beskrivelse,hjemmel,kassationskode,offentlighedundtaget,principiel,sagsnummer,titel
    ,virkning
    ,sag_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.afleveret, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.hjemmel, 
    attrEgenskaberObj.kassationskode, 
    attrEgenskaberObj.offentlighedundtaget, 
    attrEgenskaberObj.principiel, 
    attrEgenskaberObj.sagsnummer, 
    attrEgenskaberObj.titel,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_sag_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the sag_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM sag_attr_egenskaber b
      WHERE 
       b.sag_registrering_id=new_sag_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    sag_attr_egenskaber
    (
    brugervendtnoegle,afleveret,beskrivelse,hjemmel,kassationskode,offentlighedundtaget,principiel,sagsnummer,titel
    ,virkning
    ,sag_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.afleveret, 
    attrEgenskaberObj.beskrivelse, 
    attrEgenskaberObj.hjemmel, 
    attrEgenskaberObj.kassationskode, 
    attrEgenskaberObj.offentlighedundtaget, 
    attrEgenskaberObj.principiel, 
    attrEgenskaberObj.sagsnummer, 
    attrEgenskaberObj.titel,
    attrEgenskaberObj.virkning,
    new_sag_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO sag_attr_egenskaber (
    brugervendtnoegle,afleveret,beskrivelse,hjemmel,kassationskode,offentlighedundtaget,principiel,sagsnummer,titel
    ,virkning
    ,sag_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.afleveret,
      a.beskrivelse,
      a.hjemmel,
      a.kassationskode,
      a.offentlighedundtaget,
      a.principiel,
      a.sagsnummer,
      a.titel,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_sag_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the sag_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the sag_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM sag_attr_egenskaber b
    WHERE 
          b.sag_registrering_id=new_sag_registrering.id
) d
  JOIN sag_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.sag_registrering_id=prev_sag_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_sag:=as_read_sag(sag_uuid, (new_sag_registrering.registrering).timeperiod,null);
read_prev_sag:=as_read_sag(sag_uuid, (prev_sag_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_sag.registrering[1].registrering).TimePeriod)=lower((new_sag_registrering.registrering).TimePeriod) AND lower((read_prev_sag.registrering[1].registrering).TimePeriod)=lower((prev_sag_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating sag with id [%]: The ordering of as_list_sag should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',sag_uuid,to_json(new_sag_registrering),to_json(read_new_sag.registrering[1].registrering),to_json(prev_sag_registrering),to_json(prev_new_sag.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_sag_reg:=ROW(
ROW(null,(read_new_sag.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_sag.registrering[1]).tilsFremdrift ,
(read_new_sag.registrering[1]).attrEgenskaber ,
(read_new_sag.registrering[1]).relationer 
)::sagRegistreringType
;

read_prev_sag_reg:=ROW(
ROW(null,(read_prev_sag.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_sag.registrering[1]).tilsFremdrift ,
(read_prev_sag.registrering[1]).attrEgenskaber ,
(read_prev_sag.registrering[1]).relationer 
)::sagRegistreringType
;


IF read_prev_sag_reg=read_new_sag_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_sag_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_sag_reg);
  RAISE EXCEPTION 'Aborted updating sag with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',sag_uuid,to_json(read_new_sag_reg),to_json(read_prev_sag_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_sag_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_sag(sag_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber sagegenskaberattrtype[], tilsfremdrift sagfremdrifttilstype[], relationer sagrelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr sagregistreringtype[]) OWNER TO mox;

--
-- Name: as_update_tilstand(uuid, uuid, text, livscykluskode, tilstandegenskaberattrtype[], tilstandstatustilstype[], tilstandpublicerettilstype[], tilstandrelationtype[], timestamp with time zone, tilstandregistreringtype[]); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION as_update_tilstand(tilstand_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber tilstandegenskaberattrtype[], tilsstatus tilstandstatustilstype[], tilspubliceret tilstandpublicerettilstype[], relationer tilstandrelationtype[], lostupdatepreventiontz timestamp with time zone DEFAULT NULL::timestamp with time zone, auth_criteria_arr tilstandregistreringtype[] DEFAULT NULL::tilstandregistreringtype[]) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  read_new_tilstand TilstandType;
  read_prev_tilstand TilstandType;
  read_new_tilstand_reg TilstandRegistreringType;
  read_prev_tilstand_reg TilstandRegistreringType;
  new_tilstand_registrering tilstand_registrering;
  prev_tilstand_registrering tilstand_registrering;
  tilstand_relation_navn TilstandRelationKode;
  attrEgenskaberObj TilstandEgenskaberAttrType;
  auth_filtered_uuids uuid[];
  rel_type_max_index_prev_rev int;
  rel_type_max_index_arr _tilstandRelationMaxIndex[];
  tilstand_rel_type_cardinality_unlimited tilstandRelationKode[]:=ARRAY['tilstandsvaerdi'::TilstandRelationKode,'begrundelse'::TilstandRelationKode,'tilstandskvalitet'::TilstandRelationKode,'tilstandsvurdering'::TilstandRelationKode,'tilstandsaktoer'::TilstandRelationKode,'tilstandsudstyr'::TilstandRelationKode,'samtykke'::TilstandRelationKode,'tilstandsdokument'::TilstandRelationKode]::TilstandRelationKode[];
  tilstand_uuid_underscores text;
  tilstand_rel_seq_name text;
  tilstand_rel_type_cardinality_unlimited_present_in_argument tilstandRelationKode[];
BEGIN

--create a new registrering

IF NOT EXISTS (select a.id from tilstand a join tilstand_registrering b on b.tilstand_id=a.id  where a.id=tilstand_uuid) THEN
   RAISE EXCEPTION 'Unable to update tilstand with uuid [%], being unable to find any previous registrations.',tilstand_uuid USING ERRCODE = 'MO400';
END IF;

PERFORM a.id FROM tilstand a
WHERE a.id=tilstand_uuid
FOR UPDATE; --We synchronize concurrent invocations of as_updates of this particular object on a exclusive row lock. This lock will be held by the current transaction until it terminates.

/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_tilstand(array[tilstand_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[tilstand_uuid]) THEN
  RAISE EXCEPTION 'Unable to update tilstand with uuid [%]. Object does not met stipulated criteria:%',tilstand_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/


new_tilstand_registrering := _as_create_tilstand_registrering(tilstand_uuid,livscykluskode, brugerref, note);
prev_tilstand_registrering := _as_get_prev_tilstand_registrering(new_tilstand_registrering);

IF lostUpdatePreventionTZ IS NOT NULL THEN
  IF NOT (LOWER((prev_tilstand_registrering.registrering).timeperiod)=lostUpdatePreventionTZ) THEN
    RAISE EXCEPTION 'Unable to update tilstand with uuid [%], as the tilstand seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).',tilstand_uuid,lostUpdatePreventionTZ,LOWER((prev_tilstand_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
  END IF;   
END IF;




--handle relationer (relations)

IF relationer IS NOT NULL AND coalesce(array_length(relationer,1),0)=0 THEN
--raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]',note;
ELSE

  --1) Insert relations given as part of this update
  --2) Insert relations of previous registration, with index values not included in this update. Please notice that for the logic to work,
  --  it is very important that the index sequences start with the max value for index of the same type in the previous registration

  --Ad 1)

--build array with the max index values of the different types of relations of the previous registration
SELECT array_agg(rel_type_max_index)::_tilstandRelationMaxIndex[] into rel_type_max_index_arr
FROM
(
  SELECT
  (ROW(rel_type,coalesce(max(rel_index),0))::_tilstandRelationMaxIndex) rel_type_max_index  
  FROM tilstand_relation a
  where a.tilstand_registrering_id=prev_tilstand_registrering.id
  and a.rel_type = any (tilstand_rel_type_cardinality_unlimited)
  group by rel_type
) as a
;


--Create temporary sequences

SELECT array_agg( DISTINCT a.RelType) into tilstand_rel_type_cardinality_unlimited_present_in_argument FROM  unnest(relationer) a WHERE a.RelType = any (tilstand_rel_type_cardinality_unlimited) ;
tilstand_uuid_underscores:=replace(tilstand_uuid::text, '-', '_');

IF coalesce(array_length(tilstand_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH tilstand_relation_navn IN ARRAY (tilstand_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  tilstand_rel_seq_name := 'tilstand_' || tilstand_relation_navn::text || tilstand_uuid_underscores;

  rel_type_max_index_prev_rev:=null;

  SELECT 
    a.indeks into rel_type_max_index_prev_rev
  FROM
    unnest(rel_type_max_index_arr) a(relType,indeks)
  WHERE
    a.relType=tilstand_relation_navn
  ;
  
  IF rel_type_max_index_prev_rev IS NULL THEN
    rel_type_max_index_prev_rev:=0;
  END IF;

  EXECUTE 'CREATE TEMPORARY SEQUENCE ' || tilstand_rel_seq_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START ' ||  (rel_type_max_index_prev_rev+1)::text ||'
  CACHE 1;';

END LOOP;
END IF;

      INSERT INTO tilstand_relation (
        tilstand_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type,
                    rel_index,
                      tilstand_vaerdi_attr
      )
      SELECT
        new_tilstand_registrering.id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType,
                    CASE 
                    WHEN a.relType = any (tilstand_rel_type_cardinality_unlimited) THEN
                      CASE WHEN a.indeks IS NULL OR b.id IS NULL THEN --for new relations and relations with index given that is not found in prev registrering, we'll assign new index values 
                        nextval('tilstand_' || a.relType::text || tilstand_uuid_underscores)
                      ELSE
                        a.indeks
                      END
                    ELSE
                    NULL
                    END,
                      CASE
                        WHEN 
                        a.relType='tilstandsvaerdi' AND
                         ( NOT ((a.tilstandsVaerdiAttr) IS NULL))
                         AND 
                         (
                           (a.tilstandsVaerdiAttr).forventet IS NOT NULL
                           OR
                           (a.tilstandsVaerdiAttr).nominelVaerdi IS NOT NULL
                         ) THEN (a.tilstandsVaerdiAttr)
                        ELSE
                        NULL
                      END
      FROM unnest(relationer) as a
      LEFT JOIN tilstand_relation b on a.relType = any (tilstand_rel_type_cardinality_unlimited) and b.tilstand_registrering_id=prev_tilstand_registrering.id and a.relType=b.rel_type and a.indeks=b.rel_index
    ;


--Drop temporary sequences

IF coalesce(array_length(tilstand_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH tilstand_relation_navn IN ARRAY (SELECT array_agg( DISTINCT a.RelType) FROM  unnest(relationer) a WHERE a.RelType = any (tilstand_rel_type_cardinality_unlimited))
  LOOP
  tilstand_rel_seq_name := 'tilstand_' || tilstand_relation_navn::text || tilstand_uuid_underscores;
  EXECUTE 'DROP  SEQUENCE ' || tilstand_rel_seq_name || ';';
END LOOP;
END IF;

  --Ad 2)

  /**********************/
  -- 0..1 relations 
  --Please notice, that for 0..1 relations for tilstand, we're ignoring index here, and handling it the same way, that is done for other object types (like Facet, Klasse etc). That is, you only make changes for the virkningsperiod that you explicitly specify (unless you delete all relations) 

  FOREACH tilstand_relation_navn in array ARRAY['tilstandsobjekt'::TilstandRelationKode,'tilstandstype'::TilstandRelationKode]::TilstandRelationKode[]
  LOOP

    INSERT INTO tilstand_relation (
        tilstand_registrering_id,
          virkning,
            rel_maal_uuid,
              rel_maal_urn,
                rel_type,
                  objekt_type,
                    rel_index,
                      tilstand_vaerdi_attr          
      )
    SELECT 
        new_tilstand_registrering.id, 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.rel_maal_uuid,
              a.rel_maal_urn,
                a.rel_type,
                  a.objekt_type,
                    NULL,--a.rel_index, rel_index is not to be used for 0..1 relations    
                      a.tilstand_vaerdi_attr    
    FROM
    (
      --build an array of the timeperiod of the virkning of the relations of the new registrering to pass to _subtract_tstzrange_arr on the relations of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM tilstand_relation b
      WHERE 
            b.tilstand_registrering_id=new_tilstand_registrering.id
            and
            b.rel_type=tilstand_relation_navn
    ) d
    JOIN tilstand_relation a ON true
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.tilstand_registrering_id=prev_tilstand_registrering.id 
          and a.rel_type=tilstand_relation_navn 
    ;
  END LOOP;

  /**********************/
  -- 0..n relations
  
      INSERT INTO tilstand_relation (
            tilstand_registrering_id,
              virkning,
                rel_maal_uuid,
                  rel_maal_urn,
                    rel_type,
                      objekt_type,
                        rel_index,
                          tilstand_vaerdi_attr
          )
      SELECT 
            new_tilstand_registrering.id,
              a.virkning,
                a.rel_maal_uuid,
                  a.rel_maal_urn,
                    a.rel_type,
                      a.objekt_type,
                        a.rel_index,
                          a.tilstand_vaerdi_attr
      FROM tilstand_relation a
      LEFT JOIN tilstand_relation b on b.tilstand_registrering_id=new_tilstand_registrering.id and b.rel_type=a.rel_type and b.rel_index=a.rel_index
      WHERE a.tilstand_registrering_id=prev_tilstand_registrering.id 
      and a.rel_type = any (tilstand_rel_type_cardinality_unlimited)
      and b.id is null --don't transfer relations of prev. registrering, if the index was specified in data given to the/this update-function
      ;

/**********************/


END IF;
/**********************/
-- handle tilstande (states)

IF tilsStatus IS NOT NULL AND coalesce(array_length(tilsStatus,1),0)=0 THEN
--raise debug 'Skipping [Status] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --tilstand_tils_status
  /********************************************/

  --Ad 1)

  INSERT INTO tilstand_tils_status (
          virkning,
            status,
              tilstand_registrering_id
  ) 
  SELECT
          a.virkning,
            a.status,
              new_tilstand_registrering.id
  FROM
  unnest(tilsStatus) as a
  ;
   

  --Ad 2

  INSERT INTO tilstand_tils_status (
          virkning,
            status,
              tilstand_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.status,
              new_tilstand_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the tilstand_tils_status of the new registrering to pass to _subtract_tstzrange_arr on the tilstand_tils_status of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM tilstand_tils_status b
      WHERE 
            b.tilstand_registrering_id=new_tilstand_registrering.id
  ) d
    JOIN tilstand_tils_status a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.tilstand_registrering_id=prev_tilstand_registrering.id     
  ;


/**********************/

END IF;



IF tilsPubliceret IS NOT NULL AND coalesce(array_length(tilsPubliceret,1),0)=0 THEN
--raise debug 'Skipping [Publiceret] as it is explicit set to empty array';
ELSE
  --1) Insert tilstande/states given as part of this update
  --2) Insert tilstande/states of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

  /********************************************/
  --tilstand_tils_publiceret
  /********************************************/

  --Ad 1)

  INSERT INTO tilstand_tils_publiceret (
          virkning,
            publiceret,
              tilstand_registrering_id
  ) 
  SELECT
          a.virkning,
            a.publiceret,
              new_tilstand_registrering.id
  FROM
  unnest(tilsPubliceret) as a
  ;
   

  --Ad 2

  INSERT INTO tilstand_tils_publiceret (
          virkning,
            publiceret,
              tilstand_registrering_id
  )
  SELECT 
          ROW(
            c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
          ) :: virkning,
            a.publiceret,
              new_tilstand_registrering.id
  FROM
  (
   --build an array of the timeperiod of the virkning of the tilstand_tils_publiceret of the new registrering to pass to _subtract_tstzrange_arr on the tilstand_tils_publiceret of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM tilstand_tils_publiceret b
      WHERE 
            b.tilstand_registrering_id=new_tilstand_registrering.id
  ) d
    JOIN tilstand_tils_publiceret a ON true  
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE a.tilstand_registrering_id=prev_tilstand_registrering.id     
  ;


/**********************/

END IF;


/**********************/
--Handle attributter (attributes) 

/********************************************/
--tilstand_attr_egenskaber
/********************************************/

--Generate and insert any merged objects, if any fields are null in attrTilstandObj
IF attrEgenskaber IS NOT null THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(attrEgenskaber) a
  JOIN  unnest(attrEgenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.brugervendtnoegle,a.beskrivelse, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update tilstand with uuid [%], as the tilstand have overlapping virknings in the given egenskaber array :%',tilstand_uuid,to_json(attrEgenskaber)  USING ERRCODE = 'MO400';

  END IF;


  FOREACH attrEgenskaberObj in array attrEgenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (attrEgenskaberObj).brugervendtnoegle is null OR 
   (attrEgenskaberObj).beskrivelse is null 
  THEN

  INSERT INTO
  tilstand_attr_egenskaber
  (
    brugervendtnoegle,beskrivelse
    ,virkning
    ,tilstand_registrering_id
  )
  SELECT
    coalesce(attrEgenskaberObj.brugervendtnoegle,a.brugervendtnoegle),
    coalesce(attrEgenskaberObj.beskrivelse,a.beskrivelse),
	ROW (
	  (a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
	  (attrEgenskaberObj.virkning).AktoerRef,
	  (attrEgenskaberObj.virkning).AktoerTypeKode,
	  (attrEgenskaberObj.virkning).NoteTekst
	)::Virkning,
    new_tilstand_registrering.id
  FROM tilstand_attr_egenskaber a
  WHERE
    a.tilstand_registrering_id=prev_tilstand_registrering.id 
    and (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the attrEgenskaberObj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  tilstand_attr_egenskaber
  (
    brugervendtnoegle,beskrivelse
    ,virkning
    ,tilstand_registrering_id
  )
  SELECT 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.beskrivelse,
	  ROW (
	       b.tz_range_leftover,
	      (attrEgenskaberObj.virkning).AktoerRef,
	      (attrEgenskaberObj.virkning).AktoerTypeKode,
	      (attrEgenskaberObj.virkning).NoteTekst
	  )::Virkning,
    new_tilstand_registrering.id
  FROM
  (
  --build an array of the timeperiod of the virkning of the tilstand_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM tilstand_attr_egenskaber b
      WHERE 
       b.tilstand_registrering_id=new_tilstand_registrering.id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((attrEgenskaberObj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;

  ELSE
    --insert attrEgenskaberObj raw (if there were no null-valued fields) 

    INSERT INTO
    tilstand_attr_egenskaber
    (
    brugervendtnoegle,beskrivelse
    ,virkning
    ,tilstand_registrering_id
    )
    VALUES ( 
    attrEgenskaberObj.brugervendtnoegle, 
    attrEgenskaberObj.beskrivelse,
    attrEgenskaberObj.virkning,
    new_tilstand_registrering.id
    );

  END IF;

  END LOOP;
END IF;


IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber,1),0)=0 THEN
--raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';  
ELSE 

--Handle egenskaber of previous registration, taking overlapping virknings into consideration (using function subtract_tstzrange)

INSERT INTO tilstand_attr_egenskaber (
    brugervendtnoegle,beskrivelse
    ,virkning
    ,tilstand_registrering_id
)
SELECT
      a.brugervendtnoegle,
      a.beskrivelse,
	  ROW(
	    c.tz_range_leftover,
	      (a.virkning).AktoerRef,
	      (a.virkning).AktoerTypeKode,
	      (a.virkning).NoteTekst
	  ) :: virkning,
	 new_tilstand_registrering.id
FROM
(
 --build an array of the timeperiod of the virkning of the tilstand_attr_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the tilstand_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM tilstand_attr_egenskaber b
    WHERE 
          b.tilstand_registrering_id=new_tilstand_registrering.id
) d
  JOIN tilstand_attr_egenskaber a ON true  
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE a.tilstand_registrering_id=prev_tilstand_registrering.id     
;





END IF;


/******************************************************************/
--If the new registrering is identical to the previous one, we need to throw an exception to abort the transaction. 

read_new_tilstand:=as_read_tilstand(tilstand_uuid, (new_tilstand_registrering.registrering).timeperiod,null);
read_prev_tilstand:=as_read_tilstand(tilstand_uuid, (prev_tilstand_registrering.registrering).timeperiod ,null);
 
--the ordering in as_list (called by as_read) ensures that the latest registration is returned at index pos 1

IF NOT (lower((read_new_tilstand.registrering[1].registrering).TimePeriod)=lower((new_tilstand_registrering.registrering).TimePeriod) AND lower((read_prev_tilstand.registrering[1].registrering).TimePeriod)=lower((prev_tilstand_registrering.registrering).TimePeriod)) THEN
  RAISE EXCEPTION 'Error updating tilstand with id [%]: The ordering of as_list_tilstand should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].',tilstand_uuid,to_json(new_tilstand_registrering),to_json(read_new_tilstand.registrering[1].registrering),to_json(prev_tilstand_registrering),to_json(prev_new_tilstand.registrering[1].registrering) USING ERRCODE = 'MO500';
END IF;
 
 --we'll ignore the registreringBase part in the comparrison - except for the livcykluskode

read_new_tilstand_reg:=ROW(
ROW(null,(read_new_tilstand.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_new_tilstand.registrering[1]).tilsStatus ,
(read_new_tilstand.registrering[1]).tilsPubliceret ,
(read_new_tilstand.registrering[1]).attrEgenskaber ,
(read_new_tilstand.registrering[1]).relationer 
)::tilstandRegistreringType
;

read_prev_tilstand_reg:=ROW(
ROW(null,(read_prev_tilstand.registrering[1].registrering).livscykluskode,null,null)::registreringBase,
(read_prev_tilstand.registrering[1]).tilsStatus ,
(read_prev_tilstand.registrering[1]).tilsPubliceret ,
(read_prev_tilstand.registrering[1]).attrEgenskaber ,
(read_prev_tilstand.registrering[1]).relationer 
)::tilstandRegistreringType
;


IF read_prev_tilstand_reg=read_new_tilstand_reg THEN
  --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_tilstand_reg);
  --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_tilstand_reg);
  RAISE EXCEPTION 'Aborted updating tilstand with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]',tilstand_uuid,to_json(read_new_tilstand_reg),to_json(read_prev_tilstand_reg) USING ERRCODE = 'MO400';
END IF;

/******************************************************************/


return new_tilstand_registrering.id;



END;
$$;


ALTER FUNCTION actual_state.as_update_tilstand(tilstand_uuid uuid, brugerref uuid, note text, livscykluskode livscykluskode, attregenskaber tilstandegenskaberattrtype[], tilsstatus tilstandstatustilstype[], tilspubliceret tilstandpublicerettilstype[], relationer tilstandrelationtype[], lostupdatepreventiontz timestamp with time zone, auth_criteria_arr tilstandregistreringtype[]) OWNER TO mox;

--
-- Name: my_as_create_or_import_tilstand(); Type: FUNCTION; Schema: actual_state; Owner: mox
--

CREATE FUNCTION my_as_create_or_import_tilstand() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	new_uuid2 uuid;
	registrering tilstandRegistreringType;
	registrering2 tilstandRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkTilstandsobjekt Virkning;
	virkTilstandsvaerdi1 Virkning;
	virkTilstandsvaerdi2 Virkning;
	virkTilstandskvalitet1 Virkning;
	virkTilstandskvalitet2 Virkning;
	virkPubliceret Virkning;
	virkStatus Virkning;
	tilstandEgenskab tilstandEgenskaberAttrType;
	tilstandStatus tilstandStatusTilsType;
	tilstandPubliceret tilstandPubliceretTilsType;
	tilstandRelTilstandsobjekt tilstandRelationType;
	tilstandRelTilstandsvaerdi1 tilstandRelationType;
	tilstandRelTilstandsvaerdi2 tilstandRelationType;
	tilstandRelTilstandskvalitet1 tilstandRelationType;
	tilstandRelTilstandskvalitet2 tilstandRelationType;
	
	uuidTilstandsobjekt uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	--uuidTilstandsvaerdi1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;


	uuidTilstandsvaerdi2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	--urnTilstandsvaerdi2 text:='urn:isbn:0451450523'::text;
	uuidTilstandskvalitet1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidTilstandskvalitet2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	actual_publiceret_virk virkning;
	actual_publiceret_value tilstandStatusTils;
	actual_publiceret tilstandStatusTilsType;
	actual_relationer tilstandRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	read_Tilstand1 TilstandType;
	expected_tilstand1 TilstandType;
	read_Tilstand2 TilstandType;
	expected_tilstand2 TilstandType;
BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkTilstandsobjekt :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkTilstandsvaerdi1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkTilstandsvaerdi2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkstatus := ROW (
	'[2016-12-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx20'
) :: Virkning
;

virkTilstandskvalitet1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkTilstandskvalitet2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

tilstandRelTilstandsobjekt := ROW (
	'tilstandsobjekt'::tilstandRelationKode
	,virkTilstandsobjekt
	,uuidTilstandsobjekt
	,null
	,'Person'
	,900 --NOTICE: Should be replace in by import function
	,null --TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;


tilstandRelTilstandsvaerdi1 := ROW (
	'tilstandsvaerdi'::tilstandRelationKode,
		virkTilstandsvaerdi1,
	null,
	null,
	null
	,768 --NOTICE: Should be replace in by import function
	,ROW(true,'82')::TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;



tilstandRelTilstandsvaerdi2 := ROW (
	'tilstandsvaerdi'::tilstandRelationKode,
		virkTilstandsvaerdi2,
	uuidTilstandsvaerdi2,
	null,--urnTilstandsvaerdi2
	'Klasse'
	,800 --NOTICE: Should be replace in by import function
	, null --TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;



tilstandRelTilstandskvalitet1 := ROW (
	'tilstandskvalitet'::tilstandRelationKode,
		virkTilstandskvalitet1,
	uuidTilstandskvalitet1,
	null,
	'Klasse'
	,7268 --NOTICE: Should be replace in by import function
	, null --TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;



tilstandRelTilstandskvalitet2 := ROW (
	'tilstandskvalitet'::tilstandRelationKode,
		virkTilstandskvalitet2,
	uuidTilstandskvalitet2,
	null,
	'Klasse'
	,3 --NOTICE: Should be replace in by import function
	,null --TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;



tilstandStatus := ROW (
virkStatus,
'Aktiv'::TilstandStatusTils
):: tilstandStatusTilsType
;

tilstandPubliceret := ROW (
virkPubliceret,
'Normal'::TilstandPubliceretTils
)::tilstandPubliceretTilsType;

tilstandEgenskab := ROW (
'brugervendtnoegle_tilstand_1' --text, 
,'beskrivelse_tilstand_1'-- text,
,virkEgenskaber
) :: tilstandEgenskaberAttrType
;


registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[tilstandStatus]::tilstandStatusTilsType[],
	ARRAY[tilstandPubliceret]::TilstandPubliceretTilsType[],
ARRAY[tilstandEgenskab]::tilstandEgenskaberAttrType[],
ARRAY[tilstandRelTilstandsobjekt,tilstandRelTilstandsvaerdi1,tilstandRelTilstandsvaerdi2,tilstandRelTilstandskvalitet1,tilstandRelTilstandskvalitet2]) :: tilstandRegistreringType
;


--raise notice 'to be written tilstand 1:%',to_json(registrering);

new_uuid1 := as_create_or_import_tilstand(registrering);



read_Tilstand1 := as_read_tilstand(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);
--raise notice 'read_Tilstand1:%',to_json(read_Tilstand1);

expected_tilstand1:=ROW(
		new_uuid1,
		ARRAY[
			ROW(
			(read_Tilstand1.registrering[1]).registrering
			,ARRAY[tilstandStatus]::tilstandStatusTilsType[]
			,ARRAY[tilstandPubliceret]::tilstandPubliceretTilsType[]
			,ARRAY[tilstandEgenskab]::tilstandEgenskaberAttrType[]
			,ARRAY[
				ROW (
				'tilstandsvaerdi'::tilstandRelationKode,
					virkTilstandsvaerdi2,
				uuidTilstandsvaerdi2,
				null,--urnTilstandsvaerdi2
				'Klasse'
				,2 --NOTICE: Was replace din by import function
				, ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
			,
				ROW (
				'tilstandskvalitet'::tilstandRelationKode,
					virkTilstandskvalitet2,
				uuidTilstandskvalitet2,
				null,
				'Klasse'
				,2 --NOTICE: Was replaced by import function
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
			,
				ROW (
				'tilstandskvalitet'::tilstandRelationKode,
					virkTilstandskvalitet1,
				uuidTilstandskvalitet1,
				null,
				'Klasse'
				,1 --NOTICE: Was replaced  by import function
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
			,
				ROW (
				'tilstandsobjekt'::tilstandRelationKode
				,virkTilstandsobjekt
				,uuidTilstandsobjekt
				,null
				,'Person'
				,NULL --NOTICE: Was replaced
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
				,
				 ROW (
					'tilstandsvaerdi'::tilstandRelationKode,
						virkTilstandsvaerdi1,
					null,
					null,
					null
					,1 --NOTICE: Was replaced by import function
					,ROW(true,'82')::TilstandVaerdiRelationAttrType
				) :: tilstandRelationType
			
				]::TilstandRelationType[]
			)::TilstandRegistreringType
			]::TilstandRegistreringType[]
		)::TilstandType
;

--raise notice 'expected_tilstand1:%',to_json(expected_tilstand1);




/*********************************/
--test with no relations of unlimited cardinality
registrering2 := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[tilstandStatus]::tilstandStatusTilsType[],
	ARRAY[tilstandPubliceret]::TilstandPubliceretTilsType[],
ARRAY[tilstandEgenskab]::tilstandEgenskaberAttrType[],
ARRAY[tilstandRelTilstandsobjekt]) :: tilstandRegistreringType
;

new_uuid2 := as_create_or_import_tilstand(registrering2);

read_Tilstand2 := as_read_tilstand(new_uuid2,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);
--raise notice 'read_Tilstand1:%',to_json(read_Tilstand1);

expected_tilstand2:=ROW(
		new_uuid2,
		ARRAY[
			ROW(
			(read_Tilstand2.registrering[1]).registrering
			,ARRAY[tilstandStatus]::tilstandStatusTilsType[]
			,ARRAY[tilstandPubliceret]::tilstandPubliceretTilsType[]
			,ARRAY[tilstandEgenskab]::tilstandEgenskaberAttrType[]
			,ARRAY[
				ROW (
				'tilstandsobjekt'::tilstandRelationKode
				,virkTilstandsobjekt
				,uuidTilstandsobjekt
				,null
				,'Person'
				,NULL --NOTICE: Was replaced
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
				]::TilstandRelationType[]
			)::TilstandRegistreringType
			]::TilstandRegistreringType[]
		)::TilstandType
;


END;
$$;


ALTER FUNCTION actual_state.my_as_create_or_import_tilstand() OWNER TO mox;

SET search_path = test, pg_catalog;

--
-- Name: test_as_create_or_import_aktivitet(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_create_or_import_aktivitet() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	new_uuid2 uuid;
	registrering aktivitetRegistreringType;
	registrering2 aktivitetRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkEgenskaber2 Virkning;
	virkAnsvarligklasse Virkning;
	virkResultatklasse1 Virkning;
	virkResultatklasse2 Virkning;
	virkDeltagerklasse1 Virkning;
	virkDeltagerklasse2 Virkning;
	virkUdfoerer1 Virkning;
	virkUdfoerer2 Virkning;
	virkPubliceret Virkning;
	virkStatus Virkning;
	aktivitetEgenskab aktivitetEgenskaberAttrType;
	aktivitetEgenskab2 aktivitetEgenskaberAttrType;
	aktivitetStatus aktivitetStatusTilsType;
	aktivitetPubliceret aktivitetPubliceretTilsType;
	aktivitetRelAnsvarligklasse aktivitetRelationType;
	aktivitetRelResultatklasse1 aktivitetRelationType;
	aktivitetRelResultatklasse2 aktivitetRelationType;
	aktivitetRelDeltagerklasse1 aktivitetRelationType;
	aktivitetRelDeltagerklasse2 aktivitetRelationType;
	aktivitetRelUdfoerer1 aktivitetRelationType;
	aktivitetRelUdfoerer2 aktivitetRelationType;

	uuidAnsvarligklasse uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	uuidResultatklasse1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;


	--uuidResultatklasse2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	urnResultatklasse2 text:='urn:isbn:0451450523'::text;
	uuidDeltagerklasse1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidDeltagerklasse2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidUdfoerer1  uuid :='884d99f6-568f-4772-8766-fac6d40f9cb0'::uuid;
	uuidUdfoerer2  uuid :='b6bb8e41-b47b-4420-b2a3-d1c38d86a1ad'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	repraesentation_uuid uuid :='0e3ed41a-08f2-4967-8689-dce625f93029'::uuid;
	repraesentation_urn text :='isbn:97800232324'::text;

	actual_publiceret_virk virkning;
	actual_publiceret_value aktivitetStatusTils;
	actual_publiceret aktivitetStatusTilsType;
	actual_relationer aktivitetRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	read_Aktivitet1 AktivitetType;
	expected_aktivitet1 AktivitetType;
	read_Aktivitet2 AktivitetType;
	expected_aktivitet2 AktivitetType;
BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, 2015-06-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaber2 :=	ROW (
	'[2015-06-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx90'
          ) :: Virkning
;

virkAnsvarligklasse :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkUdfoerer1 :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx342'
          ) :: Virkning
;

virkUdfoerer2 :=	ROW (
	'[2016-04-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx350'
          ) :: Virkning
;

virkResultatklasse1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkResultatklasse2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkstatus := ROW (
	'[2016-12-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx20'
) :: Virkning
;

virkDeltagerklasse1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkDeltagerklasse2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

aktivitetRelAnsvarligklasse := ROW (
	'ansvarligklasse'::aktivitetRelationKode
	,virkAnsvarligklasse
	,uuidAnsvarligklasse
	,null
	,'Klasse'
	,567 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;

aktivitetRelUdfoerer1 := ROW (
	'udfoerer'::aktivitetRelationKode
	,virkUdfoerer1
	,uuidUdfoerer1
	,null
	,'Person'
	,3 --NOTICE: Should be replace in by import function
	,ROW (
		 'valgfri'::AktivitetAktoerAttrObligatoriskKode,
  		'foreloebigt'::AktivitetAktoerAttrAccepteretKode,
  repraesentation_uuid,
  null 
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
;


aktivitetRelUdfoerer2 := ROW (
	'udfoerer'::aktivitetRelationKode
	,virkUdfoerer2
	,uuidUdfoerer2
	,null
	,'Person'
	,3 --NOTICE: Should be replace in by import function
	,ROW (
		 'noedvendig'::AktivitetAktoerAttrObligatoriskKode,
  		'accepteret'::AktivitetAktoerAttrAccepteretKode,
  null,
  repraesentation_urn
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
;


aktivitetRelResultatklasse1 := ROW (
	'resultatklasse'::aktivitetRelationKode,
		virkResultatklasse1,
	uuidResultatklasse1,
	null,
	'Klasse'
	,768 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;



aktivitetRelResultatklasse2 := ROW (
	'resultatklasse'::aktivitetRelationKode,
		virkResultatklasse2,
	null,
	urnResultatklasse2,
	'Klasse'
	,800 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;



aktivitetRelDeltagerklasse1 := ROW (
	'deltagerklasse'::aktivitetRelationKode,
		virkDeltagerklasse1,
	uuidDeltagerklasse1,
	null,
	'Klasse'
	,7268 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;



aktivitetRelDeltagerklasse2 := ROW (
	'deltagerklasse'::aktivitetRelationKode,
		virkDeltagerklasse2,
	uuidDeltagerklasse2,
	null,
	'Klasse'
	,3 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;



aktivitetStatus := ROW (
virkStatus,
'Aktiv'::AktivitetStatusTils
):: aktivitetStatusTilsType
;

aktivitetPubliceret := ROW (
virkPubliceret,
'Normal'::AktivitetPubliceretTils
)::aktivitetPubliceretTilsType;


aktivitetEgenskab := ROW (
 'aktivitet_1_brugervendtnoegle',
 'aktivitet_1_aktivitetnavn',
 'aktivitet_1_beskrivelse',
 '2017-02-25 17:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
  INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
 'aktivitet_1_formaal'
,virkEgenskaber
) :: aktivitetEgenskaberAttrType
;

aktivitetEgenskab2 := ROW (
 'aktivitet_2_brugervendtnoegle',
 'aktivitet_2_aktivitetnavn',
 'aktivitet_2_beskrivelse',
 '2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
'2017-02-27 12:00'::timestamptz, -- sluttidspunkt,
  INTERVAL '0000-00 01 04:00:01.0', --tidsforbrug
 'aktivitet_2_formaal'
,virkEgenskaber2
) :: aktivitetEgenskaberAttrType
;


registrering := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[aktivitetStatus]::aktivitetStatusTilsType[],
	ARRAY[aktivitetPubliceret]::AktivitetPubliceretTilsType[],
ARRAY[aktivitetEgenskab,aktivitetEgenskab2]::aktivitetEgenskaberAttrType[],
ARRAY[aktivitetRelAnsvarligklasse,aktivitetRelResultatklasse1,aktivitetRelResultatklasse2,aktivitetRelDeltagerklasse1,aktivitetRelDeltagerklasse2,aktivitetRelUdfoerer1,aktivitetRelUdfoerer2]) :: aktivitetRegistreringType
;


--raise notice 'to be written aktivitet 1:%',to_json(registrering);

new_uuid1 := as_create_or_import_aktivitet(registrering);

RETURN NEXT ok(true,'No errors running as_create_or_import_aktivitet');


read_Aktivitet1 := as_read_aktivitet(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);
--raise notice 'read_Aktivitet1:%',to_json(read_Aktivitet1);

expected_aktivitet1:=ROW(
		new_uuid1,
		ARRAY[
			ROW(
			(read_Aktivitet1.registrering[1]).registrering
			,ARRAY[aktivitetStatus]::aktivitetStatusTilsType[]
			,ARRAY[aktivitetPubliceret]::aktivitetPubliceretTilsType[]
			,ARRAY[aktivitetEgenskab,aktivitetEgenskab2]::aktivitetEgenskaberAttrType[]
			,ARRAY[
				ROW (
				'deltagerklasse'::aktivitetRelationKode,
					virkDeltagerklasse2,
				uuidDeltagerklasse2,
				null,
				'Klasse'
				,2 --NOTICE: Should be replace in by import function
				,ROW (null,null,null,null)::AktivitetAktoerAttr   --NOTICE: empty composites will be removed in python layer --aktoerAttr
			) :: aktivitetRelationType
			,
			ROW (
					'udfoerer'::aktivitetRelationKode
					,virkUdfoerer1
					,uuidUdfoerer1
					,null
					,'Person'
					,1 --NOTICE: was replaced by import function
					,ROW (
						'valgfri'::AktivitetAktoerAttrObligatoriskKode,
						'foreloebigt'::AktivitetAktoerAttrAccepteretKode,
				repraesentation_uuid,
				null 
					)::AktivitetAktoerAttr
				) :: aktivitetRelationType
				,
				ROW (
					'udfoerer'::aktivitetRelationKode
					,virkUdfoerer2
					,uuidUdfoerer2
					,null
					,'Person'
					,2 --NOTICE: Was replaced in by import function
					,ROW (
						'noedvendig'::AktivitetAktoerAttrObligatoriskKode,
						'accepteret'::AktivitetAktoerAttrAccepteretKode,
				null,
				repraesentation_urn
					)::AktivitetAktoerAttr
				) :: aktivitetRelationType
				,
				ROW (
					'resultatklasse'::aktivitetRelationKode,
						virkResultatklasse1,
					uuidResultatklasse1,
					null,
					'Klasse'
					,1 --NOTICE: Was replaced
					,ROW (null,null,null,null)::AktivitetAktoerAttr  --aktoerAttr
				) :: aktivitetRelationType
				,
				ROW (
				'deltagerklasse'::aktivitetRelationKode,
					virkDeltagerklasse1,
				uuidDeltagerklasse1,
				null,
				'Klasse'
				,1 --NOTICE: Was replaced  by import function
				,ROW (null,null,null,null)::AktivitetAktoerAttr  --aktoerAttr
			) :: aktivitetRelationType,

				ROW (
				'ansvarligklasse'::aktivitetRelationKode
				,virkAnsvarligklasse
				,uuidAnsvarligklasse
				,null
				,'Klasse'
				,NULL --NOTICE: Was replaced
				,ROW (null,null,null,null)::AktivitetAktoerAttr  --aktoerAttr
			) :: aktivitetRelationType
			,ROW (
				'resultatklasse'::aktivitetRelationKode,
					virkResultatklasse2,
				null,
				urnResultatklasse2,
				'Klasse'
				,2 --NOTICE: Was replaced
				,ROW (null,null,null,null)::AktivitetAktoerAttr  --aktoerAttr
			) :: aktivitetRelationType

				]::AktivitetRelationType[]
			)::AktivitetRegistreringType
			]::AktivitetRegistreringType[]
		)::AktivitetType
;

--raise notice 'expected_aktivitet1:%',to_json(expected_aktivitet1);



RETURN NEXT IS(
	read_Aktivitet1,
	expected_aktivitet1
	,'test create aktivitet #1'
);


/**************************************************/
--test with no unlimited carinality relations given


registrering2 := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[aktivitetStatus]::aktivitetStatusTilsType[],
	ARRAY[aktivitetPubliceret]::AktivitetPubliceretTilsType[],
ARRAY[aktivitetEgenskab,aktivitetEgenskab2]::aktivitetEgenskaberAttrType[],
ARRAY[	ROW (
				'ansvarligklasse'::aktivitetRelationKode
				,virkAnsvarligklasse
				,uuidAnsvarligklasse
				,null
				,'Klasse'
				,NULL 
				,null --ROW (null,null,null,null)::AktivitetAktoerAttr  --aktoerAttr
			) :: aktivitetRelationType
]::aktivitetRelationType[]
);

new_uuid2 := as_create_or_import_aktivitet(registrering2);



read_Aktivitet2 := as_read_aktivitet(new_uuid2,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);
--raise notice 'read_Aktivitet1:%',to_json(read_Aktivitet1);

expected_aktivitet2:=ROW(
		new_uuid2,
		ARRAY[
			ROW(
			(read_Aktivitet2.registrering[1]).registrering
			,ARRAY[aktivitetStatus]::aktivitetStatusTilsType[]
			,ARRAY[aktivitetPubliceret]::aktivitetPubliceretTilsType[]
			,ARRAY[aktivitetEgenskab,aktivitetEgenskab2]::aktivitetEgenskaberAttrType[]
			,ARRAY[
					ROW (
				'ansvarligklasse'::aktivitetRelationKode
				,virkAnsvarligklasse
				,uuidAnsvarligklasse
				,null
				,'Klasse'
				,NULL 
				,ROW (null,null,null,null)::AktivitetAktoerAttr  --aktoerAttr
			) :: aktivitetRelationType
				]::AktivitetRelationType[]
			)::AktivitetRegistreringType
			]::AktivitetRegistreringType[]
		)::AktivitetType
;

RETURN NEXT IS(
	read_Aktivitet2,
	expected_aktivitet2
	,'test create aktivitet #2'
);





END;
$$;


ALTER FUNCTION test.test_as_create_or_import_aktivitet() OWNER TO mox;

--
-- Name: test_as_create_or_import_dokument(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_create_or_import_dokument() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid uuid;
	registrering dokumentRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber1 Virkning;
	virkEgenskaber2 Virkning;
	virkAnsvarlig Virkning;
	virkBesvarelser1 Virkning;
	virkBesvarelser2 Virkning;
	virkFremdrift Virkning;
	dokumentEgenskab1 dokumentEgenskaberAttrType;
	dokumentEgenskab2 dokumentEgenskaberAttrType;
	dokumentFremdrift dokumentFremdriftTilsType;
	dokumentRelAnsvarlig dokumentRelationType;
	dokumentRelBesvarelser1 dokumentRelationType;
	dokumentRelBesvarelser2 dokumentRelationType;
	uuidAnsvarlig uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	uuidBesvarelser1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	--uuidBesvarelser2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	urnBesvarelser2 text:='urn:isbn:0451450523'::text;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	actual_fremdrift_virk virkning;
	actual_fremdrift_value dokumentFremdriftTils;
	actual_fremdrift dokumentFremdriftTilsType;
	actual_relationer dokumentRelationType[];
	actual_egenskaber dokumentEgenskaberAttrType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	docVariant1 DokumentVariantType;
	docVariant2 DokumentVariantType;
	docVariantEgenskaber1A DokumentVariantEgenskaberType;
	docVariantEgenskaber1AVirkning Virkning;
	docVariantEgenskaber1B DokumentVariantEgenskaberType;
	docVariantEgenskaber1BVirkning Virkning;
	docVariantEgenskaber2A DokumentVariantEgenskaberType;
	docVariantEgenskaber2AVirkning Virkning;	
	docDel1A DokumentDelType;
	docDel1B DokumentDelType;
	docDel2A DokumentDelType;
	docDel2B DokumentDelType;
	docDel1AEgenskaber DokumentDelEgenskaberType;
	docDel1A2Egenskaber DokumentDelEgenskaberType;
	docDel1AEgenskaberVirkning Virkning;
	docDel1A2EgenskaberVirkning Virkning;
	docDel1BEgenskaber DokumentDelEgenskaberType;
	docDel1BEgenskaberVirkning Virkning;
	docDel2AEgenskaber DokumentDelEgenskaberType;
	docDel2AEgenskaberVirkning Virkning;
	docDel1Arelation1 DokumentdelRelationType;
	docDel1Arelation1Virkning Virkning;
	docDel2Brelation1 DokumentdelRelationType;
	docDel2Brelation1Virkning Virkning;
	docDel2Brelation2 DokumentdelRelationType;
	docDel2Brelation2Virkning Virkning;
	actual_variant_egenskaber_variant_1 DokumentVariantEgenskaberType[];
	actual_variant_egenskaber_variant_2 DokumentVariantEgenskaberType[];
	actual_del_egenskaber_1 DokumentDelEgenskaberType[];
	actual_del_egenskaber_2 DokumentDelEgenskaberType[];
	actual_del_egenskaber_3 DokumentDelEgenskaberType[];
	actual_del_egenskaber_4 DokumentDelEgenskaberType[];
	actual_del_relationer_1 DokumentdelRelationType[];
	actual_del_relationer_2 DokumentdelRelationType[];
	actual_del_relationer_3 DokumentdelRelationType[];
	actual_del_relationer_4 DokumentdelRelationType[];
BEGIN


virkEgenskaber1 :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          'd71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;


virkEgenskaber2 :=	ROW (
	'[2014-05-12, 2015-05-12)' :: TSTZRANGE,
          'e71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;


virkAnsvarlig :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          'f71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkBesvarelser1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          'c71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkBesvarelser2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          'b71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkFremdrift := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          'a71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx10'
) :: Virkning
;

dokumentRelAnsvarlig := ROW (
	'ansvarlig'::dokumentRelationKode,
		virkAnsvarlig,
	uuidAnsvarlig,
	null,
	'Aktr'
) :: dokumentRelationType
;


dokumentRelBesvarelser1 := ROW (
	'besvarelser'::dokumentRelationKode,
		virkBesvarelser1,
	uuidBesvarelser1,
	null,
	null
) :: dokumentRelationType
;



dokumentRelBesvarelser2 := ROW (
	'besvarelser'::dokumentRelationKode,
		virkBesvarelser2,
	null,
	urnBesvarelser2,
	null
) :: dokumentRelationType
;


dokumentFremdrift := ROW (
virkFremdrift,
'Underreview'
):: dokumentFremdriftTilsType
;


dokumentEgenskab1 := ROW (
'doc_brugervendtnoegle1',
'doc_beskrivelse1', 
'10-31-2015'::date,
'doc_kassationskode1', 
4, --major int
9, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel1',
'doc_dokumenttype1',
   virkEgenskaber1
) :: dokumentEgenskaberAttrType
;

dokumentEgenskab2 := ROW (
'doc_brugervendtnoegle2',
'doc_beskrivelse2', 
'09-20-2014'::date,
'doc_kassationskode2', 
5, --major int
10, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel2','doc_Offentlighedundtaget_Hjemmel2') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel2',
'doc_dokumenttype2',
   virkEgenskaber2
) :: dokumentEgenskaberAttrType
;




docDel2Brelation2Virkning :=	ROW (
	'(2011-08-24, 2015-10-01]' :: TSTZRANGE,
          '971cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;

docDel2Brelation1Virkning :=	ROW (
	'[2012-05-08, infinity)' :: TSTZRANGE,
          '871cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;


docDel1Arelation1Virkning :=	ROW (
	'[2014-05-10, infinity)' :: TSTZRANGE,
          '771cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx71'
          ) :: Virkning
;


docVariantEgenskaber2AVirkning :=	ROW (
	'[2014-07-12, infinity)' :: TSTZRANGE,
          '671cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx281'
          ) :: Virkning
;

docVariantEgenskaber1BVirkning :=	ROW (
	'[2014-06-11, infinity)' :: TSTZRANGE,
          '571cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx291'
          ) :: Virkning
;


docVariantEgenskaber1AVirkning :=	ROW (
	'[2013-02-27, 2014-06-11)' :: TSTZRANGE,
          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx191'
          ) :: Virkning
;

docDel1AEgenskaberVirkning :=	ROW (
	'[2014-03-30, infinity)' :: TSTZRANGE,
          '371cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;

docDel1A2EgenskaberVirkning :=	ROW (
	'[2010-01-20, 2014-03-20)' :: TSTZRANGE,
          '271cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx113'
          ) :: Virkning
;


docDel1BEgenskaberVirkning :=	ROW (
	'[2015-10-11, infinity)' :: TSTZRANGE,
          '171cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

docDel2AEgenskaberVirkning :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '901cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx13'
          ) :: Virkning
;


docVariantEgenskaber1A:=
ROW(
true, --arkivering boolean, 
false, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
false, --produktion boolean,
 docVariantEgenskaber1AVirkning
)::DokumentVariantEgenskaberType;

docVariantEgenskaber1B:=
ROW(
false, --arkivering boolean, 
false, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
true, --produktion boolean,
 docVariantEgenskaber1BVirkning
)::DokumentVariantEgenskaberType;


docVariantEgenskaber2A:=
ROW(
false, --arkivering boolean, 
true, --delvisscannet boolean, 
false, --offentliggoerelse boolean, 
true, --produktion boolean,
 docVariantEgenskaber2AVirkning
)::DokumentVariantEgenskaberType;


docDel2Brelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  docDel2Brelation1Virkning,
  'a24a2dd4-415f-4104-b7a7-84607488c096'::uuid,
  null, --urn,
  'Bruger'
)::DokumentdelRelationType;


docDel2Brelation2:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  docDel2Brelation2Virkning,
  null,
  'urn:cpr 8883394', 
  'Bruger'
)::DokumentdelRelationType;


docDel1Arelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  docDel2Brelation2Virkning,
  'b24a2dd4-415f-4104-b7a7-84607488c091'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;


docDel1AEgenskaber:= ROW(
1, --indeks int,
'del_indhold1', 
'del_lokation1', 
'del_mimetype1',
 docDel1AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

docDel1A2Egenskaber:=ROW(
2, --indeks int,
'del_indhold4', 
'del_lokation4', 
'del_mimetype4',
 docDel1A2EgenskaberVirkning 
)::DokumentDelEgenskaberType
;

docDel1BEgenskaber:= ROW(
98, --indeks int,
'del_indhold2', 
'del_lokation2', 
'del_mimetype2',
 docDel1BEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

docDel2AEgenskaber:= ROW(
8, --indeks int,
'del_indhold3', 
'del_lokation3', 
'del_mimetype3',
 docDel2AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;


docDel1A:=
ROW(
'doc_deltekst1A',
  ARRAY[docDel1AEgenskaber,docDel1A2Egenskaber],
  ARRAY[docDel1Arelation1]
)::DokumentDelType;

docDel1B:=
ROW(
'doc_deltekst1B',
  ARRAY[docDel1BEgenskaber],
  ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

docDel2A:=
ROW(
'doc_deltekst2A',
  ARRAY[docDel2AEgenskaber],
  ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

docDel2B:=
ROW(
'doc_deltekst2B',
  ARRAY[]::DokumentDelEgenskaberType[],
  ARRAY[docDel2Brelation1,docDel2Brelation2]
)::DokumentDelType;


docVariant1 := ROW (
	'doc_varianttekst1',
  	ARRAY[docVariantEgenskaber1A,docVariantEgenskaber1B],
  	ARRAY[docDel1A,docDel1B]
)::DokumentVariantType;


docVariant2 := ROW (
	'doc_varianttekst2',
  ARRAY[docVariantEgenskaber2A],
  ARRAY[docDel2A,docDel2B]
)::DokumentVariantType;

registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 85') :: RegistreringBase
	,
ARRAY[dokumentFremdrift]::dokumentFremdriftTilsType[],
ARRAY[dokumentEgenskab1,dokumentEgenskab2]::dokumentEgenskaberAttrType[],
ARRAY[dokumentRelAnsvarlig,dokumentRelBesvarelser1,dokumentRelBesvarelser2],
ARRAY[docVariant1,docVariant2]
) :: dokumentRegistreringType
;


new_uuid := as_create_or_import_dokument(registrering);

RETURN NEXT is(
	ARRAY(
		SELECT
			id
		FROM
		dokument
		where id=new_uuid
		),
	ARRAY[new_uuid]::uuid[]
);


SELECT
	(a.registrering).* into actual_registrering
FROM
dokument_registrering a
where dokument_id=new_uuid
;


RETURN NEXT is(actual_registrering.livscykluskode,(registrering.registrering).livscykluskode,'registrering livscykluskode');
RETURN NEXT is(actual_registrering.brugerref,(registrering.registrering).brugerref,'registrering brugerref');
RETURN NEXT is(actual_registrering.note,(registrering.registrering).note,'registrering note');
RETURN NEXT ok(upper(actual_registrering.timeperiod)='infinity'::timestamp with time zone,'registrering timeperiod upper is infinity');
RETURN NEXT ok(lower(actual_registrering.timeperiod) <clock_timestamp(),'registrering timeperiod before now');
RETURN NEXT ok(lower(actual_registrering.timeperiod) > clock_timestamp() - 3 * interval '1 second',' registrering timeperiod later than 3 secs' );

SELECT
	 	(a.virkning).* into actual_fremdrift_virk
FROM dokument_tils_fremdrift a 
JOIN dokument_registrering as b on a.dokument_registrering_id=b.id
WHERE b.dokument_id=new_uuid
;

SELECT
	 	a.fremdrift into actual_fremdrift_value
FROM dokument_tils_fremdrift a 
JOIN dokument_registrering as b on a.dokument_registrering_id=b.id
WHERE b.dokument_id=new_uuid
;

actual_fremdrift:=ROW(
	actual_fremdrift_virk,
	actual_fremdrift_value
)::dokumentFremdriftTilsType ;


RETURN NEXT is(actual_fremdrift.virkning,dokumentFremdrift.virkning,'fremdrift virkning');
RETURN NEXT is(actual_fremdrift.fremdrift,dokumentFremdrift.fremdrift,'fremdrift value');

SELECT
array_agg(
			ROW (
					a.rel_type,
					a.virkning,
					a.rel_maal_uuid,
					a.rel_maal_urn,
					a.objekt_type 
				):: dokumentRelationType
			order by a.id
		) into actual_relationer
FROM dokument_relation a
JOIN dokument_registrering as b on a.dokument_registrering_id=b.id
WHERE b.dokument_id=new_uuid
;

RETURN NEXT is(
	actual_relationer,
	ARRAY[dokumentRelAnsvarlig,dokumentRelBesvarelser1,dokumentRelBesvarelser2]
,'relations present');

SELECT array_agg(
	ROW(
		a.brugervendtnoegle,
		a.beskrivelse, 
		a.brevdato,
		a.kassationskode, 
		a.major, 
		a.minor, 
		a.offentlighedundtaget,
		a.titel,
		a.dokumenttype,
 		a.virkning
 )::dokumentEgenskaberAttrType
	order by a.major ASC
) into actual_egenskaber
from dokument_attr_egenskaber a
JOIN dokument_registrering as b on a.dokument_registrering_id=b.id
WHERE b.dokument_id=new_uuid
;


RETURN NEXT is(
	actual_egenskaber,
	ARRAY[dokumentEgenskab1,dokumentEgenskab2]
,'egenskaber present');

--****************************
--Test document variants egenskaber

SELECT array_agg(
	ROW(
		a.arkivering, 
		a.delvisscannet, 
		a.offentliggoerelse, 
		a.produktion,
 		a.virkning
		)::DokumentVariantEgenskaberType
	order by a.id asc
	) into actual_variant_egenskaber_variant_1
from  dokument_variant_egenskaber a
join dokument_variant b on a.variant_id=b.id
join dokument_registrering c on b.dokument_registrering_id=c.id
WHERE c.dokument_id=new_uuid
and b.varianttekst='doc_varianttekst1'
;

RETURN NEXT is(
	actual_variant_egenskaber_variant_1,
	ARRAY[docVariantEgenskaber1A,docVariantEgenskaber1B]
,'dokument variant egenskaber 1 present');


SELECT array_agg(
	ROW(
		a.arkivering, 
		a.delvisscannet, 
		a.offentliggoerelse, 
		a.produktion,
 		a.virkning
		)::DokumentVariantEgenskaberType
	order by a.id asc
	) into actual_variant_egenskaber_variant_2
from  dokument_variant_egenskaber a
join dokument_variant b on a.variant_id=b.id
join dokument_registrering c on b.dokument_registrering_id=c.id
WHERE c.dokument_id=new_uuid
and b.varianttekst='doc_varianttekst2'
;

RETURN NEXT is(
	actual_variant_egenskaber_variant_2,
	ARRAY[docVariantEgenskaber2A]
,'dokument variant egenskaber 2 present');


--****************************
--Test document variants del egenskaber


SELECT array_agg(
	ROW(
		a.indeks,
		a.indhold,
		a.lokation,
		a.mimetype,
 		a.virkning
		)::DokumentDelEgenskaberType
	order by a.id asc
	) into actual_del_egenskaber_1
from  dokument_del_egenskaber a
join dokument_del d on a.del_id = d.id
join dokument_variant b on d.variant_id=b.id
join dokument_registrering c on b.dokument_registrering_id=c.id
WHERE c.dokument_id=new_uuid
and b.varianttekst='doc_varianttekst1'
and d.deltekst='doc_deltekst1A'
;

RETURN NEXT is(
	actual_del_egenskaber_1,
	ARRAY[docDel1AEgenskaber,docDel1A2Egenskaber]
,'dokument variant del egenskaber 1 present');


SELECT array_agg(
	ROW(
		a.indeks,
		a.indhold,
		a.lokation,
		a.mimetype,
 		a.virkning
		)::DokumentDelEgenskaberType
	order by a.id asc
	) into actual_del_egenskaber_2
from  dokument_del_egenskaber a
join dokument_del d on a.del_id = d.id
join dokument_variant b on d.variant_id=b.id
join dokument_registrering c on b.dokument_registrering_id=c.id
WHERE c.dokument_id=new_uuid
and b.varianttekst='doc_varianttekst1'
and d.deltekst='doc_deltekst1B'
;

RETURN NEXT is(
	actual_del_egenskaber_2,
	ARRAY[docDel1BEgenskaber]
,'dokument variant del egenskaber 2 present');


SELECT array_agg(
	ROW(
		a.indeks,
		a.indhold,
		a.lokation,
		a.mimetype,
 		a.virkning
		)::DokumentDelEgenskaberType
	order by a.id asc
	) into actual_del_egenskaber_3
from  dokument_del_egenskaber a
join dokument_del d on a.del_id = d.id
join dokument_variant b on d.variant_id=b.id
join dokument_registrering c on b.dokument_registrering_id=c.id
WHERE c.dokument_id=new_uuid
and b.varianttekst='doc_varianttekst2'
and d.deltekst='doc_deltekst2A'
;

RETURN NEXT is(
	actual_del_egenskaber_3,
	ARRAY[docDel2AEgenskaber]
,'dokument variant del egenskaber 3 present');


SELECT array_agg(
	ROW(
		a.indeks,
		a.indhold,
		a.lokation,
		a.mimetype,
 		a.virkning
		)::DokumentDelEgenskaberType
	order by a.id asc
	) into actual_del_egenskaber_4
from  dokument_del_egenskaber a
join dokument_del d on a.del_id = d.id
join dokument_variant b on d.variant_id=b.id
join dokument_registrering c on b.dokument_registrering_id=c.id
WHERE c.dokument_id=new_uuid
and b.varianttekst='doc_varianttekst2'
and d.deltekst='doc_deltekst2B'
;

RETURN NEXT ok(
	coalesce(array_length(actual_del_egenskaber_4,1),0)=0 
,'dokument variant del egenskaber 4 ok');


--****************************
--Test document variants del relationer

SELECT array_agg(
	ROW(
		a.rel_type,
  		a.virkning,
  		a.rel_maal_uuid,
  		a.rel_maal_urn,
  		a.objekt_type
		)::DokumentdelRelationType
	order by a.id asc
	) into actual_del_relationer_1
from  dokument_del_relation a
join dokument_del d on a.del_id = d.id
join dokument_variant b on d.variant_id=b.id
join dokument_registrering c on b.dokument_registrering_id=c.id
WHERE c.dokument_id=new_uuid
and b.varianttekst='doc_varianttekst1'
and d.deltekst='doc_deltekst1A'
;

RETURN NEXT is(
	actual_del_relationer_1,
	ARRAY[docDel1Arelation1]
,'dokument variant del relationer 1 present');



SELECT array_agg(
	ROW(
		a.rel_type,
  		a.virkning,
  		a.rel_maal_uuid,
  		a.rel_maal_urn,
  		a.objekt_type
		)::DokumentdelRelationType
	order by a.id asc
	) into actual_del_relationer_2
from  dokument_del_relation a
join dokument_del d on a.del_id = d.id
join dokument_variant b on d.variant_id=b.id
join dokument_registrering c on b.dokument_registrering_id=c.id
WHERE c.dokument_id=new_uuid
and b.varianttekst='doc_varianttekst1'
and d.deltekst='doc_deltekst1B'
;

RETURN NEXT ok(
	coalesce(array_length(actual_del_relationer_2,1),0)=0 
,'dokument variant del relationer 2 ok');



SELECT array_agg(
	ROW(
		a.rel_type,
  		a.virkning,
  		a.rel_maal_uuid,
  		a.rel_maal_urn,
  		a.objekt_type
		)::DokumentdelRelationType
	order by a.id asc
	) into actual_del_relationer_3
from  dokument_del_relation a
join dokument_del d on a.del_id = d.id
join dokument_variant b on d.variant_id=b.id
join dokument_registrering c on b.dokument_registrering_id=c.id
WHERE c.dokument_id=new_uuid
and b.varianttekst='doc_varianttekst2'
and d.deltekst='doc_deltekst2A'
;

RETURN NEXT ok(
	coalesce(array_length(actual_del_relationer_3,1),0)=0 
,'dokument variant del relationer 3 ok');


SELECT array_agg(
	ROW(
		a.rel_type,
  		a.virkning,
  		a.rel_maal_uuid,
  		a.rel_maal_urn,
  		a.objekt_type
		)::DokumentdelRelationType
	order by a.id asc
	) into actual_del_relationer_4
from  dokument_del_relation a
join dokument_del d on a.del_id = d.id
join dokument_variant b on d.variant_id=b.id
join dokument_registrering c on b.dokument_registrering_id=c.id
WHERE c.dokument_id=new_uuid
and b.varianttekst='doc_varianttekst2'
and d.deltekst='doc_deltekst2B'
;

RETURN NEXT is(
	actual_del_relationer_4,
	ARRAY[docDel2Brelation1,docDel2Brelation2]
,'dokument variant del relationer 4 present');


--****************************
--test an import operation
uuid_returned_from_import:=as_create_or_import_dokument(registrering,uuid_to_import);

RETURN NEXT is(
	uuid_returned_from_import,
	uuid_to_import,
	'import returns uuid'
	);

RETURN NEXT is(
	ARRAY(
		SELECT
			id
		FROM
		dokument
		where id=uuid_to_import
		),
	ARRAY[uuid_to_import]::uuid[]
,'import creates new dokument.');




END;
$$;


ALTER FUNCTION test.test_as_create_or_import_dokument() OWNER TO mox;

--
-- Name: test_as_create_or_import_facet(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_create_or_import_facet() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid uuid;
	registrering FacetRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkAnsvarlig Virkning;
	virkRedaktoer1 Virkning;
	virkRedaktoer2 Virkning;
	virkPubliceret Virkning;
	facetEgenskab FacetEgenskaberAttrType;
	facetPubliceret FacetPubliceretTilsType;
	facetRelAnsvarlig FacetRelationType;
	facetRelRedaktoer1 FacetRelationType;
	facetRelRedaktoer2 FacetRelationType;
	uuidAnsvarlig uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	uuidRedaktoer1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	--uuidRedaktoer2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	urnRedaktoer2 text:='urn:isbn:0451450523'::text;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	actual_publiceret_virk virkning;
	actual_publiceret_value FacetPubliceretTils;
	actual_publiceret FacetPubliceretTilsType;
	actual_relationer FacetRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_to_import2 uuid :='90819cce-043b-447f-ba1e-92e6a75df929'::uuid;
	uuid_returned_from_import uuid;
	uuid_returned_from_import2 uuid;
BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkAnsvarlig :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

facetRelAnsvarlig := ROW (
	'ansvarlig'::FacetRelationKode,
		virkAnsvarlig,
	uuidAnsvarlig,
	null,
	'Aktr'
) :: FacetRelationType
;


facetRelRedaktoer1 := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer1,
	uuidRedaktoer1,
	null,
	null
) :: FacetRelationType
;



facetRelRedaktoer2 := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer2,
	null,
	urnRedaktoer2,
	null
) :: FacetRelationType
;


facetPubliceret := ROW (
virkPubliceret,
'Publiceret'
):: FacetPubliceretTilsType
;


facetEgenskab := ROW (
'brugervendt_noegle_text1',
   'facetbeskrivelse_text1',
   'facetplan_text1',
   'facetopbygning_text1',
   'facetophavsret_text1',
   'facetsupplement_text1',
   'retskilde_text1',
   virkEgenskaber
) :: FacetEgenskaberAttrType
;


registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
ARRAY[facetPubliceret]::FacetPubliceretTilsType[],
ARRAY[facetEgenskab]::FacetEgenskaberAttrType[],
ARRAY[facetRelAnsvarlig,facetRelRedaktoer1,facetRelRedaktoer2]
) :: FacetRegistreringType
;


new_uuid := as_create_or_import_facet(registrering);

RETURN NEXT is(
	ARRAY(
		SELECT
			id
		FROM
		facet
		where id=new_uuid
		),
	ARRAY[new_uuid]::uuid[]
);


SELECT
	(a.registrering).* into actual_registrering
FROM
facet_registrering a
where facet_id=new_uuid
;


RETURN NEXT is(actual_registrering.livscykluskode,(registrering.registrering).livscykluskode,'registrering livscykluskode');
RETURN NEXT is(actual_registrering.brugerref,(registrering.registrering).brugerref,'registrering brugerref');
RETURN NEXT is(actual_registrering.note,(registrering.registrering).note,'registrering note');
RETURN NEXT ok(upper(actual_registrering.timeperiod)='infinity'::timestamp with time zone,'registrering timeperiod upper is infinity');
RETURN NEXT ok(lower(actual_registrering.timeperiod) <clock_timestamp(),'registrering timeperiod before now');
RETURN NEXT ok(lower(actual_registrering.timeperiod) > clock_timestamp() - 3 * interval '1 second',' registrering timeperiod later than 3 secs' );

SELECT
	 	(a.virkning).* into actual_publiceret_virk
FROM facet_tils_publiceret a 
JOIN facet_registrering as b on a.facet_registrering_id=b.id
WHERE b.facet_id=new_uuid
;

SELECT
	 	a.publiceret into actual_publiceret_value
FROM facet_tils_publiceret a 
JOIN facet_registrering as b on a.facet_registrering_id=b.id
WHERE b.facet_id=new_uuid
;

actual_publiceret:=ROW(
	actual_publiceret_virk,
	actual_publiceret_value
)::FacetPubliceretTilsType ;


RETURN NEXT is(actual_publiceret.virkning,facetPubliceret.virkning,'publiceret virkning');
RETURN NEXT is(actual_publiceret.publiceret,facetPubliceret.publiceret,'publiceret value');

SELECT
array_agg(
			ROW (
					a.rel_type,
					a.virkning,
					a.rel_maal_uuid,
					a.rel_maal_urn,
					a.objekt_type 
				):: FacetRelationType
		) into actual_relationer
FROM facet_relation a
JOIN facet_registrering as b on a.facet_registrering_id=b.id
WHERE b.facet_id=new_uuid
;

RETURN NEXT is(
	actual_relationer,
	ARRAY[facetRelAnsvarlig,facetRelRedaktoer1,facetRelRedaktoer2]
,'relations present');

--****************************
--test an import operation
uuid_returned_from_import:=as_create_or_import_facet(registrering,uuid_to_import);

RETURN NEXT is(
	uuid_returned_from_import,
	uuid_to_import,
	'import returns uuid'
	);

RETURN NEXT is(
	ARRAY(
		SELECT
			id
		FROM
		facet
		where id=uuid_to_import
		),
	ARRAY[uuid_to_import]::uuid[]
,'import creates new facet.');

--****************************
--test that an exception is thrown when stipulated access criteria is not met


BEGIN
uuid_returned_from_import2:=as_create_or_import_facet(registrering,uuid_to_import2,
	ARRAY[
	ROW(
		null,
		array [
			ROW (
			null,
			'IkkePubliceret'
			):: FacetPubliceretTilsType
		]
		,null
		,null
		)
	::FacetRegistreringType
		]
	);


RETURN NEXT ok(false,'as_create_or_import test auth criteria#1: Should throw MO401 exception');
EXCEPTION  
WHEN sqlstate 'MO401' THEN
	RETURN NEXT ok(true,'as_create_or_import test auth criteria#1: Throws MO401 exception (as it should)');
END;

--****************************
--test that an exception is not thrown when stipulated access criteria is met

uuid_returned_from_import2:=as_create_or_import_facet(registrering,uuid_to_import2,
	ARRAY[
	ROW(
		null,
		array [
			ROW (
			null,
			'Publiceret'
			):: FacetPubliceretTilsType
		]
		,null
		,null
		)
	::FacetRegistreringType
		]
	);

RETURN NEXT is (uuid_returned_from_import2,uuid_to_import2,'No exception thrown, when criteria is met invoking import.');



END;
$$;


ALTER FUNCTION test.test_as_create_or_import_facet() OWNER TO mox;

--
-- Name: test_as_create_or_import_indsats(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_create_or_import_indsats() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	registrering indsatsRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkIndsatsmodtager Virkning;
	virkIndsatssag1 Virkning;
	virkIndsatssag2 Virkning;
	virkIndsatsaktoer1 Virkning;
	virkIndsatsaktoer2 Virkning;
	virkPubliceret Virkning;
	virkFremdrift Virkning;
	indsatsEgenskab indsatsEgenskaberAttrType;
	indsatsFremdrift indsatsFremdriftTilsType;
	indsatsPubliceret indsatsPubliceretTilsType;
	indsatsRelIndsatsmodtager indsatsRelationType;
	indsatsRelIndsatssag1 indsatsRelationType;
	indsatsRelIndsatssag2 indsatsRelationType;
	indsatsRelIndsatsaktoer1 indsatsRelationType;
	indsatsRelIndsatsaktoer2 indsatsRelationType;
	
	uuidIndsatsmodtager uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	uuidIndsatssag1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;


	--uuidIndsatssag2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	urnIndsatssag2 text:='urn:isbn:0451450523'::text;
	uuidIndsatsaktoer1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidIndsatsaktoer2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	actual_publiceret_virk virkning;
	actual_publiceret_value indsatsFremdriftTils;
	actual_publiceret indsatsFremdriftTilsType;
	actual_relationer indsatsRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	read_Indsats1 IndsatsType;
	expected_indsats1 IndsatsType;
BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkIndsatsmodtager :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkIndsatssag1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkIndsatssag2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkfremdrift := ROW (
	'[2016-12-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx20'
) :: Virkning
;

virkIndsatsaktoer1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkIndsatsaktoer2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

indsatsRelIndsatsmodtager := ROW (
	'indsatsmodtager'::indsatsRelationKode
	,virkIndsatsmodtager
	,uuidIndsatsmodtager
	,null
	,'Person'
	,567 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;


indsatsRelIndsatssag1 := ROW (
	'indsatssag'::indsatsRelationKode,
		virkIndsatssag1,
	uuidIndsatssag1,
	null,
	'Sag'
	,768 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsRelIndsatssag2 := ROW (
	'indsatssag'::indsatsRelationKode,
		virkIndsatssag2,
	null,
	urnIndsatssag2,
	'Sag'
	,800 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsRelIndsatsaktoer1 := ROW (
	'indsatsaktoer'::indsatsRelationKode,
		virkIndsatsaktoer1,
	uuidIndsatsaktoer1,
	null,
	'Person'
	,7268 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsRelIndsatsaktoer2 := ROW (
	'indsatsaktoer'::indsatsRelationKode,
		virkIndsatsaktoer2,
	uuidIndsatsaktoer2,
	null,
	'Person'
	,3 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsFremdrift := ROW (
virkFremdrift,
'Visiteret'::IndsatsFremdriftTils
):: indsatsFremdriftTilsType
;

indsatsPubliceret := ROW (
virkPubliceret,
'Normal'::IndsatsPubliceretTils
)::indsatsPubliceretTilsType;

indsatsEgenskab := ROW (
'brugervendtnoegle_indsats_1' --text, 
,'beskrivelse_indsats_1'-- text,
, '2017-01-20 08:00'::timestamptz  -- starttidspunkt,
, '2017-01-20 12:00'::timestamptz -- sluttidspunkt,
,virkEgenskaber
) :: indsatsEgenskaberAttrType
;


registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[indsatsPubliceret]::IndsatsPubliceretTilsType[],
ARRAY[indsatsFremdrift]::indsatsFremdriftTilsType[],
ARRAY[indsatsEgenskab]::indsatsEgenskaberAttrType[],
ARRAY[indsatsRelIndsatsmodtager,indsatsRelIndsatssag1,indsatsRelIndsatssag2,indsatsRelIndsatsaktoer1,indsatsRelIndsatsaktoer2]) :: indsatsRegistreringType
;


--raise notice 'to be written indsats 1:%',to_json(registrering);

new_uuid1 := as_create_or_import_indsats(registrering);

RETURN NEXT ok(true,'No errors running as_create_or_import_indsats');


read_Indsats1 := as_read_indsats(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);
raise notice 'read_Indsats1:%',to_json(read_Indsats1);

expected_indsats1:=ROW(
		new_uuid1,
		ARRAY[
			ROW(
			(read_Indsats1.registrering[1]).registrering
			,ARRAY[indsatsPubliceret]::indsatsPubliceretTilsType[]
			,ARRAY[indsatsFremdrift]::indsatsFremdriftTilsType[]
			,ARRAY[indsatsEgenskab]::indsatsEgenskaberAttrType[]
			,ARRAY[
				ROW (
				'indsatsaktoer'::indsatsRelationKode,
					virkIndsatsaktoer2,
				uuidIndsatsaktoer2,
				null,
				'Person'
				,2 --NOTICE: Should be replace in by import function
			) :: indsatsRelationType
				,
				ROW (
					'indsatssag'::indsatsRelationKode,
						virkIndsatssag1,
					uuidIndsatssag1,
					null,
					'Sag'
					,1 --NOTICE: Was replaced
				) :: indsatsRelationType
				,
				ROW (
				'indsatsaktoer'::indsatsRelationKode,
					virkIndsatsaktoer1,
				uuidIndsatsaktoer1,
				null,
				'Person'
				,1 --NOTICE: Was replaced  by import function
			) :: indsatsRelationType
			,
				ROW (
				'indsatsmodtager'::indsatsRelationKode
				,virkIndsatsmodtager
				,uuidIndsatsmodtager
				,null
				,'Person'
				,NULL --NOTICE: Was replaced
			) :: indsatsRelationType
			,ROW (
				'indsatssag'::indsatsRelationKode,
					virkIndsatssag2,
				null,
				urnIndsatssag2,
				'Sag'
				,2 --NOTICE: Was replaced
			) :: indsatsRelationType

				]::IndsatsRelationType[]
			)::IndsatsRegistreringType
			]::IndsatsRegistreringType[]
		)::IndsatsType
;

--raise notice 'expected_indsats1:%',to_json(expected_indsats1);



RETURN NEXT IS(
	read_Indsats1,
	expected_indsats1
	,'test create indsats #1'
);







END;
$$;


ALTER FUNCTION test.test_as_create_or_import_indsats() OWNER TO mox;

--
-- Name: test_as_create_or_import_sag(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_create_or_import_sag() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	registrering sagRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkPrimaerklasse Virkning;
	virkSekundaerpart1 Virkning;
	virkSekundaerpart2 Virkning;
	virkAndresager1 Virkning;
	virkAndresager2 Virkning;
	virkPubliceret Virkning;
	sagEgenskab sagEgenskaberAttrType;
	sagFremdrift sagFremdriftTilsType;
	sagRelPrimaerklasse sagRelationType;
	sagRelSekundaerpart1 sagRelationType;
	sagRelSekundaerpart2 sagRelationType;
	sagRelAndresager1 sagRelationType;
	sagRelAndresager2 sagRelationType;
	virkJournalNotat1 Virkning;
	uuidJournalNotat1  uuid :='97109356-e87e-4b10-ad5d-36de6e3ee011'::uuid;
	sagJournalNotat1 sagRelationType;
	virkJournalNotat2 Virkning;
	uuidJournalNotat2  uuid :='82109356-e87e-4b10-ad5d-36de6e3ee082'::uuid;
	sagJournalNotat2 sagRelationType;
	virkJournalNotat3 Virkning;
	uuidJournalNotat3  uuid :='27109356-e87e-4b10-ad5d-36de6e3ee015'::uuid;
	sagJournalNotat3 sagRelationType;

	virkJournalNotat4 Virkning;
	uuidJournalNotat4  uuid :='62109356-e87e-4b10-ad5d-36de6e3ee019'::uuid;
	sagJournalNotat4 sagRelationType;
	virkJournalNotat5 Virkning;
	uuidJournalNotat5  uuid :='80109356-e87e-4b10-ad5d-36de6e3ee007'::uuid;
	sagJournalNotat5 sagRelationType;

	virkJournalNotat6 Virkning;
	uuidJournalNotat6  uuid :='90109356-e87e-4b10-ad5d-36de6e3ee009'::uuid;
	sagJournalNotat6 sagRelationType;

	virkJournalNotat7 Virkning;
	uuidJournalNotat7  uuid :='92109356-e87e-4b10-ad5d-36de6e3ee011'::uuid;
	sagJournalNotat7 sagRelationType;

	uuidPrimaerklasse uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	uuidSekundaerpart1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;


	--uuidSekundaerpart2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	urnSekundaerpart2 text:='urn:isbn:0451450523'::text;
	uuidAndresager1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidAndresager2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	actual_publiceret_virk virkning;
	actual_publiceret_value sagFremdriftTils;
	actual_publiceret sagFremdriftTilsType;
	actual_relationer sagRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	read_Sag1 SagType;
	expected_sag1 SagType;
BEGIN


virkJournalNotat1 :=	ROW (
	'[2014-05-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat1,
          'Bruger',
          'NoteEx1233'
          ) :: Virkning
;


virkJournalNotat2 :=	ROW (
	'[2014-06-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat2,
          'Bruger',
          'NoteEx12331'
          ) :: Virkning
;

virkJournalNotat3 :=	ROW (
	'[2014-07-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat3,
          'Bruger',
          'NoteEx12332'
          ) :: Virkning
;

virkJournalNotat4 :=	ROW (
	'[2014-08-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat4,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkJournalNotat5 :=	ROW (
	'[2014-09-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat5,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;

virkJournalNotat6 :=	ROW (
	'[2014-02-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat5,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;

virkJournalNotat7 :=	ROW (
	'[2014-09-19, infinity)' :: TSTZRANGE,
          uuidJournalNotat5,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkPrimaerklasse :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkSekundaerpart1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkSekundaerpart2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkAndresager1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkAndresager2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

sagRelPrimaerklasse := ROW (
	'ansvarlig'::sagRelationKode
	,virkPrimaerklasse
	,uuidPrimaerklasse
	,null
	,'Klasse'
	,567 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;


sagRelSekundaerpart1 := ROW (
	'sekundaerpart'::sagRelationKode,
		virkSekundaerpart1,
	uuidSekundaerpart1,
	null,
	'Person'
	,768 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;



sagRelSekundaerpart2 := ROW (
	'sekundaerpart'::sagRelationKode,
		virkSekundaerpart2,
	null,
	urnSekundaerpart2,
	'Person'
	,800 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;



sagRelAndresager1 := ROW (
	'andresager'::sagRelationKode,
		virkAndresager1,
	uuidAndresager1,
	null,
	'Person'
	,7268 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;



sagRelAndresager2 := ROW (
	'andresager'::sagRelationKode,
		virkAndresager2,
	uuidAndresager2,
	null,
	'Person'
	,3 --NOTICE: Should be replace in by import function
	,null 
	,ROW(null,null,null)::JournalNotatType 
	,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
) :: sagRelationType
;


sagJournalNotat1:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat1,
					uuidJournalNotat1,
					null,
					'Person'
					,4  --NOTICE: Should be replace in by import function
					,'journalnotat'::SagRelationJournalPostSpecifikKode
					, ROW('journal_txt1','journal_notat1','journal_format1')::JournalNotatType --journalNotat
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);


sagJournalNotat2:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat2,
					uuidJournalNotat2,
					null,
					'Person'
					,5  --NOTICE: Should be replace in by import function
					,'journalnotat'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,'journal_format2')::JournalNotatType --journalNotat
					,null --journalDokumentAttr
				);


sagJournalNotat3:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat3,
					uuidJournalNotat3,
					null,
					'Person'
					,6  --NOTICE: Should be replace in by import function
					,'journalnotat'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);


sagJournalNotat4:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat4,
					uuidJournalNotat4,
					null,
					'Person'
					,19  --NOTICE: Should be replace in by import function
					,'vedlagtdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW('vedlagt_titel_1', ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);

sagJournalNotat5:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat5,
					uuidJournalNotat5,
					null,
					'Person'
					,20  --NOTICE: Should be replace in by import function
					,'tilakteretdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(NULL, ROW('AlternativTitel_1','Hjemmel_1')::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);

sagJournalNotat6:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat6,
					uuidJournalNotat6,
					null,
					'Person'
					,21  --NOTICE: Should be replace in by import function
					,'tilakteretdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(NULL, ROW('AlternativTitel_2',NULL)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);

sagJournalNotat7:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat7,
					uuidJournalNotat7,
					null,
					'Person'
					,22  --NOTICE: Should be replace in by import function
					,'tilakteretdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(NULL, ROW(NULL,'Hjemmel_3')::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);

sagFremdrift := ROW (
virkPubliceret,
'Opstaaet'
):: sagFremdriftTilsType
;


sagEgenskab := ROW (
'brugervendtnoegle_sag_1' --text, 
 ,false --'afleveret_sag_1'-- boolean,
,'beskrivelse_sag_1'-- text,
, 'hjemmel_sag_1'-- text,
, 'kassationskode_sag_1'-- text,
,ROW( 
	'alternativTitel_sag_1'
	,'hjemmel_sag_1'
 )::offentlighedundtagettype
, true --principiel boolean,
,'sagsnummer_1' -- text,
, 'titel_sag_1'-- text,
,virkEgenskaber
) :: sagEgenskaberAttrType
;


registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
ARRAY[sagFremdrift]::sagFremdriftTilsType[],
ARRAY[sagEgenskab]::sagEgenskaberAttrType[],
ARRAY[sagRelPrimaerklasse,sagRelSekundaerpart1,sagRelSekundaerpart2,sagRelAndresager1,sagRelAndresager2,sagJournalNotat1,sagJournalNotat2,sagJournalNotat3,sagJournalNotat4,sagJournalNotat5,sagJournalNotat6,sagJournalNotat7]
) :: sagRegistreringType
;


new_uuid1 := as_create_or_import_sag(registrering);

RETURN NEXT ok(true,'No errors running as_create_or_import_sag');


read_Sag1 := as_read_sag(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);
--raise notice 'read_Sag1:%',to_json(read_Sag1);

expected_sag1:=ROW(
		new_uuid1,
		ARRAY[
			ROW(
			(read_Sag1.registrering[1]).registrering
			,ARRAY[sagFremdrift]::sagFremdriftTilsType[]
			,ARRAY[sagEgenskab]::sagEgenskaberAttrType[]
			,ARRAY[
				ROW (
						'ansvarlig'::sagRelationKode
						,virkPrimaerklasse
						,uuidPrimaerklasse
						,null
						,'Klasse'
						,null  --NOTICE: Is nulled by import
						,null --relTypeSpec
						,ROW(null,null,null)::JournalNotatType --journalNotat
						,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType  --journalDokumentAttr
					) :: sagRelationType
				,  ROW (
						'sekundaerpart'::sagRelationKode,
							virkSekundaerpart1,
						uuidSekundaerpart1,
						null,
						'Person'
						,1 
						,null --relTypeSpec
						,ROW(null,null,null)::JournalNotatType 
						,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType
					) :: sagRelationType
				, 
				ROW (
					'sekundaerpart'::sagRelationKode,
						virkSekundaerpart2,
					null,
					urnSekundaerpart2,
					'Person'
					,2 
					,null --relTypeSpec
					,ROW(null,null,null)::JournalNotatType 
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				) :: sagRelationType
				,
				ROW (
					'andresager'::sagRelationKode,
						virkAndresager1,
					uuidAndresager1,
					null,
					'Person'
					,1 
					,null --relTypeSpec
					,ROW(null,null,null)::JournalNotatType 
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				) :: sagRelationType
				, ROW (
					'andresager'::sagRelationKode,
						virkAndresager2,
					uuidAndresager2,
					null,
					'Person'
					,2 
					,null --relTypeSpec
					,ROW(null,null,null)::JournalNotatType 
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				) :: sagRelationType
				,
				 ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat1,
					uuidJournalNotat1,
					null,
					'Person'
					,1 
					,'journalnotat'::SagRelationJournalPostSpecifikKode
					, ROW('journal_txt1','journal_notat1','journal_format1')::JournalNotatType --journalNotat
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				)
				 ,
				 ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat2,
					uuidJournalNotat2,
					null,
					'Person'
					,2  --NOTICE: 
					,'journalnotat'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,'journal_format2')::JournalNotatType --journalNotat
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType  --journalDokumentAttr
				),
				  ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat3,
					uuidJournalNotat3,
					null,
					'Person'
					,3  --NOTICE: Should be replace in by import function
					,'journalnotat'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType  --journalDokumentAttr
				)
				 ,ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat4,
					uuidJournalNotat4,
					null,
					'Person'
					,4  --NOTICE: Should be replace in by import function
					,'vedlagtdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW('vedlagt_titel_1', ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				)
				 ,ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat5,
					uuidJournalNotat5,
					null,
					'Person'
					,5  --NOTICE: Should be replace in by import function
					,'tilakteretdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(NULL, ROW('AlternativTitel_1','Hjemmel_1')::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				),
				 ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat6,
					uuidJournalNotat6,
					null,
					'Person'
					,6  --NOTICE: Should be replace in by import function
					,'tilakteretdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(NULL, ROW('AlternativTitel_2',NULL)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				)
				,
				 ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat7,
					uuidJournalNotat7,
					null,
					'Person'
					,7  --NOTICE: Should be replace in by import function
					,'tilakteretdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(NULL, ROW(NULL,'Hjemmel_3')::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
					)
				]::SagRelationType[]
			)::SagRegistreringType
			]::SagRegistreringType[]
		)::SagType
;

--raise notice 'expected_sag1:%',to_json(expected_sag1);



RETURN NEXT IS(
	read_Sag1,
	expected_sag1
	,'test create sag #1'
);







END;
$$;


ALTER FUNCTION test.test_as_create_or_import_sag() OWNER TO mox;

--
-- Name: test_as_filter_unauth_facet(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_filter_unauth_facet() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuidA uuid;
	new_uuidB uuid;
	new_uuidC uuid;
	registrering FacetRegistreringType;
	registrering2 FacetRegistreringType;
	registrering3 FacetRegistreringType;
	virkEgenskaber Virkning;
	virkEgenskaberB Virkning;
	virkEgenskaberC Virkning;
	virkEgenskaberC2 Virkning;
	virkEgenskaberD Virkning;
	virkAnsvarlig Virkning;
	virkRedaktoer1 Virkning;
	virkRedaktoer2 Virkning;
	virkPubliceret Virkning;
	virkPubliceretB Virkning;
	virkPubliceretC Virkning;
	facetEgenskabA FacetEgenskaberAttrType;
	facetEgenskabB FacetEgenskaberAttrType;
	facetEgenskabC FacetEgenskaberAttrType;
	facetEgenskabC2 FacetEgenskaberAttrType;
	facetPubliceret FacetPubliceretTilsType;
	facetPubliceretB FacetPubliceretTilsType;
	facetPubliceretC FacetPubliceretTilsType;
	facetRelAnsvarlig FacetRelationType;
	facetRelRedaktoer1 FacetRelationType;
	facetRelRedaktoer2 FacetRelationType;
	uuidAnsvarlig uuid :='e8477d45-a525-4b71-b0fa-eb25bb3c4b23'::uuid;
	uuidRedaktoer1 uuid :='55c3dc9c-60f2-4543-8971-7d1db40c4864'::uuid;
	uuidRedaktoer2 uuid :='c721b26d-daca-461a-a4ca-ec072f9ab9a7'::uuid;
	uuidRegistrering uuid :='107244b5-f00c-4679-a97a-b436176f05d5'::uuid;
	actual_facets1 FacetType[];
	expected_facets1 FacetType[];
	override_timeperiod1 TSTZRANGE;
	override_timeperiod2 TSTZRANGE;

	filter_reg4 FacetRegistreringType;
	filter_reg5 FacetRegistreringType;
	filter_reg6 FacetRegistreringType;
	filter_reg7A FacetRegistreringType;
	filter_reg7B FacetRegistreringType;
	filter_reg8A FacetRegistreringType;
	filter_reg8B FacetRegistreringType;
	filter_reg8C FacetRegistreringType;
	filter_reg9A FacetRegistreringType;
	filter_reg9B FacetRegistreringType;
	filter_reg9C FacetRegistreringType;
	filter_reg10A FacetRegistreringType;
	filter_reg10B FacetRegistreringType;
	filter_reg10C FacetRegistreringType;
	actual_result1 uuid[];
	actual_result2 uuid[];
	actual_result3 uuid[];
	actual_result4 uuid[];
	actual_result5 uuid[];
	actual_result6 uuid[];
	actual_result7 uuid[];
	actual_result8 uuid[];
	actual_result9 uuid[];
	actual_result10 uuid[];
	expected_result1 uuid[];
	expected_result2 uuid[];
	expected_result3 uuid[];
	expected_result4 uuid[];
	expected_result5 uuid[];
	expected_result6 uuid[];
	expected_result7 uuid[];
	expected_result8 uuid[];
	expected_result9 uuid[];
	expected_result10 uuid[];
BEGIN



virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          'ed4dc687-59e3-4b79-8f14-0f60a0145901'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaberB :=	ROW (
	'[2014-05-13, infinity)' :: TSTZRANGE,
          '48fcbc8b-4c72-4466-9dcc-0451f57b5b52'::uuid,
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;


virkEgenskaberC :=	ROW (
	'[2014-05-13, 2015-01-01)' :: TSTZRANGE,
          '48fcbc8b-4c72-4466-9dcc-0451f57b5b52'::uuid,
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;

virkEgenskaberC2 :=	ROW (
	'[2015-01-01, infinity)' :: TSTZRANGE,
          '98fcbc8b-4c72-4466-9dcc-0451f57b5b55'::uuid,
          'Bruger',
          'NoteEx8'
          ) :: Virkning
;


virkAnsvarlig :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          '7ac7ba19-8d41-427d-9353-907f2b09c011'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          '6892a667-63d9-4ecd-ada1-173f4d7d0c3e'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          'df93d345-e332-47f3-81f2-25a4bb6ae39e'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;


virkPubliceret:=	ROW (
	'[2015-05-01, infinity)' :: TSTZRANGE,
          'e6a1beb5-0c7e-4299-984a-64aa3963aa4a'::uuid,
          'Bruger',
          'NoteEx8'
          ) :: Virkning
;

virkPubliceretB:=	ROW (
	'[2014-05-13, infinity)' :: TSTZRANGE,
          '42fbf12c-da1c-4f2e-8ee7-995a4b3dd6cf'::uuid,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;


virkPubliceretC:=	ROW (
	'[2013-05-13, infinity)' :: TSTZRANGE,
          '02fbf12c-da1c-4f2e-8ee7-995a4b3dd6c7'::uuid,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;



facetRelAnsvarlig := ROW (
	'ansvarlig'::FacetRelationKode,
		virkAnsvarlig,
	uuidAnsvarlig,
	null,
	null
) :: FacetRelationType
;


facetRelRedaktoer1 := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer1,
	uuidRedaktoer1,
	null,
	null
) :: FacetRelationType
;



facetRelRedaktoer2 := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer2,
	uuidRedaktoer2,
	null,
	null
) :: FacetRelationType
;


facetPubliceret := ROW (
virkPubliceret,
'Publiceret'
):: FacetPubliceretTilsType
;

facetPubliceretB := ROW (
virkPubliceretB,
'IkkePubliceret'
):: FacetPubliceretTilsType
;


facetPubliceretC := ROW (
virkPubliceretC,
'Publiceret'
):: FacetPubliceretTilsType
;



facetEgenskabA := ROW (
'brugervendt_noegle_A',
   'facetbeskrivelse_A',
   'facetplan_ABC',
   'facetopbygning_AB',
   'facetophavsret_A',
   'facetsupplement_A',
   NULL,--'retskilde_text1',
   virkEgenskaber
) :: FacetEgenskaberAttrType
;

facetEgenskabB := ROW (
'brugervendt_noegle_B',
   'facetbeskrivelse_B',
   'facetplan_ABC',
   'facetopbygning_AB',
   'facetophavsret_BC',
   'facetsupplement_B',
   NULL, --restkilde
   virkEgenskaberB
) :: FacetEgenskaberAttrType
;

facetEgenskabC := ROW (
'brugervendt_noegle_C',
   'facetbeskrivelse_C',
   'facetplan_ABC',
   'facetopbygning_C',
   'facetophavsret_BC',
   'facetsupplement_C',
   NULL, --restkilde
   virkEgenskaberC
) :: FacetEgenskaberAttrType
;


facetEgenskabC2 := ROW (
'brugervendt_noegle_C2',
   'facetbeskrivelse_C2',
   'facetplan_C',
   'facetopbygning_C2',
   'facetophavsret_BC',
   'facetsupplement_C2',
   'restkilde_C2',
   virkEgenskaberC2
) :: FacetEgenskaberAttrType
;

registrering := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
ARRAY[facetPubliceret]::FacetPubliceretTilsType[],
ARRAY[facetEgenskabA]::FacetEgenskaberAttrType[],
ARRAY[facetRelRedaktoer1,facetRelRedaktoer2,facetRelAnsvarlig]
) :: FacetRegistreringType
;

registrering2 := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 27') :: RegistreringBase
	,
ARRAY[facetPubliceretB]::FacetPubliceretTilsType[],
ARRAY[facetEgenskabB]::FacetEgenskaberAttrType[],
ARRAY[facetRelRedaktoer1]
) :: FacetRegistreringType
;


registrering3 := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 85') :: RegistreringBase
	,
ARRAY[facetPubliceretC],
ARRAY[facetEgenskabC,facetEgenskabC2]::FacetEgenskaberAttrType[],
null
) :: FacetRegistreringType
;

new_uuidA := as_create_or_import_facet(registrering);
new_uuidB := as_create_or_import_facet(registrering2);
new_uuidC := as_create_or_import_facet(registrering3);


/***************************************/
expected_result1:=ARRAY[new_uuidA,new_uuidB,new_uuidC];
actual_result1:=_as_filter_unauth_facet(array[new_uuidA,new_uuidB,new_uuidC]::uuid[],null);

RETURN NEXT ok( coalesce(array_length(expected_result1,1),0)=coalesce(array_length(actual_result1,1),0) AND actual_result1 @>expected_result1,'Test for null criteria');


expected_result2:=ARRAY[]::uuid[];
actual_result2:=_as_filter_unauth_facet(array[new_uuidA,new_uuidB,new_uuidC]::uuid[],array[]::FacetRegistreringType[]);

RETURN NEXT ok( coalesce(array_length(expected_result2,1),0)=coalesce(array_length(actual_result2,1),0) AND actual_result2 @>expected_result2,'Test for empty criteria array');



expected_result3:=ARRAY[]::uuid[];
actual_result3:=_as_filter_unauth_facet(array[]::uuid[],array[]::FacetRegistreringType[]);

RETURN NEXT ok( coalesce(array_length(expected_result3,1),0)=coalesce(array_length(actual_result3,1),0) AND actual_result3 @>expected_result3,'Test for empty uuid array');

/***************************************/

filter_reg4:=ROW(
	null --reg base
	,ARRAY[]::FacetPubliceretTilsType[]
	,ARRAY[
		ROW(
			null --'brugervendt_noegle_C',
   			,null --'facetbeskrivelse_C',
   			,'facetplan_ABC'
   			,null --'facetopbygning_C',
   			,null --'facetophavsret_C',
   			,null --'facetsupplement_C',
   			,NULL --restkilde
   			,null --virkEgenskaberC
			)::FacetEgenskaberAttrType
	]::FacetEgenskaberAttrType[]
	,ARRAY[]::FacetRelationType[]
)::FacetRegistreringType;


expected_result4:=array[new_uuidA,new_uuidB]::uuid[];
actual_result4:=_as_filter_unauth_facet(array[new_uuidA,new_uuidB,new_uuidC]::uuid[],array[filter_reg4]::FacetRegistreringType[]);

RETURN NEXT ok( coalesce(array_length(expected_result4,1),0)=coalesce(array_length(actual_result4,1),0) AND actual_result4 @>expected_result4,'Test #4');

/***************************************/


filter_reg5:=ROW(
	null --reg base
	,ARRAY[
			ROW(
				null,
				'Publiceret'
				)::FacetPubliceretTilsType
			]::FacetPubliceretTilsType[]
	,ARRAY[
		ROW(
			null --'brugervendt_noegle_C',
   			,null --'facetbeskrivelse_C',
   			,'facetplan_ABC'
   			,null --'facetopbygning_C',
   			,null --'facetophavsret_C',
   			,null --'facetsupplement_C',
   			,NULL --restkilde
   			,null --virkEgenskaberC
			)::FacetEgenskaberAttrType
	]::FacetEgenskaberAttrType[]
	,ARRAY[]::FacetRelationType[]
)::FacetRegistreringType;


expected_result5:=array[new_uuidA]::uuid[];
actual_result5:=_as_filter_unauth_facet(array[new_uuidA,new_uuidB,new_uuidC]::uuid[],array[filter_reg5]::FacetRegistreringType[]);

RETURN NEXT ok( coalesce(array_length(expected_result5,1),0)=coalesce(array_length(actual_result5,1),0) AND actual_result5 @>expected_result5,'Test #5');

/***************************************/

filter_reg6:=ROW(
	null --reg base
	,null --ARRAY[]::FacetPubliceretTilsType[]
	,ARRAY[
		ROW(
			null --'brugervendt_noegle_C',
   			,null --'facetbeskrivelse_C',
   			,'facetplan_ABC'
   			,'facetopbygning_AB' --'facetopbygning_C',
   			,null --'facetophavsret_C',
   			,null --'facetsupplement_C',
   			,NULL --restkilde
   			,null --virkEgenskaberC
			)::FacetEgenskaberAttrType
		,
		ROW(
			'brugervendt_noegle_B'
   			,null --'facetbeskrivelse_C',
   			,null
   			,null --'facetopbygning_C',
   			,null --'facetophavsret_C',
   			,null --'facetsupplement_C',
   			,NULL --restkilde
   			,null --virkEgenskaberC
			)::FacetEgenskaberAttrType
	]::FacetEgenskaberAttrType[]
	,null --ARRAY[]::FacetRelationType[]
)::FacetRegistreringType;


expected_result6:=array[new_uuidB]::uuid[];
actual_result6:=_as_filter_unauth_facet(array[new_uuidA,new_uuidB,new_uuidC]::uuid[],array[filter_reg6]::FacetRegistreringType[]);

RETURN NEXT ok( coalesce(array_length(expected_result6,1),0)=coalesce(array_length(actual_result6,1),0) AND actual_result6 @>expected_result6,'Test #6');

/***************************************/
filter_reg7A:=ROW(
	null --reg base
	,null --ARRAY[]::FacetPubliceretTilsType[]
	,ARRAY[
		ROW(
			null --'brugervendt_noegle_C',
   			,null --'facetbeskrivelse_C',
   			,'facetplan_ABC'
   			,'facetopbygning_AB' --'facetopbygning_C',
   			,null --'facetophavsret_C',
   			,null --'facetsupplement_C',
   			,NULL --restkilde
   			,null --virkEgenskaberC
			)::FacetEgenskaberAttrType
	]::FacetEgenskaberAttrType[]
	,null --ARRAY[]::FacetRelationType[]
)::FacetRegistreringType;

filter_reg7B:=ROW(
	null --reg base
	,null --ARRAY[]::FacetPubliceretTilsType[]
	,ARRAY[
		ROW(
			'brugervendt_noegle_B'
   			,null --'facetbeskrivelse_C',
   			,null
   			,null --'facetopbygning_C',
   			,null --'facetophavsret_C',
   			,null --'facetsupplement_C',
   			,NULL --restkilde
   			,null --virkEgenskaberC
			)::FacetEgenskaberAttrType
	]::FacetEgenskaberAttrType[]
	,null --ARRAY[]::FacetRelationType[]
)::FacetRegistreringType;



expected_result7:=array[new_uuidA,new_uuidB]::uuid[];
actual_result7:=_as_filter_unauth_facet(array[new_uuidA,new_uuidB,new_uuidC]::uuid[],array[filter_reg7A,filter_reg7B]::FacetRegistreringType[]);

RETURN NEXT ok( coalesce(array_length(expected_result7,1),0)=coalesce(array_length(actual_result7,1),0) AND actual_result7 @>expected_result7,'Test #7');


/***************************************/


filter_reg8A:=ROW(
	null --reg base
	,ARRAY[ROW(
				null,
				'IkkePubliceret'
				)::FacetPubliceretTilsType
			]::FacetPubliceretTilsType[]
	,ARRAY[]::FacetEgenskaberAttrType[]
	,null --ARRAY[]::FacetRelationType[]
)::FacetRegistreringType;

filter_reg8B:=ROW(
	null --reg base
	,null --ARRAY[]::FacetPubliceretTilsType[]
	,ARRAY[
		ROW(
			null
   			,null --'facetbeskrivelse_C',
   			,null
   			,null --'facetopbygning_C',
   			,null --'facetophavsret_C',
   			,'facetsupplement_C2' --'facetsupplement_C',
   			,NULL --restkilde
   			,null --virkEgenskaberC
			)::FacetEgenskaberAttrType
	]::FacetEgenskaberAttrType[]
	,null --ARRAY[]::FacetRelationType[]
)::FacetRegistreringType;


filter_reg8C:=ROW(
	null --reg base
	,null --ARRAY[]::FacetPubliceretTilsType[]
	, null--ARRAY[]::FacetEgenskaberAttrType[]
	,ARRAY[
		 ROW (
			'ansvarlig'::FacetRelationKode,
				null,
			uuidAnsvarlig,
			null,
			null
		) :: FacetRelationType
	]::FacetRelationType[]
)::FacetRegistreringType;


expected_result8:=array[new_uuidA,new_uuidB,new_uuidC]::uuid[];
actual_result8:=_as_filter_unauth_facet(array[new_uuidA,new_uuidB,new_uuidC]::uuid[],array[filter_reg8A,filter_reg8B,filter_reg8C]::FacetRegistreringType[]);


--RAISE NOTICE 'expected_result8:%',expected_result8 ;
--RAISE NOTICE 'actual_result8:%',actual_result8 ;

RETURN NEXT ok( coalesce(array_length(expected_result8,1),0)=coalesce(array_length(actual_result8,1),0) AND actual_result8 @>expected_result8,'Test #8');


/***************************************/


filter_reg9A:=ROW(
	null --reg base
	,ARRAY[ROW(
				null,
				'IkkePubliceret'
				)::FacetPubliceretTilsType
			]::FacetPubliceretTilsType[]
	,ARRAY[]::FacetEgenskaberAttrType[]
	,ARRAY[
		 ROW (
			'ansvarlig'::FacetRelationKode,
				null,
			uuidAnsvarlig,
			null,
			null
		) :: FacetRelationType--ARRAY[]::FacetRelationType[]
		 ]
)::FacetRegistreringType;

filter_reg9B:=ROW(
	null --reg base
	,null --ARRAY[]::FacetPubliceretTilsType[]
	,ARRAY[
		ROW(
			null
   			,null --'facetbeskrivelse_C',
   			,null
   			,null --'facetopbygning_C',
   			,null --'facetophavsret_C',
   			,'facetsupplement_C2' --'facetsupplement_C',
   			,NULL --restkilde
   			,null --virkEgenskaberC
			)::FacetEgenskaberAttrType
	]::FacetEgenskaberAttrType[]
	,null --ARRAY[]::FacetRelationType[]
)::FacetRegistreringType;


filter_reg9C:=ROW(
	null --reg base
	,null --ARRAY[]::FacetPubliceretTilsType[]
	, null--ARRAY[]::FacetEgenskaberAttrType[]
	,ARRAY[
		 ROW (
			'ansvarlig'::FacetRelationKode,
				null,
			uuidAnsvarlig,
			null,
			null
		) :: FacetRelationType
	]::FacetRelationType[]
)::FacetRegistreringType;


expected_result9:=array[new_uuidA,new_uuidC]::uuid[];
actual_result9:=_as_filter_unauth_facet(array[new_uuidA,new_uuidB,new_uuidC]::uuid[],array[filter_reg9A,filter_reg9B,filter_reg9C]::FacetRegistreringType[]);


--RAISE NOTICE 'expected_result9:%',expected_result9 ;
--RAISE NOTICE 'actual_result9:%',actual_result9 ;

RETURN NEXT ok( coalesce(array_length(expected_result9,1),0)=coalesce(array_length(actual_result9,1),0) AND actual_result9 @>expected_result9,'Test #9');

/***************************************/

filter_reg10A:=ROW(
	null --reg base
	,ARRAY[ROW(
				null,
				'IkkePubliceret'
				)::FacetPubliceretTilsType
			]::FacetPubliceretTilsType[]
	,ARRAY[]::FacetEgenskaberAttrType[]
	,ARRAY[
		 ROW (
			'ansvarlig'::FacetRelationKode,
				null,
			uuidAnsvarlig,
			null,
			null
		) :: FacetRelationType--ARRAY[]::FacetRelationType[]
		 ]
)::FacetRegistreringType;

filter_reg10B:=ROW(
	null --reg base
	,null --ARRAY[]::FacetPubliceretTilsType[]
	,ARRAY[
		ROW(
			null
   			,null --'facetbeskrivelse_C',
   			,null
   			,null --'facetopbygning_C',
   			,null --'facetophavsret_C',
   			,'facetsupplement_C2' --'facetsupplement_C',
   			,NULL --restkilde
   			,null --virkEgenskaberC
			)::FacetEgenskaberAttrType
	]::FacetEgenskaberAttrType[]
	,null --ARRAY[]::FacetRelationType[]
)::FacetRegistreringType;


filter_reg10C:=ROW(
	null --reg base
	,null --ARRAY[]::FacetPubliceretTilsType[]
	, null--ARRAY[]::FacetEgenskaberAttrType[]
	,ARRAY[
		 ROW (
			'ansvarlig'::FacetRelationKode,
				null,
			uuidAnsvarlig,
			null,
			null
		) :: FacetRelationType
	]::FacetRelationType[]
)::FacetRegistreringType;


expected_result10:=array[new_uuidC]::uuid[];
actual_result10:=_as_filter_unauth_facet(array[new_uuidB,new_uuidC]::uuid[],array[filter_reg10A,filter_reg10B,filter_reg10C]::FacetRegistreringType[]);


--RAISE NOTICE 'expected_result10:%',expected_result10 ;
--RAISE NOTICE 'actual_result10:%',actual_result10 ;

RETURN NEXT ok( coalesce(array_length(expected_result10,1),0)=coalesce(array_length(actual_result10,1),0) AND actual_result10 @>expected_result10,'Test #10');


END;
$$;


ALTER FUNCTION test.test_as_filter_unauth_facet() OWNER TO mox;

--
-- Name: test_as_filter_unauth_indsats(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_filter_unauth_indsats() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	new_uuid2 uuid;
	new_uuid3 uuid;
	registrering indsatsRegistreringType;
	registrering2 indsatsRegistreringType;
	registrering3 indsatsRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkEgenskaber2 Virkning;
	virkEgenskaber3 Virkning;
	virkIndsatsmodtager Virkning;
	virkIndsatsmodtager3 Virkning;
	virkIndsatssag1 Virkning;
	virkIndsatssag2 Virkning;
	virkIndsatsaktoer1 Virkning;
	virkIndsatsaktoer2 Virkning;
	virkPubliceret Virkning;
	virkPubliceret3 Virkning;
	virkFremdrift Virkning;
	virkFremdrift3 Virkning;
	indsatsEgenskab indsatsEgenskaberAttrType;
	indsatsEgenskab2 indsatsEgenskaberAttrType;
	indsatsEgenskab3 indsatsEgenskaberAttrType;
	indsatsFremdrift indsatsFremdriftTilsType;
	indsatsFremdrift3 indsatsFremdriftTilsType;
	indsatsPubliceret indsatsPubliceretTilsType;
	indsatsPubliceret3 indsatsPubliceretTilsType;
	indsatsRelIndsatsmodtager indsatsRelationType;
	indsatsRelIndsatsmodtager3 indsatsRelationType;
	indsatsRelIndsatssag1 indsatsRelationType;
	indsatsRelIndsatssag2 indsatsRelationType;
	indsatsRelIndsatsaktoer1 indsatsRelationType;
	indsatsRelIndsatsaktoer2 indsatsRelationType;
	
	uuidIndsatsmodtager uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	uuidIndsatssag1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	uuidIndsatsmodtager3 uuid :='6cf639ec-82e9-45aa-8723-1dd0b42af37e'::uuid;

	--uuidIndsatssag2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	urnIndsatssag2 text:='urn:isbn:0451450523'::text;
	uuidIndsatsaktoer1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidIndsatsaktoer2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	actual_publiceret_virk virkning;
	actual_publiceret_value indsatsFremdriftTils;
	actual_publiceret indsatsFremdriftTilsType;
	actual_relationer indsatsRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	read_Indsats1 IndsatsType;
	read_Indsats2 IndsatsType;
	read_Indsats3 IndsatsType;
	expected_indsats1 IndsatsType;

expected_filter_res_1 uuid[];
	expected_filter_res_2 uuid[];
	expected_filter_res_3 uuid[];
	expected_filter_res_4 uuid[];
	expected_filter_res_5 uuid[];
	expected_filter_res_6 uuid[];
	expected_filter_res_7 uuid[];

	actual_filter_res_1 uuid[];
	actual_filter_res_2 uuid[];
	actual_filter_res_3 uuid[];
	actual_filter_res_4 uuid[];
	actual_filter_res_5 uuid[];
	actual_filter_res_6 uuid[];
	actual_filter_res_7 uuid[];
	


BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaber2 :=	ROW (
	'[2016-06-01, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx43'
          ) :: Virkning
;

virkIndsatsmodtager :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkIndsatssag1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkIndsatssag2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkfremdrift := ROW (
	'[2016-12-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx20'
) :: Virkning
;

virkIndsatsaktoer1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkIndsatsaktoer2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

indsatsRelIndsatsmodtager := ROW (
	'indsatsmodtager'::indsatsRelationKode
	,virkIndsatsmodtager
	,uuidIndsatsmodtager
	,null
	,'Person'
	,567 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;


indsatsRelIndsatssag1 := ROW (
	'indsatssag'::indsatsRelationKode,
		virkIndsatssag1,
	uuidIndsatssag1,
	null,
	'Sag'
	,768 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsRelIndsatssag2 := ROW (
	'indsatssag'::indsatsRelationKode,
		virkIndsatssag2,
	null,
	urnIndsatssag2,
	'Sag'
	,800 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsRelIndsatsaktoer1 := ROW (
	'indsatsaktoer'::indsatsRelationKode,
		virkIndsatsaktoer1,
	uuidIndsatsaktoer1,
	null,
	'Person'
	,7268 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsRelIndsatsaktoer2 := ROW (
	'indsatsaktoer'::indsatsRelationKode,
		virkIndsatsaktoer2,
	uuidIndsatsaktoer2,
	null,
	'Person'
	,3 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsFremdrift := ROW (
virkFremdrift,
'Visiteret'::IndsatsFremdriftTils
):: indsatsFremdriftTilsType
;

indsatsPubliceret := ROW (
virkPubliceret,
'Normal'::IndsatsPubliceretTils
)::indsatsPubliceretTilsType;

indsatsEgenskab := ROW (
'brugervendtnoegle_indsats_1' --text, 
,'beskrivelse_indsats_faelles'-- text,
, '2017-01-20 08:00'::timestamptz  -- starttidspunkt,
, '2017-01-20 12:00'::timestamptz -- sluttidspunkt,
,virkEgenskaber
) :: indsatsEgenskaberAttrType
;


registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[indsatsPubliceret]::IndsatsPubliceretTilsType[],
ARRAY[indsatsFremdrift]::indsatsFremdriftTilsType[],
ARRAY[indsatsEgenskab]::indsatsEgenskaberAttrType[],
ARRAY[indsatsRelIndsatsmodtager,indsatsRelIndsatssag1,indsatsRelIndsatssag2,indsatsRelIndsatsaktoer1,indsatsRelIndsatsaktoer2]) :: indsatsRegistreringType
;


--raise notice 'to be written indsats 1:%',to_json(registrering);

new_uuid1 := as_create_or_import_indsats(registrering);

RETURN NEXT ok(true,'No errors running as_create_or_import_indsats #1');



/*********************************************/


indsatsEgenskab2 := ROW (
'brugervendtnoegle_indsats_2' --text, 
,'beskrivelse_indsats_faelles'-- text,
, '2017-01-25 09:00'::timestamptz  -- starttidspunkt,
, '2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,virkEgenskaber2
) :: indsatsEgenskaberAttrType
;



registrering2 := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 35') :: RegistreringBase
	,
	ARRAY[indsatsPubliceret]::IndsatsPubliceretTilsType[],
ARRAY[indsatsFremdrift]::indsatsFremdriftTilsType[],
ARRAY[indsatsEgenskab2]::indsatsEgenskaberAttrType[],
ARRAY[indsatsRelIndsatsmodtager,indsatsRelIndsatsaktoer1,indsatsRelIndsatsaktoer2]) :: indsatsRegistreringType
;


--raise notice 'to be written indsats 1:%',to_json(registrering);

new_uuid2 := as_create_or_import_indsats(registrering2);

RETURN NEXT ok(true,'No errors running as_create_or_import_indsats #2');


/*********************************************/
virkEgenskaber3 :=	ROW (
	'[2017-06-01, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx50'
          ) :: Virkning
;

indsatsEgenskab3 := ROW (
'brugervendtnoegle_indsats_3' --text, 
,'beskrivelse_indsats_faelles'-- text,
, '2017-02-25 09:00'::timestamptz  -- starttidspunkt,
, '2017-02-26 12:00'::timestamptz -- sluttidspunkt,
,virkEgenskaber3
) :: indsatsEgenskaberAttrType
;


virkIndsatsmodtager3 :=	ROW (
	'[2015-06-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx50'
          ) :: Virkning
;


indsatsRelIndsatsmodtager3 := ROW (
	'indsatsmodtager'::indsatsRelationKode
	,virkIndsatsmodtager3
	,uuidIndsatsmodtager3
	,null
	,'Person'
	,1 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;

virkPubliceret3 := ROW (
	'[2016-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx40'
) :: Virkning
;

virkfremdrift3 := ROW (
	'[2016-12-01, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx30'
) :: Virkning
;


indsatsFremdrift3 := ROW (
virkFremdrift3,
'Vurderet'::IndsatsFremdriftTils
):: indsatsFremdriftTilsType
;

indsatsPubliceret3 := ROW (
virkPubliceret3,
'IkkePubliceret'::IndsatsPubliceretTils
)::indsatsPubliceretTilsType;


registrering3 := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 35') :: RegistreringBase
	,
	ARRAY[indsatsPubliceret3]::IndsatsPubliceretTilsType[],
ARRAY[indsatsFremdrift3]::indsatsFremdriftTilsType[],
ARRAY[indsatsEgenskab3]::indsatsEgenskaberAttrType[],
ARRAY[indsatsRelIndsatsmodtager3]::indsatsRelationType[] ) :: indsatsRegistreringType
;


--raise notice 'to be written indsats 1:%',to_json(registrering);

new_uuid3 := as_create_or_import_indsats(registrering3);

RETURN NEXT ok(true,'No errors running as_create_or_import_indsats #3');



/*********************************************/

expected_filter_res_1:=array[new_uuid2]::uuid[];


actual_filter_res_1:=_as_filter_unauth_indsats(
	array[new_uuid1,new_uuid2,new_uuid3]::uuid[]
		,ARRAY[ ROW(
			null,
			null,
			null,
			ARRAY[ ROW (
'brugervendtnoegle_indsats_2' --text, 
,null--'beskrivelse_indsats_2'-- text,
, null--'2017-01-25 09:00'::timestamptz  -- starttidspunkt,
, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType ]::IndsatsEgenskaberAttrType[],
			null-- AktivitetRelationType[]
		)::indsatsRegistreringType]::indsatsRegistreringType[]	
);

--read_Indsats1:=as_read_indsats(new_uuid1,null,null);
--read_Indsats2:=as_read_indsats(new_uuid2,null,null);
--read_Indsats3:=as_read_indsats(new_uuid3,null,null);

--raise notice 'indsats reg1 #1:%',to_json(actual_filter_res_1);

--raise notice 'returned uuids from filter #1:%',to_json(actual_filter_res_1);

RETURN NEXT ok(expected_filter_res_1 @> actual_filter_res_1 and actual_filter_res_1 @>expected_filter_res_1 and coalesce(array_length(expected_filter_res_1,1),0)=coalesce(array_length(actual_filter_res_1,1),0), 'unauth filter indsats #1.');

/**************************************************/

expected_filter_res_2:=array[new_uuid1]::uuid[];


actual_filter_res_2:=_as_filter_unauth_indsats(
	array[new_uuid1,new_uuid2,new_uuid3]::uuid[]
		,ARRAY[ ROW(
			null,
			null,
			null,
			ARRAY[ ROW (
null --text, 
,null--'beskrivelse_indsats_2'-- text,
, '2017-01-20 08:00'::timestamptz  -- starttidspunkt,
, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType ]::IndsatsEgenskaberAttrType[],
			null-- AktivitetRelationType[]
		)::indsatsRegistreringType]::indsatsRegistreringType[]	
);

--read_Indsats1:=as_read_indsats(new_uuid1,null,null);
--read_Indsats2:=as_read_indsats(new_uuid2,null,null);
--read_Indsats3:=as_read_indsats(new_uuid3,null,null);

--raise notice 'indsats reg1 #1:%',to_json(actual_filter_res_2);

--raise notice 'returned uuids from filter #1:%',to_json(actual_filter_res_2);

RETURN NEXT ok(expected_filter_res_2 @> actual_filter_res_2 and actual_filter_res_2 @>expected_filter_res_2 and coalesce(array_length(expected_filter_res_2,1),0)=coalesce(array_length(actual_filter_res_2,1),0), 'unauth filter indsats #2.');
/**************************************************/

expected_filter_res_3:=array[new_uuid3]::uuid[];


actual_filter_res_3:=_as_filter_unauth_indsats(
	array[new_uuid1,new_uuid2,new_uuid3]::uuid[]
		,ARRAY[ ROW(
			null,
			 ARRAY [ROW (
			null,
			'IkkePubliceret'::IndsatsPubliceretTils
			 )::indsatsPubliceretTilsType]::indsatsPubliceretTilsType[],
			null,
			null,
			null-- AktivitetRelationType[]
		)::indsatsRegistreringType]::indsatsRegistreringType[]	
);

--read_Indsats1:=as_read_indsats(new_uuid1,null,null);
--read_Indsats2:=as_read_indsats(new_uuid2,null,null);
--read_Indsats3:=as_read_indsats(new_uuid3,null,null);

--raise notice 'indsats reg1 #1:%',to_json(actual_filter_res_3);

--raise notice 'returned uuids from filter #1:%',to_json(actual_filter_res_3);

RETURN NEXT ok(expected_filter_res_3 @> actual_filter_res_3 and actual_filter_res_3 @>expected_filter_res_3 and coalesce(array_length(expected_filter_res_3,1),0)=coalesce(array_length(actual_filter_res_3,1),0), 'unauth filter indsats #3.');

/**************************************************/

expected_filter_res_4:=array[new_uuid3]::uuid[];


actual_filter_res_4:=_as_filter_unauth_indsats(
	array[new_uuid1,new_uuid2,new_uuid3]::uuid[]
		,ARRAY[ ROW(
			null,
			null,
			array [ROW (
			null,
			'Vurderet'::IndsatsFremdriftTils
			):: indsatsFremdriftTilsType]::indsatsFremdriftTilsType[],
			null,
			null-- AktivitetRelationType[]
		)::indsatsRegistreringType]::indsatsRegistreringType[]	
);



--read_Indsats1:=as_read_indsats(new_uuid1,null,null);
--read_Indsats2:=as_read_indsats(new_uuid2,null,null);
--read_Indsats3:=as_read_indsats(new_uuid3,null,null);

--raise notice 'indsats reg1 #1:%',to_json(actual_filter_res_4);

--raise notice 'returned uuids from filter #1:%',to_json(actual_filter_res_4);

RETURN NEXT ok(expected_filter_res_4 @> actual_filter_res_4 and actual_filter_res_4 @>expected_filter_res_4 and coalesce(array_length(expected_filter_res_4,1),0)=coalesce(array_length(actual_filter_res_4,1),0), 'unauth filter indsats #4.');

/**************************************************/

expected_filter_res_5:=array[]::uuid[];


actual_filter_res_5:=_as_filter_unauth_indsats(
	array[new_uuid1,new_uuid2,new_uuid3]::uuid[]
		,ARRAY[ ROW(
			null,
			null,
			array [ROW (
			null,
			'Disponeret'::IndsatsFremdriftTils
			):: indsatsFremdriftTilsType]::indsatsFremdriftTilsType[],
			null,
			null-- AktivitetRelationType[]
		)::indsatsRegistreringType]::indsatsRegistreringType[]	
);



--read_Indsats1:=as_read_indsats(new_uuid1,null,null);
--read_Indsats2:=as_read_indsats(new_uuid2,null,null);
--read_Indsats3:=as_read_indsats(new_uuid3,null,null);

--raise notice 'indsats reg1 #1:%',to_json(actual_filter_res_5);

--raise notice 'returned uuids from filter #1:%',to_json(actual_filter_res_5);

RETURN NEXT ok(expected_filter_res_5 @> actual_filter_res_5 and actual_filter_res_5 @>expected_filter_res_5 and coalesce(array_length(expected_filter_res_5,1),0)=coalesce(array_length(actual_filter_res_5,1),0), 'unauth filter indsats #5.');

/**************************************************/

expected_filter_res_6:=array[new_uuid3]::uuid[];


actual_filter_res_6:=_as_filter_unauth_indsats(
	array[new_uuid1,new_uuid2,new_uuid3]::uuid[]
		,ARRAY[ ROW(
			null,
			null,
			null,
			null,
			array[
			 ROW (
				'indsatsmodtager'::indsatsRelationKode
					,null
				,uuidIndsatsmodtager3
					,null
					,null
					,null
				) :: indsatsRelationType
			]::indsatsRelationType[]
		)::indsatsRegistreringType]::indsatsRegistreringType[]	
);



--read_Indsats1:=as_read_indsats(new_uuid1,null,null);
--read_Indsats2:=as_read_indsats(new_uuid2,null,null);
--read_Indsats3:=as_read_indsats(new_uuid3,null,null);

--raise notice 'indsats reg1 #1:%',to_json(actual_filter_res_6);

--raise notice 'returned uuids from filter #1:%',to_json(actual_filter_res_6);

RETURN NEXT ok(expected_filter_res_6 @> actual_filter_res_6 and actual_filter_res_6 @>expected_filter_res_6 and coalesce(array_length(expected_filter_res_6,1),0)=coalesce(array_length(actual_filter_res_6,1),0), 'unauth filter indsats #6.');

/**************************************************/

expected_filter_res_7:=array[]::uuid[];


actual_filter_res_7:=_as_filter_unauth_indsats(
	array[new_uuid1,new_uuid2]::uuid[]
		,ARRAY[ ROW(
			null,
			null,
			null,
			null,
			array[
			 ROW (
				'indsatsmodtager'::indsatsRelationKode
					,null
				,uuidIndsatsmodtager3
					,null
					,null
					,null
				) :: indsatsRelationType
			]::indsatsRelationType[]
		)::indsatsRegistreringType]::indsatsRegistreringType[]	
);



--read_Indsats1:=as_read_indsats(new_uuid1,null,null);
--read_Indsats2:=as_read_indsats(new_uuid2,null,null);
--read_Indsats3:=as_read_indsats(new_uuid3,null,null);

--raise notice 'indsats reg1 #1:%',to_json(actual_filter_res_7);

--raise notice 'returned uuids from filter #1:%',to_json(actual_filter_res_7);

RETURN NEXT ok(expected_filter_res_7 @> actual_filter_res_7 and actual_filter_res_7 @>expected_filter_res_7 and coalesce(array_length(expected_filter_res_7,1),0)=coalesce(array_length(actual_filter_res_7,1),0), 'unauth filter indsats #7.');



END;
$$;


ALTER FUNCTION test.test_as_filter_unauth_indsats() OWNER TO mox;

--
-- Name: test_as_list_dokument(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_list_dokument() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
doc1_new_uuid uuid;
	doc1_registrering dokumentRegistreringType;
	doc1_virkEgenskaber1 Virkning;
	doc1_virkEgenskaber2 Virkning;
	doc1_virkAnsvarlig Virkning;
	doc1_virkBesvarelser1 Virkning;
	doc1_virkBesvarelser2 Virkning;
	doc1_virkFremdrift Virkning;
	doc1_dokumentEgenskab1 dokumentEgenskaberAttrType;
	doc1_dokumentEgenskab2 dokumentEgenskaberAttrType;
	doc1_dokumentFremdrift dokumentFremdriftTilsType;
	doc1_dokumentRelAnsvarlig dokumentRelationType;
	doc1_dokumentRelBesvarelser1 dokumentRelationType;
	doc1_dokumentRelBesvarelser2 dokumentRelationType;
	doc1_uuidAnsvarlig uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	doc1_uuidBesvarelser1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	--uuidBesvarelser2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	doc1_urnBesvarelser2 text:='urn:isbn:0451450523'::text;
	doc1_uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	doc1_docVariant1 DokumentVariantType;
	doc1_docVariant2 DokumentVariantType;
	doc1_docVariantEgenskaber1A DokumentVariantEgenskaberType;
	doc1_docVariantEgenskaber1AVirkning Virkning;
	doc1_docVariantEgenskaber1B DokumentVariantEgenskaberType;
	doc1_docVariantEgenskaber1BVirkning Virkning;
	doc1_docVariantEgenskaber2A DokumentVariantEgenskaberType;
	doc1_docVariantEgenskaber2AVirkning Virkning;	
	doc1_docDel1A DokumentDelType;
	doc1_docDel1B DokumentDelType;
	doc1_docDel2A DokumentDelType;
	doc1_docDel2B DokumentDelType;
	doc1_docDel1AEgenskaber DokumentDelEgenskaberType;
	doc1_docDel1A2Egenskaber DokumentDelEgenskaberType;
	doc1_docDel1AEgenskaberVirkning Virkning;
	doc1_docDel1A2EgenskaberVirkning Virkning;
	doc1_docDel1BEgenskaber DokumentDelEgenskaberType;
	doc1_docDel1BEgenskaberVirkning Virkning;
	doc1_docDel2AEgenskaber DokumentDelEgenskaberType;
	doc1_docDel2AEgenskaberVirkning Virkning;
	doc1_docDel1Arelation1 DokumentdelRelationType;
	doc1_docDel1Arelation1Virkning Virkning;
	doc1_docDel2Brelation1 DokumentdelRelationType;
	doc1_docDel2Brelation1Virkning Virkning;
	doc1_docDel2Brelation2 DokumentdelRelationType;
	doc1_docDel2Brelation2Virkning Virkning;


	doc2_new_uuid uuid;
	doc2_registrering dokumentRegistreringType;
	doc2_virkEgenskaber1 Virkning;
	doc2_virkEgenskaber2 Virkning;
	doc2_virkAnsvarlig Virkning;
	doc2_virkBesvarelser1 Virkning;
	doc2_virkBesvarelser2 Virkning;
	doc2_virkFremdrift Virkning;
	doc2_dokumentEgenskab1 dokumentEgenskaberAttrType;
	doc2_dokumentEgenskab2 dokumentEgenskaberAttrType;
	doc2_dokumentFremdrift dokumentFremdriftTilsType;
	doc2_dokumentRelAnsvarlig dokumentRelationType;
	doc2_dokumentRelBesvarelser1 dokumentRelationType;
	doc2_dokumentRelBesvarelser2 dokumentRelationType;
	doc2_uuidAnsvarlig uuid :='17109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	doc2_uuidBesvarelser1 uuid :='27160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	--uuidBesvarelser2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	doc2_urnBesvarelser2 text:='urn:isbn:9451450523'::text;
	doc2_uuidRegistrering uuid :='3f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	doc2_docVariant1 DokumentVariantType;
	doc2_docVariant2 DokumentVariantType;
	doc2_docVariantEgenskaber1A DokumentVariantEgenskaberType;
	doc2_docVariantEgenskaber1AVirkning Virkning;
	doc2_docVariantEgenskaber1B DokumentVariantEgenskaberType;
	doc2_docVariantEgenskaber1BVirkning Virkning;
	doc2_docVariantEgenskaber2A DokumentVariantEgenskaberType;
	doc2_docVariantEgenskaber2AVirkning Virkning;	
	doc2_docDel1A DokumentDelType;
	doc2_docDel1B DokumentDelType;
	doc2_docDel2A DokumentDelType;
	doc2_docDel2B DokumentDelType;
	doc2_docDel1AEgenskaber DokumentDelEgenskaberType;
	doc2_docDel1A2Egenskaber DokumentDelEgenskaberType;
	doc2_docDel1AEgenskaberVirkning Virkning;
	doc2_docDel1A2EgenskaberVirkning Virkning;
	doc2_docDel1BEgenskaber DokumentDelEgenskaberType;
	doc2_docDel1BEgenskaberVirkning Virkning;
	doc2_docDel2AEgenskaber DokumentDelEgenskaberType;
	doc2_docDel2AEgenskaberVirkning Virkning;
	doc2_docDel1Arelation1 DokumentdelRelationType;
	doc2_docDel1Arelation1Virkning Virkning;
	doc2_docDel2Brelation1 DokumentdelRelationType;
	doc2_docDel2Brelation1Virkning Virkning;
	doc2_docDel2Brelation2 DokumentdelRelationType;
	doc2_docDel2Brelation2Virkning Virkning;

	actual_dokuments1 DokumentType[];
	expected_dokuments1 DokumentType[];

	doc1_override_timeperiod TSTZRANGE;
	doc2_override_timeperiod TSTZRANGE;

	actual_dokuments2 DokumentType[];
	expected_dokuments2 DokumentType[];

	actual_dokuments3 DokumentType[];
	expected_dokuments3 DokumentType[];

	actual_dokuments4 DokumentType[];
	expected_dokuments4 DokumentType[];

	actual_dokuments5 DokumentType[];
	expected_dokuments5 DokumentType[];

	document5 DokumentType;

BEGIN


doc1_virkEgenskaber1 :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          'd71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;


doc1_virkEgenskaber2 :=	ROW (
	'[2014-05-12, 2015-05-12)' :: TSTZRANGE,
          'e71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;


doc1_virkAnsvarlig :=	ROW (
	'[2014-05-11, infinity)' :: TSTZRANGE,
          'f71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

doc1_virkBesvarelser1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          'c71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


doc1_virkBesvarelser2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          'b71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

doc1_virkFremdrift := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          'a71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx10'
) :: Virkning
;

doc1_dokumentRelAnsvarlig := ROW (
	'ansvarlig'::dokumentRelationKode,
		doc1_virkAnsvarlig,
	doc1_uuidAnsvarlig,
	null,
	'Aktr'
) :: dokumentRelationType
;


doc1_dokumentRelBesvarelser1 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc1_virkBesvarelser1,
	doc1_uuidBesvarelser1,
	null,
	null
) :: dokumentRelationType
;



doc1_dokumentRelBesvarelser2 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc1_virkBesvarelser2,
	null,
	doc1_urnBesvarelser2,
	null
) :: dokumentRelationType
;


doc1_dokumentFremdrift := ROW (
doc1_virkFremdrift,
'Underreview'
):: dokumentFremdriftTilsType
;


doc1_dokumentEgenskab1 := ROW (
'doc_brugervendtnoegle1',
'doc_beskrivelse1', 
'10-31-2015'::date,
'doc_kassationskode1', 
4, --major int
9, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel1',
'doc_dokumenttype1',
   doc1_virkEgenskaber1
) :: dokumentEgenskaberAttrType
;

doc1_dokumentEgenskab2 := ROW (
'doc_brugervendtnoegle2',
'doc_beskrivelse2', 
'09-20-2014'::date,
'doc_kassationskode2', 
5, --major int
10, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel2','doc_Offentlighedundtaget_Hjemmel2') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel2',
'doc_dokumenttype2',
   doc1_virkEgenskaber2
) :: dokumentEgenskaberAttrType
;




doc1_docDel2Brelation2Virkning :=	ROW (
	'(2014-02-24, 2015-10-01]' :: TSTZRANGE,
          '971cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;

doc1_docDel2Brelation1Virkning :=	ROW (
	'[2012-05-08, infinity)' :: TSTZRANGE,
          '871cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;


doc1_docDel1Arelation1Virkning :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          '771cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx71'
          ) :: Virkning
;


doc1_docVariantEgenskaber2AVirkning :=	ROW (
	'[2014-07-12, infinity)' :: TSTZRANGE,
          '671cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx281'
          ) :: Virkning
;

doc1_docVariantEgenskaber1BVirkning :=	ROW (
	'[2015-01-01, infinity)' :: TSTZRANGE,
          '571cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx291'
          ) :: Virkning
;


doc1_docVariantEgenskaber1AVirkning :=	ROW (
	'[2013-02-27, 2015-01-01)' :: TSTZRANGE,
          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx191'
          ) :: Virkning
;

doc1_docDel1AEgenskaberVirkning :=	ROW (
	'[2014-03-30, infinity)' :: TSTZRANGE,
          '371cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;

doc1_docDel1A2EgenskaberVirkning :=	ROW (
	'[2010-01-20, 2014-03-20)' :: TSTZRANGE,
          '271cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx113'
          ) :: Virkning
;


doc1_docDel1BEgenskaberVirkning :=	ROW (
	'[2015-10-11, infinity)' :: TSTZRANGE,
          '171cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

doc1_docDel2AEgenskaberVirkning :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '901cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx13'
          ) :: Virkning
;


doc1_docVariantEgenskaber1A:=
ROW(
true, --arkivering boolean, 
false, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
false, --produktion boolean,
 doc1_docVariantEgenskaber1AVirkning
)::DokumentVariantEgenskaberType;

doc1_docVariantEgenskaber1B:=
ROW(
false, --arkivering boolean, 
false, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
true, --produktion boolean,
 doc1_docVariantEgenskaber1BVirkning
)::DokumentVariantEgenskaberType;


doc1_docVariantEgenskaber2A:=
ROW(
false, --arkivering boolean, 
true, --delvisscannet boolean, 
false, --offentliggoerelse boolean, 
true, --produktion boolean,
 doc1_docVariantEgenskaber2AVirkning
)::DokumentVariantEgenskaberType;


doc1_docDel2Brelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_docDel2Brelation1Virkning,
  'a24a2dd4-415f-4104-b7a7-84607488c096'::uuid,
  null, --urn,
  'Bruger'
)::DokumentdelRelationType;


doc1_docDel2Brelation2:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_docDel2Brelation2Virkning,
  null,
  'urn:cpr 8883394', 
  'Bruger'
)::DokumentdelRelationType;


doc1_docDel1Arelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_docDel1Arelation1Virkning,
  'b24a2dd4-415f-4104-b7a7-84607488c091'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;


doc1_docDel1AEgenskaber:= ROW(
1, --indeks int,
'del_indhold1', 
'del_lokation1', 
'del_mimetype1',
 doc1_docDel1AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc1_docDel1A2Egenskaber:=ROW(
2, --indeks int,
'del_indhold4', 
'del_lokation4', 
'del_mimetype4',
 doc1_docDel1A2EgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc1_docDel1BEgenskaber:= ROW(
98, --indeks int,
'del_indhold2', 
'del_lokation2', 
'del_mimetype2',
 doc1_docDel1BEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc1_docDel2AEgenskaber:= ROW(
8, --indeks int,
'del_indhold3', 
'del_lokation3', 
'del_mimetype3',
 doc1_docDel2AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;


doc1_docDel1A:=
ROW(
'doc_deltekst1A',
  ARRAY[doc1_docDel1AEgenskaber,doc1_docDel1A2Egenskaber],
  ARRAY[doc1_docDel1Arelation1]
)::DokumentDelType;

doc1_docDel1B:=
ROW(
'doc_deltekst1B',
  ARRAY[doc1_docDel1BEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc1_docDel2A:=
ROW(
'doc_deltekst2A',
  ARRAY[doc1_docDel2AEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc1_docDel2B:=
ROW(
'doc_deltekst2B',
  null,--ARRAY[]::DokumentDelEgenskaberType[],
  ARRAY[doc1_docDel2Brelation1,doc1_docDel2Brelation2]
)::DokumentDelType;


doc1_docVariant1 := ROW (
	'doc_varianttekst1',
  	ARRAY[doc1_docVariantEgenskaber1B,doc1_docVariantEgenskaber1A],
  	ARRAY[doc1_docDel1A,doc1_docDel1B]
)::DokumentVariantType;


doc1_docVariant2 := ROW (
	'doc_varianttekst2',
  ARRAY[doc1_docVariantEgenskaber2A],
  ARRAY[doc1_docDel2A,doc1_docDel2B]
)::DokumentVariantType;

doc1_registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	doc1_uuidRegistrering,
	'Test Note 85') :: RegistreringBase
	,
ARRAY[doc1_dokumentFremdrift]::dokumentFremdriftTilsType[],
ARRAY[doc1_dokumentEgenskab1,doc1_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
ARRAY[doc1_dokumentRelBesvarelser1,doc1_dokumentRelAnsvarlig,doc1_dokumentRelBesvarelser2],
ARRAY[doc1_docVariant1,doc1_docVariant2]
) :: dokumentRegistreringType
;


doc1_new_uuid := as_create_or_import_dokument(doc1_registrering);


/**************************************************************/
/*						Create doc 2						  */
/**************************************************************/


doc2_virkEgenskaber1 :=	ROW (
	'[2014-02-20, infinity)' :: TSTZRANGE,
          'c71cc58a-3149-414a-9392-dcbcbbccddfe'::uuid,
          'Bruger',
          'NoteEx13'
          ) :: Virkning
;


doc2_virkEgenskaber2 :=	ROW (
	'[2013-11-30, 2014-02-20)' :: TSTZRANGE,
          'd71cc58a-3149-414a-9392-dcbcbbccddf7'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;


doc2_virkAnsvarlig :=	ROW (
	'[2014-04-10, infinity)' :: TSTZRANGE,
          'a71cc58a-3149-414a-9392-dcbcbbccddf7'::uuid,
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;

doc2_virkBesvarelser1 :=	ROW (
	'[2015-12-09, infinity)' :: TSTZRANGE,
          '371cc58a-3149-414a-9392-dcbcbbccddf9'::uuid,
          'Bruger',
          'NoteEx239'
          ) :: Virkning
;


doc2_virkBesvarelser2 :=	ROW (
	'[2015-04-10, 2017-05-10)' :: TSTZRANGE,
          'c71cc58a-3149-414a-9392-dcbcbbccddf1'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

doc2_virkFremdrift := ROW (
	'[2011-04-20, infinity)' :: TSTZRANGE,
          'a71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx10'
) :: Virkning
;

doc2_dokumentRelAnsvarlig := ROW (
	'ansvarlig'::dokumentRelationKode,
		doc2_virkAnsvarlig,
	doc2_uuidAnsvarlig,
	null,
	'Aktr'
) :: dokumentRelationType
;


doc2_dokumentRelBesvarelser1 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc2_virkBesvarelser1,
	doc2_uuidBesvarelser1,
	null,
	null
) :: dokumentRelationType
;



doc2_dokumentRelBesvarelser2 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc2_virkBesvarelser2,
	null,
	doc2_urnBesvarelser2,
	null
) :: dokumentRelationType
;


doc2_dokumentFremdrift := ROW (
doc2_virkFremdrift,
'Underreview'
):: dokumentFremdriftTilsType
;


doc2_dokumentEgenskab1 := ROW (
'doc_brugervendtnoegle2_1',
'doc_beskrivelse2_1', 
'01-10-2014'::date,
'doc_kassationskode2_1', 
11, --major int
2, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel2_1','doc_Offentlighedundtaget_Hjemmel2_1') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel2_1',
'doc_dokumenttype2_1',
   doc2_virkEgenskaber1
) :: dokumentEgenskaberAttrType
;

doc2_dokumentEgenskab2 := ROW (
'doc_brugervendtnoegle2_2',
'doc_beskrivelse2_2', 
'08-28-2013'::date,
'doc_kassationskode2_2', 
12, --major int
6, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel2_2','doc_Offentlighedundtaget_Hjemmel2_2') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel2_2',
'doc_dokumenttype2_2',
   doc2_virkEgenskaber2
) :: dokumentEgenskaberAttrType
;




doc2_docDel2Brelation2Virkning :=	ROW (
	'(2012-07-12, 2014-10-01]' :: TSTZRANGE,
          '071cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;

doc2_docDel2Brelation1Virkning :=	ROW (
	'[2013-05-07, infinity)' :: TSTZRANGE,
          '171cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;


doc2_docDel1Arelation1Virkning :=	ROW (
	'[2013-10-15, infinity)' :: TSTZRANGE,
          '271cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx71'
          ) :: Virkning
;


doc2_docVariantEgenskaber2AVirkning :=	ROW (
	'[2014-07-12, infinity)' :: TSTZRANGE,
          '371cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx281'
          ) :: Virkning
;

doc2_docVariantEgenskaber1BVirkning :=	ROW (
	'[2014-06-11, infinity)' :: TSTZRANGE,
          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx291'
          ) :: Virkning
;


doc2_docVariantEgenskaber1AVirkning :=	ROW (
	'[2013-02-27, 2014-06-11)' :: TSTZRANGE,
          '571cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx191'
          ) :: Virkning
;

doc2_docDel1AEgenskaberVirkning :=	ROW (
	'[2014-03-30, infinity)' :: TSTZRANGE,
          '671cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;

doc2_docDel1A2EgenskaberVirkning :=	ROW (
	'[2010-01-20, 2014-03-20)' :: TSTZRANGE,
          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx113'
          ) :: Virkning
;


doc2_docDel1BEgenskaberVirkning :=	ROW (
	'[2015-10-11, infinity)' :: TSTZRANGE,
          '871cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

doc2_docDel2AEgenskaberVirkning :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '001cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx13'
          ) :: Virkning
;


doc2_docVariantEgenskaber1A:=
ROW(
false, --arkivering boolean, 
false, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
true, --produktion boolean,
 doc2_docVariantEgenskaber1AVirkning
)::DokumentVariantEgenskaberType;

doc2_docVariantEgenskaber1B:=
ROW(
true, --arkivering boolean, 
false, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
true, --produktion boolean,
 doc2_docVariantEgenskaber1BVirkning
)::DokumentVariantEgenskaberType;


doc2_docVariantEgenskaber2A:=
ROW(
false, --arkivering boolean, 
false, --delvisscannet boolean, 
false, --offentliggoerelse boolean, 
false, --produktion boolean,
 doc2_docVariantEgenskaber2AVirkning
)::DokumentVariantEgenskaberType;


doc2_docDel2Brelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc2_docDel2Brelation1Virkning,
  '124a2dd4-415f-4104-b7a7-84607488c096'::uuid,
  null, --urn,
  'Bruger'
)::DokumentdelRelationType;


doc2_docDel2Brelation2:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc2_docDel2Brelation2Virkning,
  null,
  'urn:cpr 8883394', 
  'Bruger'
)::DokumentdelRelationType;


doc2_docDel1Arelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc2_docDel2Brelation2Virkning,
  '524a2dd4-415f-4104-b7a7-84607488c091'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;


doc2_docDel1AEgenskaber:= ROW(
1, --indeks int,
'del_indhold2_1', 
'del_lokation2_1', 
'del_mimetype2_1',
 doc2_docDel1AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc2_docDel1A2Egenskaber:=ROW(
2, --indeks int,
'del_indhold2_4', 
'del_lokation2_4', 
'del_mimetype2_4',
 doc2_docDel1A2EgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc2_docDel1BEgenskaber:= ROW(
98, --indeks int,
'del_indhold2_2', 
'del_lokation2_2', 
'del_mimetype2_2',
 doc2_docDel1BEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc2_docDel2AEgenskaber:= ROW(
8, --indeks int,
'del_indhold2_3', 
'del_lokation2_3', 
'del_mimetype2_3',
 doc2_docDel2AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;


doc2_docDel1A:=
ROW(
'doc_deltekst2_1A',
  ARRAY[doc2_docDel1AEgenskaber,doc2_docDel1A2Egenskaber],
  ARRAY[doc2_docDel1Arelation1]
)::DokumentDelType;

doc2_docDel1B:=
ROW(
'doc_deltekst2_1B',
  ARRAY[doc2_docDel1BEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc2_docDel2A:=
ROW(
'doc_deltekst2_2A',
  ARRAY[doc2_docDel2AEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc2_docDel2B:=
ROW(
'doc_deltekst2_2B',
  null,--ARRAY[]::DokumentDelEgenskaberType[],
  ARRAY[doc2_docDel2Brelation1,doc2_docDel2Brelation2]
)::DokumentDelType;


doc2_docVariant1 := ROW (
	'doc_varianttekst2_1',
  	ARRAY[doc2_docVariantEgenskaber1A,doc2_docVariantEgenskaber1B],
  	ARRAY[doc2_docDel1A,doc2_docDel1B]
)::DokumentVariantType;


doc2_docVariant2 := ROW (
	'doc_varianttekst2_2',
  ARRAY[doc2_docVariantEgenskaber2A],
  ARRAY[doc2_docDel2A,doc2_docDel2B]
)::DokumentVariantType;

doc2_registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	doc2_uuidRegistrering,
	'Test Note 50') :: RegistreringBase
	,
ARRAY[doc2_dokumentFremdrift]::dokumentFremdriftTilsType[],
ARRAY[doc2_dokumentEgenskab1,doc2_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
ARRAY[doc2_dokumentRelAnsvarlig,doc2_dokumentRelBesvarelser1,doc2_dokumentRelBesvarelser2],
ARRAY[doc2_docVariant1,doc2_docVariant2]
) :: dokumentRegistreringType
;


doc2_new_uuid := as_create_or_import_dokument(doc2_registrering);

/********************************************************************/


actual_dokuments1:= as_list_dokument(array[doc1_new_uuid,doc2_new_uuid]::uuid[],null,null);


select 
(a.registrering).timeperiod into doc1_override_timeperiod
from dokument_registrering a
where 
dokument_id=doc1_new_uuid;

select 
(a.registrering).timeperiod into doc2_override_timeperiod
from dokument_registrering a
where 
dokument_id=doc2_new_uuid;


expected_dokuments1:= ARRAY[
		ROW(
			doc1_new_uuid,
			ARRAY[
					ROW(
						ROW(
							doc1_override_timeperiod, --this is cheating, but helps the comparison efforts below. (The timeperiod is set during creation/initialization )
							(doc1_registrering.registrering).livscykluskode,
							(doc1_registrering.registrering).brugerref,
							(doc1_registrering.registrering).note 
							)::RegistreringBase
						,doc1_registrering.tilsfremdrift
						,doc1_registrering.attrEgenskaber
						,doc1_registrering.relationer
						,doc1_registrering.varianter
					)::dokumentRegistreringType
				]::dokumentRegistreringType[]
			)::dokumentType
		,
	ROW(
			doc2_new_uuid,
			ARRAY[
					ROW(
						ROW(
							doc2_override_timeperiod, --this is cheating, but helps the comparison efforts below. (The timeperiod is set during creation/initialization )
							(doc2_registrering.registrering).livscykluskode,
							(doc2_registrering.registrering).brugerref,
							(doc2_registrering.registrering).note 
							)::RegistreringBase
						,doc2_registrering.tilsfremdrift
						,doc2_registrering.attrEgenskaber
						,doc2_registrering.relationer
						,doc2_registrering.varianter
					)::dokumentRegistreringType
			]::dokumentRegistreringType[]
			)::dokumentType
	]::dokumentType[];

select array_agg(a.* order by a.id) from unnest(expected_dokuments1) as a into expected_dokuments1;

--raise notice 'list dokument expected_dokuments1:%',to_json(expected_dokuments1);
--raise notice 'list dokument actual_dokuments1:%',to_json(actual_dokuments1);

RETURN NEXT is(
	actual_dokuments1,
	expected_dokuments1,	
	'dokument list test 1');


/******************************************************/
--Test for filtration on virkning



actual_dokuments2 :=as_list_dokument(array[doc1_new_uuid,doc2_new_uuid]::uuid[],null,'(-infinity, 01-01-2015)' :: TSTZRANGE);


expected_dokuments2:= ARRAY[
		ROW(
			doc1_new_uuid,
			ARRAY[
					ROW(
						ROW(
							doc1_override_timeperiod, --this is cheating, but helps the comparison efforts below. (The timeperiod is set during creation/initialization )
							(doc1_registrering.registrering).livscykluskode,
							(doc1_registrering.registrering).brugerref,
							(doc1_registrering.registrering).note 
							)::RegistreringBase
						,null--doc1_registrering.tilsfremdrift
						,ARRAY[doc1_dokumentEgenskab2]::dokumentEgenskaberAttrType[]
						,ARRAY[doc1_dokumentRelAnsvarlig]
						--,doc1_registrering.varianter
						,ARRAY[
							ROW (
								'doc_varianttekst1',
							  	ARRAY[doc1_docVariantEgenskaber1A],
							  	ARRAY[ROW(
								'doc_deltekst1A',
								  ARRAY[doc1_docDel1AEgenskaber,doc1_docDel1A2Egenskaber],
								  null
								)::DokumentDelType]
							)::DokumentVariantType
							,doc1_docVariant2
						]::DokumentVariantType[]
					)::dokumentRegistreringType
				]::dokumentRegistreringType[]
			)::dokumentType
		,
	ROW(
			doc2_new_uuid,
			ARRAY[
					ROW(
						ROW(
							doc2_override_timeperiod, --this is cheating, but helps the comparison efforts below. (The timeperiod is set during creation/initialization )
							(doc2_registrering.registrering).livscykluskode,
							(doc2_registrering.registrering).brugerref,
							(doc2_registrering.registrering).note 
							)::RegistreringBase
						,doc2_registrering.tilsfremdrift
						,doc2_registrering.attrEgenskaber
						,ARRAY[doc2_dokumentRelAnsvarlig]
						,ARRAY[
						ROW (
							'doc_varianttekst2_1',
						  	ARRAY[doc2_docVariantEgenskaber1A,doc2_docVariantEgenskaber1B],
						  	ARRAY[doc2_docDel1A]
						)::DokumentVariantType
						,doc2_docVariant2
						]::DokumentVariantType[]
						--doc2_registrering.varianter
					)::dokumentRegistreringType
			]::dokumentRegistreringType[]
			)::dokumentType
	]::dokumentType[];





select array_agg(a.* order by a.id) from unnest(expected_dokuments2) as a into expected_dokuments2;

--raise notice 'list dokument expected_dokuments2:%',to_json(expected_dokuments2);
--raise notice 'list dokument actual_dokuments2:%',to_json(actual_dokuments2);


RETURN NEXT is(
	actual_dokuments2,
	expected_dokuments2,	
	'dokument list virkning filter test');


/********************************************/
--Test filter on non existing reg time.


actual_dokuments3:=as_list_dokument(array[doc1_new_uuid,doc2_new_uuid]::uuid[], tstzrange(clock_timestamp() - interval '2 hour', clock_timestamp() - interval '1 hour'),'(-infinity, 01-01-2015)' :: TSTZRANGE);

RETURN NEXT ok(coalesce(array_length(actual_dokuments3,1),0)=0,'Test on filter on reg time with no reg.');

--Test filter on current reg 


actual_dokuments4:=as_list_dokument(array[doc1_new_uuid,doc2_new_uuid]::uuid[], tstzrange(clock_timestamp() - interval '1 hour',clock_timestamp()) ,'(-infinity, 01-01-2015)' :: TSTZRANGE);


RETURN NEXT is(
	actual_dokuments4,
	expected_dokuments2,	--Notice using expected_dokuments2 as this is what we expect
	'Test on filter on reg time - current time.');

--Test on list on single uuid

actual_dokuments5:=as_list_dokument(array[doc2_new_uuid]::uuid[],  tstzrange(clock_timestamp() - interval '1 hour',clock_timestamp()) ,'(-infinity, 01-01-2015)' :: TSTZRANGE);

IF expected_dokuments2[1].id = doc2_new_uuid THEN
	expected_dokuments5:=array_append(expected_dokuments5,expected_dokuments2[1]);
ELSE
	expected_dokuments5:=array_append(expected_dokuments5,expected_dokuments2[2]);
END IF;
 

--raise notice 'list dokument expected_dokuments5:%',to_json(expected_dokuments5);
--raise notice 'list dokument actual_dokuments5:%',to_json(actual_dokuments5);


RETURN NEXT is(
	actual_dokuments5,
	expected_dokuments5,	
	'Test list single uuid.');		







END;
$$;


ALTER FUNCTION test.test_as_list_dokument() OWNER TO mox;

--
-- Name: test_as_list_facet(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_list_facet() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid uuid;
	new_uuid2 uuid;
	registrering FacetRegistreringType;
	registrering2 FacetRegistreringType;
	virkEgenskaber Virkning;
	virkEgenskaberB Virkning;
	virkEgenskaberC Virkning;
	virkEgenskaberD Virkning;
	virkAnsvarlig Virkning;
	virkRedaktoer1 Virkning;
	virkRedaktoer2 Virkning;
	virkPubliceret Virkning;
	virkPubliceretB Virkning;
	virkPubliceretC Virkning;
	facetEgenskabA FacetEgenskaberAttrType;
	facetEgenskabB FacetEgenskaberAttrType;
	facetEgenskabC FacetEgenskaberAttrType;
	facetEgenskabD FacetEgenskaberAttrType;
	facetPubliceret FacetPubliceretTilsType;
	facetPubliceretB FacetPubliceretTilsType;
	facetPubliceretC FacetPubliceretTilsType;
	facetRelAnsvarlig FacetRelationType;
	facetRelRedaktoer1 FacetRelationType;
	facetRelRedaktoer2 FacetRelationType;
	uuidAnsvarlig uuid :='e8477d45-a525-4b71-b0fa-eb25bb3c4b23'::uuid;
	uuidRedaktoer1 uuid :='55c3dc9c-60f2-4543-8971-7d1db40c4864'::uuid;
	uuidRedaktoer2 uuid :='c721b26d-daca-461a-a4ca-ec072f9ab9a7'::uuid;
	uuidRegistrering uuid :='107244b5-f00c-4679-a97a-b436176f05d5'::uuid;
	actual_facets1 FacetType[];
	expected_facets1 FacetType[];
	override_timeperiod1 TSTZRANGE;
	override_timeperiod2 TSTZRANGE;
	actual_facets2 FacetType[];
	expected_facets2 FacetType[];
	actual_facets3 FacetType[];
	expected_facets3 FacetType[];

BEGIN



virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          'ed4dc687-59e3-4b79-8f14-0f60a0145901'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaberB :=	ROW (
	'[2014-05-13, infinity)' :: TSTZRANGE,
          '48fcbc8b-4c72-4466-9dcc-0451f57b5b52'::uuid,
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;


virkAnsvarlig :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          '7ac7ba19-8d41-427d-9353-907f2b09c011'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          '6892a667-63d9-4ecd-ada1-173f4d7d0c3e'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          'df93d345-e332-47f3-81f2-25a4bb6ae39e'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;


virkPubliceret:=	ROW (
	'[2015-05-01, infinity)' :: TSTZRANGE,
          'e6a1beb5-0c7e-4299-984a-64aa3963aa4a'::uuid,
          'Bruger',
          'NoteEx8'
          ) :: Virkning
;

virkPubliceretB:=	ROW (
	'[2014-05-13, 2015-05-01)' :: TSTZRANGE,
          '42fbf12c-da1c-4f2e-8ee7-995a4b3dd6cf'::uuid,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;



facetRelAnsvarlig := ROW (
	'ansvarlig'::FacetRelationKode,
		virkAnsvarlig,
	uuidAnsvarlig,
	null,
	null
) :: FacetRelationType
;


facetRelRedaktoer1 := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer1,
	uuidRedaktoer1,
	null,
	null
) :: FacetRelationType
;



facetRelRedaktoer2 := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer2,
	uuidRedaktoer2,
	null,
	null
) :: FacetRelationType
;


facetPubliceret := ROW (
virkPubliceret,
'Publiceret'
):: FacetPubliceretTilsType
;

facetPubliceretB := ROW (
virkPubliceretB,
'IkkePubliceret'
):: FacetPubliceretTilsType
;

facetEgenskabA := ROW (
'brugervendt_noegle_A',
   'facetbeskrivelse_A',
   'facetplan_A',
   'facetopbygning_A',
   'facetophavsret_A',
   'facetsupplement_A',
   NULL,--'retskilde_text1',
   virkEgenskaber
) :: FacetEgenskaberAttrType
;

facetEgenskabB := ROW (
'brugervendt_noegle_B',
   'facetbeskrivelse_B',
   'facetplan_B',
   'facetopbygning_B',
   'facetophavsret_B',
   'facetsupplement_B',
   NULL, --restkilde
   virkEgenskaberB
) :: FacetEgenskaberAttrType
;


registrering := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
ARRAY[facetPubliceret,facetPubliceretB]::FacetPubliceretTilsType[],
ARRAY[facetEgenskabA]::FacetEgenskaberAttrType[],
ARRAY[facetRelRedaktoer1,facetRelRedaktoer2,facetRelAnsvarlig]
) :: FacetRegistreringType
;

registrering2 := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 27') :: RegistreringBase
	,
ARRAY[facetPubliceretB]::FacetPubliceretTilsType[],
ARRAY[facetEgenskabB]::FacetEgenskaberAttrType[],
ARRAY[facetRelRedaktoer1]
) :: FacetRegistreringType
;


new_uuid := as_create_or_import_facet(registrering);
new_uuid2 := as_create_or_import_facet(registrering2);

actual_facets1:=as_list_facet(array[new_uuid,new_uuid2]::uuid[],null,null);


select 
(a.registrering).timeperiod into override_timeperiod1
from facet_registrering a
where 
facet_id=new_uuid;

select 
(a.registrering).timeperiod into override_timeperiod2
from facet_registrering a
where 
facet_id=new_uuid2;


expected_facets1:= ARRAY[
		ROW(
			new_uuid,
			ARRAY[
					ROW(
						ROW(
							override_timeperiod1, --this is cheating, but helps the comparison efforts below. (The timeperiod is set during creation/initialization )
							(registrering.registrering).livscykluskode,
							(registrering.registrering).brugerref,
							(registrering.registrering).note 
							)::RegistreringBase
						,registrering.tilsPubliceret
						,registrering.attrEgenskaber
						,registrering.relationer
					)::FacetRegistreringType
				]::FacetRegistreringType[]
			)::FacetType
		,
	ROW(
			new_uuid2,
			ARRAY[
					ROW(
						ROW(
							override_timeperiod2, --this is cheating, but helps the comparison efforts below. (The timeperiod is set during creation/initialization )
							(registrering2.registrering).livscykluskode,
							(registrering2.registrering).brugerref,
							(registrering2.registrering).note 
							)::RegistreringBase
						,registrering2.tilsPubliceret
						,registrering2.attrEgenskaber
						,registrering2.relationer
					)::FacetRegistreringType
			]::FacetRegistreringType[]
			)::FacetType
	]::FacetType[];

select array_agg(a.* order by a.id) from unnest(expected_facets1) as a into expected_facets1;

--raise notice 'list facet expected_facets1:%',to_json(expected_facets1);
--raise notice 'list facet actual_facets1:%',to_json(actual_facets1);


RETURN NEXT is(
	actual_facets1,
	expected_facets1,	
	'list test 1');

/**********************************************************/
BEGIN 


actual_facets2=as_list_facet(array[new_uuid,new_uuid2]::uuid[],null,null,
ARRAY[
 ROW (
	null --reg base
	,null -- publiceret ,
	,ARRAY[
	ROW (
	'brugervendt_noegle_B',
	   null,
	   null,
	   null,
	   null,
	   null,
	   NULL, --restkilde
   	null --virkEgenskaberB
) :: FacetEgenskaberAttrType]::FacetEgenskaberAttrType[]
	,null --relationer 
) :: FacetRegistreringType
]::FacetRegistreringType[]
);

RETURN NEXT ok(false,'as_list_facet test #2: Should throw MO401 exception');
EXCEPTION  
WHEN sqlstate 'MO401' THEN
	RETURN NEXT ok(true,'as_list_facet test #2: Throws MO401 exception (as it should)');
END;


/**********************************************************/


actual_facets3=as_list_facet(array[new_uuid2]::uuid[],null,null,
ARRAY[
 ROW (
	null --reg base
	,null -- publiceret ,
	,ARRAY[
	ROW (
	'brugervendt_noegle_B',
	   null,
	   null,
	   null,
	   null,
	   null,
	   NULL, --restkilde
   	null --virkEgenskaberB
) :: FacetEgenskaberAttrType]::FacetEgenskaberAttrType[]
	,null --relationer 
) :: FacetRegistreringType
]::FacetRegistreringType[]
);

expected_facets3:= ARRAY[
	ROW(
			new_uuid2,
			ARRAY[
					ROW(
						ROW(
							override_timeperiod2, --this is cheating, but helps the comparison efforts below. (The timeperiod is set during creation/initialization )
							(registrering2.registrering).livscykluskode,
							(registrering2.registrering).brugerref,
							(registrering2.registrering).note 
							)::RegistreringBase
						,registrering2.tilsPubliceret
						,registrering2.attrEgenskaber
						,registrering2.relationer
					)::FacetRegistreringType
			]::FacetRegistreringType[]
			)::FacetType
	]::FacetType[];

RETURN NEXT is(
	actual_facets3,
	expected_facets3,	
	'facet list test #3');

END;
$$;


ALTER FUNCTION test.test_as_list_facet() OWNER TO mox;

--
-- Name: test_as_list_klasse(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_list_klasse() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid uuid;
	registrering KlasseRegistreringType;
	new_uuid2 uuid;
	registrering2 KlasseRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkEgenskaberB Virkning;
	virkEgenskaberC Virkning;
	virkEgenskaberD Virkning;
	virkEgenskaberE Virkning;
	virkAnsvarlig Virkning;
	virkRedaktoer1 Virkning;
	virkRedaktoer2 Virkning;
	virkPubliceret Virkning;
	virkPubliceretB Virkning;
	virkPubliceretC Virkning;
	klasseEgenskabA KlasseEgenskaberAttrType;
	klasseEgenskabB KlasseEgenskaberAttrType;
	klasseEgenskabC KlasseEgenskaberAttrType;
	klasseEgenskabD KlasseEgenskaberAttrType;
	klasseEgenskabE KlasseEgenskaberAttrType;
	klassePubliceret KlassePubliceretTilsType;
	klassePubliceretB KlassePubliceretTilsType;
	klassePubliceretC KlassePubliceretTilsType;
	klasseRelAnsvarlig KlasseRelationType;
	klasseRelRedaktoer1 KlasseRelationType;
	klasseRelRedaktoer2 KlasseRelationType;
	uuidAnsvarlig uuid :='be61544e-985f-4559-ac64-7034ae889d53'::uuid;
	uuidRedaktoer1 uuid :='981fe680-3881-4331-a64e-92fc253c687b'::uuid;
	uuidRedaktoer2 uuid :='0b1944e6-4c49-4a24-bf1b-bceef3b6f00f'::uuid;
	uuidRegistrering uuid :='8076ac04-8099-4d0c-ba78-56d0c577023a'::uuid;
	update_reg_id bigint;
	actual_relationer KlasseRelationType[];
	actual_publiceret KlassePubliceretTilsType[];
	actual_egenskaber KlasseEgenskaberAttrType[];
	klasseEgenskabA_Soegeord1 KlasseSoegeordType;
	klasseEgenskabA_Soegeord2 KlasseSoegeordType;
	klasseEgenskabB_Soegeord1 KlasseSoegeordType;
	klasseEgenskabB_Soegeord2 KlasseSoegeordType;
	klasseEgenskabB_Soegeord3 KlasseSoegeordType;
	klasseEgenskabB_Soegeord4 KlasseSoegeordType;
	klasseEgenskabC_Soegeord1 KlasseSoegeordType;
	klasseEgenskabC_Soegeord2 KlasseSoegeordType;
	klasseEgenskabC_Soegeord3 KlasseSoegeordType;
	klasseEgenskabE_Soegeord1 KlasseSoegeordType;
	klasseEgenskabE_Soegeord2 KlasseSoegeordType;
	klasseEgenskabE_Soegeord3 KlasseSoegeordType;
	klasseEgenskabE_Soegeord4 KlasseSoegeordType;
	klasseEgenskabE_Soegeord5 KlasseSoegeordType;
	read_klasse1 KlasseType;
	expected_klasse1 KlasseType;
	read_klasse2 KlasseType;
	expected_klasse2 KlasseType;
	actual_klasses_1 KlasseType[];
	actual_klasses_2 KlasseType[];
	actual_klasses_3 KlasseType[];
	--expected_klasses_1 KlasseType[];
	--expected_klasses_2 KlasseType[];
	expected_klasses_3 KlasseType[];
BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          '303514bc-9014-4591-a8a9-22eb37c592f9'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaberB :=	ROW (
	'[2014-05-13, 2015-01-01)' :: TSTZRANGE,
          '858a568b-2ad0-4168-8b83-c48b8238106c'::uuid,
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;


virkAnsvarlig :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          '0befe457-cef5-4888-b49c-bbee77e44f99'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          'f700e686-5bed-45b3-9d13-c09bbdf2ad1a'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          '1c0ce5a4-02c4-4697-ab39-00b7da0b1f54'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;


virkPubliceret:=	ROW (
	'[2015-05-01, infinity)' :: TSTZRANGE,
          '01cdb20d-1897-4966-9552-0a691f162daf'::uuid,
          'Bruger',
          'NoteEx8'
          ) :: Virkning
;

virkPubliceretB:=	ROW (
	'[2014-05-13, 2015-05-01)' :: TSTZRANGE,
          '38efbe3e-3b93-470a-956a-793ca0c8f219'::uuid,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;



klasseRelAnsvarlig := ROW (
	'ansvarlig'::KlasseRelationKode,
		virkAnsvarlig,
	uuidAnsvarlig,
	null,
	null
) :: KlasseRelationType
;


klasseRelRedaktoer1 := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer1,
	uuidRedaktoer1,
	null,
	null
) :: KlasseRelationType
;



klasseRelRedaktoer2 := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer2,
	uuidRedaktoer2,
	null,
	null
) :: KlasseRelationType
;


klassePubliceret := ROW (
virkPubliceret,
'Publiceret'
):: KlassePubliceretTilsType
;

klassePubliceretB := ROW (
virkPubliceretB,
'IkkePubliceret'
):: KlassePubliceretTilsType
;


klasseEgenskabA_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabA_Soegeord1',
'beskrivelse_klasseEgenskabA_Soegeord1',
'soegeordskategori_klasseEgenskabA_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabA_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabA_Soegeord2',
'beskrivelse_klasseEgenskabA_Soegeord2',
'soegeordskategori_klasseEgenskabA_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabA := ROW (
'brugervendt_noegle_A',
   'klassebeskrivelse_A',
   'eksempel_A',
	'omfang_A',
   'titel_A',
   'retskilde_A',
   NULL,--'aendringsnotat_text1',
   ARRAY[klasseEgenskabA_Soegeord1,klasseEgenskabA_Soegeord2]::KlasseSoegeordType[], 
   virkEgenskaber
) :: KlasseEgenskaberAttrType
;


klasseEgenskabB_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord1',
'beskrivelse_klasseEgenskabB_Soegeord1',
'soegeordskategori_klasseEgenskabB_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabB_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord2',
'beskrivelse_klasseEgenskabB_Soegeord2',
'soegeordskategori_klasseEgenskabB_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabB_Soegeord3 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord3',
'beskrivelse_klasseEgenskabB_Soegeord3',
'soegeordskategori_klasseEgenskabB_Soegeord3'
)::KlasseSoegeordType
;
klasseEgenskabB_Soegeord4 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord4',
'beskrivelse_klasseEgenskabB_Soegeord4',
'soegeordskategori_klasseEgenskabB_Soegeord4'
)::KlasseSoegeordType
;


klasseEgenskabE_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord1',
'beskrivelse_klasseEgenskabE_Soegeord1',
'soegeordskategori_klasseEgenskabE_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabE_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord2',
'beskrivelse_klasseEgenskabE_Soegeord2',
'soegeordskategori_klasseEgenskabE_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabE_Soegeord3 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord3',
'beskrivelse_klasseEgenskabE_Soegeord3',
'soegeordskategori_klasseEgenskabE_Soegeord3'
)::KlasseSoegeordType
;
klasseEgenskabE_Soegeord4 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord4',
'beskrivelse_klasseEgenskabE_Soegeord4',
'soegeordskategori_klasseEgenskabE_Soegeord4'
)::KlasseSoegeordType
;

klasseEgenskabE_Soegeord5 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord5',
'beskrivelse_klasseEgenskabE_Soegeord5',
'soegeordskategori_klasseEgenskabE_Soegeord5'
)::KlasseSoegeordType
;


klasseEgenskabB := ROW (
'brugervendt_noegle_B',
   'klassebeskrivelse_B',
   'eksempel_B',
	'omfang_B',
   'titel_B',
   'retskilde_B',
   NULL, --aendringsnotat
    ARRAY[klasseEgenskabB_Soegeord1,klasseEgenskabB_Soegeord2,klasseEgenskabB_Soegeord3,klasseEgenskabB_Soegeord4]::KlasseSoegeordType[], --soegeord
   virkEgenskaberB
) :: KlasseEgenskaberAttrType
;


registrering := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 54') :: RegistreringBase
	,
ARRAY[klassePubliceret,klassePubliceretB]::KlassePubliceretTilsType[],
ARRAY[klasseEgenskabA,klasseEgenskabB]::KlasseEgenskaberAttrType[],
ARRAY[klasseRelRedaktoer2,klasseRelRedaktoer1,klasseRelAnsvarlig]
) :: KlasseRegistreringType
;

new_uuid := as_create_or_import_klasse(registrering);


virkEgenskaberC :=	ROW (
	'[2015-01-13, infinity)' :: TSTZRANGE,
          '668bbef5-be2c-4805-af50-f92195561334'::uuid,
          'Bruger',
          'NoteEx20'
          ) :: Virkning
;

virkEgenskaberD :=	ROW (
	'[2013-06-30, 2014-06-01)' :: TSTZRANGE,
          'fab32a69-2c94-49aa-96fd-cddac42f4ca6'::uuid,
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;

virkEgenskaberE:=	ROW (
	'[2014-08-01, 2014-10-20)' :: TSTZRANGE,
          'bd2c3576-5eeb-42f1-aee1-9460d52a3080'::uuid,
          'Bruger',
          'NoteEx20'
          ) :: Virkning
;

klasseEgenskabC := ROW (
   NULL,--'brugervendt_noegle_text1',
   NULL, --'klassebeskrivelse_text1',
   NULL,--'eksempel_text1',
	'omfang_C',
   'titel_C',
   'retskilde_C',
   'aendringsnotat_C',
   ARRAY[]::KlasseSoegeordType[], --soegeord
   virkEgenskaberC
) :: KlasseEgenskaberAttrType
;

klasseEgenskabD := ROW (
'brugervendt_noegle_D',
   'klassebeskrivelse_D',
   'eksempel_D',
   'omfang_D',
   NULL,-- 'titel_D',
   'retskilde_D',
   NULL, --aendringsnotat
    NULL, --soegeord
   virkEgenskaberD
) :: KlasseEgenskaberAttrType
;

klasseEgenskabE := ROW (
'brugervendt_noegle_E',
   'klassebeskrivelse_E',
   'eksempel_E',
	'omfang_E',
   'titel_E',
   'retskilde_E',
   NULL, --aendringsnotat
    ARRAY[klasseEgenskabE_Soegeord1,klasseEgenskabE_Soegeord2,klasseEgenskabE_Soegeord3,klasseEgenskabE_Soegeord4,klasseEgenskabE_Soegeord5]::KlasseSoegeordType[], --soegeord
   virkEgenskaberE
) :: KlasseEgenskaberAttrType
;

virkPubliceretC:=	ROW (
	'[2015-01-01, 2015-05-01]' :: TSTZRANGE,
          '54506144-5b4d-49b4-8bdf-14258ac28b80'::uuid,
          'Bruger',
          'NoteEx10'
          ) :: Virkning
;



klassePubliceretC := ROW (
virkPubliceretC,
''::KlassePubliceretTils
):: KlassePubliceretTilsType
;


registrering2 := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 5') :: RegistreringBase
	,
array[klassePubliceretC]::KlassePubliceretTilsType[],
  array[klasseEgenskabD,klasseEgenskabE,klasseEgenskabC]::KlasseEgenskaberAttrType[],
  array[klasseRelAnsvarlig]::KlasseRelationType[]
) :: KlasseRegistreringType
;

new_uuid2 := as_create_or_import_klasse(registrering2);

read_Klasse1 := as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);




expected_Klasse1 :=
				ROW(
					new_uuid,
					ARRAY[
						ROW(
							ROW(
								((read_Klasse1.registrering[1]).registrering).timeperiod, --this is cheating, but helps the comparison efforts below. (The timeperiod is set during creation/initialization )
								(registrering.registrering).livscykluskode,
								(registrering.registrering).brugerref,
								(registrering.registrering).note 
								)::RegistreringBase
							,registrering.tilsPubliceret
							,registrering.attrEgenskaber
							,registrering.relationer
						)::KlasseRegistreringType
					]::KlasseRegistreringType[]
			)::KlasseType
;


read_Klasse2 := as_read_Klasse(new_uuid2,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

expected_Klasse2 :=
				ROW(
					new_uuid2,
					ARRAY[
						ROW(
							ROW(
								((read_Klasse2.registrering[1]).registrering).timeperiod, --this is cheating, but helps the comparison efforts below. (The timeperiod is set during creation/initialization )
								(registrering2.registrering).livscykluskode,
								(registrering2.registrering).brugerref,
								(registrering2.registrering).note 
								)::RegistreringBase
							,array[klassePubliceretC]
							,array[
							klasseEgenskabD,klasseEgenskabE,
							ROW(
							klasseEgenskabC.brugervendtnoegle,
							klasseEgenskabC.beskrivelse,
							klasseEgenskabC.eksempel,
							klasseEgenskabC.omfang,
							klasseEgenskabC.titel,
							klasseEgenskabC.retskilde,
							klasseEgenskabC.aendringsnotat,
							NULL, --notice: empty array for soegeord get read as null
 							klasseEgenskabC.virkning 
							)::KlasseEgenskaberAttrType
							]::KlasseEgenskaberAttrType[]
							,registrering2.relationer
						)::KlasseRegistreringType
					]::KlasseRegistreringType[]
			)::KlasseType
;





actual_klasses_1:=as_list_klasse(array[new_uuid]::uuid[],null,null);

--RAISE NOTICE 'actual_klasses_1:%',to_json(actual_klasses_1);
--RAISE NOTICE 'expected_Klasse1_arr_json:%',to_json(ARRAY[expected_Klasse1]);



RETURN NEXT is(
	actual_klasses_1,
	ARRAY[expected_Klasse1],	
	'list klasse test 1');

actual_klasses_2:=as_list_klasse(array[new_uuid2]::uuid[],null,null);


--RAISE NOTICE 'actual_klasses_2:%',to_json(actual_klasses_2);
--RAISE NOTICE 'expected_Klasse2_arr_json:%',to_json(expected_Klasse2);


RETURN NEXT is(
	actual_klasses_2,
	ARRAY[expected_Klasse2],	
	'list klasse test 2');





actual_klasses_3:=as_list_klasse(array[new_uuid,new_uuid2]::uuid[],null,null);


select array_agg(a.* order by a.id) from unnest(ARRAY[expected_Klasse1,expected_Klasse2]) as a into expected_klasses_3;



RETURN NEXT is(
	actual_klasses_3,
	expected_klasses_3,	
	'list klasse test 3');


END;
$$;


ALTER FUNCTION test.test_as_list_klasse() OWNER TO mox;

--
-- Name: test_as_read_facet(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_read_facet() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid uuid;
	registrering FacetRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkAnsvarlig Virkning;
	virkRedaktoer1 Virkning;
	virkRedaktoer2 Virkning;
	virkPubliceret Virkning;
	facetEgenskab FacetEgenskaberAttrType;
	facetPubliceret FacetPubliceretTilsType;
	facetRelAnsvarlig FacetRelationType;
	facetRelRedaktoer1 FacetRelationType;
	facetRelRedaktoer2 FacetRelationType;
	uuidAnsvarlig uuid :='bf0a1162-69f0-4242-b217-e2d29e06d13a'::uuid;
	uuidRedaktoer1 uuid :='180c0ab2-4210-4b91-94b8-2eff23d3cf10'::uuid;
	uuidRedaktoer2 uuid :='8cbe2b05-34b2-4147-a917-35ed36813e55'::uuid;
	uuidRegistrering uuid :='7ed5e259-78b2-4921-9e4b-d54380be343b'::uuid;
	read_facet1 FacetType;
	expected_facet1 FacetType;
BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          '342d9380-56af-4624-a014-7166fb3bbe8e'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkAnsvarlig :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          '26eba752-87fa-4a4a-baed-005f24a13301'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          'fbf707e2-3fe6-43e8-8033-2ca5a24698cd'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          'b1bf237a-ce19-48d9-a20d-b50562f56938'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          'b3fbc404-5c94-43f5-aacf-372ab1401967'::uuid,
          'Bruger',
          'NoteEx10'
) :: Virkning
;


facetRelAnsvarlig := ROW (
	'ansvarlig'::FacetRelationKode,
		virkAnsvarlig,
	uuidAnsvarlig,
	null,
	null
) :: FacetRelationType
;


facetRelRedaktoer1 := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer1,
	uuidRedaktoer1,
	null,
	null
) :: FacetRelationType
;



facetRelRedaktoer2 := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer2,
	uuidRedaktoer2,
	null,
	null
) :: FacetRelationType
;


facetPubliceret := ROW (
virkPubliceret,
'Publiceret'
):: FacetPubliceretTilsType
;


facetEgenskab := ROW (
'brugervendt_noegle_text1',
   'facetbeskrivelse_text1',
   'facetplan_text1',
   'facetopbygning_text1',
   'facetophavsret_text1',
   'facetsupplement_text1',
   'retskilde_text1',
   virkEgenskaber
) :: FacetEgenskaberAttrType
;


registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
ARRAY[facetPubliceret]::FacetPubliceretTilsType[],
ARRAY[facetEgenskab]::FacetEgenskaberAttrType[],
ARRAY[facetRelRedaktoer1,facetRelRedaktoer2,facetRelAnsvarlig]
) :: FacetRegistreringType
;

new_uuid := as_create_or_import_facet(registrering);

read_facet1 := as_read_facet(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

expected_facet1 :=
				ROW(
					new_uuid,
					ARRAY[
						ROW(
							ROW(
								((read_facet1.registrering[1]).registrering).timeperiod, --this is cheating, but helps the comparison efforts below. (The timeperiod is set during creation/initialization )
								(registrering.registrering).livscykluskode,
								(registrering.registrering).brugerref,
								(registrering.registrering).note 
								)::RegistreringBase
							,registrering.tilsPubliceret
							,registrering.attrEgenskaber
							,registrering.relationer
						)::FacetRegistreringType
					]::FacetRegistreringType[]
			)::FacetType
;

RETURN NEXT is(
read_facet1,
expected_facet1,
'simple search test 1'
);


--RAISE NOTICE 'read_facet1_json:%',to_json(read_facet1);
--RAISE NOTICE 'expected_facet1_json:%',to_json(expected_facet1);

--TODO Test for different scenarios



END;
$$;


ALTER FUNCTION test.test_as_read_facet() OWNER TO mox;

--
-- Name: test_as_read_klasse(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_read_klasse() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid uuid;
	registrering KlasseRegistreringType;
	new_uuid2 uuid;
	registrering2 KlasseRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkEgenskaberB Virkning;
	virkEgenskaberC Virkning;
	virkEgenskaberD Virkning;
	virkEgenskaberE Virkning;
	virkAnsvarlig Virkning;
	virkRedaktoer1 Virkning;
	virkRedaktoer2 Virkning;
	virkPubliceret Virkning;
	virkPubliceretB Virkning;
	virkPubliceretC Virkning;
	klasseEgenskabA KlasseEgenskaberAttrType;
	klasseEgenskabB KlasseEgenskaberAttrType;
	klasseEgenskabC KlasseEgenskaberAttrType;
	klasseEgenskabD KlasseEgenskaberAttrType;
	klasseEgenskabE KlasseEgenskaberAttrType;
	klassePubliceret KlassePubliceretTilsType;
	klassePubliceretB KlassePubliceretTilsType;
	klassePubliceretC KlassePubliceretTilsType;
	klasseRelAnsvarlig KlasseRelationType;
	klasseRelRedaktoer1 KlasseRelationType;
	klasseRelRedaktoer2 KlasseRelationType;
	uuidAnsvarlig uuid :='21899b1a-afce-466a-8054-b8268789038b'::uuid;
	uuidRedaktoer1 uuid :='ed97bd42-427b-4f06-a321-de9ba9453dbd'::uuid;
	uuidRedaktoer2 uuid :='e16ed1ea-176a-45ae-99dc-b27d7849e9c9'::uuid;
	uuidRegistrering uuid :='4e5a2388-f620-4279-839c-ec59dd18d0e7'::uuid;
	update_reg_id bigint;
	actual_relationer KlasseRelationType[];
	actual_publiceret KlassePubliceretTilsType[];
	actual_egenskaber KlasseEgenskaberAttrType[];
	klasseEgenskabA_Soegeord1 KlasseSoegeordType;
	klasseEgenskabA_Soegeord2 KlasseSoegeordType;
	klasseEgenskabB_Soegeord1 KlasseSoegeordType;
	klasseEgenskabB_Soegeord2 KlasseSoegeordType;
	klasseEgenskabB_Soegeord3 KlasseSoegeordType;
	klasseEgenskabB_Soegeord4 KlasseSoegeordType;
	klasseEgenskabC_Soegeord1 KlasseSoegeordType;
	klasseEgenskabC_Soegeord2 KlasseSoegeordType;
	klasseEgenskabC_Soegeord3 KlasseSoegeordType;
	klasseEgenskabE_Soegeord1 KlasseSoegeordType;
	klasseEgenskabE_Soegeord2 KlasseSoegeordType;
	klasseEgenskabE_Soegeord3 KlasseSoegeordType;
	klasseEgenskabE_Soegeord4 KlasseSoegeordType;
	klasseEgenskabE_Soegeord5 KlasseSoegeordType;
	read_klasse1 KlasseType;
	expected_klasse1 KlasseType;
	read_klasse2 KlasseType;
	expected_klasse2 KlasseType;
	--tempResSoegeord KlasseSoegeordTypeWID[];
	--tempResEgenskaberAttr KlasseEgenskaberAttrTypeWID[];
	
BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          '09adacb1-b183-4939-a1ab-a4a3f612bcdb'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaberB :=	ROW (
	'[2014-05-13, 2015-01-01)' :: TSTZRANGE,
          '5b3469ab-1f70-4861-8ecf-74fb5975ec2b'::uuid,
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;


virkAnsvarlig :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          '6fedbb57-7dda-415e-856a-ce6ae9402c8a'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          '3f9dd4e2-2155-4301-8078-a4c68e8ffe5a'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          '6f544174-856a-408d-86e5-b26f257e3c8f'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;


virkPubliceret:=	ROW (
	'[2015-05-01, infinity)' :: TSTZRANGE,
          '3f9dd4e2-2155-4301-8076-a4c68e8ffe5a'::uuid,
          'Bruger',
          'NoteEx8'
          ) :: Virkning
;

virkPubliceretB:=	ROW (
	'[2014-05-13, 2015-05-01)' :: TSTZRANGE,
          'dac7ae9c-8aa2-4bfa-962b-6fd6354e55f1'::uuid,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;



klasseRelAnsvarlig := ROW (
	'ansvarlig'::KlasseRelationKode,
		virkAnsvarlig,
	uuidAnsvarlig,
	null,
	null
) :: KlasseRelationType
;


klasseRelRedaktoer1 := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer1,
	uuidRedaktoer1,
	null,
	null
) :: KlasseRelationType
;



klasseRelRedaktoer2 := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer2,
	uuidRedaktoer2,
	null,
	null
) :: KlasseRelationType
;


klassePubliceret := ROW (
virkPubliceret,
'Publiceret'
):: KlassePubliceretTilsType
;

klassePubliceretB := ROW (
virkPubliceretB,
'IkkePubliceret'
):: KlassePubliceretTilsType
;


klasseEgenskabA_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabA_Soegeord1',
'beskrivelse_klasseEgenskabA_Soegeord1',
'soegeordskategori_klasseEgenskabA_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabA_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabA_Soegeord2',
'beskrivelse_klasseEgenskabA_Soegeord2',
'soegeordskategori_klasseEgenskabA_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabA := ROW (
'brugervendt_noegle_A',
   'klassebeskrivelse_A',
   'eksempel_A',
	'omfang_A',
   'titel_A',
   'retskilde_A',
   NULL,--'aendringsnotat_text1',
   ARRAY[klasseEgenskabA_Soegeord1,klasseEgenskabA_Soegeord2]::KlasseSoegeordType[], 
   virkEgenskaber
) :: KlasseEgenskaberAttrType
;


klasseEgenskabB_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord1',
'beskrivelse_klasseEgenskabB_Soegeord1',
'soegeordskategori_klasseEgenskabB_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabB_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord2',
'beskrivelse_klasseEgenskabB_Soegeord2',
'soegeordskategori_klasseEgenskabB_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabB_Soegeord3 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord3',
'beskrivelse_klasseEgenskabB_Soegeord3',
'soegeordskategori_klasseEgenskabB_Soegeord3'
)::KlasseSoegeordType
;
klasseEgenskabB_Soegeord4 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord4',
'beskrivelse_klasseEgenskabB_Soegeord4',
'soegeordskategori_klasseEgenskabB_Soegeord4'
)::KlasseSoegeordType
;


klasseEgenskabE_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord1',
'beskrivelse_klasseEgenskabE_Soegeord1',
'soegeordskategori_klasseEgenskabE_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabE_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord2',
'beskrivelse_klasseEgenskabE_Soegeord2',
'soegeordskategori_klasseEgenskabE_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabE_Soegeord3 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord3',
'beskrivelse_klasseEgenskabE_Soegeord3',
'soegeordskategori_klasseEgenskabE_Soegeord3'
)::KlasseSoegeordType
;
klasseEgenskabE_Soegeord4 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord4',
'beskrivelse_klasseEgenskabE_Soegeord4',
'soegeordskategori_klasseEgenskabE_Soegeord4'
)::KlasseSoegeordType
;

klasseEgenskabE_Soegeord5 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord5',
'beskrivelse_klasseEgenskabE_Soegeord5',
'soegeordskategori_klasseEgenskabE_Soegeord5'
)::KlasseSoegeordType
;


klasseEgenskabB := ROW (
'brugervendt_noegle_B',
   'klassebeskrivelse_B',
   'eksempel_B',
	'omfang_B',
   'titel_B',
   'retskilde_B',
   NULL, --aendringsnotat
    ARRAY[klasseEgenskabB_Soegeord1,klasseEgenskabB_Soegeord2,klasseEgenskabB_Soegeord3,klasseEgenskabB_Soegeord4]::KlasseSoegeordType[], --soegeord
   virkEgenskaberB
) :: KlasseEgenskaberAttrType
;


registrering := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
ARRAY[klassePubliceret,klassePubliceretB]::KlassePubliceretTilsType[],
ARRAY[klasseEgenskabA,klasseEgenskabB]::KlasseEgenskaberAttrType[],
ARRAY[klasseRelAnsvarlig,klasseRelRedaktoer2,klasseRelRedaktoer1]
) :: KlasseRegistreringType
;

new_uuid := as_create_or_import_klasse(registrering);


registrering := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 54') :: RegistreringBase
	,
ARRAY[klassePubliceret,klassePubliceretB]::KlassePubliceretTilsType[],
ARRAY[klasseEgenskabA,klasseEgenskabB]::KlasseEgenskaberAttrType[],
ARRAY[klasseRelAnsvarlig,klasseRelRedaktoer2,klasseRelRedaktoer1]
) :: KlasseRegistreringType
;

new_uuid := as_create_or_import_klasse(registrering);


virkEgenskaberC :=	ROW (
	'[2015-01-13, infinity)' :: TSTZRANGE,
          '99e031a2-d84e-4431-b3cd-a7e632a385f0'::uuid,
          'Bruger',
          'NoteEx20'
          ) :: Virkning
;

virkEgenskaberD :=	ROW (
	'[2013-06-30, 2014-06-01)' :: TSTZRANGE,
          '86308373-4ef2-41a2-a276-95697567b536'::uuid,
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;

virkEgenskaberE:=	ROW (
	'[2014-08-01, 2014-10-20)' :: TSTZRANGE,
          '951cabb7-8d5c-46ec-906a-17d9cc916e77'::uuid,
          'Bruger',
          'NoteEx20'
          ) :: Virkning
;

klasseEgenskabC := ROW (
   NULL,--'brugervendt_noegle_text1',
   NULL, --'klassebeskrivelse_text1',
   NULL,--'eksempel_text1',
	'omfang_C',
   'titel_C',
   'retskilde_C',
   'aendringsnotat_C',
   ARRAY[]::KlasseSoegeordType[], --soegeord
   virkEgenskaberC
) :: KlasseEgenskaberAttrType
;

klasseEgenskabD := ROW (
'brugervendt_noegle_D',
   'klassebeskrivelse_D',
   'eksempel_D',
   'omfang_D',
   NULL,-- 'titel_D',
   'retskilde_D',
   NULL, --aendringsnotat
    NULL, --soegeord
   virkEgenskaberD
) :: KlasseEgenskaberAttrType
;

klasseEgenskabE := ROW (
'brugervendt_noegle_E',
   'klassebeskrivelse_E',
   'eksempel_E',
	'omfang_E',
   'titel_E',
   'retskilde_E',
   NULL, --aendringsnotat
    ARRAY[klasseEgenskabE_Soegeord1,klasseEgenskabE_Soegeord2,klasseEgenskabE_Soegeord3,klasseEgenskabE_Soegeord4,klasseEgenskabE_Soegeord5]::KlasseSoegeordType[], --soegeord
   virkEgenskaberE
) :: KlasseEgenskaberAttrType
;

virkPubliceretC:=	ROW (
	'[2015-01-01, 2015-05-01]' :: TSTZRANGE,
          '7f9dd4e2-2155-4301-8076-a4c68e8ffe5c'::uuid,
          'Bruger',
          'NoteEx10'
          ) :: Virkning
;



klassePubliceretC := ROW (
virkPubliceretC,
''::KlassePubliceretTils
):: KlassePubliceretTilsType
;


registrering2 := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 5') :: RegistreringBase
	,
array[klassePubliceretC]::KlassePubliceretTilsType[],
  array[klasseEgenskabC,klasseEgenskabD,klasseEgenskabE]::KlasseEgenskaberAttrType[],
  array[klasseRelAnsvarlig]::KlasseRelationType[]
) :: KlasseRegistreringType
;

new_uuid2 := as_create_or_import_klasse(registrering2);


read_Klasse1 := as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

expected_Klasse1 :=
				ROW(
					new_uuid,
					ARRAY[
						ROW(
							ROW(
								((read_Klasse1.registrering[1]).registrering).timeperiod, --this is cheating, but helps the comparison efforts below. (The timeperiod is set during creation/initialization )
								(registrering.registrering).livscykluskode,
								(registrering.registrering).brugerref,
								(registrering.registrering).note 
								)::RegistreringBase
							,registrering.tilsPubliceret
							,registrering.attrEgenskaber
							,registrering.relationer
						)::KlasseRegistreringType
					]::KlasseRegistreringType[]
			)::KlasseType
;

--RAISE NOTICE 'expected_Klasse1_json:%',to_json(expected_Klasse1);
--RAISE NOTICE 'read_Klasse1:%',to_json(read_Klasse1);

RETURN NEXT is(
read_Klasse1,
expected_Klasse1,
'simple read klasse test 1'
);


read_Klasse2 := as_read_Klasse(new_uuid2,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

expected_Klasse2 :=
				ROW(
					new_uuid2,
					ARRAY[
						ROW(
							ROW(
								((read_Klasse2.registrering[1]).registrering).timeperiod, --this is cheating, but helps the comparison efforts below. (The timeperiod is set during creation/initialization )
								(registrering2.registrering).livscykluskode,
								(registrering2.registrering).brugerref,
								(registrering2.registrering).note 
								)::RegistreringBase
							,ARRAY[klassePubliceretC]--registrering2.tilsPubliceret
							,array[klasseEgenskabD,klasseEgenskabE,
							ROW(
							klasseEgenskabC.brugervendtnoegle,
							klasseEgenskabC.beskrivelse,
							klasseEgenskabC.eksempel,
							klasseEgenskabC.omfang,
							klasseEgenskabC.titel,
							klasseEgenskabC.retskilde,
							klasseEgenskabC.aendringsnotat,
							null, --array[]::KlasseSoegeordType[], empty array is read as null
 							klasseEgenskabC.virkning 
							)::KlasseEgenskaberAttrType
							]::KlasseEgenskaberAttrType[]
							,registrering2.relationer
						)::KlasseRegistreringType
					]::KlasseRegistreringType[]
			)::KlasseType
;

--RAISE NOTICE 'read_Klasse2_json:%',to_json(read_Klasse2);
--RAISE NOTICE 'expected_Klasse2_json:%',to_json(expected_Klasse2);

RETURN NEXT is(
read_Klasse2,
expected_Klasse2,
'simple read klasse test 2'
);






END;
$$;


ALTER FUNCTION test.test_as_read_klasse() OWNER TO mox;

--
-- Name: test_as_search_aktivitet(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_search_aktivitet() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	new_uuid2 uuid;
	registrering aktivitetRegistreringType;
	registrering2 aktivitetRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkEgenskaber2 Virkning;
	virkAnsvarligklasse Virkning;
	virkResultatklasse1 Virkning;
	virkResultatklasse2 Virkning;
	virkDeltagerklasse1 Virkning;
	virkDeltagerklasse2 Virkning;
	virkUdfoerer1 Virkning;
	virkUdfoerer2 Virkning;
	virkPubliceret Virkning;
	virkStatus Virkning;
	aktivitetEgenskab aktivitetEgenskaberAttrType;
	aktivitetEgenskab2 aktivitetEgenskaberAttrType;
	aktivitetStatus aktivitetStatusTilsType;
	aktivitetPubliceret aktivitetPubliceretTilsType;
	aktivitetRelAnsvarligklasse aktivitetRelationType;
	aktivitetRelResultatklasse1 aktivitetRelationType;
	aktivitetRelResultatklasse2 aktivitetRelationType;
	aktivitetRelDeltagerklasse1 aktivitetRelationType;
	aktivitetRelDeltagerklasse2 aktivitetRelationType;
	aktivitetRelUdfoerer1 aktivitetRelationType;
	aktivitetRelUdfoerer2 aktivitetRelationType;

	uuidAnsvarligklasse uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	uuidResultatklasse1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;


	--uuidResultatklasse2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	urnResultatklasse2 text:='urn:isbn:0451450523'::text;
	uuidDeltagerklasse1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidDeltagerklasse2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidUdfoerer1  uuid :='884d99f6-568f-4772-8766-fac6d40f9cb0'::uuid;
	uuidUdfoerer2  uuid :='b6bb8e41-b47b-4420-b2a3-d1c38d86a1ad'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	repraesentation_uuid uuid :='0e3ed41a-08f2-4967-8689-dce625f93029'::uuid;
	repraesentation_urn text :='isbn:97800232324'::text;

	actual_publiceret_virk virkning;
	actual_publiceret_value aktivitetStatusTils;
	actual_publiceret aktivitetStatusTilsType;
	actual_relationer aktivitetRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	read_Aktivitet1 AktivitetType;
	expected_aktivitet1 AktivitetType;
	read_Aktivitet2 AktivitetType;
	expected_aktivitet2 AktivitetType;

	expected_search_res_1 uuid[];
	expected_search_res_2 uuid[];
	expected_search_res_3 uuid[];
	expected_search_res_4 uuid[];
	expected_search_res_5 uuid[];
	expected_search_res_6 uuid[];
	expected_search_res_7 uuid[];
	expected_search_res_8 uuid[];
	expected_search_res_9 uuid[];
	expected_search_res_10 uuid[];
	expected_search_res_11 uuid[];
	expected_search_res_12 uuid[];
	expected_search_res_13 uuid[];
	expected_search_res_14 uuid[];
	expected_search_res_15 uuid[];
	expected_search_res_16 uuid[];
	expected_search_res_17 uuid[];
	expected_search_res_18 uuid[];
	expected_search_res_19 uuid[];
	expected_search_res_20 uuid[];
	expected_search_res_21 uuid[];
	expected_search_res_22 uuid[];
	expected_search_res_23 uuid[];
	expected_search_res_24 uuid[];
	expected_search_res_25 uuid[];
	expected_search_res_26 uuid[];
	expected_search_res_27 uuid[];
	expected_search_res_28 uuid[];
	expected_search_res_29 uuid[];

	actual_search_res_1 uuid[];
	actual_search_res_2 uuid[];
	actual_search_res_3 uuid[];
	actual_search_res_4 uuid[];
	actual_search_res_5 uuid[];
	actual_search_res_6 uuid[];
	actual_search_res_7 uuid[];
	actual_search_res_8 uuid[];
	actual_search_res_9 uuid[];
	actual_search_res_10 uuid[];
	actual_search_res_11 uuid[];
	actual_search_res_12 uuid[];
	actual_search_res_13 uuid[];
	actual_search_res_14 uuid[];
	actual_search_res_15 uuid[];
	actual_search_res_16 uuid[];
	actual_search_res_17 uuid[];
	actual_search_res_18 uuid[];
	actual_search_res_19 uuid[];
	actual_search_res_20 uuid[];
	actual_search_res_21 uuid[];
	actual_search_res_22 uuid[];
	actual_search_res_23 uuid[];
	actual_search_res_24 uuid[];
	actual_search_res_25 uuid[];
	actual_search_res_26 uuid[];
	actual_search_res_27 uuid[];
	actual_search_res_28 uuid[];
	actual_search_res_29 uuid[];

BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, 2015-06-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaber2 :=	ROW (
	'[2015-06-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx90'
          ) :: Virkning
;

virkAnsvarligklasse :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkUdfoerer1 :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx342'
          ) :: Virkning
;

virkUdfoerer2 :=	ROW (
	'[2016-04-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx350'
          ) :: Virkning
;

virkResultatklasse1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkResultatklasse2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkstatus := ROW (
	'[2016-12-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx20'
) :: Virkning
;

virkDeltagerklasse1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkDeltagerklasse2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

aktivitetRelAnsvarligklasse := ROW (
	'ansvarligklasse'::aktivitetRelationKode
	,virkAnsvarligklasse
	,uuidAnsvarligklasse
	,null
	,'Klasse'
	,567 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;

aktivitetRelUdfoerer1 := ROW (
	'udfoerer'::aktivitetRelationKode
	,virkUdfoerer1
	,uuidUdfoerer1
	,null
	,'Person'
	,3 --NOTICE: Should be replace in by import function
	,ROW (
		 'valgfri'::AktivitetAktoerAttrObligatoriskKode,
  		'foreloebigt'::AktivitetAktoerAttrAccepteretKode,
  repraesentation_uuid,
  null 
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
;


aktivitetRelUdfoerer2 := ROW (
	'udfoerer'::aktivitetRelationKode
	,virkUdfoerer2
	,uuidUdfoerer2
	,null
	,'Person'
	,3 --NOTICE: Should be replace in by import function
	,ROW (
		 'noedvendig'::AktivitetAktoerAttrObligatoriskKode,
  		'accepteret'::AktivitetAktoerAttrAccepteretKode,
  null,
  repraesentation_urn
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
;


aktivitetRelResultatklasse1 := ROW (
	'resultatklasse'::aktivitetRelationKode,
		virkResultatklasse1,
	uuidResultatklasse1,
	null,
	'Klasse'
	,768 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;



aktivitetRelResultatklasse2 := ROW (
	'resultatklasse'::aktivitetRelationKode,
		virkResultatklasse2,
	null,
	urnResultatklasse2,
	'Klasse'
	,800 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;



aktivitetRelDeltagerklasse1 := ROW (
	'deltagerklasse'::aktivitetRelationKode,
		virkDeltagerklasse1,
	uuidDeltagerklasse1,
	null,
	'Klasse'
	,7268 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;



aktivitetRelDeltagerklasse2 := ROW (
	'deltagerklasse'::aktivitetRelationKode,
		virkDeltagerklasse2,
	uuidDeltagerklasse2,
	null,
	'Klasse'
	,3 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;



aktivitetStatus := ROW (
virkStatus,
'Aktiv'::AktivitetStatusTils
):: aktivitetStatusTilsType
;

aktivitetPubliceret := ROW (
virkPubliceret,
'Normal'::AktivitetPubliceretTils
)::aktivitetPubliceretTilsType;


aktivitetEgenskab := ROW (
 'aktivitet_1_brugervendtnoegle',
 'aktivitet_1_aktivitetnavn',
 'aktivitet_1_beskrivelse',
 '2017-02-25 17:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
  INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
 'aktivitet_1_formaal'
,virkEgenskaber
) :: aktivitetEgenskaberAttrType
;

aktivitetEgenskab2 := ROW (
 'aktivitet_2_brugervendtnoegle',
 'aktivitet_2_aktivitetnavn',
 'aktivitet_2_beskrivelse',
 '2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
'2017-02-27 12:00'::timestamptz, -- sluttidspunkt,
  INTERVAL '0000-00 01 04:00:01.0', --tidsforbrug
 'aktivitet_2_formaal'
,virkEgenskaber2
) :: aktivitetEgenskaberAttrType
;


registrering := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[aktivitetStatus]::aktivitetStatusTilsType[],
	ARRAY[aktivitetPubliceret]::AktivitetPubliceretTilsType[],
ARRAY[aktivitetEgenskab]::aktivitetEgenskaberAttrType[],
ARRAY[aktivitetRelAnsvarligklasse,aktivitetRelResultatklasse1,aktivitetRelResultatklasse2,aktivitetRelDeltagerklasse1,aktivitetRelDeltagerklasse2,aktivitetRelUdfoerer1,aktivitetRelUdfoerer2]) :: aktivitetRegistreringType
;


--raise notice 'to be written aktivitet 1:%',to_json(registrering);

new_uuid1 := as_create_or_import_aktivitet(registrering);

RETURN NEXT ok(true,'No errors running as_create_or_import_aktivitet #1 ');


--raise notice 'expected_aktivitet1:%',to_json(expected_aktivitet1);


RETURN NEXT IS(
	read_Aktivitet1,
	expected_aktivitet1
	,'test create aktivitet #1'
);


/**************************************************/



registrering2 := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[aktivitetStatus]::aktivitetStatusTilsType[],
	ARRAY[aktivitetPubliceret]::AktivitetPubliceretTilsType[],
ARRAY[aktivitetEgenskab,aktivitetEgenskab2]::aktivitetEgenskaberAttrType[],
ARRAY[	ROW (
				'ansvarligklasse'::aktivitetRelationKode
				,virkAnsvarligklasse
				,uuidAnsvarligklasse
				,null
				,'Klasse'
				,NULL 
				,null --ROW (null,null,null,null)::AktivitetAktoerAttr  --aktoerAttr
			) :: aktivitetRelationType
]::aktivitetRelationType[]
);

new_uuid2 := as_create_or_import_aktivitet(registrering2);

RETURN NEXT ok(true,'No errors running as_create_or_import_aktivitet #2 ');



/**************************************************/


expected_search_res_1:=array[new_uuid2]::uuid[];

actual_search_res_1:=as_search_aktivitet(null,null,
		ROW(
			null,
			null,-- AktivitetStatusTilsType[],
			null,-- AktivitetPubliceretTilsType[],
			ARRAY[ ROW (
 'aktivitet_2_brugervendtnoegle',
 null,--'aktivitet_2_aktivitetnavn',
 null,--'aktivitet_2_beskrivelse',
 null,--'2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
 null,--'2017-02-27 12:00'::timestamptz, -- sluttidspunkt,
 null,-- INTERVAL '0000-00 01 04:00:01.0', --tidsforbrug
 null,--'aktivitet_2_formaal'
 null--virkEgenskaber2
) :: aktivitetEgenskaberAttrType ]::aktivitetEgenskaberAttrType[],
			null-- AktivitetRelationType[]
			)::aktivitetRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_1 @> actual_search_res_1 and actual_search_res_1 @>expected_search_res_1 and coalesce(array_length(expected_search_res_1,1),0)=coalesce(array_length(actual_search_res_1,1),0), 'search aktivitet #1.');


/**************************************************/

expected_search_res_2:=array[new_uuid1,new_uuid2]::uuid[];

actual_search_res_2:=as_search_aktivitet(null,null,
			ROW(
			null,
			null,-- AktivitetStatusTilsType[],
			null,-- AktivitetPubliceretTilsType[],
			ARRAY[ ROW (
 null,--'aktivitet_2_brugervendtnoegle',
 null,--'aktivitet_2_aktivitetnavn',
 null,--'aktivitet_2_beskrivelse',
 '2017-02-25 17:00'::timestamptz,--'2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
 null,--'2017-02-27 12:00'::timestamptz, -- sluttidspunkt,
 null,-- INTERVAL '0000-00 01 04:00:01.0', --tidsforbrug
 null,--'aktivitet_2_formaal'
 null--virkEgenskaber2
) :: aktivitetEgenskaberAttrType ]::aktivitetEgenskaberAttrType[],
			null-- AktivitetRelationType[]
			)::aktivitetRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_2 @> actual_search_res_2 and actual_search_res_2 @>expected_search_res_2 and coalesce(array_length(expected_search_res_2,1),0)=coalesce(array_length(actual_search_res_2,1),0), 'search aktivitet #2.');

/**************************************************/
expected_search_res_3:=array[new_uuid2]::uuid[];

actual_search_res_3:=as_search_aktivitet(null,null,
		ROW(
			null,
			null,-- AktivitetStatusTilsType[],
			null,-- AktivitetPubliceretTilsType[],
			ARRAY[ ROW (
 null,--'aktivitet_3_brugervendtnoegle',
 null,--'aktivitet_3_aktivitetnavn',
 null,--'aktivitet_3_beskrivelse',
 null,--'2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_3' --text
 null,--'2017-02-27 12:00'::timestamptz, -- sluttidspunkt,
 INTERVAL '0000-00 01 04:00:01.0', --tidsforbrug
 null,--'aktivitet_3_formaal'
 null--virkEgenskaber2
) :: aktivitetEgenskaberAttrType ]::aktivitetEgenskaberAttrType[],
			null-- AktivitetRelationType[]
			)::aktivitetRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_3 @> actual_search_res_3 and actual_search_res_3 @>expected_search_res_3 and coalesce(array_length(expected_search_res_3,1),0)=coalesce(array_length(actual_search_res_3,1),0), 'search aktivitet #3.');

/**************************************************/
expected_search_res_4:=array[new_uuid1]::uuid[];

actual_search_res_4:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null,--registreringObj
		null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,array[repraesentation_uuid]::uuid[]
		,null --anyurnArr
);

RETURN NEXT ok(expected_search_res_4 @> actual_search_res_4 and actual_search_res_4 @>expected_search_res_4 and coalesce(array_length(expected_search_res_4,1),0)=coalesce(array_length(actual_search_res_4,1),0), 'search aktivitet #4.');

/**************************************************/
expected_search_res_5:=array[new_uuid1]::uuid[];

actual_search_res_5:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null,--registreringObj
		null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,array[repraesentation_urn]::text[] --anyurnArr
);

RETURN NEXT ok(expected_search_res_5 @> actual_search_res_5 and actual_search_res_5 @>expected_search_res_5 and coalesce(array_length(expected_search_res_5,1),0)=coalesce(array_length(actual_search_res_5,1),0), 'search aktivitet #5.');


/**************************************************/
expected_search_res_6:=array[new_uuid2]::uuid[];

actual_search_res_6:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null,--registreringObj
		null --virkningSoeg	
		,null --maxResults
		,array['aktivitet_2_brugervendtnoegle']::text[] --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
);

RETURN NEXT ok(expected_search_res_6 @> actual_search_res_6 and actual_search_res_6 @>expected_search_res_6 and coalesce(array_length(expected_search_res_6,1),0)=coalesce(array_length(actual_search_res_6,1),0), 'search aktivitet #6.');


/**************************************************/
expected_search_res_7:=array[new_uuid1]::uuid[];

actual_search_res_7:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		ROW(
			null,
			null,-- AktivitetStatusTilsType[],
			null,-- AktivitetPubliceretTilsType[],
			null,
			ARRAY [
				ROW (
	'udfoerer'::aktivitetRelationKode
	,null--virkUdfoerer1
	,null--uuidUdfoerer1
	,null
	,null--'Person'
	,null--3 --NOTICE: Should be replace in by import function
	,ROW (
		 null,--'valgfri'::AktivitetAktoerAttrObligatoriskKode,
  		'foreloebigt'::AktivitetAktoerAttrAccepteretKode,
    null,--repraesentation_uuid,
  null 
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
			]::AktivitetRelationType[]
							)::aktivitetRegistreringType
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
);

RETURN NEXT ok(expected_search_res_7 @> actual_search_res_7 and actual_search_res_7 @>expected_search_res_7 and coalesce(array_length(expected_search_res_7,1),0)=coalesce(array_length(actual_search_res_7,1),0), 'search aktivitet #7.');


/**************************************************/
expected_search_res_8:=array[]::uuid[];

actual_search_res_8:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		ROW(
			null,
			null,-- AktivitetStatusTilsType[],
			null,-- AktivitetPubliceretTilsType[],
			null,
			ARRAY [
				ROW (
	'udfoerer'::aktivitetRelationKode
	,null--virkUdfoerer1
	,null--uuidUdfoerer1
	,null
	,null--'Person'
	,null--3 --NOTICE: Should be replace in by import function
	,ROW (
		 'noedvendig'::AktivitetAktoerAttrObligatoriskKode, --'valgfri'::AktivitetAktoerAttrObligatoriskKode,
  		'foreloebigt'::AktivitetAktoerAttrAccepteretKode,
    null,--repraesentation_uuid,
  null 
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
			]::AktivitetRelationType[]
							)::aktivitetRegistreringType
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
);

RETURN NEXT ok(expected_search_res_8 @> actual_search_res_8 and actual_search_res_8 @>expected_search_res_8 and coalesce(array_length(expected_search_res_8,1),0)=coalesce(array_length(actual_search_res_8,1),0), 'search aktivitet #8.');


/**************************************************/
expected_search_res_9:=array[new_uuid1]::uuid[];

actual_search_res_9:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		ROW(
			null,
			null,-- AktivitetStatusTilsType[],
			null,-- AktivitetPubliceretTilsType[],
			null,
			ARRAY [
				ROW (
	'udfoerer'::aktivitetRelationKode
	,null--virkUdfoerer1
	,null--uuidUdfoerer1
	,null
	,null--'Person'
	,null--3 --NOTICE: Should be replace in by import function
	,ROW (
		 null, --'valgfri'::AktivitetAktoerAttrObligatoriskKode,
  		null,
    repraesentation_uuid,--repraesentation_uuid,
  null 
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
			]::AktivitetRelationType[]
							)::aktivitetRegistreringType
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
);

RETURN NEXT ok(expected_search_res_9 @> actual_search_res_9 and actual_search_res_9 @>expected_search_res_9 and coalesce(array_length(expected_search_res_9,1),0)=coalesce(array_length(actual_search_res_9,1),0), 'search aktivitet #9.');


/**************************************************/
expected_search_res_10:=array[]::uuid[];

actual_search_res_10:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		ROW(
			null,
			null,-- AktivitetStatusTilsType[],
			null,-- AktivitetPubliceretTilsType[],
			null,
			ARRAY [
				ROW (
	'udfoerer'::aktivitetRelationKode
	,null--virkUdfoerer1
	,null--uuidUdfoerer1
	,null
	,null--'Person'
	,null--3 --NOTICE: Should be replace in by import function
	,ROW (
		 null, --'valgfri'::AktivitetAktoerAttrObligatoriskKode,
  		null,
     uuidAnsvarligklasse,--repraesentation_uuid,
  null 
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
			]::AktivitetRelationType[]
							)::aktivitetRegistreringType
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
);

RETURN NEXT ok(expected_search_res_10 @> actual_search_res_10 and actual_search_res_10 @>expected_search_res_10 and coalesce(array_length(expected_search_res_10,1),0)=coalesce(array_length(actual_search_res_10,1),0), 'search aktivitet #10.');

/**************************************************/
expected_search_res_11:=array[new_uuid1]::uuid[];

actual_search_res_11:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		ROW(
			null,
			null,-- AktivitetStatusTilsType[],
			null,-- AktivitetPubliceretTilsType[],
			null,
			ARRAY [
				ROW (
	'udfoerer'::aktivitetRelationKode
	,null--virkUdfoerer1
	,null--uuidUdfoerer1
	,null
	,null--'Person'
	,null--3 --NOTICE: Should be replace in by import function
	,ROW (
		 null, --'valgfri'::AktivitetAktoerAttrObligatoriskKode,
  		null,
     null,--repraesentation_uuid,
  repraesentation_urn 
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
			]::AktivitetRelationType[]
							)::aktivitetRegistreringType
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
);

RETURN NEXT ok(expected_search_res_11 @> actual_search_res_11 and actual_search_res_11 @>expected_search_res_11 and coalesce(array_length(expected_search_res_11,1),0)=coalesce(array_length(actual_search_res_11,1),0), 'search aktivitet #11.');

/**************************************************/
expected_search_res_12:=array[new_uuid1,new_uuid2]::uuid[];

actual_search_res_12:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				'2016-04-01 00:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				null,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				null,--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
				null--,virkEgenskaber
				) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_12 @> actual_search_res_12 and actual_search_res_12 @>expected_search_res_12 and coalesce(array_length(expected_search_res_12,1),0)=coalesce(array_length(actual_search_res_12,1),0), 'search aktivitet #12.');

/**************************************************/

/**************************************************/
expected_search_res_13:=array[]::uuid[];

actual_search_res_13:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				'2018-01-01 00:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				null,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				null,--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
				null--,virkEgenskaber
				) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_13 @> actual_search_res_13 and actual_search_res_13 @>expected_search_res_13 and coalesce(array_length(expected_search_res_13,1),0)=coalesce(array_length(actual_search_res_13,1),0), 'search aktivitet #13.');

--raise notice 'actual_search_res_13:%',to_json(actual_search_res_13);
--raise notice 'expected_search_res_13:%',to_json(expected_search_res_13);

/**************************************************/

expected_search_res_14:=array[new_uuid1,new_uuid2]::uuid[];

actual_search_res_14:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				'2016-01-01 00:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				null,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				null,--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
						ROW (
			'[2015-06-01, 2015-06-01]' :: TSTZRANGE,
				null,
				null,
				null
				) :: Virkning
						) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_14 @> actual_search_res_14 and actual_search_res_14 @>expected_search_res_14 and coalesce(array_length(expected_search_res_14,1),0)=coalesce(array_length(actual_search_res_14,1),0), 'search aktivitet #14.');
/**************************************************/

/**************************************************/

expected_search_res_15:=array[new_uuid2]::uuid[];

actual_search_res_15:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				'2016-01-01 00:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				null,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				null,--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
						ROW (
			'[2015-06-10, 2015-06-10]' :: TSTZRANGE,
				null,
				null,
				null
				) :: Virkning
						) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_15 @> actual_search_res_15 and actual_search_res_15 @>expected_search_res_15 and coalesce(array_length(expected_search_res_15,1),0)=coalesce(array_length(actual_search_res_15,1),0), 'search aktivitet #15.');

/**************************************************/

/**************************************************/
expected_search_res_16:=array[new_uuid2]::uuid[];

actual_search_res_16:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				null,--'2018-01-01 00:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				'2017-02-27 09:00'::timestamptz,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				null,--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
				null--,virkEgenskaber
				) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_16 @> actual_search_res_16 and actual_search_res_16 @>expected_search_res_16 and coalesce(array_length(expected_search_res_16,1),0)=coalesce(array_length(actual_search_res_16,1),0), 'search aktivitet #16.');


/**************************************************/
expected_search_res_17:=array[new_uuid2,new_uuid1]::uuid[];

actual_search_res_17:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				null,--'2018-01-01 00:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				'2017-02-27 08:00'::timestamptz,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				null,--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
				null--,virkEgenskaber
				) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_17 @> actual_search_res_17 and actual_search_res_17 @>expected_search_res_17 and coalesce(array_length(expected_search_res_17,1),0)=coalesce(array_length(actual_search_res_17,1),0), 'search aktivitet #17.');


/**************************************************/
expected_search_res_18:=array[]::uuid[];

actual_search_res_18:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				null,--'2018-01-01 00:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				'2017-02-27 13:00'::timestamptz,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				null,--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
				null--,virkEgenskaber
				) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_18 @> actual_search_res_18 and actual_search_res_18 @>expected_search_res_18 and coalesce(array_length(expected_search_res_18,1),0)=coalesce(array_length(actual_search_res_18,1),0), 'search aktivitet #18.');

/**************************************************/
expected_search_res_19:=array[new_uuid1,new_uuid2]::uuid[];

actual_search_res_19:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				'2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				null,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				null,--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
				null--,virkEgenskaber
				) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_19 @> actual_search_res_19 and actual_search_res_19 @>expected_search_res_19 and coalesce(array_length(expected_search_res_19,1),0)=coalesce(array_length(actual_search_res_19,1),0), 'search aktivitet #19.');


/**************************************************/
expected_search_res_20:=array[new_uuid1,new_uuid2]::uuid[];

actual_search_res_20:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				null,--'2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				null,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				INTERVAL '0000-00 01 00:00:00.0',--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
				null--,virkEgenskaber
				) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_20 @> actual_search_res_20 and actual_search_res_20 @>expected_search_res_20 and coalesce(array_length(expected_search_res_20,1),0)=coalesce(array_length(actual_search_res_20,1),0), 'search aktivitet #20.');

/**************************************************/
expected_search_res_21:=array[]::uuid[];

actual_search_res_21:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,'[2015-06-10 , 2015-06-10]' :: TSTZRANGE --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				null,--'2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				null,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				INTERVAL '0000-00 02 00:00:00.0',--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
				null--,virkEgenskaber
				) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_21 @> actual_search_res_21 and actual_search_res_21 @>expected_search_res_21 and coalesce(array_length(expected_search_res_21,1),0)=coalesce(array_length(actual_search_res_21,1),0), 'search aktivitet #21.');

/**************************************************/
expected_search_res_22:=array[new_uuid2]::uuid[];

actual_search_res_22:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,'[2015-06-10 , 2015-06-10]' :: TSTZRANGE --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				null,--'2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				null,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				INTERVAL '0000-00 01 00:00:00.0',--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
				null--,virkEgenskaber
				) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_22 @> actual_search_res_22 and actual_search_res_22 @>expected_search_res_22 and coalesce(array_length(expected_search_res_22,1),0)=coalesce(array_length(actual_search_res_22,1),0), 'search aktivitet #22.');
/**************************************************/
expected_search_res_23:=array[new_uuid2]::uuid[];

actual_search_res_23:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,null	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,null --search_operator_greater_then_attr_egenskaber
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				null,--'2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				null,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				INTERVAL '0000-00 02 00:00:00.0',--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
				null--,virkEgenskaber
				) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]   --search_operator_less_then_attr_egenskaber

);

RETURN NEXT ok(expected_search_res_23 @> actual_search_res_23 and actual_search_res_23 @>expected_search_res_23 and coalesce(array_length(expected_search_res_23,1),0)=coalesce(array_length(actual_search_res_23,1),0), 'search aktivitet #23.');

/**************************************************/

expected_search_res_24:=array[]::uuid[];

actual_search_res_24:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,null	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,null --search_operator_greater_then_attr_egenskaber
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				null,--'2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				null,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				INTERVAL '0000-00 01 00:00:00.0',--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
				null--,virkEgenskaber
				) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]   --search_operator_less_then_attr_egenskaber

);

RETURN NEXT ok(expected_search_res_24 @> actual_search_res_24 and actual_search_res_24 @>expected_search_res_24 and coalesce(array_length(expected_search_res_24,1),0)=coalesce(array_length(actual_search_res_24,1),0), 'search aktivitet #24.');

/**************************************************/

expected_search_res_25:=array[new_uuid1,new_uuid2]::uuid[];

actual_search_res_25:=as_search_aktivitet(
		null,--firstResult
		null,--aktivitet_uuid
		null
		,null	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr AktivitetRegistreringType[]=null,
		,null --search_operator_greater_then_attr_egenskaber
		,ARRAY[
			ROW (
				null,--'aktivitet_1_brugervendtnoegle',
				null,--'aktivitet_1_aktivitetnavn',
				null,--'aktivitet_1_beskrivelse',
				null,--'2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
				null,--'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
				INTERVAL '0000-01 00 00:00:00.0',--INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
				null,--'aktivitet_1_formaal'
				null--,virkEgenskaber
				) :: aktivitetEgenskaberAttrType
		]::AktivitetEgenskaberAttrType[]   --search_operator_less_then_attr_egenskaber

);

RETURN NEXT ok(expected_search_res_25 @> actual_search_res_25 and actual_search_res_25 @>expected_search_res_25 and coalesce(array_length(expected_search_res_25,1),0)=coalesce(array_length(actual_search_res_25,1),0), 'search aktivitet #25.');



--raise notice 'actual_search_res_19:%',to_json(actual_search_res_19);
--raise notice 'expected_search_res_19:%',to_json(expected_search_res_19);


/*
	firstResult int,--TOOD ??
	aktivitet_uuid uuid,
	registreringObj AktivitetRegistreringType,
	virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	maxResults int = 2147483647,
	anyAttrValueArr text[] = '{}'::text[],
	anyuuidArr	uuid[] = '{}'::uuid[],
	anyurnArr text[] = '{}'::text[],
	auth_criteria_arr AktivitetRegistreringType[]=null,
	search_operator_greater_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
	search_operator_less_then_attr_egenskaber AktivitetEgenskaberAttrType[]=null
*/

END;
$$;


ALTER FUNCTION test.test_as_search_aktivitet() OWNER TO mox;

--
-- Name: test_as_search_dokument(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_search_dokument() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 

doc1_new_uuid uuid;
	doc1_registrering dokumentRegistreringType;
	doc1_virkEgenskaber1 Virkning;
	doc1_virkEgenskaber2 Virkning;
	doc1_virkAnsvarlig Virkning;
	doc1_virkBesvarelser1 Virkning;
	doc1_virkBesvarelser2 Virkning;
	doc1_virkFremdrift Virkning;
	doc1_dokumentEgenskab1 dokumentEgenskaberAttrType;
	doc1_dokumentEgenskab2 dokumentEgenskaberAttrType;
	doc1_dokumentFremdrift dokumentFremdriftTilsType;
	doc1_dokumentRelAnsvarlig dokumentRelationType;
	doc1_dokumentRelBesvarelser1 dokumentRelationType;
	doc1_dokumentRelBesvarelser2 dokumentRelationType;
	doc1_uuidAnsvarlig uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	doc1_uuidBesvarelser1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	--uuidBesvarelser2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	doc1_urnBesvarelser2 text:='urn:isbn:0451450523'::text;
	doc1_uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	doc1_docVariant1 DokumentVariantType;
	doc1_docVariant2 DokumentVariantType;
	doc1_docVariantEgenskaber1A DokumentVariantEgenskaberType;
	doc1_docVariantEgenskaber1AVirkning Virkning;
	doc1_docVariantEgenskaber1B DokumentVariantEgenskaberType;
	doc1_docVariantEgenskaber1BVirkning Virkning;
	doc1_docVariantEgenskaber2A DokumentVariantEgenskaberType;
	doc1_docVariantEgenskaber2AVirkning Virkning;	
	doc1_docDel1A DokumentDelType;
	doc1_docDel1B DokumentDelType;
	doc1_docDel2A DokumentDelType;
	doc1_docDel2B DokumentDelType;
	doc1_docDel1AEgenskaber DokumentDelEgenskaberType;
	doc1_docDel1A2Egenskaber DokumentDelEgenskaberType;
	doc1_docDel1AEgenskaberVirkning Virkning;
	doc1_docDel1A2EgenskaberVirkning Virkning;
	doc1_docDel1BEgenskaber DokumentDelEgenskaberType;
	doc1_docDel1BEgenskaberVirkning Virkning;
	doc1_docDel2AEgenskaber DokumentDelEgenskaberType;
	doc1_docDel2AEgenskaberVirkning Virkning;
	doc1_docDel1Arelation1 DokumentdelRelationType;
	doc1_docDel1Arelation1Virkning Virkning;
	doc1_docDel2Brelation1 DokumentdelRelationType;
	doc1_docDel2Brelation1Virkning Virkning;
	doc1_docDel2Brelation2 DokumentdelRelationType;
	doc1_docDel2Brelation2Virkning Virkning;

	doc1_extraRel1 DokumentdelRelationType;
	doc1_extraRel2 DokumentdelRelationType;
	doc1_extraRelVirkning1 Virkning;
	doc1_extraRelVirkning2 Virkning;

	doc2_new_uuid uuid;
	doc2_registrering dokumentRegistreringType;
	doc2_virkEgenskaber1 Virkning;
	doc2_virkEgenskaber2 Virkning;
	doc2_virkAnsvarlig Virkning;
	doc2_virkBesvarelser1 Virkning;
	doc2_virkBesvarelser2 Virkning;
	doc2_virkFremdrift Virkning;
	doc2_dokumentEgenskab1 dokumentEgenskaberAttrType;
	doc2_dokumentEgenskab2 dokumentEgenskaberAttrType;
	doc2_dokumentFremdrift dokumentFremdriftTilsType;
	doc2_dokumentRelAnsvarlig dokumentRelationType;
	doc2_dokumentRelBesvarelser1 dokumentRelationType;
	doc2_dokumentRelBesvarelser2 dokumentRelationType;
	doc2_uuidAnsvarlig uuid :='20109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	doc2_uuidBesvarelser1 uuid :='15160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	--uuidBesvarelser2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	doc2_urnBesvarelser2 text:='urn:isbn:0451450529'::text;
	doc2_uuidRegistrering uuid :='17368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	doc2_docVariant1 DokumentVariantType;
	doc2_docVariant2 DokumentVariantType;
	doc2_docVariantEgenskaber1A DokumentVariantEgenskaberType;
	doc2_docVariantEgenskaber1AVirkning Virkning;
	doc2_docVariantEgenskaber1B DokumentVariantEgenskaberType;
	doc2_docVariantEgenskaber1BVirkning Virkning;
	doc2_docVariantEgenskaber2A DokumentVariantEgenskaberType;
	doc2_docVariantEgenskaber2AVirkning Virkning;	
	doc2_docDel1A DokumentDelType;
	doc2_docDel1B DokumentDelType;
	doc2_docDel2A DokumentDelType;
	doc2_docDel2B DokumentDelType;
	doc2_docDel1AEgenskaber DokumentDelEgenskaberType;
	doc2_docDel1A2Egenskaber DokumentDelEgenskaberType;
	doc2_docDel1AEgenskaberVirkning Virkning;
	doc2_docDel1A2EgenskaberVirkning Virkning;
	doc2_docDel1BEgenskaber DokumentDelEgenskaberType;
	doc2_docDel1BEgenskaberVirkning Virkning;
	doc2_docDel2AEgenskaber DokumentDelEgenskaberType;
	doc2_docDel2AEgenskaberVirkning Virkning;
	doc2_docDel1Arelation1 DokumentdelRelationType;
	doc2_docDel1Arelation1Virkning Virkning;
	doc2_docDel2Brelation1 DokumentdelRelationType;
	doc2_docDel2Brelation1Virkning Virkning;
	doc2_docDel2Brelation2 DokumentdelRelationType;
	doc2_docDel2Brelation2Virkning Virkning;

	doc2_extraRel1 DokumentdelRelationType;
	doc2_extraRel2 DokumentdelRelationType;
	doc2_extraRelVirkning1 Virkning;
	doc2_extraRelVirkning2 Virkning;


doc3_new_uuid uuid;
	doc3_registrering dokumentRegistreringType;
	doc3_virkEgenskaber1 Virkning;
	doc3_virkEgenskaber2 Virkning;
	doc3_virkAnsvarlig Virkning;
	doc3_virkBesvarelser1 Virkning;
	doc3_virkBesvarelser2 Virkning;
	doc3_virkFremdrift Virkning;
	doc3_dokumentEgenskab1 dokumentEgenskaberAttrType;
	doc3_dokumentEgenskab2 dokumentEgenskaberAttrType;
	doc3_dokumentFremdrift dokumentFremdriftTilsType;
	doc3_dokumentRelAnsvarlig dokumentRelationType;
	doc3_dokumentRelBesvarelser1 dokumentRelationType;
	doc3_dokumentRelBesvarelser2 dokumentRelationType;
	doc3_uuidAnsvarlig uuid :='85109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	doc3_uuidBesvarelser1 uuid :='56160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	--uuidBesvarelser2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	doc3_urnBesvarelser2 text:='urn:isbn:2451450529'::text;
	doc3_uuidRegistrering uuid :='84368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	doc3_docVariant1 DokumentVariantType;
	doc3_docVariant2 DokumentVariantType;
	doc3_docVariantEgenskaber1A DokumentVariantEgenskaberType;
	doc3_docVariantEgenskaber1AVirkning Virkning;
	doc3_docVariantEgenskaber1B DokumentVariantEgenskaberType;
	doc3_docVariantEgenskaber1BVirkning Virkning;
	doc3_docVariantEgenskaber2A DokumentVariantEgenskaberType;
	doc3_docVariantEgenskaber2AVirkning Virkning;	
	doc3_docDel1A DokumentDelType;
	doc3_docDel1B DokumentDelType;
	doc3_docDel2A DokumentDelType;
	doc3_docDel2B DokumentDelType;
	doc3_docDel1AEgenskaber DokumentDelEgenskaberType;
	doc3_docDel1A2Egenskaber DokumentDelEgenskaberType;
	doc3_docDel1AEgenskaberVirkning Virkning;
	doc3_docDel1A2EgenskaberVirkning Virkning;
	doc3_docDel1BEgenskaber DokumentDelEgenskaberType;
	doc3_docDel1BEgenskaberVirkning Virkning;
	doc3_docDel2AEgenskaber DokumentDelEgenskaberType;
	doc3_docDel2AEgenskaberVirkning Virkning;
	doc3_docDel1Arelation1 DokumentdelRelationType;
	doc3_docDel1Arelation1Virkning Virkning;
	doc3_docDel2Brelation1 DokumentdelRelationType;
	doc3_docDel2Brelation1Virkning Virkning;
	doc3_docDel2Brelation2 DokumentdelRelationType;
	doc3_docDel2Brelation2Virkning Virkning;

	doc3_extraRel1 DokumentdelRelationType;
	doc3_extraRel2 DokumentdelRelationType;
	doc3_extraRelVirkning1 Virkning;
	doc3_extraRelVirkning2 Virkning;


	search_result1 uuid[];
	search_result2 uuid[];
	search_result3 uuid[];
	search_result4 uuid[];
	search_result5 uuid[];
	search_result6 uuid[];
	search_result7 uuid[];
	search_result8 uuid[];
	search_result9 uuid[];

	expected_result1 uuid[];
	expected_result2 uuid[];
	expected_result3 uuid[];
	expected_result4 uuid[];
	expected_result5 uuid[];
	expected_result6 uuid[];
	expected_result7 uuid[];
	expected_result8 uuid[];
	expected_result9 uuid[];
	
	read_doc1 DokumentType;
	read_doc2 DokumentType;
	read_doc3 DokumentType;

	search_reg11 DokumentRegistreringType;
	search_reg12 DokumentRegistreringType;
	search_reg13 DokumentRegistreringType;
	search_reg14 DokumentRegistreringType;
	search_reg15 DokumentRegistreringType;
	search_reg16 DokumentRegistreringType;
	search_reg17 DokumentRegistreringType;
	search_reg18 DokumentRegistreringType;
	search_reg19 DokumentRegistreringType;


	search_result11 uuid[];
	search_result12 uuid[];
	search_result13 uuid[];
	search_result14 uuid[];
	search_result15 uuid[];
	search_result16 uuid[];
	search_result17 uuid[];
	search_result18 uuid[];
	search_result19 uuid[];

	expected_result11 uuid[];
	expected_result12 uuid[];
	expected_result13 uuid[];
	expected_result14 uuid[];
	expected_result15 uuid[];
	expected_result16 uuid[];
	expected_result17 uuid[];
	expected_result18 uuid[];
	expected_result19 uuid[];
	

	search_reg21 DokumentRegistreringType;
	search_reg22 DokumentRegistreringType;
	search_reg23 DokumentRegistreringType;
	search_reg24 DokumentRegistreringType;
	search_reg25 DokumentRegistreringType;
	search_reg26 DokumentRegistreringType;
	search_reg27 DokumentRegistreringType;
	search_reg28 DokumentRegistreringType;
	search_reg29 DokumentRegistreringType;
	search_reg20 DokumentRegistreringType;

	search_result20 uuid[];
	search_result21 uuid[];
	search_result22 uuid[];
	search_result23 uuid[];
	search_result24 uuid[];
	search_result25 uuid[];
	search_result26 uuid[];
	search_result27 uuid[];
	search_result28 uuid[];
	search_result29 uuid[];

	expected_result20 uuid[];
	expected_result21 uuid[];
	expected_result22 uuid[];
	expected_result23 uuid[];
	expected_result24 uuid[];
	expected_result25 uuid[];
	expected_result26 uuid[];
	expected_result27 uuid[];
	expected_result28 uuid[];
	expected_result29 uuid[];

	search_result30 uuid[];
	search_result31 uuid[];
	search_result32 uuid[];
	search_result33 uuid[];
	search_result34 uuid[];
	search_result35 uuid[];
	search_result36 uuid[];
	search_result37 uuid[];
	search_result38 uuid[];
	search_result39 uuid[];

	expected_result30 uuid[];
	expected_result31 uuid[];
	expected_result32 uuid[];
	expected_result33 uuid[];
	expected_result34 uuid[];
	expected_result35 uuid[];
	expected_result36 uuid[];
	expected_result37 uuid[];
	expected_result38 uuid[];
	expected_result39 uuid[];



BEGIN 

doc1_virkEgenskaber1 :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          'd71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;


doc1_virkEgenskaber2 :=	ROW (
	'[2014-05-12, 2015-05-12)' :: TSTZRANGE,
          'e71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;


doc1_virkAnsvarlig :=	ROW (
	'[2014-05-11, infinity)' :: TSTZRANGE,
          'f71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

doc1_virkBesvarelser1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          'c71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


doc1_virkBesvarelser2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          'b71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

doc1_virkFremdrift := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          'a71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx10'
) :: Virkning
;

doc1_dokumentRelAnsvarlig := ROW (
	'ansvarlig'::dokumentRelationKode,
		doc1_virkAnsvarlig,
	doc1_uuidAnsvarlig,
	null,
	'Aktr'
) :: dokumentRelationType
;


doc1_dokumentRelBesvarelser1 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc1_virkBesvarelser1,
	doc1_uuidBesvarelser1,
	null,
	null
) :: dokumentRelationType
;



doc1_dokumentRelBesvarelser2 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc1_virkBesvarelser2,
	null,
	doc1_urnBesvarelser2,
	null
) :: dokumentRelationType
;


doc1_dokumentFremdrift := ROW (
doc1_virkFremdrift,
'Underreview'
):: dokumentFremdriftTilsType
;


doc1_dokumentEgenskab1 := ROW (
'doc_brugervendtnoegle1',
'doc_beskrivelse1', 
'10-31-2015'::date,
'doc_kassationskode1', 
4, --major int
9, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel1',
'doc_dokumenttype1',
   doc1_virkEgenskaber1
) :: dokumentEgenskaberAttrType
;

doc1_dokumentEgenskab2 := ROW (
'doc_brugervendtnoegle2',
'doc_beskrivelse2', 
'09-20-2014'::date,
'doc_kassationskode2', 
5, --major int
10, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel2','doc_Offentlighedundtaget_Hjemmel2') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel2',
'doc_dokumenttype2',
   doc1_virkEgenskaber2
) :: dokumentEgenskaberAttrType
;




doc1_docDel2Brelation2Virkning :=	ROW (
	'(2014-02-24, 2015-10-01]' :: TSTZRANGE,
          '971cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;

doc1_docDel2Brelation1Virkning :=	ROW (
	'[2012-05-08, infinity)' :: TSTZRANGE,
          '871cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;


doc1_docDel1Arelation1Virkning :=	ROW (
	'[2015-05-09, infinity)' :: TSTZRANGE,
          '771cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx71'
          ) :: Virkning
;


doc1_docVariantEgenskaber2AVirkning :=	ROW (
	'[2014-07-12, infinity)' :: TSTZRANGE,
          '671cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx281'
          ) :: Virkning
;

doc1_docVariantEgenskaber1BVirkning :=	ROW (
	'[2015-01-01, infinity)' :: TSTZRANGE,
          '571cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx291'
          ) :: Virkning
;


doc1_docVariantEgenskaber1AVirkning :=	ROW (
	'[2013-02-27, 2015-01-01)' :: TSTZRANGE,
          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx191'
          ) :: Virkning
;

doc1_docDel1AEgenskaberVirkning :=	ROW (
	'[2014-03-30, infinity)' :: TSTZRANGE,
          '371cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;

doc1_docDel1A2EgenskaberVirkning :=	ROW (
	'[2010-01-20, 2014-03-20)' :: TSTZRANGE,
          '271cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx113'
          ) :: Virkning
;


doc1_docDel1BEgenskaberVirkning :=	ROW (
	'[2015-10-11, infinity)' :: TSTZRANGE,
          '171cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

doc1_docDel2AEgenskaberVirkning :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '901cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx13'
          ) :: Virkning
;

doc1_extraRelVirkning1 :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '120cc58a-3149-414a-9392-dcbcbbccddd9'::uuid,
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;
doc1_extraRelVirkning2 :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '280cc58a-3149-414a-9392-dcbcbbccddc0'::uuid,
          'Bruger',
          'NoteEx143'
          ) :: Virkning
;


doc1_docVariantEgenskaber1A:=
ROW(
true, --arkivering boolean, 
false, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
false, --produktion boolean,
 doc1_docVariantEgenskaber1AVirkning
)::DokumentVariantEgenskaberType;

doc1_docVariantEgenskaber1B:=
ROW(
false, --arkivering boolean, 
false, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
true, --produktion boolean,
 doc1_docVariantEgenskaber1BVirkning
)::DokumentVariantEgenskaberType;


doc1_docVariantEgenskaber2A:=
ROW(
false, --arkivering boolean, 
true, --delvisscannet boolean, 
false, --offentliggoerelse boolean, 
true, --produktion boolean,
 doc1_docVariantEgenskaber2AVirkning
)::DokumentVariantEgenskaberType;


doc1_docDel2Brelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_docDel2Brelation1Virkning,
  'a24a2dd4-415f-4104-b7a7-84607488c096'::uuid,
  null, --urn,
  'Bruger'
)::DokumentdelRelationType;


doc1_docDel2Brelation2:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_docDel2Brelation2Virkning,
  null,
  'urn:cpr 8883394', 
  'Bruger'
)::DokumentdelRelationType;


doc1_docDel1Arelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_docDel1Arelation1Virkning,
  'b24a2dd4-415f-4104-b7a7-84607488c091'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;

doc1_extraRel1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_extraRelVirkning1,
  '009a2dd4-415f-4104-b7a7-84607488c027'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;


doc1_extraRel2:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_extraRelVirkning2,
  '889a2dd4-415f-4104-b7a7-84607488c019'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;



doc1_docDel1AEgenskaber:= ROW(
1, --indeks int,
'del_indhold1', 
'del_lokation1', 
'del_mimetype1',
 doc1_docDel1AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc1_docDel1A2Egenskaber:=ROW(
2, --indeks int,
'del_indhold4', 
'del_lokation4', 
'del_mimetype4',
 doc1_docDel1A2EgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc1_docDel1BEgenskaber:= ROW(
98, --indeks int,
'del_indhold2', 
'del_lokation2', 
'del_mimetype2',
 doc1_docDel1BEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc1_docDel2AEgenskaber:= ROW(
8, --indeks int,
'del_indhold3', 
'del_lokation3', 
'del_mimetype3',
 doc1_docDel2AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;


doc1_docDel1A:=
ROW(
'doc_deltekst1A',
  ARRAY[doc1_docDel1AEgenskaber,doc1_docDel1A2Egenskaber],
  ARRAY[doc1_docDel1Arelation1]
)::DokumentDelType;

doc1_docDel1B:=
ROW(
'doc_deltekst1B',
  ARRAY[doc1_docDel1BEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc1_docDel2A:=
ROW(
'doc_deltekst2A',
  ARRAY[doc1_docDel2AEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc1_docDel2B:=
ROW(
'doc_deltekst2B',
  null,--ARRAY[]::DokumentDelEgenskaberType[],
  ARRAY[doc1_docDel2Brelation1,doc1_docDel2Brelation2]
)::DokumentDelType;


doc1_docVariant1 := ROW (
	'doc_varianttekst2_1',
  	ARRAY[doc1_docVariantEgenskaber1B,doc1_docVariantEgenskaber1A],
  	ARRAY[doc1_docDel1A,
  	ROW(
  		'doc_deltekst1B',
  		ARRAY[doc1_docDel1BEgenskaber],
  		ARRAY[doc1_extraRel1,doc1_extraRel2]
  		)::DokumentDelType
  	]
)::DokumentVariantType;


doc1_docVariant2 := ROW (
	'doc_varianttekst2',
  ARRAY[doc1_docVariantEgenskaber2A],
  ARRAY[doc1_docDel2A,doc1_docDel2B]
)::DokumentVariantType;

doc1_registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	doc1_uuidRegistrering,
	'Test Note 85') :: RegistreringBase
	,
ARRAY[doc1_dokumentFremdrift]::dokumentFremdriftTilsType[],
ARRAY[doc1_dokumentEgenskab1,doc1_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
ARRAY[doc1_dokumentRelBesvarelser1,doc1_dokumentRelAnsvarlig,doc1_dokumentRelBesvarelser2],
ARRAY[doc1_docVariant1,doc1_docVariant2]
) :: dokumentRegistreringType
;


doc1_new_uuid := as_create_or_import_dokument(doc1_registrering);



/***************************************************/
/*
firstResult int,--TOOD ??
	klasse_uuid uuid,
	registreringObj KlasseRegistreringType,
	virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
*/


search_result1 :=as_search_dokument(
	null,--TOOD ??
	null,
	ROW(
		null, --registrering
		null, --fremdrift
		ARRAY[
		ROW(
			NULL--'doc_brugervendtnoegle1',
			,NULL--'doc_beskrivelse1', 
			,'10-31-2015'::date
			,NULL --'doc_kassationskode1', 
			,NULL --4, --major int
			,NULL --9, --minor int
			,NULL --ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
			,NULL --'doc_titel1',
			,NULL --'doc_dokumenttype1',
	   		,null
		) :: dokumentEgenskaberAttrType
		], --egenskaber
		null, --relationer
		null --varianter
	)::dokumentRegistreringType
	,null
	);

expected_result1=array[doc1_new_uuid]::uuid[];

RETURN NEXT is(search_result1, expected_result1 ,'test dokument search.#1');


/***************************************************/




search_result2 :=as_search_dokument(
	null,--TOOD ??
	null,
	ROW(
		null, --registrering
		null, --fremdrift
		ARRAY[
		ROW(
			NULL--'doc_brugervendtnoegle1',
			,NULL--'doc_beskrivelse1', 
			,'10-30-2015'::date
			,NULL --'doc_kassationskode1', 
			,NULL --4, --major int
			,NULL --9, --minor int
			,NULL --ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
			,NULL --'doc_titel1',
			,NULL --'doc_dokumenttype1',
	   		,null
		) :: dokumentEgenskaberAttrType
		], --egenskaber
		null, --relationer
		null --varianter
	)::dokumentRegistreringType
	,null
	);

expected_result2=array[]::uuid[];

RETURN NEXT is(search_result2, expected_result2 ,'test dokument search.#2');

/***************************************************/


search_result3 :=as_search_dokument(
	null,--TOOD ??
	null,
	ROW(
		null, --registrering
		null, --fremdrift
		ARRAY[
		ROW(
			NULL--'doc_brugervendtnoegle1',
			,NULL--'doc_beskrivelse1', 
			,NULL
			,NULL --'doc_kassationskode1', 
			,4 --NULL --4, --major int
			,NULL --9, --minor int
			,NULL --ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
			,NULL --'doc_titel1',
			,NULL --'doc_dokumenttype1',
	   		,null
		) :: dokumentEgenskaberAttrType
		], --egenskaber
		null, --relationer
		null --varianter
	)::dokumentRegistreringType
	,null
	);

expected_result3=array[doc1_new_uuid]::uuid[];

RETURN NEXT is(search_result3, expected_result3 ,'test dokument search.#3');

/***************************************************/


search_result4 :=as_search_dokument(
	null,--TOOD ??
	null,
	ROW(
		null, --registrering
		null, --fremdrift
		ARRAY[
		ROW(
			NULL--'doc_brugervendtnoegle1',
			,NULL--'doc_beskrivelse1', 
			,NULL
			,NULL --'doc_kassationskode1', 
			,6 --NULL --4, --major int
			,NULL --9, --minor int
			,NULL --ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
			,NULL --'doc_titel1',
			,NULL --'doc_dokumenttype1',
	   		,null
		) :: dokumentEgenskaberAttrType
		], --egenskaber
		null, --relationer
		null --varianter
	)::dokumentRegistreringType
	,null
	);

expected_result4=array[]::uuid[];

RETURN NEXT is(search_result4, expected_result4 ,'test dokument search.#4');


/***************************************************/


search_result5 :=as_search_dokument(
	null,--TOOD ??
	null,
	ROW(
		null, --registrering
		null, --fremdrift
		ARRAY[
		ROW(
			NULL--'doc_brugervendtnoegle1',
			,NULL--'doc_beskrivelse1', 
			,NULL
			,NULL --'doc_kassationskode1', 
			,NULL  --4, --major int
			,NULL --9, --minor int
			,ROW('doc_Offentlighedundtaget_AlternativTitel3',null) --ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
			,NULL --'doc_titel1',
			,NULL --'doc_dokumenttype1',
	   		,null
		) :: dokumentEgenskaberAttrType
		], --egenskaber
		null, --relationer
		null --varianter
	)::dokumentRegistreringType
	,null
	);

expected_result5=array[]::uuid[];

RETURN NEXT is(search_result5, expected_result5 ,'test dokument search.#5');


/***************************************************/


search_result6 :=as_search_dokument(
	null,--TOOD ??
	null,
	ROW(
		null, --registrering
		null, --fremdrift
		ARRAY[
		ROW(
			NULL--'doc_brugervendtnoegle1',
			,NULL--'doc_beskrivelse1', 
			,NULL
			,NULL --'doc_kassationskode1', 
			,NULL  --4, --major int
			,NULL --9, --minor int
			,ROW('doc_Offentlighedundtaget_AlternativTitel2',null) --ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
			,NULL --'doc_titel1',
			,NULL --'doc_dokumenttype1',
	   		,null
		) :: dokumentEgenskaberAttrType
		], --egenskaber
		null, --relationer
		null --varianter
	)::dokumentRegistreringType
	,null
	);

expected_result6=array[doc1_new_uuid]::uuid[];

RETURN NEXT is(search_result6, expected_result6 ,'test dokument search.#6');

/***************************************************/


search_result7 :=as_search_dokument(
	null,--TOOD ??
	null,
	ROW(
		null, --registrering
		null, --fremdrift
		ARRAY[
		ROW(
			NULL--'doc_brugervendtnoegle1',
			,NULL--'doc_beskrivelse1', 
			,NULL
			,NULL --'doc_kassationskode1', 
			,NULL  --4, --major int
			,NULL --9, --minor int
			,ROW('doc_Offentlighedundtaget_AlternativTitel2','doc_Offentlighedundtaget_Hjemmel1') --ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
			,NULL --'doc_titel1',
			,NULL --'doc_dokumenttype1',
	   		,null
		) :: dokumentEgenskaberAttrType
		], --egenskaber
		null, --relationer
		null --varianter
	)::dokumentRegistreringType
	,null
	);

expected_result7=array[]::uuid[];

RETURN NEXT is(search_result7, expected_result7 ,'test dokument search.#7');


/***************************************************/


search_result8 :=as_search_dokument(
	null,--TOOD ??
	null,
	ROW(
		null, --registrering
		null, --fremdrift
		ARRAY[
		ROW(
			NULL--'doc_brugervendtnoegle1',
			,NULL--'doc_beskrivelse1', 
			,NULL
			,NULL --'doc_kassationskode1', 
			,NULL  --4, --major int
			,NULL --9, --minor int
			,ROW(null,'doc_Offentlighedundtaget_Hjemmel2') --ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
			,NULL --'doc_titel1',
			,NULL --'doc_dokumenttype1',
	   		,null
		) :: dokumentEgenskaberAttrType
		], --egenskaber
		null, --relationer
		null --varianter
	)::dokumentRegistreringType
	,null
	);

expected_result8=array[doc1_new_uuid]::uuid[];

RETURN NEXT is(search_result8, expected_result8 ,'test dokument search.#8');



/***************************************************/


search_result9 :=as_search_dokument(
	null,--TOOD ??
	null,
	ROW(
		null, --registrering
		null, --fremdrift
		ARRAY[
		ROW(
			NULL--'doc_brugervendtnoegle1',
			,NULL--'doc_beskrivelse1', 
			,NULL
			,NULL --'doc_kassationskode1', 
			,NULL  --4, --major int
			,NULL --9, --minor int
			,ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType --offentlighedundtagettype,
			,NULL --'doc_titel1',
			,NULL --'doc_dokumenttype1',
	   		,null
		) :: dokumentEgenskaberAttrType
		], --egenskaber
		null, --relationer
		null --varianter
	)::dokumentRegistreringType
	,null
	);

expected_result9=array[doc1_new_uuid]::uuid[];

RETURN NEXT is(search_result9, expected_result9 ,'test dokument search.#9');



/***************************************************/


doc2_virkEgenskaber1 :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          'd71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;


doc2_virkEgenskaber2 :=	ROW (
	'[2014-05-12, 2015-05-12)' :: TSTZRANGE,
          'e71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;


doc2_virkAnsvarlig :=	ROW (
	'[2013-05-11, infinity)' :: TSTZRANGE,
          'f71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

doc2_virkBesvarelser1 :=	ROW (
	'[2014-05-10, infinity)' :: TSTZRANGE,
          'c71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


doc2_virkBesvarelser2 :=	ROW (
	'[2014-05-10, 2016-05-10)' :: TSTZRANGE,
          'b71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

doc2_virkFremdrift := ROW (
	'[2014-05-18, infinity)' :: TSTZRANGE,
          'a71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx10'
) :: Virkning
;

doc2_dokumentRelAnsvarlig := ROW (
	'ansvarlig'::dokumentRelationKode,
		doc2_virkAnsvarlig,
	doc2_uuidAnsvarlig,
	null,
	'Aktr'
) :: dokumentRelationType
;


doc2_dokumentRelBesvarelser1 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc2_virkBesvarelser1,
	doc2_uuidBesvarelser1,
	null,
	null
) :: dokumentRelationType
;



doc2_dokumentRelBesvarelser2 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc2_virkBesvarelser2,
	null,
	doc2_urnBesvarelser2,
	null
) :: dokumentRelationType
;


doc2_dokumentFremdrift := ROW (
doc2_virkFremdrift,
'Underreview'
):: dokumentFremdriftTilsType
;


doc2_dokumentEgenskab1 := ROW (
'doc2_brugervendtnoegle1',
'doc_beskrivelse1', 
'09-30-2015'::date,
'doc2_kassationskode1', 
3, --major int
34, --minor int
ROW('doc2_Offentlighedundtaget_AlternativTitel1','doc2_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc2_titel1',
'doc2_dokumenttype1',
   doc2_virkEgenskaber1
) :: dokumentEgenskaberAttrType
;

doc2_dokumentEgenskab2 := ROW (
'doc2_brugervendtnoegle2',
'doc_beskrivelse1', 
'08-20-2014'::date,
'doc2_kassationskode2', 
8, --major int
12, --minor int
ROW('doc2_Offentlighedundtaget_AlternativTitel2','doc2_Offentlighedundtaget_Hjemmel2') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc2_titel2',
'doc2_dokumenttype2',
   doc2_virkEgenskaber2
) :: dokumentEgenskaberAttrType
;




doc2_docDel2Brelation2Virkning :=	ROW (
	'(2014-02-24, 2015-10-01]' :: TSTZRANGE,
          '971cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;

doc2_docDel2Brelation1Virkning :=	ROW (
	'[2012-05-08, infinity)' :: TSTZRANGE,
          '871cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;


doc2_docDel1Arelation1Virkning :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          '771cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx71'
          ) :: Virkning
;


doc2_docVariantEgenskaber2AVirkning :=	ROW (
	'[2014-07-12, infinity)' :: TSTZRANGE,
          '671cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx281'
          ) :: Virkning
;

doc2_docVariantEgenskaber1BVirkning :=	ROW (
	'[2015-01-01, infinity)' :: TSTZRANGE,
          '571cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx291'
          ) :: Virkning
;


doc2_docVariantEgenskaber1AVirkning :=	ROW (
	'[2010-02-27, 2015-01-01)' :: TSTZRANGE,
          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx191'
          ) :: Virkning
;

doc2_docDel1AEgenskaberVirkning :=	ROW (
	'[2014-03-28, infinity)' :: TSTZRANGE,
          '371cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;

doc2_docDel1A2EgenskaberVirkning :=	ROW (
	'[2010-01-20, 2014-03-20)' :: TSTZRANGE,
          '271cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx113'
          ) :: Virkning
;


doc2_docDel1BEgenskaberVirkning :=	ROW (
	'[2015-10-11, infinity)' :: TSTZRANGE,
          '171cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

doc2_docDel2AEgenskaberVirkning :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '901cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx13'
          ) :: Virkning
;

doc2_extraRelVirkning1 :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '120cc58a-3149-414a-9392-dcbcbbccddd9'::uuid,
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;
doc2_extraRelVirkning2 :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '280cc58a-3149-414a-9392-dcbcbbccddc0'::uuid,
          'Bruger',
          'NoteEx143'
          ) :: Virkning
;


doc2_docVariantEgenskaber1A:=
ROW(
false, --arkivering boolean, 
true, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
false, --produktion boolean,
 doc2_docVariantEgenskaber1AVirkning
)::DokumentVariantEgenskaberType;

doc2_docVariantEgenskaber1B:=
ROW(
false, --arkivering boolean, 
true, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
true, --produktion boolean,
 doc2_docVariantEgenskaber1BVirkning
)::DokumentVariantEgenskaberType;


doc2_docVariantEgenskaber2A:=
ROW(
true, --arkivering boolean, 
true, --delvisscannet boolean, 
false, --offentliggoerelse boolean, 
false, --produktion boolean,
 doc2_docVariantEgenskaber2AVirkning
)::DokumentVariantEgenskaberType;


doc2_docDel2Brelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc2_docDel2Brelation1Virkning,
  '904a2dd4-415f-4104-b7a7-84607488c096'::uuid,
  null, --urn,
  'Bruger'
)::DokumentdelRelationType;


doc2_docDel2Brelation2:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc2_docDel2Brelation2Virkning,
  null,
  'urn:cpr 9900000', 
  'Bruger'
)::DokumentdelRelationType;


doc2_docDel1Arelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc2_docDel1Arelation1Virkning,
  '100a2dd4-415f-4104-b7a7-84607488c091'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;

doc2_extraRel1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc2_extraRelVirkning1,
  '200a2dd4-415f-4104-b7a7-84607488c027'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;


doc2_extraRel2:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc2_extraRelVirkning2,
  '300a2dd4-415f-4104-b7a7-84607488c019'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;



doc2_docDel1AEgenskaber:= ROW(
1, --indeks int,
'del_indhold1_doc2', 
'del_lokation1_doc2', 
'del_mimetype1_doc2',
 doc2_docDel1AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc2_docDel1A2Egenskaber:=ROW(
2, --indeks int,
'del_indhold4_doc2', 
'del_lokation4_doc2', 
'del_mimetype1',
 doc2_docDel1A2EgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc2_docDel1BEgenskaber:= ROW(
98, --indeks int,
'del_indhold2_doc2', 
'del_lokation2_doc2', 
'del_mimetype2_doc2',
 doc2_docDel1BEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc2_docDel2AEgenskaber:= ROW(
8, --indeks int,
'del_indhold3_doc2', 
'del_lokation3_doc2', 
'del_mimetype3_doc2',
 doc2_docDel2AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;


doc2_docDel1A:=
ROW(
'doc2_deltekst1A_doc2',
  ARRAY[doc2_docDel1AEgenskaber,doc2_docDel1A2Egenskaber],
  ARRAY[doc2_docDel1Arelation1]
)::DokumentDelType;

doc2_docDel1B:=
ROW(
'doc2_deltekst1B_doc2',
  ARRAY[doc2_docDel1BEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc2_docDel2A:=
ROW(
'doc2_deltekst2A_doc2',
  ARRAY[doc2_docDel2AEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc2_docDel2B:=
ROW(
'doc2_deltekst2B_doc2',
  null,--ARRAY[]::DokumentDelEgenskaberType[],
  ARRAY[doc2_docDel2Brelation1,doc2_docDel2Brelation2]
)::DokumentDelType;


doc2_docVariant1 := ROW (
	'doc2_varianttekst2_1',
  	ARRAY[doc2_docVariantEgenskaber1B,doc2_docVariantEgenskaber1A],
  	ARRAY[doc2_docDel1A,
  	ROW(
  		'doc2_deltekst1B_doc2',
  		ARRAY[doc2_docDel1BEgenskaber],
  		ARRAY[doc2_extraRel1,doc2_extraRel2]
  		)::DokumentDelType
  	]
)::DokumentVariantType;


doc2_docVariant2 := ROW (
	'doc2_varianttekst2_doc2',
  ARRAY[doc2_docVariantEgenskaber2A],
  ARRAY[doc2_docDel2A,doc2_docDel2B]
)::DokumentVariantType;

doc2_registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	doc2_uuidRegistrering,
	'Test Note 100') :: RegistreringBase
	,
ARRAY[doc2_dokumentFremdrift]::dokumentFremdriftTilsType[],
ARRAY[doc2_dokumentEgenskab1,doc2_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
ARRAY[doc2_dokumentRelBesvarelser1,doc2_dokumentRelAnsvarlig,doc2_dokumentRelBesvarelser2],
ARRAY[doc2_docVariant1,doc2_docVariant2]
) :: dokumentRegistreringType
;


doc2_new_uuid := as_create_or_import_dokument(doc2_registrering);

/***************************************************/

doc3_virkEgenskaber1 :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          'd71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;


doc3_virkEgenskaber2 :=	ROW (
	'[2013-05-12, 2015-05-12)' :: TSTZRANGE,
          'e71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;


doc3_virkAnsvarlig :=	ROW (
	'[2013-05-11, infinity)' :: TSTZRANGE,
          'f71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

doc3_virkBesvarelser1 :=	ROW (
	'[2013-05-10, infinity)' :: TSTZRANGE,
          'c71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


doc3_virkBesvarelser2 :=	ROW (
	'[2013-05-10, 2016-05-10)' :: TSTZRANGE,
          'b71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

doc3_virkFremdrift := ROW (
	'[2013-05-18, infinity)' :: TSTZRANGE,
          'a71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx10'
) :: Virkning
;

doc3_dokumentRelAnsvarlig := ROW (
	'ansvarlig'::dokumentRelationKode,
		doc3_virkAnsvarlig,
	doc3_uuidAnsvarlig,
	null,
	'Aktr'
) :: dokumentRelationType
;


doc3_dokumentRelBesvarelser1 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc3_virkBesvarelser1,
	doc3_uuidBesvarelser1,
	null,
	null
) :: dokumentRelationType
;



doc3_dokumentRelBesvarelser2 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc3_virkBesvarelser2,
	null,
	doc3_urnBesvarelser2,
	null
) :: dokumentRelationType
;


doc3_dokumentFremdrift := ROW (
doc3_virkFremdrift,
'Underreview'
):: dokumentFremdriftTilsType
;


doc3_dokumentEgenskab1 := ROW (
'doc_brugervendtnoegle1_doc3',
'doc_beskrivelse1', 
'10-31-2015'::date,
'doc_kassationskode1_doc3', 
4, --major int
9, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel1',
'doc_dokumenttype1',
   doc3_virkEgenskaber1
) :: dokumentEgenskaberAttrType
;

doc3_dokumentEgenskab2 := ROW (
'doc_brugervendtnoegle2_doc3',
'doc_beskrivelse1', 
'09-20-2014'::date,
'doc_kassationskode2_doc3', 
5, --major int
10, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel2','doc_Offentlighedundtaget_Hjemmel2') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel2',
'doc_dokumenttype2',
   doc3_virkEgenskaber2
) :: dokumentEgenskaberAttrType
;




doc3_docDel2Brelation2Virkning :=	ROW (
	'(2014-02-24, 2015-10-01]' :: TSTZRANGE,
          '800cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;

doc3_docDel2Brelation1Virkning :=	ROW (
	'[2012-05-08, infinity)' :: TSTZRANGE,
          '810cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;


doc3_docDel1Arelation1Virkning :=	ROW (
	'[2010-04-10, infinity)' :: TSTZRANGE,
          '820cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx71'
          ) :: Virkning
;


doc3_docVariantEgenskaber2AVirkning :=	ROW (
	'[2014-07-12, infinity)' :: TSTZRANGE,
          '840cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx281'
          ) :: Virkning
;

doc3_docVariantEgenskaber1BVirkning :=	ROW (
	'[2015-01-01, infinity)' :: TSTZRANGE,
          '830cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx291'
          ) :: Virkning
;


doc3_docVariantEgenskaber1AVirkning :=	ROW (
	'[2013-02-27, 2015-01-01)' :: TSTZRANGE,
          '850cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx191'
          ) :: Virkning
;

doc3_docDel1AEgenskaberVirkning :=	ROW (
	'[2014-03-30, infinity)' :: TSTZRANGE,
          '860cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;

doc3_docDel1A2EgenskaberVirkning :=	ROW (
	'[2010-01-20, 2014-03-20)' :: TSTZRANGE,
          '870cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx113'
          ) :: Virkning
;


doc3_docDel1BEgenskaberVirkning :=	ROW (
	'[2015-10-11, infinity)' :: TSTZRANGE,
          '880cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

doc3_docDel2AEgenskaberVirkning :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '890cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx13'
          ) :: Virkning
;

doc3_extraRelVirkning1 :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '900cc58a-3149-414a-9392-dcbcbbccddd9'::uuid,
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;
doc3_extraRelVirkning2 :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '910cc58a-3149-414a-9392-dcbcbbccddc0'::uuid,
          'Bruger',
          'NoteEx143'
          ) :: Virkning
;


doc3_docVariantEgenskaber1A:=
ROW(
true, --arkivering boolean, 
false, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
false, --produktion boolean,
 doc3_docVariantEgenskaber1AVirkning
)::DokumentVariantEgenskaberType;

doc3_docVariantEgenskaber1B:=
ROW(
false, --arkivering boolean, 
false, --delvisscannet boolean, 
false, --offentliggoerelse boolean, 
false, --produktion boolean,
 doc3_docVariantEgenskaber1BVirkning
)::DokumentVariantEgenskaberType;


doc3_docVariantEgenskaber2A:=
ROW(
false, --arkivering boolean, 
false, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
true, --produktion boolean,
 doc3_docVariantEgenskaber2AVirkning
)::DokumentVariantEgenskaberType;


doc3_docDel2Brelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc3_docDel2Brelation1Virkning,
  '700a2dd4-415f-4104-b7a7-84607488c096'::uuid,
  null, --urn,
  'Bruger'
)::DokumentdelRelationType;


doc3_docDel2Brelation2:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc3_docDel2Brelation2Virkning,
  null,
  'urn:cpr 7000000', 
  'Bruger'
)::DokumentdelRelationType;


doc3_docDel1Arelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc3_docDel1Arelation1Virkning,
  '800a2dd4-415f-4104-b7a7-84607488c091'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;

doc3_extraRel1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc3_extraRelVirkning1,
  '720a2dd4-415f-4104-b7a7-84607488c027'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;


doc3_extraRel2:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc3_extraRelVirkning2,
  '730a2dd4-415f-4104-b7a7-84607488c019'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;



doc3_docDel1AEgenskaber:= ROW(
1, --indeks int,
'del_indhold1_doc3', 
'del_lokation1_doc3', 
'del_mimetype1',
 doc3_docDel1AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc3_docDel1A2Egenskaber:=ROW(
2, --indeks int,
'del_indhold4_doc3', 
'del_lokation4_doc3', 
'del_mimetype4_doc3',
 doc3_docDel1A2EgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc3_docDel1BEgenskaber:= ROW(
98, --indeks int,
'del_indhold2_doc3', 
'del_lokation2_doc3', 
'del_mimetype2_doc3',
 doc3_docDel1BEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc3_docDel2AEgenskaber:= ROW(
8, --indeks int,
'del_indhold3_doc3', 
'del_lokation3_doc3', 
'del_mimetype3_doc3',
 doc3_docDel2AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;


doc3_docDel1A:=
ROW(
'doc_deltekst1A',
  ARRAY[doc3_docDel1AEgenskaber,doc3_docDel1A2Egenskaber],
  ARRAY[doc3_docDel1Arelation1]
)::DokumentDelType;

doc3_docDel1B:=
ROW(
'doc_deltekst1B_doc3',
  ARRAY[doc3_docDel1BEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc3_docDel2A:=
ROW(
'doc_deltekst2A',
  ARRAY[doc3_docDel2AEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc3_docDel2B:=
ROW(
'doc_deltekst2B_doc3',
  null,--ARRAY[]::DokumentDelEgenskaberType[],
  ARRAY[doc3_docDel2Brelation1,doc3_docDel2Brelation2]
)::DokumentDelType;


doc3_docVariant1 := ROW (
	'doc_varianttekst2_1',
  	ARRAY[doc3_docVariantEgenskaber1B,doc3_docVariantEgenskaber1A],
  	ARRAY[doc3_docDel1A,
  	ROW(
  		'doc_deltekst1B',
  		ARRAY[doc3_docDel1BEgenskaber],
  		ARRAY[doc3_extraRel1,doc3_extraRel2]
  		)::DokumentDelType
  	]
)::DokumentVariantType;


doc3_docVariant2 := ROW (
	'doc_varianttekst2',
  ARRAY[doc3_docVariantEgenskaber2A],
  ARRAY[doc3_docDel2A,doc3_docDel2B]
)::DokumentVariantType;

doc3_registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	doc3_uuidRegistrering,
	'Test Note 500') :: RegistreringBase
	,
ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

doc3_new_uuid := as_create_or_import_dokument(doc3_registrering);
/***************************************************/
read_doc1 := as_read_dokument(doc1_new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'read_doc1:%',to_json(read_doc1);

read_doc2 := as_read_dokument(doc2_new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'read_doc2:%',to_json(read_doc2);


read_doc3 := as_read_dokument(doc3_new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'read_doc3:%',to_json(read_doc3);

/***************************************************/


search_reg11:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,ARRAY[
	 ROW (
		 null --'doc2_brugervendtnoegle1',
		,'doc_beskrivelse1'
		,null --'09-30-2015'::date,
		,null --'doc2_kassationskode1', 
		,null --3, --major int
		,null --minor int
		,null --ROW('doc2_Offentlighedundtaget_AlternativTitel1','doc2_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
		,null --'doc2_titel1',
		,null --'doc2_dokumenttype1',
		,null--   doc2_virkEgenskaber1
	) :: dokumentEgenskaberAttrType
	]::dokumentEgenskaberAttrType[]
	  -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		'doc_varianttekst2_1'
		,null --egenskaber
		,null --dele
		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result11:=ARRAY[doc1_new_uuid,doc3_new_uuid]::uuid[];

search_result11:=as_search_dokument(null,null,search_reg11,null);


RETURN NEXT ok(expected_result11 @> search_result11 and search_result11 @>expected_result11 and coalesce(array_length(search_result11,1),0)=coalesce(array_length(expected_result11,1),0), 'search dokument #11.');

/***************************************************/



search_reg12:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,ARRAY[
	 ROW (
		 null --'doc2_brugervendtnoegle1',
		,null --'doc_beskrivelse1'
		,null --'09-30-2015'::date,
		,'doc_kassationskode1'
		,null --3, --major int
		,null --minor int
		,null --ROW('doc2_Offentlighedundtaget_AlternativTitel1','doc2_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
		,null --'doc2_titel1',
		,null --'doc2_dokumenttype1',
		,null--   doc2_virkEgenskaber1
	) :: dokumentEgenskaberAttrType
	]::dokumentEgenskaberAttrType[]
	  -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		'doc_varianttekst2_1'
		,null --egenskaber
		,null --dele
		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result12:=ARRAY[doc1_new_uuid]::uuid[];

search_result12:=as_search_dokument(null,null,search_reg12,null);


RETURN NEXT ok(expected_result12 @> search_result12 and search_result12 @>expected_result12 and coalesce(array_length(search_result12,1),0)=coalesce(array_length(expected_result12,1),0), 'search dokument #12.');

/***************************************************/


search_reg13:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,null -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		'doc_varianttekst2_1'
		,ARRAY [ROW(
				false, --arkivering boolean, 
				null, --delvisscannet boolean, 
				null, --offentliggoerelse boolean, 
				null, --produktion boolean,
				null
				)::DokumentVariantEgenskaberType
			,
			ROW(
				null, --arkivering boolean, 
				null, --delvisscannet boolean, 
				false, --offentliggoerelse boolean, 
				null, --produktion boolean,
				null
				)::DokumentVariantEgenskaberType
		]::DokumentVariantEgenskaberType[]
		,null --dele
		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result13:=ARRAY[doc3_new_uuid]::uuid[];

search_result13:=as_search_dokument(null,null,search_reg13,null);


RETURN NEXT ok(expected_result13 @> search_result13 and search_result13 @>expected_result13 and coalesce(array_length(search_result13,1),0)=coalesce(array_length(expected_result13,1),0), 'search dokument #13.');

/***************************************************/


search_reg14:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,null -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		'doc%'
		,ARRAY [ROW(
				null, --arkivering boolean, 
				true, --delvisscannet boolean, 
				null, --offentliggoerelse boolean, 
				null, --produktion boolean,
				null
				)::DokumentVariantEgenskaberType
			
		]::DokumentVariantEgenskaberType[]
		,null --dele
		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result14:=ARRAY[doc1_new_uuid,doc2_new_uuid]::uuid[];

search_result14:=as_search_dokument(null,null,search_reg14,null);


RETURN NEXT ok(expected_result14 @> search_result14 and search_result14 @>expected_result14 and coalesce(array_length(search_result14,1),0)=coalesce(array_length(expected_result14,1),0), 'search dokument #14.');

/***************************************************/


search_reg15:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,null -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		'doc%'
		,ARRAY [ROW(
				null, --arkivering boolean, 
				true, --delvisscannet boolean, 
				null, --offentliggoerelse boolean, 
				null, --produktion boolean,
				ROW (
			'[2010-03-27, 2010-04-01)' :: TSTZRANGE
          	,null --'471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          	,null --'Bruger',
          	,null --'NoteEx191'
          	) :: Virkning
				)::DokumentVariantEgenskaberType
			
		]::DokumentVariantEgenskaberType[]
		,null --dele
		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result15:=ARRAY[doc2_new_uuid]::uuid[];

search_result15:=as_search_dokument(null,null,search_reg15,null);


RETURN NEXT ok(expected_result15 @> search_result15 and search_result15 @>expected_result15 and coalesce(array_length(search_result15,1),0)=coalesce(array_length(expected_result15,1),0), 'search dokument #15.');

/***************************************************/

search_reg16:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,null -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		'doc_varianttekst2_1'
		,ARRAY [ROW(
				null, --arkivering boolean, 
				false, --delvisscannet boolean, 
				null, --offentliggoerelse boolean, 
				null, --produktion boolean,
				null --virkning
				)::DokumentVariantEgenskaberType
			
		]::DokumentVariantEgenskaberType[]
		,ARRAY[
		ROW(
			'doc_deltekst1A'
			,ARRAY[
			 ROW(
				null --1, --indeks int,
				,null --'del_indhold1', 
				, null --'del_lokation1', 
				,'del_mimetype1'
				,null
				)::DokumentDelEgenskaberType
			 ,
			  ROW(
				null --1, --indeks int,
				,'del_indhold1_doc3' --'del_indhold1', 
				, null --'del_lokation1', 
				,null
				,null
				)::DokumentDelEgenskaberType
			]::DokumentDelEgenskaberType[]   --egenskaber
			,null --relationer
			)::DokumentDelType
		]::DokumentDelType[]

		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result16:=ARRAY[doc3_new_uuid]::uuid[];

search_result16:=as_search_dokument(null,null,search_reg16,null);


RETURN NEXT ok(expected_result16 @> search_result16 and search_result16 @>expected_result16 and coalesce(array_length(search_result16,1),0)=coalesce(array_length(expected_result16,1),0), 'search dokument #16.');

/***************************************************/


search_reg17:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,null -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		null --varianttekst
		,null --variantegenskaber
		,ARRAY[
		ROW(
			null --deltekst
			,ARRAY[
			 ROW(
				null --1, --indeks int,
				,null --'del_indhold1', 
				, null --'del_lokation1', 
				,'del_mimetype1'
					,ROW (
					'[2011-01-20, 2011-01-25]' :: TSTZRANGE,
	         		null,
	          		null,
	          		null
	          		) :: Virkning
				)::DokumentDelEgenskaberType
			]::DokumentDelEgenskaberType[]   --egenskaber
			,null --del relationer
			)::DokumentDelType
		]::DokumentDelType[]

		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result17:=ARRAY[doc2_new_uuid]::uuid[];

search_result17:=as_search_dokument(null,null,search_reg17,null);


RETURN NEXT ok(expected_result17 @> search_result17 and search_result17 @>expected_result17 and coalesce(array_length(search_result17,1),0)=coalesce(array_length(expected_result17,1),0), 'search dokument #17.');

/***************************************************/

search_reg18:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,null -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		null --varianttekst
		,null --variantegenskaber
		,ARRAY[
		ROW(
			null --deltekst
			,ARRAY[
			 ROW(
				null --1, --indeks int,
				,null --'del_indhold1', 
				, null --'del_lokation1', 
				,'del_mimetype1'
					,ROW (
					'[2014-05-20, 2014-05-25]' :: TSTZRANGE,
	         		null,
	          		null,
	          		null
	          		) :: Virkning
				)::DokumentDelEgenskaberType
			]::DokumentDelEgenskaberType[]   --egenskaber
			,null --del relationer
			)::DokumentDelType
		]::DokumentDelType[]

		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result18:=ARRAY[doc1_new_uuid,doc3_new_uuid]::uuid[];

search_result18:=as_search_dokument(null,null,search_reg18,null);


RETURN NEXT ok(expected_result18 @> search_result18 and search_result18 @>expected_result18 and coalesce(array_length(search_result18,1),0)=coalesce(array_length(expected_result18,1),0), 'search dokument #18.');

/***************************************************/

search_reg19
:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,null -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		null --varianttekst
		,null --variantegenskaber
		,ARRAY[
		ROW(
			null --deltekst
			,ARRAY[
			 ROW(
				null --1, --indeks int,
				,null --'del_indhold1', 
				, null --'del_lokation1', 
				,'del_mimetype1'
					,ROW (
					'[2014-03-25, 2014-03-26)' :: TSTZRANGE,
	         		null,
	          		null,
	          		null
	          		) :: Virkning
				)::DokumentDelEgenskaberType
			]::DokumentDelEgenskaberType[]   --egenskaber
			,null --del relationer
			)::DokumentDelType
		]::DokumentDelType[]

		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result19
:=ARRAY[]::uuid[];

search_result19
:=as_search_dokument(null,null,search_reg19
,null);


RETURN NEXT ok(expected_result19 @> search_result19 and search_result19 @>expected_result19 and coalesce(array_length(search_result19 ,1),0)=coalesce(array_length(expected_result19,1),0), 'search dokument #19.');

/***************************************************/

search_reg20
:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,null -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		null  --varianttekst
		,null --variantegenskaber
		,ARRAY[
		ROW(
			null --deltekst
			,ARRAY[
			 ROW(
				null --1, --indeks int,
				,null --'del_indhold1', 
				, null --'del_lokation1', 
				,'del_mimetype1'
				,null	
				)::DokumentDelEgenskaberType
			]::DokumentDelEgenskaberType[]   --egenskaber
			,null --del relationer
			)::DokumentDelType
		]::DokumentDelType[]

		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result20:=ARRAY[doc1_new_uuid,doc2_new_uuid,doc3_new_uuid]::uuid[];

search_result20
:=as_search_dokument(null,null,search_reg20
,null);


RETURN NEXT ok(expected_result20 @> search_result20 and search_result20 @>expected_result20 and coalesce(array_length(search_result20 ,1),0)=coalesce(array_length(expected_result20,1),0), 'search dokument #20.');

/***************************************************/



search_reg21
:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,null -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		'doc_varianttekst2_1' --null --varianttekst
		,null --variantegenskaber
		,ARRAY[
		ROW(
			null --deltekst
			,ARRAY[
			 ROW(
				null --1, --indeks int,
				,null --'del_indhold1', 
				, null --'del_lokation1', 
				,'del_mimetype1'
				,null	
				)::DokumentDelEgenskaberType
			]::DokumentDelEgenskaberType[]   --egenskaber
			, ARRAY[
				ROW(
					'underredigeringaf'
  					,null --virkning Virkning,
  					,'800a2dd4-415f-4104-b7a7-84607488c091'
  					,null
  					,'Bruger'
					)::DokumentdelRelationType
			]::DokumentdelRelationType[]
			)::DokumentDelType
		]::DokumentDelType[]
		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result21:=ARRAY[doc3_new_uuid]::uuid[];

search_result21
:=as_search_dokument(null,null,search_reg21
,null);


RETURN NEXT ok(expected_result21 @> search_result21 and search_result21 @>expected_result21 and coalesce(array_length(search_result21 ,1),0)=coalesce(array_length(expected_result21,1),0), 'search dokument #21.');

/***************************************************/


search_reg22
:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,null -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		'doc_varianttekst2_1' --null --varianttekst
		,null --variantegenskaber
		,ARRAY[
		ROW(
			'doc_deltekst1A' --deltekst
			,ARRAY[
			 ROW(
				null --1, --indeks int,
				,null --'del_indhold1', 
				, null --'del_lokation1', 
				,'del_mimetype1'
				,null	
				)::DokumentDelEgenskaberType
			]::DokumentDelEgenskaberType[]   --egenskaber
			, ARRAY[
				ROW(
					'underredigeringaf'
  					,null --virkning Virkning,
  					,null
  					,null
  					,'Bruger'
					)::DokumentdelRelationType
			]::DokumentdelRelationType[]
			)::DokumentDelType
		]::DokumentDelType[]
		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result22:=ARRAY[doc3_new_uuid,doc1_new_uuid]::uuid[];

search_result22
:=as_search_dokument(null,null,search_reg22
,null);


RETURN NEXT ok(expected_result22 @> search_result22 and search_result22 @>expected_result22 and coalesce(array_length(search_result22 ,1),0)=coalesce(array_length(expected_result22,1),0), 'search dokument #22.');

/***************************************************/

/***************************************************/


search_reg23

:= ROW (
	null --base reg
	,null -- fremdrift ARRAY[doc3_dokumentFremdrift]::dokumentFremdriftTilsType[],
	,null -- egenskaber ARRAY[doc3_dokumentEgenskab1,doc3_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
	,null --relations ARRAY[doc3_dokumentRelBesvarelser1,doc3_dokumentRelAnsvarlig,doc3_dokumentRelBesvarelser2],
	,ARRAY[
	ROW(
		'doc_varianttekst2_1' --null --varianttekst
		,null --variantegenskaber
		,ARRAY[
		ROW(
			'doc_deltekst1A' --deltekst
			,ARRAY[
			 ROW(
				null --1, --indeks int,
				,null --'del_indhold1', 
				, null --'del_lokation1', 
				,'del_mimetype1'
				,null	
				)::DokumentDelEgenskaberType
			]::DokumentDelEgenskaberType[]   --egenskaber
			, ARRAY[
				ROW(
					'underredigeringaf'
  					,ROW (
					'[2010-01-10, 2010-08-30)' :: TSTZRANGE
          			,null --'771cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          			,null--'Bruger',
          			,null --'NoteEx71'
          			) :: Virkning --virkning Virkning,
  					,null
  					,null
  					,'Bruger'
					)::DokumentdelRelationType
			]::DokumentdelRelationType[]
			)::DokumentDelType
		]::DokumentDelType[]
		)::DokumentVariantType
	]::DokumentVariantType[]
	--null --variants ARRAY[doc3_docVariant1,doc3_docVariant2]
) :: dokumentRegistreringType
;

expected_result23
:=ARRAY[doc3_new_uuid]::uuid[];

search_result23

:=as_search_dokument(null,null,search_reg23

,null);


RETURN NEXT ok(expected_result23 @> search_result23 and search_result23 @>expected_result23 and coalesce(array_length(search_result23,1),0)=coalesce(array_length(expected_result23,1),0), 'search dokument #23.');

/***************************************************/

expected_result24
:=ARRAY[doc2_new_uuid]::uuid[];

search_result24:=as_search_dokument(
	null
	,null --dokument_uuid uuid,
	,null --registreringObj DokumentRegistreringType,
	,null --virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	,null --maxResults int = 2147483647,
	,null --anyAttrValueArr text[] = '{}'::text[],
	,array[doc2_uuidBesvarelser1]::uuid[]
	,null --anyurnArr text[] = '{}'::text[],
	);


RETURN NEXT ok(expected_result24 @> search_result24 and search_result24 @>expected_result24 and coalesce(array_length(search_result24,1),0)=coalesce(array_length(expected_result24,1),0), 'search dokument #24.');



/***************************************************/

expected_result25
:=ARRAY[doc1_new_uuid]::uuid[];

search_result25:=as_search_dokument(
	null
	,null --dokument_uuid uuid,
	,null --registreringObj DokumentRegistreringType,
	,null --virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	,null --maxResults int = 2147483647,
	,null --anyAttrValueArr text[] = '{}'::text[],
	,array['b24a2dd4-415f-4104-b7a7-84607488c091'::uuid]::uuid[]
	,null --anyurnArr text[] = '{}'::text[],
	);


RETURN NEXT ok(expected_result25 @> search_result25 and search_result25 @>expected_result25 and coalesce(array_length(search_result25,1),0)=coalesce(array_length(expected_result25,1),0), 'search dokument #25.');


/***************************************************/

expected_result26
:=ARRAY[doc1_new_uuid]::uuid[];

search_result26:=as_search_dokument(
	null
	,null --dokument_uuid uuid,
	,null --registreringObj DokumentRegistreringType,
	,null --virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	,null --maxResults int = 2147483647,
	,null --anyAttrValueArr text[] = '{}'::text[],
	,null --array['b24a2dd4-415f-4104-b7a7-84607488c091'::uuid]::uuid[]
	,array[doc1_urnBesvarelser2] --anyurnArr text[] = '{}'::text[],
	);


RETURN NEXT ok(expected_result26 @> search_result26 and search_result26 @>expected_result26 and coalesce(array_length(search_result26,1),0)=coalesce(array_length(expected_result26,1),0), 'search dokument #26.');

/***************************************************/

expected_result27
:=ARRAY[doc3_new_uuid]::uuid[];

search_result27:=as_search_dokument(
	null
	,null --dokument_uuid uuid,
	,null --registreringObj DokumentRegistreringType,
	,null --virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	,null --maxResults int = 2147483647,
	,null --anyAttrValueArr text[] = '{}'::text[],
	,null --array['b24a2dd4-415f-4104-b7a7-84607488c091'::uuid]::uuid[]
	,array['urn:cpr 7000000'] --anyurnArr text[] = '{}'::text[],
	);


RETURN NEXT ok(expected_result27 @> search_result27 and search_result27 @>expected_result27 and coalesce(array_length(search_result27,1),0)=coalesce(array_length(expected_result27,1),0), 'search dokument #27.');


/***************************************************/
expected_result28
:=ARRAY[doc2_new_uuid]::uuid[];

search_result28:=as_search_dokument(
	null
	,null --dokument_uuid uuid,
	,null --registreringObj DokumentRegistreringType,
	,null --virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	,null --maxResults int = 2147483647,
	,array['doc2_kassationskode1']::text[] --anyAttrValueArr text[] = '{}'::text[],
	,null --array['b24a2dd4-415f-4104-b7a7-84607488c091'::uuid]::uuid[]
	,null --array['urn:cpr 7000000'] --anyurnArr text[] = '{}'::text[],
	);


RETURN NEXT ok(expected_result28 @> search_result28 and search_result28 @>expected_result28 and coalesce(array_length(search_result28,1),0)=coalesce(array_length(expected_result28,1),0), 'search dokument #28.');



/***************************************************/
expected_result29
:=ARRAY[doc1_new_uuid,doc2_new_uuid,doc3_new_uuid]::uuid[];

search_result29:=as_search_dokument(
	null
	,null --dokument_uuid uuid,
	,null --registreringObj DokumentRegistreringType,
	,null --virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	,null --maxResults int = 2147483647,
	,array['del_mimetype1%']::text[] --anyAttrValueArr text[] = '{}'::text[],
	,null --array['b24a2dd4-415f-4104-b7a7-84607488c091'::uuid]::uuid[]
	,null --array['urn:cpr 7000000'] --anyurnArr text[] = '{}'::text[],
	);


RETURN NEXT ok(expected_result29 @> search_result29 and search_result29 @>expected_result29 and coalesce(array_length(search_result29,1),0)=coalesce(array_length(expected_result29,1),0), 'search dokument #29.');

/***************************************************/
expected_result30
:=ARRAY[doc1_new_uuid,doc3_new_uuid]::uuid[];

search_result30:=as_search_dokument(
	null
	,null --dokument_uuid uuid,
	,null --registreringObj DokumentRegistreringType,
	,TSTZRANGE(current_timestamp,current_timestamp,'[]') --virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	,null --maxResults int = 2147483647,
	,array['del_mimetype1']::text[] --anyAttrValueArr text[] = '{}'::text[],
	,null --array['b24a2dd4-415f-4104-b7a7-84607488c091'::uuid]::uuid[]
	,null --array['urn:cpr 7000000'] --anyurnArr text[] = '{}'::text[],
	);


--RAISE NOTICE 'expected_result30:%',to_json(expected_result30);
--RAISE NOTICE 'search_result30:%',to_json(search_result30);

RETURN NEXT ok(expected_result30 @> search_result30 and search_result30 @>expected_result30 and coalesce(array_length(search_result30,1),0)=coalesce(array_length(expected_result30,1),0), 'search dokument #30.');


/***************************************************/

expected_result31:=ARRAY[doc2_new_uuid]::uuid[];

search_result31:=as_search_dokument(
	null
	,null --dokument_uuid uuid,
	,null --registreringObj DokumentRegistreringType,
	,null --virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	,null --maxResults int = 2147483647,
	,array['doc2_Offentlighedundtaget_Hjemmel1']::text[] --anyAttrValueArr text[] = '{}'::text[],
	,null --array['b24a2dd4-415f-4104-b7a7-84607488c091'::uuid]::uuid[]
	,null --array['urn:cpr 7000000'] --anyurnArr text[] = '{}'::text[],
	);


--RAISE NOTICE 'expected_result31:%',to_json(expected_result31);
--RAISE NOTICE 'search_result31:%',to_json(search_result31);

RETURN NEXT ok(expected_result31 @> search_result31 and search_result31 @>expected_result31 and coalesce(array_length(search_result31,1),0)=coalesce(array_length(expected_result31,1),0), 'search dokument #31.');







END;
$$;


ALTER FUNCTION test.test_as_search_dokument() OWNER TO mox;

--
-- Name: test_as_search_facet(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_search_facet() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid_A uuid;
	registrering_A FacetRegistreringType;
	actual_registrering_A registreringBase;
	virkEgenskaber_A Virkning;
	virkAnsvarlig_A Virkning;
	virkRedaktoer1_A Virkning;
	virkRedaktoer2_A Virkning;
	virkPubliceret_A Virkning;
	facetEgenskab_A FacetEgenskaberAttrType;
	facetPubliceret_A FacetPubliceretTilsType;
	facetRelAnsvarlig_A FacetRelationType;
	facetRelRedaktoer1_A FacetRelationType;
	facetRelRedaktoer2_A FacetRelationType;
	uuidAnsvarlig_A uuid :=uuid_generate_v4();
	uuidRedaktoer1_A uuid :=uuid_generate_v4();
	uuidRedaktoer2_A uuid :=uuid_generate_v4();
	uuidregistrering_A uuid :=uuid_generate_v4();
	

	new_uuid_B uuid;
	registrering_B FacetRegistreringType;
	actual_registrering_B registreringBase;
	virkEgenskaber_B Virkning;
	virkAnsvarlig_B Virkning;
	virkRedaktoer1_B Virkning;
	virkRedaktoer2_B Virkning;
	virkPubliceret_B Virkning;
	virkpubliceret2_b Virkning;
	facetEgenskab_B FacetEgenskaberAttrType;
	facetPubliceret_B FacetPubliceretTilsType;
	facetPubliceret_B2 FacetPubliceretTilsType;
	facetRelAnsvarlig_B FacetRelationType;
	facetRelRedaktoer1_B FacetRelationType;
	facetRelRedaktoer2_B FacetRelationType;
	uuidAnsvarlig_B uuid :=uuid_generate_v4();
	uuidRedaktoer1_B uuid :=uuid_generate_v4();
	uuidRedaktoer2_B uuid :=uuid_generate_v4();
	uuidregistrering_B uuid :=uuid_generate_v4();


	new_uuid_C uuid;
	registrering_C FacetRegistreringType;
	actual_registrering_C registreringBase;
	virkEgenskaber_C Virkning;
	virkAnsvarlig_C Virkning;
	virkRedaktoer1_C Virkning;
	virkRedaktoer2_C Virkning;
	virkPubliceret_C Virkning;
	virkpubliceret2_C Virkning;
	facetEgenskab_C FacetEgenskaberAttrType;
	facetPubliceret_C FacetPubliceretTilsType;
	facetPubliceret_C2 FacetPubliceretTilsType;
	facetRelAnsvarlig_C FacetRelationType;
	facetRelRedaktoer1_C FacetRelationType;
	facetRelRedaktoer2_C FacetRelationType;
	uuidAnsvarlig_C uuid :=uuid_generate_v4();
	uuidRedaktoer1_C uuid :=uuid_generate_v4();
	uuidRedaktoer2_C uuid :=uuid_generate_v4();
	uuidregistrering_C uuid :=uuid_generate_v4();


	search_result1 uuid[];
	search_result2 uuid[];
	search_result3 uuid[];
	search_result4 uuid[];
	search_result5 uuid[];
	search_result6 uuid[];
	search_result7 uuid[];
	search_result8 uuid[];
	search_result9 uuid[];
	search_result9B uuid[];

	expected_result2 uuid[];
	expected_result4 uuid[];
	expected_result8 uuid[];
	expected_result9 uuid[];
	expected_result9B uuid[];

	search_registrering_3 FacetRegistreringType;
	search_registrering_4 FacetRegistreringType;
	search_registrering_5 FacetRegistreringType;
	search_registrering_6 FacetRegistreringType;
	search_registrering_7 FacetRegistreringType;
	search_registrering_8 FacetRegistreringType;
	search_registrering_9 FacetRegistreringType;

BEGIN


virkEgenskaber_A :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkAnsvarlig_A :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1_A :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2_A :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;


virkPubliceret_A := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;



facetRelAnsvarlig_A := ROW (
	'ansvarlig'::FacetRelationKode,
		virkAnsvarlig_A,
	uuidAnsvarlig_A,
	null,
	null
) :: FacetRelationType
;


facetRelRedaktoer1_A := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer1_A,
	uuidRedaktoer1_A,
	null,
	null
) :: FacetRelationType
;



facetRelRedaktoer2_A := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer2_A,
	uuidRedaktoer2_A,
	null,
	null
) :: FacetRelationType
;


facetPubliceret_A := ROW (
virkPubliceret_A,
'Publiceret'
):: FacetPubliceretTilsType
;


facetEgenskab_A := ROW (
'brugervendt_noegle_text1',
   'facetbeskrivelse_text1',
   'facetplan_text1',
   'facetopbygning_text1',
   'facetophavsret_text1',
   'facetsupplement_text1',
   'retskilde_text1',
   virkEgenskaber_A
) :: FacetEgenskaberAttrType
;


registrering_A := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidregistrering_A,
	'Test Note 4') :: registreringBase
	,
ARRAY[facetPubliceret_A]::FacetPubliceretTilsType[],
ARRAY[facetEgenskab_A]::FacetEgenskaberAttrType[],
ARRAY[facetRelAnsvarlig_A,facetRelRedaktoer1_A,facetRelRedaktoer2_A]
) :: FacetRegistreringType
;

new_uuid_A := as_create_or_import_facet(registrering_A);



--*******************


virkEgenskaber_B :=	ROW (
	'[2015-04-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkAnsvarlig_B :=	ROW (
	'[2015-04-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1_B :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2_B :=	ROW (
	'[2015-04-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret_B := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkPubliceret2_B := ROW (
	'[2014-05-18, 2015-05-18)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx143'
) :: Virkning
;


facetRelAnsvarlig_B := ROW (
	'ansvarlig'::FacetRelationKode,
		virkAnsvarlig_B,
	uuidAnsvarlig_B,
	null,
	null
) :: FacetRelationType
;


facetRelRedaktoer1_B := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer1_B,
	uuidRedaktoer1_B,
	null,
	null
) :: FacetRelationType
;



facetRelRedaktoer2_B := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer2_B,
	uuidRedaktoer2_B,
	null,
	null
) :: FacetRelationType
;


facetPubliceret_B := ROW (
virkPubliceret_B,
'Publiceret'
):: FacetPubliceretTilsType
;

facetPubliceret_B2 := ROW (
virkPubliceret2_B,
'IkkePubliceret'
):: FacetPubliceretTilsType
;


facetEgenskab_B := ROW (
'brugervendt_noegle_text2',
   'facetbeskrivelse_text2',
   'facetplan_text2',
   'facetopbygning_text2',
   'facetophavsret_text2',
   'facetsupplement_text2',
   'retskilde_text2',
   virkEgenskaber_B
) :: FacetEgenskaberAttrType
;


registrering_B := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidregistrering_B,
	'Test Note 5') :: registreringBase
	,
ARRAY[facetPubliceret_B,facetPubliceret_B2]::FacetPubliceretTilsType[],
ARRAY[facetEgenskab_B]::FacetEgenskaberAttrType[],
ARRAY[facetRelAnsvarlig_B,facetRelRedaktoer1_B,facetRelRedaktoer2_B]
) :: FacetRegistreringType
;

new_uuid_B := as_create_or_import_facet(registrering_B);


--***********************************


search_result1 :=as_search_facet(
	null,--TOOD ??
	new_uuid_A,
	null,--registrering_A Facetregistrering_AType
	null--virkningSoeg
	);

RETURN NEXT is(
search_result1,
ARRAY[new_uuid_A]::uuid[],
'simple search on single uuid'
);


search_result2 :=as_search_facet(
	null,--TOOD ??
	null,
	null,--registrering_A Facetregistrering_AType
	null--virkningSoeg
	);

expected_result2:=ARRAY[new_uuid_A,new_uuid_B]::uuid[];

RETURN NEXT ok(expected_result2 @> search_result2 and search_result2 @>expected_result2 and array_length(expected_result2,1)=array_length(search_result2,1), 'search null params');


--***********************************
--search on facets that has had the state not published at any point in time

search_registrering_3 := ROW (
	ROW (
	NULL,
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	null,null,null,null
				  	)::virkning 
				  ,'IkkePubliceret'::FacetPubliceretTils
				):: FacetPubliceretTilsType
	],--ARRAY[facetPubliceret_B]::FacetPubliceretTilsType[],
null,--ARRAY[facetEgenskab_B]::FacetEgenskaberAttrType[],
null--ARRAY[facetRelAnsvarlig_B,facetRelRedaktoer1_B,facetRelRedaktoer2_B]
):: FacetRegistreringType;

--raise notice 'search_registrering_3,%',search_registrering_3;

search_result3 :=as_search_facet(
	null,--TOOD ??
	null,
	search_registrering_3, --registrering_A Facetregistrering_AType
	null--virkningSoeg
	);

--raise notice 'search for IkkePubliceret returned:%',search_result3;

RETURN NEXT is(
search_result3,
ARRAY[new_uuid_B]::uuid[],
'search state FacetPubliceretTils IkkePubliceret'
);

--***********************************
--search on facets that were published on 18-05-2015
search_registrering_4 := ROW (
	ROW (
	NULL,
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-18, 2015-05-19]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::FacetPubliceretTils
				):: FacetPubliceretTilsType
	],--ARRAY[facetPubliceret_B]::FacetPubliceretTilsType[],
null,--ARRAY[facetEgenskab_B]::FacetEgenskaberAttrType[],
null--ARRAY[facetRelAnsvarlig_B,facetRelRedaktoer1_B,facetRelRedaktoer2_B]
):: FacetRegistreringType;



search_result4 :=as_search_facet(
	null,--TOOD ??
	null,
	search_registrering_4, --registrering_A Facetregistrering_AType
	null--virkningSoeg
	);



expected_result4:=ARRAY[new_uuid_A,new_uuid_B]::uuid[];

RETURN NEXT ok(expected_result4 @> search_result4 and search_result4 @>expected_result4 and array_length(expected_result4,1)=array_length(search_result4,1), 'search on facets that were published on 18-05-2015');


--***********************************
--search on facets that had state 'ikkepubliceret' on 30-06-2015 30-07-2015
search_registrering_5 := ROW (
	ROW (
	NULL,
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-06-30, 2015-07-30]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'IkkePubliceret'::FacetPubliceretTils
				):: FacetPubliceretTilsType
	],--ARRAY[facetPubliceret_B]::FacetPubliceretTilsType[],
null,--ARRAY[facetEgenskab_B]::FacetEgenskaberAttrType[],
null--ARRAY[facetRelAnsvarlig_B,facetRelRedaktoer1_B,facetRelRedaktoer2_B]
):: FacetRegistreringType;



search_result5 :=as_search_facet(
	null,--TOOD ??
	null,
	search_registrering_5, --registrering_A Facetregistrering_AType
	null--virkningSoeg
	);

RETURN NEXT is(
search_result5,
ARRAY[]::uuid[],
'search state FacetPubliceretTils ikkepubliceret on 30-06-2015 30-07-2015'
);

--***********************************
--search on facets with specific aktoerref and state publiceret
search_registrering_6 := ROW (
	ROW (
	NULL,
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-18, 2015-05-19]' :: TSTZRANGE,
				  	(virkPubliceret_B).AktoerRef,
				  	null,null
				  	)::virkning 
				  ,'Publiceret'::FacetPubliceretTils
				):: FacetPubliceretTilsType
	],--ARRAY[facetPubliceret_B]::FacetPubliceretTilsType[],
null,--ARRAY[facetEgenskab_B]::FacetEgenskaberAttrType[],
null--ARRAY[facetRelAnsvarlig_B,facetRelRedaktoer1_B,facetRelRedaktoer2_B]
):: FacetRegistreringType;

search_result6 :=as_search_facet(
	null,--TOOD ??
	null,
	search_registrering_6, --registrering_A Facetregistrering_AType
	null--virkningSoeg
	);

RETURN NEXT is(
search_result6,
ARRAY[new_uuid_B]::uuid[],
'search on facets with specific aktoerref and state publiceret'
);


--*******************


virkEgenskaber_C :=	ROW (
	'[2014-09-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkAnsvarlig_C :=	ROW (
	'[2014-08-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1_C :=	ROW (
	'[2014-07-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2_C :=	ROW (
	'[2013-04-10, 2015-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret_C := ROW (
	'[2015-02-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkPubliceret2_C := ROW (
	'[2013-05-18, 2015-02-18)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx143'
) :: Virkning
;


facetRelAnsvarlig_C := ROW (
	'ansvarlig'::FacetRelationKode,
		virkAnsvarlig_C,
	uuidAnsvarlig_C,
	null,
	null
) :: FacetRelationType
;


facetRelRedaktoer1_C := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer1_C,
	uuidRedaktoer1_C,
	null,
	null
) :: FacetRelationType
;



facetPubliceret_C := ROW (
virkPubliceret_C,
'Publiceret'
):: FacetPubliceretTilsType
;

facetPubliceret_C2 := ROW (
virkPubliceret2_C,
'IkkePubliceret'
):: FacetPubliceretTilsType
;


facetEgenskab_C := ROW (
'brugervendt_noegle_text3',
   'facetbeskrivelse_text3',
   'facetplan_text3',
   'facetopbygning_text3',
   'facetophavsret_text3',
   'facetsupplement_text3',
   'retskilde_text3',
   virkEgenskaber_C
) :: FacetEgenskaberAttrType
;


registrering_C := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidregistrering_C,
	'Test Note 993') :: registreringBase
	,
ARRAY[facetPubliceret_C,facetPubliceret_C2]::FacetPubliceretTilsType[],
ARRAY[facetEgenskab_C]::FacetEgenskaberAttrType[],
ARRAY[facetRelAnsvarlig_C,facetRelRedaktoer1_C]
) :: FacetRegistreringType
;

new_uuid_C := as_create_or_import_facet(registrering_C);

--*******************
--Do a test, that filters on publiceretStatus, egenskaber and relationer


search_registrering_7 := ROW (
	ROW (
	NULL,
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-18, 2015-05-19]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::FacetPubliceretTils
				):: FacetPubliceretTilsType
	],--ARRAY[facetPubliceret_B]::FacetPubliceretTilsType[],
ARRAY[
	ROW(
		NULL,
   		NULL,
        NULL,
   		NULL,
   		NULL,
   		'facetsupplement_text3',
   		NULL,
   			ROW(
				  	'[2015-01-01, 2015-02-01]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
		)::FacetEgenskaberAttrType
]::FacetEgenskaberAttrType[],
ARRAY[
	ROW (
	'redaktoerer'::FacetRelationKode,
		ROW(
				'[2013-05-01, 2015-04-11]' :: TSTZRANGE,
				 null,null,null
			)::virkning ,
			null,
			null,
			null
	) :: FacetRelationType
]
):: FacetRegistreringType;



search_result7 :=as_search_facet(
	null,--TOOD ??
	null,
	search_registrering_7, --registrering_A Facetregistrering_AType
	null--virkningSoeg
	);

RETURN NEXT is(
search_result7,
ARRAY[new_uuid_C]::uuid[],
'search state publiceretStatus, egenskaber and relationer combined'
);


--*******************
--Do a test, that filters on publiceretStatus, egenskaber and relationer


search_registrering_8 := ROW (
	ROW (
	NULL,
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-18, 2015-05-19]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::FacetPubliceretTils
				):: FacetPubliceretTilsType
	],--ARRAY[facetPubliceret_B]::FacetPubliceretTilsType[],
ARRAY[]::FacetEgenskaberAttrType[],
ARRAY[
	ROW (
	'redaktoerer'::FacetRelationKode,
		ROW(
				'[2013-05-01, 2015-04-11]' :: TSTZRANGE,
				 null,null,null
			)::virkning ,
			null,
			null,
			null
	) :: FacetRelationType
]
):: FacetRegistreringType;



search_result8 :=as_search_facet(
	null,--TOOD ??
	null,
	search_registrering_8, --registrering_A Facetregistrering_AType
	null--virkningSoeg
	);

expected_result8:=ARRAY[new_uuid_B,new_uuid_C]::uuid[];

RETURN NEXT ok(expected_result8 @> search_result8 and search_result8 @>expected_result8 and array_length(expected_result8,1)=array_length(search_result8,1), 'search state publiceretStatus and relationer combined');

/************************/
--test if search filters is filtered the rigth way, if access criteria is met.

search_registrering_9 := ROW (
	ROW (
	NULL,
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-19, 2015-05-19]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::FacetPubliceretTils
				):: FacetPubliceretTilsType
	],--ARRAY[facetPubliceret_B]::FacetPubliceretTilsType[],
	null --ARRAY[]::FacetEgenskaberAttrType[],
	,null --relations

):: FacetRegistreringType;



search_result9 :=as_search_facet(
	null,--TOOD ??
	null,
	search_registrering_9, --registrering_A Facetregistrering_AType
	null--virkningSoeg
	,null --maxResults
	,null --anyAttrValueArr
	,null --anyuuidArr
	,null --anyurnArr
	,ARRAY[
	 ROW (
	 	null --reg base
	 	,null --states
	 	,ARRAY[
		 	ROW (
			null --'brugervendt_noegle_text3',
	   		,null--'facetbeskrivelse_text3',
	   		,'facetplan_text1' --,
	  		,null --'facetopbygning_text3',
	   		,null --'facetophavsret_text3',
	   		,null --'facetsupplement_text3',
	   		,null
	   		,null
			) :: FacetEgenskaberAttrType		
	 	]::FacetEgenskaberAttrType[] 
	 	,null --relationer
	 	)::FacetRegistreringType
	 ,ROW (
	 		null --reg base
	 	,null --states
	 	,ARRAY[
		 	ROW (
			null --'brugervendt_noegle_text3',
	   		,null--'facetbeskrivelse_text3',
	   		,'facetplan_text2' --,
	  		,null --'facetopbygning_text3',
	   		,null --'facetophavsret_text3',
	   		,null --'facetsupplement_text3',
	   		,null
	   		,null
			) :: FacetEgenskaberAttrType
			]
			::FacetEgenskaberAttrType[] 
	 	,null --relationer
	 	)::FacetRegistreringType
	 	

	]::FacetRegistreringType[]
);

expected_result9:=ARRAY[new_uuid_A,new_uuid_B]::uuid[];

RETURN NEXT ok(expected_result9 @> search_result9 and search_result9 @>expected_result9 and array_length(expected_result9,1)=array_length(search_result9,1), 'search filter on stipulated access criteria #1');

--try same search_registrering_9, but his time don't supply any auth criteria

expected_result9B:=ARRAY[new_uuid_A,new_uuid_B,new_uuid_C]::uuid[];


search_result9B :=as_search_facet(
	null,--TOOD ??
	null,
	search_registrering_9, --NOTICE search_registrering_9
	null--virkningSoeg
	);

RETURN NEXT ok(expected_result9B @> search_result9B and search_result9B @>expected_result9B and array_length(expected_result9B,1)=array_length(search_result9B,1), 'no search filter, when no stipulated criteria #2');






END;
$$;


ALTER FUNCTION test.test_as_search_facet() OWNER TO mox;

--
-- Name: test_as_search_ilike_array(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_search_ilike_array() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
searchFor1 text;
searchInArr1 text[] ;
expectedRes1 boolean;
searchFor2 text;
searchInArr2 text[];
expectedRes2 boolean;
searchFor3 text;
searchInArr3 text[] ;
expectedRes3 boolean;
searchFor4 text;
searchInArr4 text[] ;
expectedRes4 boolean;
searchFor5 text;
searchInArr5 text[] ;
expectedRes5 boolean;
searchFor6 text;
searchInArr6 text[] ;
expectedRes6 boolean;
searchFor7 text;
searchInArr7 text[] ;
expectedRes7 boolean;
searchFor8 text;
searchInArr8 text[] ;
expectedRes8 boolean;
searchFor9 text;
searchInArr9 text[] ;
expectedRes9 boolean;
BEGIN



expectedRes1:=false;

RETURN NEXT is(_as_search_ilike_array(searchFor1,searchInArr1),expectedRes1,'search for null in null does not matches');

expectedRes2:=false;

searchFor2:='test';

RETURN NEXT is(_as_search_ilike_array(searchFor2,searchInArr2),expectedRes2,'search for one element in null fails');


expectedRes3:=false;

searchInArr3:=ARRAY['test','test2'];

RETURN NEXT is(_as_search_ilike_array(searchFor3,searchInArr3),expectedRes3,'search for null array fails');


expectedRes4:=true;

searchInArr4:=ARRAY['skole','test'];
searchFor4:='skole';
RETURN NEXT is(_as_search_ilike_array(searchFor4,searchInArr4),expectedRes4,'search for 1 element should match');


expectedRes5:=false;

searchInArr5:=ARRAY['skole','test'];
searchFor5:='skole2';


RETURN NEXT is(_as_search_ilike_array(searchFor5,searchInArr5),expectedRes5,'search for 1 elements in non-empty arr fails');


expectedRes6:=true;

searchInArr6:=ARRAY['skole','test'];
searchFor6:='tes%';


RETURN NEXT is(_as_search_ilike_array(searchFor6,searchInArr6),expectedRes6,'search for 1 elements in non-empty with wildcard');


expectedRes7:=false;

searchInArr7:=ARRAY['skole','test'];
searchFor7:='tes';


RETURN NEXT is(_as_search_ilike_array(searchFor7,searchInArr7),expectedRes7,'search for 1 elements in non-empty with wildcard #2');


expectedRes8:=false;

searchInArr8:=ARRAY[]::text[];
searchFor8:='';


RETURN NEXT is(_as_search_ilike_array(searchFor8,searchInArr8),expectedRes8,'search for empty string empty array');



expectedRes9:=false;

searchInArr9:=ARRAY[]::text[];
searchFor9:=null;


RETURN NEXT is(_as_search_ilike_array(searchFor9,searchInArr9),expectedRes9,'search for null in empty empty array');



END;
$$;


ALTER FUNCTION test.test_as_search_ilike_array() OWNER TO mox;

--
-- Name: test_as_search_indsats(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_search_indsats() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	new_uuid2 uuid;
	registrering indsatsRegistreringType;
	registrering2 indsatsRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkEgenskaber2 Virkning;
	virkIndsatsmodtager Virkning;
	virkIndsatssag1 Virkning;
	virkIndsatssag2 Virkning;
	virkIndsatsaktoer1 Virkning;
	virkIndsatsaktoer2 Virkning;
	virkPubliceret Virkning;
	virkFremdrift Virkning;
	indsatsEgenskab indsatsEgenskaberAttrType;
	indsatsEgenskab2 indsatsEgenskaberAttrType;
	indsatsFremdrift indsatsFremdriftTilsType;
	indsatsPubliceret indsatsPubliceretTilsType;
	indsatsRelIndsatsmodtager indsatsRelationType;
	indsatsRelIndsatssag1 indsatsRelationType;
	indsatsRelIndsatssag2 indsatsRelationType;
	indsatsRelIndsatsaktoer1 indsatsRelationType;
	indsatsRelIndsatsaktoer2 indsatsRelationType;
	
	uuidIndsatsmodtager uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	uuidIndsatssag1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;


	--uuidIndsatssag2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	urnIndsatssag2 text:='urn:isbn:0451450523'::text;
	uuidIndsatsaktoer1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidIndsatsaktoer2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	actual_publiceret_virk virkning;
	actual_publiceret_value indsatsFremdriftTils;
	actual_publiceret indsatsFremdriftTilsType;
	actual_relationer indsatsRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	read_Indsats1 IndsatsType;
	expected_indsats1 IndsatsType;

expected_search_res_1 uuid[];
	expected_search_res_2 uuid[];
	expected_search_res_3 uuid[];
	expected_search_res_4 uuid[];
	expected_search_res_5 uuid[];
	expected_search_res_6 uuid[];
	expected_search_res_7 uuid[];
	expected_search_res_8 uuid[];
	expected_search_res_9 uuid[];
	expected_search_res_10 uuid[];
	expected_search_res_11 uuid[];
	expected_search_res_12 uuid[];
	expected_search_res_13 uuid[];
	expected_search_res_14 uuid[];
	expected_search_res_15 uuid[];
	expected_search_res_16 uuid[];
	expected_search_res_17 uuid[];
	expected_search_res_18 uuid[];
	expected_search_res_19 uuid[];
	expected_search_res_20 uuid[];
	expected_search_res_21 uuid[];
	expected_search_res_22 uuid[];
	expected_search_res_23 uuid[];
	expected_search_res_24 uuid[];
	expected_search_res_25 uuid[];
	expected_search_res_26 uuid[];
	expected_search_res_27 uuid[];
	expected_search_res_28 uuid[];
	expected_search_res_29 uuid[];

	actual_search_res_1 uuid[];
	actual_search_res_2 uuid[];
	actual_search_res_3 uuid[];
	actual_search_res_4 uuid[];
	actual_search_res_5 uuid[];
	actual_search_res_6 uuid[];
	actual_search_res_7 uuid[];
	actual_search_res_8 uuid[];
	actual_search_res_9 uuid[];
	actual_search_res_10 uuid[];
	actual_search_res_11 uuid[];
	actual_search_res_12 uuid[];
	actual_search_res_13 uuid[];
	actual_search_res_14 uuid[];
	actual_search_res_15 uuid[];
	actual_search_res_16 uuid[];
	actual_search_res_17 uuid[];
	actual_search_res_18 uuid[];
	actual_search_res_19 uuid[];
	actual_search_res_20 uuid[];
	actual_search_res_21 uuid[];
	actual_search_res_22 uuid[];
	actual_search_res_23 uuid[];
	actual_search_res_24 uuid[];
	actual_search_res_25 uuid[];
	actual_search_res_26 uuid[];
	actual_search_res_27 uuid[];
	actual_search_res_28 uuid[];
	actual_search_res_29 uuid[];


BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaber2 :=	ROW (
	'[2016-06-01, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx43'
          ) :: Virkning
;

virkIndsatsmodtager :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkIndsatssag1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkIndsatssag2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkfremdrift := ROW (
	'[2016-12-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx20'
) :: Virkning
;

virkIndsatsaktoer1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkIndsatsaktoer2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

indsatsRelIndsatsmodtager := ROW (
	'indsatsmodtager'::indsatsRelationKode
	,virkIndsatsmodtager
	,uuidIndsatsmodtager
	,null
	,'Person'
	,567 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;


indsatsRelIndsatssag1 := ROW (
	'indsatssag'::indsatsRelationKode,
		virkIndsatssag1,
	uuidIndsatssag1,
	null,
	'Sag'
	,768 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsRelIndsatssag2 := ROW (
	'indsatssag'::indsatsRelationKode,
		virkIndsatssag2,
	null,
	urnIndsatssag2,
	'Sag'
	,800 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsRelIndsatsaktoer1 := ROW (
	'indsatsaktoer'::indsatsRelationKode,
		virkIndsatsaktoer1,
	uuidIndsatsaktoer1,
	null,
	'Person'
	,7268 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsRelIndsatsaktoer2 := ROW (
	'indsatsaktoer'::indsatsRelationKode,
		virkIndsatsaktoer2,
	uuidIndsatsaktoer2,
	null,
	'Person'
	,3 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsFremdrift := ROW (
virkFremdrift,
'Visiteret'::IndsatsFremdriftTils
):: indsatsFremdriftTilsType
;

indsatsPubliceret := ROW (
virkPubliceret,
'Normal'::IndsatsPubliceretTils
)::indsatsPubliceretTilsType;

indsatsEgenskab := ROW (
'brugervendtnoegle_indsats_1' --text, 
,'beskrivelse_indsats_faelles'-- text,
, '2017-01-20 08:00'::timestamptz  -- starttidspunkt,
, '2017-01-20 12:00'::timestamptz -- sluttidspunkt,
,virkEgenskaber
) :: indsatsEgenskaberAttrType
;


registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[indsatsPubliceret]::IndsatsPubliceretTilsType[],
ARRAY[indsatsFremdrift]::indsatsFremdriftTilsType[],
ARRAY[indsatsEgenskab]::indsatsEgenskaberAttrType[],
ARRAY[indsatsRelIndsatsmodtager,indsatsRelIndsatssag1,indsatsRelIndsatssag2,indsatsRelIndsatsaktoer1,indsatsRelIndsatsaktoer2]) :: indsatsRegistreringType
;


--raise notice 'to be written indsats 1:%',to_json(registrering);

new_uuid1 := as_create_or_import_indsats(registrering);

RETURN NEXT ok(true,'No errors running as_create_or_import_indsats #1');



/*********************************************/


indsatsEgenskab2 := ROW (
'brugervendtnoegle_indsats_2' --text, 
,'beskrivelse_indsats_faelles'-- text,
, '2017-01-25 09:00'::timestamptz  -- starttidspunkt,
, '2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,virkEgenskaber2
) :: indsatsEgenskaberAttrType
;



registrering2 := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 35') :: RegistreringBase
	,
	ARRAY[indsatsPubliceret]::IndsatsPubliceretTilsType[],
ARRAY[indsatsFremdrift]::indsatsFremdriftTilsType[],
ARRAY[indsatsEgenskab2]::indsatsEgenskaberAttrType[],
ARRAY[indsatsRelIndsatsmodtager,indsatsRelIndsatsaktoer1,indsatsRelIndsatsaktoer2]) :: indsatsRegistreringType
;


--raise notice 'to be written indsats 1:%',to_json(registrering);

new_uuid2 := as_create_or_import_indsats(registrering2);

RETURN NEXT ok(true,'No errors running as_create_or_import_indsats #2');


/*********************************************/

expected_search_res_1:=array[new_uuid2]::uuid[];

actual_search_res_1:=as_search_indsats(null,null,
		ROW(
			null,
			null,
			null,
			ARRAY[ ROW (
'brugervendtnoegle_indsats_2' --text, 
,null--'beskrivelse_indsats_2'-- text,
, null--'2017-01-25 09:00'::timestamptz  -- starttidspunkt,
, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType ]::IndsatsEgenskaberAttrType[],
			null-- AktivitetRelationType[]
			)::indsatsRegistreringType	
		,null
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --anyurnArr
		,null --auth_criteria_arr
		,null --search_operator_greater_than_or_equal_attr_egenskaber
		,null --search_operator_less_than_or_equal_attr_egenskaber
);

RETURN NEXT ok(expected_search_res_1 @> actual_search_res_1 and actual_search_res_1 @>expected_search_res_1 and coalesce(array_length(expected_search_res_1,1),0)=coalesce(array_length(actual_search_res_1,1),0), 'search indsats #1.');

/**************************************************/

expected_search_res_2:=array[new_uuid1,new_uuid2]::uuid[];

actual_search_res_2:=as_search_indsats(null,null,
			ROW(
			null,
			null,-- indsatsStatusTilsType[],
			null,-- indsatsPubliceretTilsType[],
			ARRAY[  ROW (
null --text, 
,'beskrivelse_indsats_faelles'-- text,
, null--'2017-01-25 09:00'::timestamptz  -- starttidspunkt,
, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType ]::indsatsEgenskaberAttrType[],
			null-- indsatsRelationType[]
			)::indsatsRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_2 @> actual_search_res_2 and actual_search_res_2 @>expected_search_res_2 and coalesce(array_length(expected_search_res_2,1),0)=coalesce(array_length(actual_search_res_2,1),0), 'search indsats #2.');


/**************************************************/
 
expected_search_res_3:=array[new_uuid2]::uuid[];

actual_search_res_3:=as_search_indsats(null,null,
		ROW(
			null,
			null,-- indsatsStatusTilsType[],
			null,-- indsatsPubliceretTilsType[],
			ARRAY[  ROW (
null --'brugervendtnoegle_indsats_2' --text, 
,null--'beskrivelse_indsats_2'-- text,
, null--'2017-01-25 09:00'::timestamptz  -- starttidspunkt,
, '2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType ]::indsatsEgenskaberAttrType[],
			null-- indsatsRelationType[]
			)::indsatsRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_3 @> actual_search_res_3 and actual_search_res_3 @>expected_search_res_3 and coalesce(array_length(expected_search_res_3,1),0)=coalesce(array_length(actual_search_res_3,1),0), 'search indsats #3.');

/**************************************************/


expected_search_res_4:=array[new_uuid1]::uuid[];

actual_search_res_4:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null,--registreringObj
		null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,array[uuidIndsatssag1]::uuid[]
		,null --anyurnArr
);

RETURN NEXT ok(expected_search_res_4 @> actual_search_res_4 and actual_search_res_4 @>expected_search_res_4 and coalesce(array_length(expected_search_res_4,1),0)=coalesce(array_length(actual_search_res_4,1),0), 'search indsats #4.');
/**************************************************/



/**************************************************/
expected_search_res_5:=array[new_uuid1]::uuid[];

actual_search_res_5:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null,--registreringObj
		null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,array[urnIndsatssag2]::text[] --anyurnArr
);

RETURN NEXT ok(expected_search_res_5 @> actual_search_res_5 and actual_search_res_5 @>expected_search_res_5 and coalesce(array_length(expected_search_res_5,1),0)=coalesce(array_length(actual_search_res_5,1),0), 'search indsats #5.');

/**************************************************/
expected_search_res_6:=array[new_uuid2]::uuid[];

actual_search_res_6:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null,--registreringObj
		null --virkningSoeg	
		,null --maxResults
		,array['brugervendtnoegle_indsats_2']::text[] --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
);

RETURN NEXT ok(expected_search_res_6 @> actual_search_res_6 and actual_search_res_6 @>expected_search_res_6 and coalesce(array_length(expected_search_res_6,1),0)=coalesce(array_length(actual_search_res_6,1),0), 'search indsats #6.');



/**************************************************/
expected_search_res_7:=array[new_uuid1,new_uuid2]::uuid[];

actual_search_res_7:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,ARRAY[
			 ROW (
null --text, 
,null--'beskrivelse_indsats_2'-- text,
, '2017-01-20 08:00'::timestamptz   -- starttidspunkt,
, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_7 @> actual_search_res_7 and actual_search_res_7 @>expected_search_res_7 and coalesce(array_length(expected_search_res_7,1),0)=coalesce(array_length(actual_search_res_7,1),0), 'search indsats #7.');

/**************************************************/


/**************************************************/
expected_search_res_8:=array[]::uuid[];

actual_search_res_8:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,ARRAY[
			 ROW (
null --'brugervendtnoegle_indsats_2' --text, 
,null--'beskrivelse_indsats_2'-- text,
, '2018-01-20 08:00'::timestamptz   -- starttidspunkt,
, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_8 @> actual_search_res_8 and actual_search_res_8 @>expected_search_res_8 and coalesce(array_length(expected_search_res_8,1),0)=coalesce(array_length(actual_search_res_8,1),0), 'search indsats #8.');

/**************************************************/
expected_search_res_9:=array[new_uuid2]::uuid[];

actual_search_res_9:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,ARRAY[
			 ROW (
null --'brugervendtnoegle_indsats_2' --text, 
,null--'beskrivelse_indsats_2'-- text,
, '2017-01-22 08:00'::timestamptz   -- starttidspunkt,
, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_9 @> actual_search_res_9 and actual_search_res_9 @>expected_search_res_9 and coalesce(array_length(expected_search_res_9,1),0)=coalesce(array_length(actual_search_res_9,1),0), 'search indsats #9.');

/**************************************************/
expected_search_res_10:=array[new_uuid2]::uuid[];

actual_search_res_10:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,ARRAY[
			 ROW (
null --'brugervendtnoegle_indsats_2' --text, 
,null--'beskrivelse_indsats_2'-- text,
, null --'2017-01-22 08:00'::timestamptz   -- starttidspunkt,
, '2017-04-20 18:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_10 @> actual_search_res_10 and actual_search_res_10 @>expected_search_res_10 and coalesce(array_length(expected_search_res_10,1),0)=coalesce(array_length(actual_search_res_10,1),0), 'search indsats #10.');

/**************************************************/
expected_search_res_11:=array[new_uuid2]::uuid[];

actual_search_res_11:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,ARRAY[
			 ROW (
null --'brugervendtnoegle_indsats_2' --text, 
,null--'beskrivelse_indsats_2'-- text,
, null --'2017-01-22 08:00'::timestamptz   -- starttidspunkt,
, '2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_11 @> actual_search_res_11 and actual_search_res_11 @>expected_search_res_11 and coalesce(array_length(expected_search_res_11,1),0)=coalesce(array_length(actual_search_res_11,1),0), 'search indsats #11.');


/**************************************************/
expected_search_res_12:=array[]::uuid[];

actual_search_res_12:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,ARRAY[
			 ROW (
null --'brugervendtnoegle_indsats_2' --text, 
,null--'beskrivelse_indsats_2'-- text,
, null --'2017-01-22 08:00'::timestamptz   -- starttidspunkt,
, '2017-06-01 12:01'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_12 @> actual_search_res_12 and actual_search_res_12 @>expected_search_res_12 and coalesce(array_length(expected_search_res_12,1),0)=coalesce(array_length(actual_search_res_12,1),0), 'search indsats #12.');


/**************************************************/
expected_search_res_13:=array[new_uuid1]::uuid[];

actual_search_res_13:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null
		,'[2016-01-01 , 2016-01-01]' :: TSTZRANGE --virkningSoeg		
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,ARRAY[
			 ROW (
null --'brugervendtnoegle_indsats_2' --text, 
,null--'beskrivelse_indsats_2'-- text,
, null --'2017-01-22 08:00'::timestamptz   -- starttidspunkt,
, '2017-01-20 08:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_13 @> actual_search_res_13 and actual_search_res_13 @>expected_search_res_13 and coalesce(array_length(expected_search_res_13,1),0)=coalesce(array_length(actual_search_res_13,1),0), 'search indsats #13.');

/**************************************************/
expected_search_res_14:=array[]::uuid[];

actual_search_res_14:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null
		,'[2014-01-01 , 2014-01-01]' :: TSTZRANGE --virkningSoeg		
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,ARRAY[
			 ROW (
null --'brugervendtnoegle_indsats_2' --text, 
,null--'beskrivelse_indsats_2'-- text,
, null --'2017-01-22 08:00'::timestamptz   -- starttidspunkt,
, '2017-01-20 08:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_14 @> actual_search_res_14 and actual_search_res_14 @>expected_search_res_14 and coalesce(array_length(expected_search_res_14,1),0)=coalesce(array_length(actual_search_res_14,1),0), 'search indsats #14.');

/**************************************************/
expected_search_res_15:=array[new_uuid2]::uuid[];

actual_search_res_15:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		ROW(
			null,
			null,-- indsatsStatusTilsType[],
			null,-- indsatsPubliceretTilsType[],
			ARRAY[  ROW (
			'brugervendtnoegle_indsats_2' --text, 
			,null--'beskrivelse_indsats_2'-- text,
			, null--'2017-01-25 09:00'::timestamptz  -- starttidspunkt,
			, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
			,null--virkEgenskaber2
			) :: indsatsEgenskaberAttrType ]::indsatsEgenskaberAttrType[],
						null-- indsatsRelationType[]
						)::indsatsRegistreringType	
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,ARRAY[
			 ROW (
null --text, 
,null--'beskrivelse_indsats_2'-- text,
, '2017-01-20 08:00'::timestamptz   -- starttidspunkt,
, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[]  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,null --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_15 @> actual_search_res_15 and actual_search_res_15 @>expected_search_res_15 and coalesce(array_length(expected_search_res_15,1),0)=coalesce(array_length(actual_search_res_15,1),0), 'search indsats #15.');


/**************************************************/


expected_search_res_16:=array[new_uuid2]::uuid[];

actual_search_res_16:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		ROW(
			null,
			null,-- indsatsStatusTilsType[],
			null,-- indsatsPubliceretTilsType[],
			ARRAY[  ROW (
			'brugervendtnoegle_indsats_2' --text, 
			,null--'beskrivelse_indsats_2'-- text,
			, null--'2017-01-25 09:00'::timestamptz  -- starttidspunkt,
			, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
			,null--virkEgenskaber2
			) :: indsatsEgenskaberAttrType ]::indsatsEgenskaberAttrType[],
						null-- indsatsRelationType[]
						)::indsatsRegistreringType	
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,null  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,ARRAY[
			 ROW (
null --text, 
,null--'beskrivelse_indsats_2'-- text,
, '2017-01-25 09:00'::timestamptz   -- starttidspunkt,
, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[] --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_16 @> actual_search_res_16 and actual_search_res_16 @>expected_search_res_16 and coalesce(array_length(expected_search_res_16,1),0)=coalesce(array_length(actual_search_res_16,1),0), 'search indsats #16.');


/**************************************************/

expected_search_res_17:=array[new_uuid2,new_uuid1]::uuid[];

actual_search_res_17:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		ROW(
			null,
			null,-- indsatsStatusTilsType[],
			null,-- indsatsPubliceretTilsType[],
			ARRAY[  ROW (
			null --'brugervendtnoegle_indsats_2' --text, 
			,'beskrivelse_indsats_faelles'-- text,
			, null--'2017-01-25 09:00'::timestamptz  -- starttidspunkt,
			, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
			,null--virkEgenskaber2
			) :: indsatsEgenskaberAttrType ]::indsatsEgenskaberAttrType[],
						null-- indsatsRelationType[]
						)::indsatsRegistreringType	
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,null  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,ARRAY[
			 ROW (
null --text, 
,null--'beskrivelse_indsats_2'-- text,
, '2017-01-25 09:00'::timestamptz   -- starttidspunkt,
, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[] --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_17 @> actual_search_res_17 and actual_search_res_17 @>expected_search_res_17 and coalesce(array_length(expected_search_res_17,1),0)=coalesce(array_length(actual_search_res_17,1),0), 'search indsats #17.');


/**************************************************/

/**************************************************/

expected_search_res_18:=array[new_uuid1]::uuid[];

actual_search_res_18:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		ROW(
			null,
			null,-- indsatsStatusTilsType[],
			null,-- indsatsPubliceretTilsType[],
			ARRAY[  ROW (
			null --'brugervendtnoegle_indsats_2' --text, 
			,'beskrivelse_indsats_faelles'-- text,
			, null--'2017-01-25 09:00'::timestamptz  -- starttidspunkt,
			, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
			,null--virkEgenskaber2
			) :: indsatsEgenskaberAttrType ]::indsatsEgenskaberAttrType[],
						null-- indsatsRelationType[]
						)::indsatsRegistreringType	
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,null  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,ARRAY[
			 ROW (
null --text, 
,null--'beskrivelse_indsats_2'-- text,
, '2017-01-25 08:00'::timestamptz   -- starttidspunkt,
, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[] --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_18 @> actual_search_res_18 and actual_search_res_18 @>expected_search_res_18 and coalesce(array_length(expected_search_res_18,1),0)=coalesce(array_length(actual_search_res_18,1),0), 'search indsats #18.');

/**************************************************/

expected_search_res_19:=array[]::uuid[];

actual_search_res_19:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		ROW(
			null,
			null,-- indsatsStatusTilsType[],
			null,-- indsatsPubliceretTilsType[],
			ARRAY[  ROW (
			'brugervendtnoegle_indsats_2' --text, 
			,null --'beskrivelse_indsats_faelles'-- text,
			, null--'2017-01-25 09:00'::timestamptz  -- starttidspunkt,
			, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
			,null--virkEgenskaber2
			) :: indsatsEgenskaberAttrType ]::indsatsEgenskaberAttrType[],
						null-- indsatsRelationType[]
						)::indsatsRegistreringType	
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,null  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,ARRAY[
			 ROW (
null --text, 
,null--'beskrivelse_indsats_2'-- text,
, '2017-01-25 08:00'::timestamptz   -- starttidspunkt,
, null--'2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[] --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_19 @> actual_search_res_19 and actual_search_res_19 @>expected_search_res_19 and coalesce(array_length(expected_search_res_19,1),0)=coalesce(array_length(actual_search_res_19,1),0), 'search indsats #19.');

/**************************************************/

expected_search_res_20:=array[new_uuid1]::uuid[];

actual_search_res_20:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null	
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,null  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,ARRAY[
			 ROW (
null --text, 
,null--'beskrivelse_indsats_2'-- text,
, '2017-01-25 09:00'::timestamptz   -- starttidspunkt,
, '2017-04-01 18:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[] --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_20 @> actual_search_res_20 and actual_search_res_20 @>expected_search_res_20 and coalesce(array_length(expected_search_res_20,1),0)=coalesce(array_length(actual_search_res_20,1),0), 'search indsats #20.');

/**************************************************/

expected_search_res_21:=array[new_uuid1,new_uuid2]::uuid[];

actual_search_res_21:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null	
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,null  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,ARRAY[
			 ROW (
null --text, 
,null--'beskrivelse_indsats_2'-- text,
, null -- starttidspunkt
, '2017-06-01 12:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[] --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_21 @> actual_search_res_21 and actual_search_res_21 @>expected_search_res_21 and coalesce(array_length(expected_search_res_21,1),0)=coalesce(array_length(actual_search_res_21,1),0), 'search indsats #21.');

/**************************************************/
expected_search_res_22:=array[new_uuid1]::uuid[];

actual_search_res_22:=as_search_indsats(
		null,--firstResult
		null,--indsats_uuid
		null	
		,null --virkningSoeg	
		,null --maxResults
		,null --anyAttrValueArr
		,null --anyuuidArr
		,null --array[repraesentation_urn]::text[] --anyurnArr
		,null --auth_criteria_arr indsatsRegistreringType[]=null,
		,null  --search_operator_greater_then_attr_egenskaber indsatsEgenskaberAttrType[]=null,
		,ARRAY[
			 ROW (
null --text, 
,null--'beskrivelse_indsats_2'-- text,
, null -- starttidspunkt
, '2017-06-01 11:00'::timestamptz -- sluttidspunkt,
,null--virkEgenskaber2
) :: indsatsEgenskaberAttrType
		]::indsatsEgenskaberAttrType[] --search_operator_less_then_attr_egenskaber indsatsEgenskaberAttrType[]=null

);

RETURN NEXT ok(expected_search_res_22 @> actual_search_res_22 and actual_search_res_22 @>expected_search_res_22 and coalesce(array_length(expected_search_res_22,1),0)=coalesce(array_length(actual_search_res_22,1),0), 'search indsats #22.');




END;
$$;


ALTER FUNCTION test.test_as_search_indsats() OWNER TO mox;

--
-- Name: test_as_search_itsystem(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_search_itsystem() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuidA uuid;
	new_uuidB uuid;
	new_uuidC uuid;
	new_uuidD uuid;
	registreringA ItsystemRegistreringType;
	registreringB ItsystemRegistreringType;
	registreringC ItsystemRegistreringType;
	registreringD ItsystemRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaberA Virkning;
	virkAnsvarligA Virkning;
	virkOrganisationer1A Virkning;
	virkOrganisationer2A Virkning;
	virkGyldighedA Virkning;
	itsystemEgenskabA ItsystemEgenskaberAttrType;
	itsystemEgenskabB ItsystemEgenskaberAttrType;
	itsystemEgenskabC ItsystemEgenskaberAttrType;
	itsystemEgenskabD ItsystemEgenskaberAttrType;
	itsystemGyldighedA ItsystemGyldighedTilsType;
	itsystemRelAnsvarligA ItsystemRelationType;
	itsystemRelOrganisationer1A ItsystemRelationType;
	itsystemRelOrganisationer2A ItsystemRelationType;
	uuidAnsvarligA uuid :='be61544e-985f-4559-ac64-7034ae889d53'::uuid;
	uuidOrganisationer1A uuid :='981fe680-3881-4331-a64e-92fc253c687b'::uuid;
	uuidOrganisationer2A uuid :='0b1944e6-4c49-4a24-bf1b-bceef3b6f00f'::uuid;
	uuidRegistreringA uuid :='8076ac04-8099-4d0c-ba78-56d0c577023a'::uuid;
	search_result1 uuid[];
	search_result2 uuid[];
	search_result3 uuid[];
	search_result4 uuid[];
	search_result5 uuid[];
	expected_result2 uuid[];
	expected_result3 uuid[];
	expected_result4 uuid[];
	expected_result5 uuid[];
BEGIN
--ItsystemGyldighedTils AS ENUM ('Aktiv','Inaktiv','');


virkEgenskaberA :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          'ce61544e-985f-4559-ac64-7034ae889d53'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkAnsvarligA :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          'ae61544e-985f-4559-ac64-7034ae889d54'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkOrganisationer1A :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          'de61544e-985f-4559-ac64-7034ae889d51'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkOrganisationer2A :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          'ee61544e-985f-4559-ac64-7034ae889d52'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkGyldighedA := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          'be61544e-985f-4559-ac64-7034ae889d54'::uuid,
          'Bruger',
          'NoteEx10'
) :: Virkning
;

itsystemRelAnsvarligA := ROW (
	'tilhoerer'::ItsystemRelationKode,
		virkAnsvarligA,
	uuidAnsvarligA,
	null,
	null
) :: ItsystemRelationType
;


itsystemRelOrganisationer1A := ROW (
	'tilknyttedeorganisationer'::ItsystemRelationKode,
		virkOrganisationer1A,
	uuidOrganisationer1A,
	null,
	null
) :: ItsystemRelationType
;



itsystemRelOrganisationer2A := ROW (
	'tilknyttedeorganisationer'::ItsystemRelationKode,
		virkOrganisationer2A,
	uuidOrganisationer2A,
	null,
	null
) :: ItsystemRelationType
;


itsystemGyldighedA := ROW (
virkGyldighedA,
'Inaktiv'::ItsystemGyldighedTils
):: ItsystemGyldighedTilsType
;




itsystemEgenskabA := ROW (
'brugervendt_noegle_text1',
   'itsystemnavn_text1',
   'itsystemtype_text1',
   ARRAY['konfigurationreference_text1','konfigurationreference_text2','konfigurationreference_text3']::text[],
   virkEgenskaberA
) :: ItsystemEgenskaberAttrType
;

itsystemEgenskabB := ROW (
'brugervendt_noegle_text1',
   'itsystemnavn_text1',
   'itsystemtype_text1',
   ARRAY['konfigurationreference_text1B','konfigurationreference_text2B','konfigurationreference_text3B']::text[],
   virkEgenskaberA
) :: ItsystemEgenskaberAttrType
;

itsystemEgenskabC := ROW (
'brugervendt_noegle_text1',
   'itsystemnavn_text1',
   'itsystemtype_text1',
   ARRAY['konfigurationreference_text1C','konfigurationreference_text2C','konfigurationreference_text3C']::text[],
   virkEgenskaberA
) :: ItsystemEgenskaberAttrType
;

itsystemEgenskabD := ROW (
'brugervendt_noegle_text1',
   'itsystemnavn_text1',
   'itsystemtype_text1',
   ARRAY[]::text[],
   virkEgenskaberA
) :: ItsystemEgenskaberAttrType
;

registreringA := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistreringA,
	'Test Note 4') :: RegistreringBase
	,
ARRAY[itsystemGyldighedA]::ItsystemGyldighedTilsType[],
ARRAY[itsystemEgenskabA]::ItsystemEgenskaberAttrType[],
ARRAY[itsystemRelAnsvarligA,itsystemRelOrganisationer1A,itsystemRelOrganisationer2A]
) :: ItsystemRegistreringType
;

registreringB := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistreringA,
	'Test Note 5') :: RegistreringBase
	,
ARRAY[itsystemGyldighedA]::ItsystemGyldighedTilsType[],
ARRAY[itsystemEgenskabB]::ItsystemEgenskaberAttrType[],
ARRAY[itsystemRelAnsvarligA,itsystemRelOrganisationer1A,itsystemRelOrganisationer2A]
) :: ItsystemRegistreringType
;

registreringC := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistreringA,
	'Test Note 5') :: RegistreringBase
	,
ARRAY[itsystemGyldighedA]::ItsystemGyldighedTilsType[],
ARRAY[itsystemEgenskabC]::ItsystemEgenskaberAttrType[],
ARRAY[itsystemRelAnsvarligA,itsystemRelOrganisationer1A,itsystemRelOrganisationer2A]
) :: ItsystemRegistreringType
;


registreringD := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistreringA,
	'Test Note 5') :: RegistreringBase
	,
ARRAY[itsystemGyldighedA]::ItsystemGyldighedTilsType[],
ARRAY[itsystemEgenskabD]::ItsystemEgenskaberAttrType[], 
ARRAY[itsystemRelAnsvarligA,itsystemRelOrganisationer1A,itsystemRelOrganisationer2A]
) :: ItsystemRegistreringType
;

new_uuidA := as_create_or_import_itsystem(registreringA);
new_uuidB := as_create_or_import_itsystem(registreringB);
new_uuidC := as_create_or_import_itsystem(registreringC);
new_uuidD := as_create_or_import_itsystem(registreringD);


search_result1 :=as_search_itsystem(
	null,--TOOD ??
	null,
	ROW(
		null,
		null, --ARRAY[itsystemGyldighed]::ItsystemGyldighedTilsType[]
		ARRAY[
		ROW('brugervendt_noegle_text1',
   			'itsystemnavn_text1',
   			'itsystemtype_text1',
   			ARRAY['konfigurationreference_text1C']::text[],
   			virkEgenskaberA) ::ItsystemEgenskaberAttrType
		]::ItsystemEgenskaberAttrType[],
		null
		)::ItsystemRegistreringType,
	null,--registrering_A Facetregistrering_AType
	null--virkningSoeg
	);

RETURN NEXT is(
search_result1,
ARRAY[new_uuidC]::uuid[],
'simple search on a single konfigurationreference'
);

---------------------------------------------------

search_result2 :=as_search_itsystem(
	null,--TOOD ??
	null,
	ROW(
		null,
		null, --ARRAY[itsystemGyldighed]::ItsystemGyldighedTilsType[]
		ARRAY[
		ROW('brugervendt_noegle_text1',
   			'itsystemnavn_text1',
   			'itsystemtype_text1',
   			ARRAY['konfigurationreference_text%']::text[],
   			virkEgenskaberA) ::ItsystemEgenskaberAttrType
		]::ItsystemEgenskaberAttrType[],
		null
		)::ItsystemRegistreringType,
	null,--registrering_A Facetregistrering_AType
	null--virkningSoeg
	);

expected_result2:=ARRAY[new_uuidA,new_uuidB,new_uuidC]::uuid[];


RETURN NEXT ok(expected_result2 @> search_result2 and search_result2 @>expected_result2 and array_length(expected_result2,1)=array_length(search_result2,1), 'wildcard search on a single konfigurationreference');
---------------------------------------------------

search_result3 :=as_search_itsystem(
	null,--TOOD ??
	null,
	ROW(
		null,
		null, --ARRAY[itsystemGyldighed]::ItsystemGyldighedTilsType[]
		ARRAY[
		ROW('brugervendt_noegle_text1',
   			'itsystemnavn_text1',
   			'itsystemtype_text1',
   			ARRAY['konfigurationreference_text%','konfigurationreference_text2B']::text[],
   			virkEgenskaberA) ::ItsystemEgenskaberAttrType
		]::ItsystemEgenskaberAttrType[],
		null
		)::ItsystemRegistreringType,
	null,--registrering_A Facetregistrering_AType
	null--virkningSoeg
	);

expected_result3:=ARRAY[new_uuidB]::uuid[];


RETURN NEXT ok(expected_result3 @> search_result3 and search_result3 @>expected_result3 and array_length(expected_result3,1)=array_length(search_result3,1), 'wildcard search on 2 konfigurationreferencer, one with wildcard');
---------------------------------------------------

search_result4 :=as_search_itsystem(
	null,--TOOD ??
	null,
	ROW(
		null,
		null, --ARRAY[itsystemGyldighed]::ItsystemGyldighedTilsType[]
		ARRAY[
		ROW('brugervendt_noegle_text1',
   			'itsystemnavn_text1',
   			'itsystemtype_text1',
   			ARRAY[]::text[],
   			virkEgenskaberA) ::ItsystemEgenskaberAttrType
		]::ItsystemEgenskaberAttrType[],
		null
		)::ItsystemRegistreringType,
	null,--registrering_A Facetregistrering_AType
	null--virkningSoeg
	);

expected_result4:=ARRAY[new_uuidD]::uuid[];


RETURN NEXT ok(expected_result4 @> search_result4 and search_result4 @>expected_result4 and coalesce(array_length(expected_result4,1),0)=coalesce(array_length(search_result4,1),0), 'search on explicit empty array konfigurationreference');
---------------------------------------------------




END;
$$;


ALTER FUNCTION test.test_as_search_itsystem() OWNER TO mox;

--
-- Name: test_as_search_klasse(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_search_klasse() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid_A uuid;
	registrering_A KlasseRegistreringType;
	actual_registrering_A registreringBase;
	virkEgenskaber_A Virkning;
	virkAnsvarlig_A Virkning;
	virkRedaktoer1_A Virkning;
	virkRedaktoer2_A Virkning;
	virkPubliceret_A Virkning;
	klasseEgenskab_A KlasseEgenskaberAttrType;
	klassePubliceret_A KlassePubliceretTilsType;
	klasseRelAnsvarlig_A KlasseRelationType;
	klasseRelRedaktoer1_A KlasseRelationType;
	klasseRelRedaktoer2_A KlasseRelationType;
	klasseRelSideordnede3_A KlasseRelationType;
	uuidAnsvarlig_A uuid :=uuid_generate_v4();
	uuidRedaktoer1_A uuid :=uuid_generate_v4();
	uuidRedaktoer2_A uuid :=uuid_generate_v4();

	uuidregistrering_AB uuid :=uuid_generate_v4();
	klasseEgenskabA_Soegeord1 KlasseSoegeordType;
	klasseEgenskabA_Soegeord2 KlasseSoegeordType;

	new_uuid_B uuid;
	registrering_B KlasseRegistreringType;
	actual_registrering_B registreringBase;
	virkEgenskaber_B Virkning;
	virkAnsvarlig_B Virkning;
	virkRedaktoer1_B Virkning;
	virkRedaktoer2_B Virkning;
	virkPubliceret_B Virkning;
	virkpubliceret2_b Virkning;
	klasseEgenskab_B KlasseEgenskaberAttrType;
	klassePubliceret_B KlassePubliceretTilsType;
	klassePubliceret_B2 KlassePubliceretTilsType;
	klasseRelAnsvarlig_B KlasseRelationType;
	klasseRelRedaktoer1_B KlasseRelationType;
	klasseRelRedaktoer2_B KlasseRelationType;
	klasseRelSideordnede3_B KlasseRelationType;
	uuidAnsvarlig_B uuid :=uuid_generate_v4();
	uuidRedaktoer1_B uuid :=uuid_generate_v4();
	uuidRedaktoer2_B uuid :=uuid_generate_v4();
	
	klasseEgenskabB_Soegeord1 KlasseSoegeordType;
	klasseEgenskabB_Soegeord2 KlasseSoegeordType;
	klasseEgenskabB_Soegeord3 KlasseSoegeordType;
	klasseEgenskabB_Soegeord4 KlasseSoegeordType;


	uuidSideordnede_AB uuid :=uuid_generate_v4();
	virkSideordnede_AB_A Virkning;
	virkSideordnede_AB_B Virkning;

	new_uuid_C uuid;
	registrering_C KlasseRegistreringType;
	actual_registrering_C registreringBase;
	virkEgenskaber_C Virkning;
	virkAnsvarlig_C Virkning;
	virkRedaktoer1_C Virkning;
	virkRedaktoer2_C Virkning;
	virkPubliceret_C Virkning;
	virkpubliceret2_C Virkning;
	klasseEgenskab_C KlasseEgenskaberAttrType;
	klassePubliceret_C KlassePubliceretTilsType;
	klassePubliceret_C2 KlassePubliceretTilsType;
	klasseRelAnsvarlig_C KlasseRelationType;
	klasseRelRedaktoer1_C KlasseRelationType;
	klasseRelRedaktoer2_C KlasseRelationType;
	uuidAnsvarlig_C uuid :=uuid_generate_v4();
	uuidRedaktoer1_C uuid :=uuid_generate_v4();
	uuidRedaktoer2_C uuid :=uuid_generate_v4();
	uuidregistrering_C uuid :=uuid_generate_v4();


	search_result1 uuid[];
	search_result1A uuid[];
	search_result2 uuid[];
	search_result2A uuid[];
	search_result3 uuid[];
	search_result3A uuid[];
	search_result4 uuid[];
	search_result5 uuid[];
	search_result6 uuid[];
	search_result7 uuid[];
	search_result8 uuid[];
	search_result9 uuid[];
	search_result10 uuid[];
	search_result11 uuid[];
	search_result12 uuid[];
	search_result13 uuid[];
	search_result14 uuid[];
	search_result15 uuid[];
	search_result16 uuid[];
	search_result17 uuid[];
	search_result18 uuid[];
	search_result19 uuid[];
	search_result20 uuid[];
	search_result21 uuid[];
	search_result22 uuid[];
	search_result23 uuid[];
	search_result24 uuid[];
	search_result25 uuid[];
	search_result26 uuid[];
	search_result27 uuid[];
	search_result28 uuid[];
	search_result29 uuid[];
	search_result30 uuid[];
	search_result31 uuid[];
	search_result32 uuid[];
	search_result33 uuid[];
	search_result34 uuid[];
	search_result35 uuid[];
	search_result36 uuid[];
	search_result37 uuid[];
	search_result38 uuid[];
	search_result39 uuid[];
	search_result40 uuid[];
	search_result41 uuid[];
	search_result42 uuid[];
	search_result43 uuid[];
	search_result44 uuid[];
	search_result45 uuid[];
	search_result46 uuid[];
	search_result47 uuid[];
	search_result48 uuid[];
	search_result49 uuid[];

	search_result200 uuid[];

	expected_result2 uuid[];
	expected_result2A uuid[];
	expected_result3A uuid[];
	expected_result4 uuid[];
	expected_result8 uuid[];
	expected_result9 uuid[];
	expected_result10 uuid[];
	expected_result11 uuid[];
	expected_result12 uuid[];
	expected_result13 uuid[];
	expected_result14 uuid[];
	expected_result15 uuid[];
	expected_result16 uuid[];
	expected_result17 uuid[];
	expected_result18 uuid[];
	expected_result19 uuid[];
	expected_result20 uuid[];
	expected_result21 uuid[];
	expected_result22 uuid[];
	expected_result23 uuid[];
	expected_result24 uuid[];
	expected_result25 uuid[];
	expected_result26 uuid[];
	expected_result27 uuid[];
	expected_result28 uuid[];
	expected_result29 uuid[];
	expected_result30 uuid[];
	expected_result31 uuid[];
	expected_result32 uuid[];
	expected_result33 uuid[];
	expected_result34 uuid[];
	expected_result35 uuid[];
	expected_result36 uuid[];
	expected_result37 uuid[];
	expected_result38 uuid[];
	expected_result39 uuid[];
	expected_result40 uuid[];
	expected_result41 uuid[];
	expected_result42 uuid[];
	expected_result43 uuid[];
	expected_result44 uuid[];
	expected_result45 uuid[];
	expected_result46 uuid[];
	expected_result47 uuid[];
	expected_result48 uuid[];
	expected_result49 uuid[];

	expected_result200 uuid[];

	search_registrering_3 KlasseRegistreringType;
	search_registrering_3A KlasseRegistreringType;
	search_registrering_4 KlasseRegistreringType;
	search_registrering_5 KlasseRegistreringType;
	search_registrering_6 KlasseRegistreringType;
	search_registrering_7 KlasseRegistreringType;
	search_registrering_8 KlasseRegistreringType;
	search_registrering_9 KlasseRegistreringType;
	search_registrering_10 KlasseRegistreringType;
	search_registrering_11 KlasseRegistreringType;
	search_registrering_12 KlasseRegistreringType;
	search_registrering_13 KlasseRegistreringType;
	search_registrering_14 KlasseRegistreringType;
	search_registrering_15 KlasseRegistreringType;
	search_registrering_16 KlasseRegistreringType;
	search_registrering_17 KlasseRegistreringType;
	search_registrering_18 KlasseRegistreringType;
	search_registrering_19 KlasseRegistreringType;
	search_registrering_20 KlasseRegistreringType;
	search_registrering_21 KlasseRegistreringType;
	search_registrering_22 KlasseRegistreringType;
	search_registrering_23 KlasseRegistreringType;
	search_registrering_24 KlasseRegistreringType;
	search_registrering_25 KlasseRegistreringType;
	search_registrering_26 KlasseRegistreringType;
	search_registrering_27 KlasseRegistreringType;
	search_registrering_28 KlasseRegistreringType;
	search_registrering_29 KlasseRegistreringType;
	search_registrering_30 KlasseRegistreringType;
	search_registrering_31 KlasseRegistreringType;
	search_registrering_32 KlasseRegistreringType;
	search_registrering_33 KlasseRegistreringType;
	search_registrering_34 KlasseRegistreringType;
	search_registrering_35 KlasseRegistreringType;
	search_registrering_36 KlasseRegistreringType;
	search_registrering_37 KlasseRegistreringType;
	search_registrering_38 KlasseRegistreringType;
	search_registrering_39 KlasseRegistreringType;
	search_registrering_40 KlasseRegistreringType;
	search_registrering_41 KlasseRegistreringType;
	search_registrering_42 KlasseRegistreringType;
	search_registrering_43 KlasseRegistreringType;
	search_registrering_44 KlasseRegistreringType;
	search_registrering_45 KlasseRegistreringType;
	search_registrering_46 KlasseRegistreringType;
	search_registrering_47 KlasseRegistreringType;
	search_registrering_48 KlasseRegistreringType;
	search_registrering_49 KlasseRegistreringType;

	search_registrering_200 KlasseRegistreringType;

	update_reg_id bigint;
	rows_affected int;
	read_Klasse1 KlasseType;
	read_Klasse2 KlasseType;
	read_Klasse3 KlasseType;
BEGIN


virkEgenskaber_A :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkAnsvarlig_A :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1_A :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2_A :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;


virkPubliceret_A := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkSideordnede_AB_A := ROW (
	'[2015-03-20, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

klasseRelAnsvarlig_A := ROW (
	'ansvarlig'::KlasseRelationKode,
		virkAnsvarlig_A,
	uuidAnsvarlig_A,
	null,
	null
) :: KlasseRelationType
;


klasseRelRedaktoer1_A := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer1_A,
	uuidRedaktoer1_A,
	null,
	null
) :: KlasseRelationType
;



klasseRelRedaktoer2_A := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer2_A,
	uuidRedaktoer2_A,
	null,
	null
) :: KlasseRelationType
;

klasseRelSideordnede3_A := ROW (
	'sideordnede'::KlasseRelationKode,
		virkSideordnede_AB_A,
	uuidSideordnede_AB,
	null,
	null
) :: KlasseRelationType
;


klassePubliceret_A := ROW (
virkPubliceret_A,
'Publiceret'
):: KlassePubliceretTilsType
;

klasseEgenskabA_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabA_Soegeord1',
'beskrivelse_klasseEgenskabA_Soegeord1',
'faellessogeord2'
)::KlasseSoegeordType
;
klasseEgenskabA_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabA_Soegeord2',
'beskrivelse_klasseEgenskabA_Soegeord2',
'faellessogeord1'
)::KlasseSoegeordType
;

klasseEgenskab_A := ROW (
'brugervendt_noegle_A',
   'klassebeskrivelse_A',
   'eksempel_faelles',
	'omfang_AB',
   'titel_A',
   'retskilde_A',
   NULL,--'aendringsnotat_text1',
   ARRAY[klasseEgenskabA_Soegeord1,klasseEgenskabA_Soegeord2]::KlasseSoegeordType[], 
   virkEgenskaber_A
) :: KlasseEgenskaberAttrType
;

registrering_A := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidregistrering_AB,
	'Test Note 4') :: registreringBase
	,
ARRAY[klassePubliceret_A]::KlassePubliceretTilsType[],
ARRAY[klasseEgenskab_A]::KlasseEgenskaberAttrType[],
ARRAY[klasseRelAnsvarlig_A,klasseRelRedaktoer1_A,klasseRelRedaktoer2_A,klasseRelSideordnede3_A]
) :: KlasseRegistreringType
;

new_uuid_A := as_create_or_import_klasse(registrering_A);



--*******************


virkEgenskaber_B :=	ROW (
	'[2015-04-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkAnsvarlig_B :=	ROW (
	'[2015-04-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1_B :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2_B :=	ROW (
	'[2015-04-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkSideordnede_AB_B := ROW (
	'[2014-01-20, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx11'
) :: Virkning
;

virkPubliceret_B := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkPubliceret2_B := ROW (
	'[2014-05-18, 2015-05-18)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx143'
) :: Virkning
;


klasseRelAnsvarlig_B := ROW (
	'ansvarlig'::KlasseRelationKode,
		virkAnsvarlig_B,
	uuidAnsvarlig_B,
	null,
	null
) :: KlasseRelationType
;


klasseRelRedaktoer1_B := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer1_B,
	uuidRedaktoer1_B,
	null,
	null
) :: KlasseRelationType
;



klasseRelRedaktoer2_B := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer2_B,
	uuidRedaktoer2_B,
	null,
	null
) :: KlasseRelationType
;

klasseRelSideordnede3_B := ROW (
	'sideordnede'::KlasseRelationKode,
		virkSideordnede_AB_B,
	uuidSideordnede_AB,
	null,
	null
) :: KlasseRelationType
;


klassePubliceret_B := ROW (
virkPubliceret_B,
'Publiceret'
):: KlassePubliceretTilsType
;

klassePubliceret_B2 := ROW (
virkPubliceret2_B,
'IkkePubliceret'
):: KlassePubliceretTilsType
;



klasseEgenskabB_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord1',
'beskrivelse_klasseEgenskabB_Soegeord1',
'soegeordskategori_klasseEgenskabB_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabB_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord2',
'beskrivelse_klasseEgenskabB_Soegeord2',
'soegeordskategori_klasseEgenskabB_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabB_Soegeord3 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord3',
'beskrivelse_klasseEgenskabB_Soegeord3',
'faellessogeord1'
)::KlasseSoegeordType
;
klasseEgenskabB_Soegeord4 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord4',
'beskrivelse_klasseEgenskabB_Soegeord4',
'faellessogeord2'
)::KlasseSoegeordType
;

klasseEgenskab_B := ROW (
'brugervendt_noegle_B',
   'klassebeskrivelse_B',
   'eksempel_faelles',
	'omfang_AB',
   'titel_B',
   'retskilde_B',
   NULL, --aendringsnotat
    ARRAY[klasseEgenskabB_Soegeord1,klasseEgenskabB_Soegeord2,klasseEgenskabB_Soegeord3,klasseEgenskabB_Soegeord4]::KlasseSoegeordType[], --soegeord
   virkEgenskaber_B
) :: KlasseEgenskaberAttrType
;

registrering_B := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidregistrering_AB,
	'Test Note 5') :: registreringBase
	,
ARRAY[klassePubliceret_B,klassePubliceret_B2]::KlassePubliceretTilsType[],
ARRAY[klasseEgenskab_B]::KlasseEgenskaberAttrType[],
ARRAY[klasseRelAnsvarlig_B,klasseRelRedaktoer1_B,klasseRelRedaktoer2_B,klasseRelSideordnede3_B]
) :: KlasseRegistreringType
;

new_uuid_B := as_create_or_import_klasse(registrering_B);


--***********************************


search_result1 :=as_search_klasse(
	null,--TOOD ??
	new_uuid_A,
	ROW (
		ROW(
			TSTZRANGE(current_timestamp,clock_timestamp(),'[]')
			--TSTZRANGE('2014-01-01','2015-01-01','[]')
			,null--Livscykluskode
			,null --uuid
			,null --test note
			)::registreringBase
		,null --KlassePubliceretTilsType
		,null --KlasseEgenskaberAttrType
		,null --relationer
		)::KlasseRegistreringType
	,null--virkningSoeg
	);

RETURN NEXT is(
search_result1,
ARRAY[new_uuid_A]::uuid[],
'simple search on single uuid'
);


search_result1A :=as_search_klasse(
	null,--TOOD ??
	new_uuid_A,
	ROW (
		ROW(
			TSTZRANGE('2014-01-01','2015-01-01','[]')
			,null--Livscykluskode
			,null --uuid
			,null --test note
			)::registreringBase
		,null --KlassePubliceretTilsType
		,null --KlasseEgenskaberAttrType
		,null --relationer
		)::KlasseRegistreringType
	,null--virkningSoeg
	);

RETURN NEXT is(
search_result1A,
ARRAY[]::uuid[],
'simple search on single uuid, with irrelevant system reg time.'
);

--***********************************

search_result2 :=as_search_klasse(
	null,--TOOD ??
	null,
	null,--registrering_A Klasseregistrering_AType
	null--virkningSoeg
	);

expected_result2:=ARRAY[new_uuid_A,new_uuid_B]::uuid[];


RETURN NEXT ok(expected_result2 @> search_result2 and search_result2 @>expected_result2 and array_length(expected_result2,1)=array_length(search_result2,1), 'search null params');



--***********************************
search_result2A :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE('2014-01-01','2014-01-01','[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,null--virkningSoeg
	);

expected_result2A:=ARRAY[]::uuid[];


RETURN NEXT ok(coalesce(array_length(expected_result2A,1),0)=coalesce(array_length(search_result2A,1),0), 'search null params, except for system reg. time');


--***********************************

--search on klasses that has had the state not published at any point in time

search_registrering_3 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	null,null,null,null
				  	)::virkning 
				  ,'IkkePubliceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
null,--ARRAY[klasseEgenskab_B]::KlasseEgenskaberAttrType[],
null--ARRAY[klasseRelAnsvarlig_B,klasseRelRedaktoer1_B,klasseRelRedaktoer2_B]
):: KlasseRegistreringType;

--raise notice 'search_registrering_3,%',search_registrering_3;

search_result3 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_3 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

--raise notice 'search for IkkePubliceret returned:%',search_result3;

RETURN NEXT is(
search_result3,
ARRAY[new_uuid_B]::uuid[],
'search state KlassePubliceretTils IkkePubliceret'
);

--***********************************
--search on klasses that has had the state not published at any point in time (but with "invalid" system.reg time )

search_registrering_3A := ROW (
	ROW (
	TSTZRANGE('2014-01-01','2014-12-31','[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	null,null,null,null
				  	)::virkning 
				  ,'IkkePubliceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
null,--ARRAY[klasseEgenskab_B]::KlasseEgenskaberAttrType[],
null--ARRAY[klasseRelAnsvarlig_B,klasseRelRedaktoer1_B,klasseRelRedaktoer2_B]
):: KlasseRegistreringType;

--raise notice 'search_registrering_3A,%',search_registrering_3A;

search_result3A :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_3A --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

--raise notice 'search for IkkePubliceret returned:%',search_result3A;

RETURN NEXT is(
search_result3A,
ARRAY[]::uuid[],
'search state KlassePubliceretTils IkkePubliceret, system.reg time'
);

--***********************************
--search on klasses that were published on 18-05-2015
search_registrering_4 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-18, 2015-05-19]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
null,--ARRAY[klasseEgenskab_B]::KlasseEgenskaberAttrType[],
null--ARRAY[klasseRelAnsvarlig_B,klasseRelRedaktoer1_B,klasseRelRedaktoer2_B]
):: KlasseRegistreringType;



search_result4 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_4 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

expected_result4=ARRAY[new_uuid_A,new_uuid_B]::uuid[];


RETURN NEXT ok(expected_result4 @> search_result4 and search_result4 @>expected_result4 and array_length(expected_result4,1)=array_length(search_result4,1), 'search state KlassePubliceretTils Publiceret on 18-05-2015 - 19-05-2015');


--***********************************
--search on klasses that had state 'ikkepubliceret' on 30-06-2015 30-07-2015
search_registrering_5 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-06-30, 2015-07-30]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'IkkePubliceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
null,--ARRAY[klasseEgenskab_B]::KlasseEgenskaberAttrType[],
null--ARRAY[klasseRelAnsvarlig_B,klasseRelRedaktoer1_B,klasseRelRedaktoer2_B]
):: KlasseRegistreringType;



search_result5 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_5 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

RETURN NEXT is(
search_result5,
ARRAY[]::uuid[],
'search state KlassePubliceretTils ikkepubliceret on 30-06-2015 30-07-2015'
);

--***********************************
--search on klasses with specific aktoerref and state publiceret
search_registrering_6 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-18, 2015-05-19]' :: TSTZRANGE,
				  	(virkPubliceret_B).AktoerRef,
				  	null,null
				  	)::virkning 
				  ,'Publiceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
null,--ARRAY[klasseEgenskab_B]::KlasseEgenskaberAttrType[],
null--ARRAY[klasseRelAnsvarlig_B,klasseRelRedaktoer1_B,klasseRelRedaktoer2_B]
):: KlasseRegistreringType;

search_result6 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_6 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

RETURN NEXT is(
search_result6,
ARRAY[new_uuid_B]::uuid[],
'search on klasses with specific aktoerref and state publiceret'
);


--*******************


virkEgenskaber_C :=	ROW (
	'[2014-09-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkAnsvarlig_C :=	ROW (
	'[2014-08-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1_C :=	ROW (
	'[2014-07-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2_C :=	ROW (
	'[2013-04-10, 2015-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret_C := ROW (
	'[2015-02-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkPubliceret2_C := ROW (
	'[2013-05-18, 2015-02-18)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx143'
) :: Virkning
;


klasseRelAnsvarlig_C := ROW (
	'ansvarlig'::KlasseRelationKode,
		virkAnsvarlig_C,
	uuidAnsvarlig_C,
	null,
	null
) :: KlasseRelationType
;


klasseRelRedaktoer1_C := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer1_C,
	uuidRedaktoer1_C,
	null,
	null
) :: KlasseRelationType
;



klassePubliceret_C := ROW (
virkPubliceret_C,
'Publiceret'
):: KlassePubliceretTilsType
;

klassePubliceret_C2 := ROW (
virkPubliceret2_C,
'IkkePubliceret'
):: KlassePubliceretTilsType
;



klasseEgenskab_C := ROW (
'brugervendt_noegle_C',
   'klassebeskrivelse_C',
   'eksempel_faelles',
	'omfang_C',
   'titel_C',
   'retskilde_C',
   'aendringsnotat_C', --aendringsnotat
    NULL, --soegeord
   virkEgenskaber_C
) :: KlasseEgenskaberAttrType
;


registrering_C := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidregistrering_C,
	'Test Note 1000') :: registreringBase
	,
ARRAY[klassePubliceret_C,klassePubliceret_C2]::KlassePubliceretTilsType[],
ARRAY[klasseEgenskab_C]::KlasseEgenskaberAttrType[],
ARRAY[klasseRelAnsvarlig_C,klasseRelRedaktoer1_C]
) :: KlasseRegistreringType
;

new_uuid_C := as_create_or_import_klasse(registrering_C);

--*******************
--Do a test, that filters on publiceretStatus, egenskaber and relationer



search_registrering_7 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-18, 2015-05-19]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
ARRAY[
	ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        NULL, --eksempel
   		NULL, --omfang
   		NULL, --titel
   		'retskilde_C',
   		NULL, --aendringsnotat
   		NULL, --soegeord
   			ROW(
				  	'[2015-01-01, 2015-02-01]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
		)::KlasseEgenskaberAttrType
]::KlasseEgenskaberAttrType[],
ARRAY[
	ROW (
	'redaktoerer'::KlasseRelationKode,
		ROW(
				'[2013-05-01, 2015-04-11]' :: TSTZRANGE,
				 null,null,null
			)::virkning ,
			null,
			null,
			null
	) :: KlasseRelationType
]
):: KlasseRegistreringType;



search_result7 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_7 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

RETURN NEXT is(
search_result7,
ARRAY[new_uuid_C]::uuid[],
'search state publiceretStatus, egenskaber and relationer combined'
);


--*******************
--Do a test, that filters on publiceretStatus, egenskaber and relationer


search_registrering_8 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-18, 2015-05-19]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
ARRAY[]::KlasseEgenskaberAttrType[],
ARRAY[
	ROW (
	'redaktoerer'::KlasseRelationKode,
		ROW(
				'[2013-05-01, 2015-04-11]' :: TSTZRANGE,
				 null,null,null
			)::virkning ,
			null,
			null,
			null
	) :: KlasseRelationType
]
):: KlasseRegistreringType;


search_result8 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_8 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

expected_result8:=ARRAY[new_uuid_B,new_uuid_C]::uuid[];

RETURN NEXT ok(expected_result8 @> search_result8 and search_result8 @>expected_result8 and array_length(expected_result8,1)=array_length(search_result8,1), 'search state publiceretStatus and relationer combined');

--*******************
--Do a test, that filters on soegeord



search_registrering_9 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-19, 2015-05-19]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
ARRAY[

ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        'eksempel_faelles', --eksempel
   		NULL, --omfang
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		ARRAY[ROW(null,null,'faellessogeord2')::KlasseSoegeordType], --soegeord
   			ROW(
				  	'[2015-05-13, 2015-05-14]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
		)::KlasseEgenskaberAttrType


]::KlasseEgenskaberAttrType[],
null
):: KlasseRegistreringType;


search_result9 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_9 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

expected_result9:=ARRAY[new_uuid_A,new_uuid_B]::uuid[];

RETURN NEXT ok(expected_result9 @> search_result9 and search_result9 @>expected_result9 and array_length(expected_result9,1)=array_length(search_result9,1), 'search state publiceretStatus and soegeord combined');

---*******************
--Do a test, that filters on soegeord (2)



search_registrering_10 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-19, 2015-05-19]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
ARRAY[

ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        NULL, --eksempel
   		NULL, --omfang
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		ARRAY[ROW(null,null,'faellessogeord1')::KlasseSoegeordType], --soegeord
   			ROW(
				  	'[2015-04-13, 2015-04-14]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
		)::KlasseEgenskaberAttrType


]::KlasseEgenskaberAttrType[],
null
):: KlasseRegistreringType;


search_result10 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_10 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

expected_result10:=ARRAY[new_uuid_B]::uuid[];

RETURN NEXT ok(expected_result10 @> search_result10 and search_result10 @>expected_result10 and array_length(expected_result10,1)=array_length(search_result10,1), 'search state publiceretStatus and soegeord combined 2');


--Do a test, that filters on soegeord (3)



search_registrering_11 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-19, 2015-05-19]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
ARRAY[

ROW(
		NULL, --brugervendtnoegle
   		'klassebeskrivelse_C', --beskrivelse
        NULL, --eksempel
   		NULL, --omfang
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		ARRAY[ROW(null,null,'faellessogeord2')::KlasseSoegeordType], --soegeord
   			ROW(
				  	'[2015-05-13, 2015-05-14]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
		)::KlasseEgenskaberAttrType


]::KlasseEgenskaberAttrType[],
null
):: KlasseRegistreringType;


search_result11 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_11 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

expected_result11:=ARRAY[]::uuid[];

--raise notice 'search_result11:%, length:%',search_result11,array_length(search_result11,1);

RETURN NEXT ok(coalesce(array_length(search_result11, 1), 0)=0 , 'search state publiceretStatus and soegeord combined 3');

---*******************
--search state publiceretStatus and common egenskab 



search_registrering_12 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-05-19, 2015-05-19]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
ARRAY[

ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        'eksempel_faelles', --eksempel
   		NULL, --omfang
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		NULL, --soegeord
   			ROW(
				  	'[2015-05-13, 2015-05-20]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
		)::KlasseEgenskaberAttrType


]::KlasseEgenskaberAttrType[],
null
):: KlasseRegistreringType;


search_result12 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_12 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

expected_result12:=ARRAY[new_uuid_A,new_uuid_B,new_uuid_C]::uuid[];

RETURN NEXT ok(expected_result12 @> search_result12 and search_result12 @>expected_result12 and array_length(expected_result12,1)=array_length(search_result12,1), 'search state publiceretStatus and common egenskab');




---*******************
--Test global virksg 1


search_registrering_13 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
ARRAY[

ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        'eksempel_faelles', --eksempel
   		NULL, --omfang
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		NULL, --soegeord
   			null
		)::KlasseEgenskaberAttrType


]::KlasseEgenskaberAttrType[],
null
):: KlasseRegistreringType;


search_result13 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_13, --registrering_A Klasseregistrering_AType
	'[2014-10-01, 2014-10-20]' :: TSTZRANGE --virkningSoeg
	);



expected_result13:=ARRAY[new_uuid_C]::uuid[];

RETURN NEXT ok(expected_result13 @> search_result13 and search_result13 @>expected_result13 and array_length(expected_result13,1)=array_length(search_result13,1), 'Test global virksg 1');


--Test global virksg 2


search_registrering_14 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
ARRAY[

ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        'eksempel_faelles', --eksempel
   		NULL, --omfang
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		NULL, --soegeord
   			null
		)::KlasseEgenskaberAttrType


]::KlasseEgenskaberAttrType[],
null
):: KlasseRegistreringType;


search_result14 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_14, --registrering_A Klasseregistrering_AType
	'[2014-10-01, 2015-04-12]' :: TSTZRANGE --virkningSoeg
	);

expected_result14:=ARRAY[new_uuid_C,new_uuid_B]::uuid[];

RETURN NEXT ok(expected_result14 @> search_result14 and search_result14 @>expected_result14 and array_length(expected_result14,1)=array_length(search_result14,1), 'Test global virksg 2');


--**************************************************
--Test global virksg 3


search_registrering_15 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
ARRAY[

ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        'eksempel_faelles', --eksempel
   		NULL, --omfang
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		NULL, --soegeord
   			ROW(
				  	'[2014-12-20, 2014-12-23]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning
		)::KlasseEgenskaberAttrType


]::KlasseEgenskaberAttrType[],
null
):: KlasseRegistreringType;


search_result15 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_15, --registrering_A Klasseregistrering_AType
	'[2014-10-01, 2015-04-12]' :: TSTZRANGE --virkningSoeg --NOTICE: Should we overruled by more specific virkning supplied above
	);

expected_result15:=ARRAY[new_uuid_C]::uuid[];

--raise notice 'Test global virksg 3:search_result15:%',to_json(search_result15);

--raise notice 'Test global virksg 3:expected_result15:%',to_json(expected_result15);

RETURN NEXT ok(expected_result15 @> search_result15 and search_result15 @>expected_result15 and array_length(expected_result15,1)=array_length(search_result15,1), 'Test global virksg 3');


--**************************************************
--Test global virksg 4


--***********************************
search_registrering_16 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2015-03-18, 2015-04-19]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
null,--ARRAY[klasseEgenskab_B]::KlasseEgenskaberAttrType[],
null--ARRAY[klasseRelAnsvarlig_B,klasseRelRedaktoer1_B,klasseRelRedaktoer2_B]
):: KlasseRegistreringType;


search_result16 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_16 --registrering_A Klasseregistrering_AType
	,'[2015-01-01, 2015-05-19]' :: TSTZRANGE --virkningSoeg --ATTENTION: Should be overruled by the more specific virkning above
	);

expected_result16=ARRAY[new_uuid_C]::uuid[];

--raise notice 'Test global virksg 5:search_result16:%',to_json(search_result16);

--raise notice 'Test global virksg 5:expected_result16:%',to_json(expected_result16);

RETURN NEXT ok(expected_result16 @> search_result16 and search_result16 @>expected_result16 and array_length(expected_result16,1)=array_length(search_result16,1), 'Test global virksg 4');


--***********************************
--Test global virksg 5
search_registrering_17 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  NULL--virkning 
				  ,'Publiceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
null,--ARRAY[klasseEgenskab_B]::KlasseEgenskaberAttrType[],
null--ARRAY[klasseRelAnsvarlig_B,klasseRelRedaktoer1_B,klasseRelRedaktoer2_B]
):: KlasseRegistreringType;


search_result17 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_17 --registrering_A Klasseregistrering_AType
	,'[2015-01-01, 2015-02-19]' :: TSTZRANGE --virkningSoeg 
	);

expected_result17=ARRAY[new_uuid_C]::uuid[];

/*
raise notice 'Test global virksg 5:search_result17:%',to_json(search_result17);

raise notice 'Test global virksg 5:expected_result17:%',to_json(expected_result17);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result17 @> search_result17 and search_result17 @>expected_result17 and array_length(expected_result17,1)=array_length(search_result17,1), 'Test global virksg 5');

--***********************************
--'Test global virksg 6'

search_registrering_18 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
null,--ARRAY[klasseEgenskab_B]::KlasseEgenskaberAttrType[],
null--ARRAY[klasseRelAnsvarlig_B,klasseRelRedaktoer1_B,klasseRelRedaktoer2_B]
):: KlasseRegistreringType;


search_result18 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_18 --registrering_A Klasseregistrering_AType
	,'[2015-01-01, 2015-02-19]' :: TSTZRANGE --virkningSoeg 
	);

expected_result18=ARRAY[new_uuid_A,new_uuid_B,new_uuid_C]::uuid[];

/*
raise notice 'Test global virksg 5:search_result18:%',to_json(search_result18);

raise notice 'Test global virksg 5:expected_result18:%',to_json(expected_result18);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result18 @> search_result18 and search_result18 @>expected_result18 and array_length(expected_result18,1)=array_length(search_result18,1), 'Test global virksg 6');


--***********************************
--'Test global virksg 7'




search_registrering_19 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
	null,
ARRAY[
	ROW (
	'redaktoerer'::KlasseRelationKode,
		ROW(
				'[2013-05-01, 2015-04-11]' :: TSTZRANGE,
				 null,null,null
			)::virkning ,
			null,
			null,
			null
	) :: KlasseRelationType
]
):: KlasseRegistreringType;


expected_result19:=ARRAY[new_uuid_B,new_uuid_C]::uuid[];


search_result19 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_19 --registrering_A Klasseregistrering_AType
	,'[2013-01-01, 2016-01-01]' :: TSTZRANGE --virkningSoeg  --NOTICE: Should be overridden by more specific virkning above
	);

/*
raise notice 'Test global virksg 5:search_result19:%',to_json(search_result19);

raise notice 'Test global virksg 5:expected_result19:%',to_json(expected_result19);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result19 @> search_result19 and search_result19 @>expected_result19 and array_length(expected_result19,1)=array_length(search_result19,1), 'Test global virksg 7');

--'Test global virksg 8'


search_registrering_20 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
	null,
ARRAY[
	ROW (
	'redaktoerer'::KlasseRelationKode,
		null,--virkning 
			null,
			null,
			null
	) :: KlasseRelationType
]
):: KlasseRegistreringType;


expected_result20:=ARRAY[new_uuid_C]::uuid[];


search_result20 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_20 --registrering_A Klasseregistrering_AType
	,'[2014-08-01, 2014-08-01]' :: TSTZRANGE --virkningSoeg 
	);

/*
raise notice 'Test global virksg 5:search_result20:%',to_json(search_result20);

raise notice 'Test global virksg 5:expected_result20:%',to_json(expected_result20);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result20 @> search_result20 and search_result20 @>expected_result20 and array_length(expected_result20,1)=array_length(search_result20,1), 'Test global virksg 8');

--******************************

--'Test global virksg 9'


search_registrering_21 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
	null,
ARRAY[
	ROW (
	'overordnetklasse'::KlasseRelationKode,
		null,--virkning 
			null,
			null,
			null
	) :: KlasseRelationType
]
):: KlasseRegistreringType;


expected_result21:=ARRAY[]::uuid[];


search_result21 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_21 --registrering_A Klasseregistrering_AType
	,'[2014-08-01, 2014-08-01]' :: TSTZRANGE --virkningSoeg 
	);

/*
raise notice 'Test global virksg 5:search_result21:%',to_json(search_result21);

raise notice 'Test global virksg 5:expected_result21:%',to_json(expected_result21);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok( coalesce(array_length(expected_result21,1),0)=coalesce(array_length(search_result21,1),0), 'Test global virksg 9');


--******************************
--Test multiple tilstande requirements 


search_registrering_22 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	'[2013-06-01, 2013-06-30]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'IkkePubliceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
			,ROW(
				  ROW(
				  	'[2015-02-19, 2016-01-30]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning 
				  ,'Publiceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
			
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
null,--ARRAY[klasseEgenskab_B]::KlasseEgenskaberAttrType[],
null--ARRAY[klasseRelAnsvarlig_B,klasseRelRedaktoer1_B,klasseRelRedaktoer2_B]
):: KlasseRegistreringType;




expected_result22:=ARRAY[new_uuid_C]::uuid[];


search_result22 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_22 --registrering_A Klasseregistrering_AType
	,null
	);

/*
raise notice 'Test global virksg 5:search_result22:%',to_json(search_result22);

raise notice 'Test global virksg 5:expected_result22:%',to_json(expected_result22);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result22 @> search_result22 and search_result22 @>expected_result22 and array_length(expected_result22,1)=array_length(search_result22,1), 'Test multiple tilstande requirements');


--******************************
--Test multiple attribute requirements 



search_registrering_23 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
ARRAY[

ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        'eksempel_faelles', --eksempel
   		NULL, --omfang
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		NULL, --soegeord
   			null
		)::KlasseEgenskaberAttrType
,
ROW(
		NULL, --brugervendtnoegle
   		'klassebeskrivelse_A', --beskrivelse
        NULL, --eksempel
   		NULL, --omfang
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		NULL, --soegeord
   			null
		)::KlasseEgenskaberAttrType

]::KlasseEgenskaberAttrType[],
null
):: KlasseRegistreringType;


expected_result23:=ARRAY[new_uuid_A]::uuid[];


search_result23 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_23 --registrering_A Klasseregistrering_AType
	,null
	);

/*
raise notice 'Test global virksg 5:search_result23:%',to_json(search_result23);

raise notice 'Test global virksg 5:expected_result23:%',to_json(expected_result23);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result23 @> search_result23 and search_result23 @>expected_result23 and array_length(expected_result23,1)=array_length(search_result23,1), 'Test multiple attribute requirements');

--******************************
--Test multiple relations requirements 


search_registrering_24 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
	null,
ARRAY[
	ROW (
	'redaktoerer'::KlasseRelationKode,
		ROW(
				  	'[2015-05-10, 2015-07-30]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning, 
			null,
			null,
			null
	) :: KlasseRelationType,
	ROW (
	'redaktoerer'::KlasseRelationKode,
		ROW(
				  	'[2015-04-20, 2015-04-20]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning, 
			null,
			null,
			null
	) :: KlasseRelationType
]
):: KlasseRegistreringType;



expected_result24:=ARRAY[new_uuid_C,new_uuid_B]::uuid[];


search_result24 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_24 --registrering_A Klasseregistrering_AType
	,null
	);

/*
raise notice 'Test global virksg 5:search_result24:%',to_json(search_result24);

raise notice 'Test global virksg 5:expected_result24:%',to_json(expected_result24);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result24 @> search_result24 and search_result24 @>expected_result24 and array_length(expected_result24,1)=array_length(search_result24,1), 'Test multiple relations requirements');

--******************************
--wildcard search attr 1

search_registrering_25 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
	ARRAY[
	ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        NULL, --eksempel
   		'omfang\_A%', --omfang AB
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		NULL, --soegeord
   			null
		)::KlasseEgenskaberAttrType
	],
	null --ARRAY[] relations
):: KlasseRegistreringType;


/*
firstResult int,--TOOD ??
	{{oio_type}}_uuid uuid,
	registreringObj {{oio_type|title}}RegistreringType,
	virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	maxResults int = 2147483647,
	anyAttrValueArr text[] = '{}'::text[],
	anyuuidArr	uuid[] = '{}'::uuid[]
*/

expected_result25:=ARRAY[new_uuid_A,new_uuid_B]::uuid[];

search_result25 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_25, --registrering_A Klasseregistrering_AType
	null
	);

/*
raise notice 'Test global virksg 5:search_result25:%',to_json(search_result25);

raise notice 'Test global virksg 5:expected_result25:%',to_json(expected_result25);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result25 @> search_result25 and search_result25 @>expected_result25 and array_length(expected_result25,1)=array_length(search_result25,1), 'wildcard search attr 1');

--******************************
--vilkaarligAttr search attr 2

search_registrering_26 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
	ARRAY[
	ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        'eksempel_faelles', --eksempel
   		NULL, --omfang AB
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		NULL, --soegeord
   			null
		)::KlasseEgenskaberAttrType
	],
	null --ARRAY[] relations
):: KlasseRegistreringType;


/*
firstResult int,--TOOD ??
	{{oio_type}}_uuid uuid,
	registreringObj {{oio_type|title}}RegistreringType,
	virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	maxResults int = 2147483647,
	anyAttrValueArr text[] = '{}'::text[],
	anyuuidArr	uuid[] = '{}'::uuid[]
*/

expected_result26:=ARRAY[new_uuid_B]::uuid[];

search_result26 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_26, --registrering_A Klasseregistrering_AType
	TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	null,
	ARRAY['brugervendt_noegle_B']::text[]
	);

/*
raise notice 'Test global virksg 5:search_result26:%',to_json(search_result26);

raise notice 'Test global virksg 5:expected_result26:%',to_json(expected_result26);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result26 @> search_result26 and search_result26 @>expected_result26 and array_length(expected_result26,1)=array_length(search_result26,1), 'vilkaarligAttr search attr 2');

--******************************
--vilkaarligAttr search attr 3

search_registrering_27 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
	ARRAY[
	ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        NULL, --eksempel
   		'omfang\_AB', --omfang AB
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		NULL, --soegeord
   			null
		)::KlasseEgenskaberAttrType
	],
	null --ARRAY[] relations
):: KlasseRegistreringType;


/*
firstResult int,--TOOD ??
	{{oio_type}}_uuid uuid,
	registreringObj {{oio_type|title}}RegistreringType,
	virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	maxResults int = 2147483647,
	anyAttrValueArr text[] = '{}'::text[],
	anyuuidArr	uuid[] = '{}'::uuid[]
*/

expected_result27:=ARRAY[]::uuid[];

search_result27 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_27, --registrering_A Klasseregistrering_AType
	TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	null,
	ARRAY['brugervendt_noegle_C']::text[]
	);

/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result27);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result27);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(coalesce(array_length(search_result27,1),0)=coalesce(array_length(expected_result27,1),0), 'vilkaarligAttr search attr 3');

--******************************
--vilkaarligAttr search attr 4

expected_result28:=ARRAY[new_uuid_C]::uuid[];

search_result28 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	null,
	ARRAY['brugervendt_noegle_C']::text[]
	);

/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result28);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result28);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result28 @> search_result28 and search_result28 @>expected_result28 and array_length(expected_result28,1)=array_length(search_result28,1), 'vilkaarligAttr search attr 4');

--******************************
--vilkaarligAttr search attr 5
expected_result29:=ARRAY[new_uuid_A,new_uuid_B]::uuid[];

search_result29 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	null,
	ARRAY['omfang\_AB']::text[]
	);

/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result29);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result29);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result29 @> search_result29 and search_result29 @>expected_result29 and array_length(expected_result29,1)=array_length(search_result29,1), 'vilkaarligAttr search attr 5');

--******************************
--vilkaarligAttr search attr 6
expected_result29:=ARRAY[new_uuid_A]::uuid[];

search_result29 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	null,
	ARRAY['omfang\_AB','titel_A']::text[]
	);

/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result29);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result29);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result29 @> search_result29 and search_result29 @>expected_result29 and array_length(expected_result29,1)=array_length(search_result29,1), 'vilkaarligAttr search attr 6');


--******************************
--vilkaarligAttr search attr 7
expected_result30:=ARRAY[new_uuid_B]::uuid[];

search_result30 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	null,
	ARRAY['omfang\_AB','beskrivelse_klasseEgenskabB_Soegeord4']::text[]
	);

/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result30);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result30);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result30 @> search_result30 and search_result30 @>expected_result30 and array_length(expected_result30,1)=array_length(search_result30,1), 'vilkaarligAttr search attr 7');

--******************************
--vilkaarligAttr search attr 8
expected_result31:=ARRAY[new_uuid_B,new_uuid_A]::uuid[];

search_result31 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,TSTZRANGE(current_timestamp,current_timestamp,'[]'),
	null,
	ARRAY['omfang\_A%']::text[]
	);

/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result31);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result31);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result31 @> search_result31 and search_result31 @>expected_result31 and array_length(expected_result31,1)=array_length(search_result31,1), 'vilkaarligAttr search attr 8');

--******************************
--vilkaarligAttr search attr 9

expected_result32:=ARRAY[new_uuid_C]::uuid[];

search_result32 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,'[2014-10-01, 2014-10-20]' :: TSTZRANGE, --virkningSoeg,
	null,
	ARRAY['eksempel_faelles']::text[]
	);
/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result32);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result32);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result32 @> search_result32 and search_result32 @>expected_result32 and array_length(expected_result32,1)=array_length(search_result32,1), 'vilkaarligAttr search attr 9');

--******************************
--vilkaarligRel search attr 1

expected_result33:=ARRAY[new_uuid_B]::uuid[];

search_result33 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,null, --virkningSoeg,
	null,
	null,
	ARRAY[uuidRedaktoer2_B]::uuid[]
	);
/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result33);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result33);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result33 @> search_result33 and search_result33 @>expected_result33 and array_length(expected_result33,1)=array_length(search_result33,1), 'vilkaarligRel search 1');

--******************************
--vilkaarligRel search attr 2

expected_result34:=ARRAY[new_uuid_A]::uuid[];

search_result34 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,null, --virkningSoeg,
	null,
	null,
	ARRAY[uuidRedaktoer2_A,uuidAnsvarlig_A]::uuid[]
	);
/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result34);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result34);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result34 @> search_result34 and search_result34 @>expected_result34 and array_length(expected_result34,1)=array_length(search_result34,1), 'vilkaarligRel search 2');

--******************************
--vilkaarligRel search attr 3

expected_result35:=ARRAY[]::uuid[];

search_result35 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,null, --virkningSoeg,
	null,
	null,
	ARRAY[uuidRedaktoer2_A,uuidAnsvarlig_C]::uuid[]
	);
/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result35);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result35);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(coalesce(array_length(expected_result35,1),0)=coalesce(array_length(search_result35,1),0), 'vilkaarligRel search 3');

--******************************
--vilkaarligRel search attr 4

expected_result36:=ARRAY[new_uuid_B]::uuid[];

search_result36 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,TSTZRANGE(current_timestamp,current_timestamp,'[]'), --virkningSoeg,
	null,
	ARRAY['eksempel_faelles']::text[],
	ARRAY[uuidAnsvarlig_B]::uuid[]
	);
/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result36);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result36);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result36 @> search_result36 and search_result36 @>expected_result36 and array_length(expected_result36,1)=array_length(search_result36,1), 'vilkaarligRel search 4');


--******************************
--vilkaarligRel search attr 5

expected_result37:=ARRAY[]::uuid[];

search_result37 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,null, --virkningSoeg,
	null,
	ARRAY['brugervendt_noegle_C'],
	ARRAY[uuidAnsvarlig_A]::uuid[]
	);
/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result37);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result37);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(coalesce(array_length(expected_result37,1),0)=coalesce(array_length(search_result37,1),0), 'vilkaarligRel search 5');

--******************************
--vilkaarligRel search attr 6

expected_result38:=ARRAY[new_uuid_B,new_uuid_A]::uuid[];

search_result38 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,TSTZRANGE(current_timestamp,current_timestamp,'[]'), --virkningSoeg,
	null,
	null,
	ARRAY[uuidSideordnede_AB]::uuid[]
	);
/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result38);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result38);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result38 @> search_result38 and search_result38 @>expected_result38 and array_length(expected_result38,1)=array_length(search_result38,1), 'vilkaarligRel search 6');

--******************************
--vilkaarligRel search attr 7

expected_result39:=ARRAY[new_uuid_B]::uuid[];

search_result39 :=as_search_klasse(
	null,--TOOD ??
	null,
	ROW(ROW (TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),NULL,NULL,NULL) :: registreringBase,NULL,NULL,NULL):: KlasseRegistreringType
	,TSTZRANGE('2014-02-27','2014-03-30','[]'), --virkningSoeg,
	null,
	null,
	ARRAY[uuidSideordnede_AB]::uuid[]
	);
/*
raise notice 'vilkaarligAttr search attr 3:%',to_json(search_result39);

raise notice 'vilkaarligAttr search attr 3:%',to_json(expected_result39);

raise notice 'Test global virksg 5:A:%',to_json(registrering_A);
raise notice 'Test global virksg 5:B:%',to_json(registrering_B);
raise notice 'Test global virksg 5:C:%',to_json(registrering_C);
*/

RETURN NEXT ok(expected_result39 @> search_result39 and search_result39 @>expected_result39 and array_length(expected_result39,1)=array_length(search_result39,1), 'vilkaarligRel search 7');



-------------------------------------------------------------------------
--we'll update system reg time of reg of klasse C to help facilitate tests
update
	klasse_registrering a
SET 
registrering=ROW (
	TSTZRANGE('2014-01-01','2014-12-31','[]'),
	'Opstaaet'::Livscykluskode,
	uuidregistrering_C,
	'Test Note 1000') :: registreringBase
where
a.klasse_id=new_uuid_C
;
-------------------------------------------------------------------------
--egenskab isoleret

search_registrering_40 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
ARRAY[
ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        'eksempel_faelles', --eksempel
   		NULL, --omfang
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		NULL, --soegeord
   		NULL
		)::KlasseEgenskaberAttrType
]::KlasseEgenskaberAttrType[],
null
):: KlasseRegistreringType;


search_result40 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_40 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

expected_result40:=ARRAY[new_uuid_A,new_uuid_B]::uuid[];

--raise notice 'expected_result40:%',to_json(expected_result40);

--raise notice 'search_result40:%',to_json(search_result40);

RETURN NEXT ok(expected_result40 @> search_result40 and search_result40 @>expected_result40 and array_length(expected_result40,1)=array_length(search_result40,1), 'search egenskab isolated, system reg filter');

-------------------------------------------------------------------------
--egenskab isolated - system reg time


search_registrering_41 := ROW (
	ROW (
	TSTZRANGE('2014-01-01','2014-12-31','[]'),
	NULL,
	NULL,
	NULL) :: registreringBase,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
ARRAY[
ROW(
		NULL, --brugervendtnoegle
   		NULL, --beskrivelse
        'eksempel_faelles', --eksempel
   		NULL, --omfang
   		NULL, --titel
   		NULL,
   		NULL, --aendringsnotat
   		NULL, --soegeord
   		NULL
		)::KlasseEgenskaberAttrType
]::KlasseEgenskaberAttrType[],
null
):: KlasseRegistreringType;


search_result41 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_41 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);

expected_result41:=ARRAY[new_uuid_C]::uuid[];

RETURN NEXT ok(expected_result41 @> search_result41 and search_result41 @>expected_result41 and array_length(expected_result41,1)=array_length(search_result41,1), 'search egenskab isolated, system reg time.');

-------------------------------------------------------------------------
--search on klasses that has had the state  published at any point in time (system reg. filtration)

search_registrering_42 := ROW (
	ROW (
	TSTZRANGE('2014-01-01','2014-12-31','[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	ARRAY[
			ROW(
				  ROW(
				  	null,null,null,null
				  	)::virkning 
				  ,'Publiceret'::KlassePubliceretTils
				):: KlassePubliceretTilsType
	],--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
null,--ARRAY[klasseEgenskab_B]::KlasseEgenskaberAttrType[],
null--ARRAY[klasseRelAnsvarlig_B,klasseRelRedaktoer1_B,klasseRelRedaktoer2_B]
):: KlasseRegistreringType;

search_result42 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_42 --registrering_A Klasseregistrering_AType
	,null--virkningSoeg
	);


RETURN NEXT is(
search_result42,
ARRAY[new_uuid_C]::uuid[],
'search state KlassePubliceretTils Publiceret, system reg filter'
);

-------------------------------------------------------------------------
search_registrering_43 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
	null,
ARRAY[
	ROW (
	'redaktoerer'::KlasseRelationKode,
		ROW(
				  	'[2015-05-10, 2015-07-30]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning, 
			null,
			null,
			null
	) :: KlasseRelationType,
	ROW (
	'redaktoerer'::KlasseRelationKode,
		ROW(
				  	'[2015-04-20, 2015-04-20]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning, 
			null,
			null,
			null
	) :: KlasseRelationType
]
):: KlasseRegistreringType;


expected_result43:=ARRAY[new_uuid_B]::uuid[];

search_result43 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_43 --registrering_A Klasseregistrering_AType
	,null
	);


RETURN NEXT ok(expected_result43 @> search_result43 and search_result43 @>expected_result43 and array_length(expected_result43,1)=array_length(search_result43,1), 'search relationer isolated, system reg time.');

-------------------------------------------------------------------------
search_registrering_44 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
	null,
ARRAY[
	ROW (
	'redaktoerer'::KlasseRelationKode,
		ROW(
				  	'[2015-05-10, 2015-07-30]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning, 
			null,
			null,
			null
	) :: KlasseRelationType,
	ROW (
	'redaktoerer'::KlasseRelationKode,
		ROW(
				  	'[2015-04-20, 2015-04-20]' :: TSTZRANGE,
				  	null,null,null
				  	)::virkning, 
			null,
			null,
			null
	) :: KlasseRelationType
]
):: KlasseRegistreringType;


expected_result44:=ARRAY[new_uuid_B]::uuid[];

search_result44 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_44 --registrering_A Klasseregistrering_AType
	,null
	);


RETURN NEXT ok(expected_result44 @> search_result44 and search_result44 @>expected_result44 and array_length(expected_result44,1)=array_length(search_result44,1), 'search relationer isolated, system reg time.');

-------------------------------------------------------------------------

search_registrering_45 := ROW (
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	uuidregistrering_AB,
	NULL) :: registreringBase
	,
	null,--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
	null,
	NULL
	):: KlasseRegistreringType;


expected_result45:=ARRAY[new_uuid_B,new_uuid_A]::uuid[];

search_result45 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_45 --registrering_A Klasseregistrering_AType
	,null
	);


RETURN NEXT ok(expected_result45 @> search_result45 and search_result45 @>expected_result45 and array_length(expected_result45,1)=array_length(search_result45,1), 'search aktorref isolated.');

-------------------------------------------------------------------------

--we'll update system reg time of reg of klasse C BACK to normal to help facilitate tests
/*
update
	klasse_registrering a
SET 
registrering=ROW (
	TSTZRANGE('2014-01-01','infinity','[)'),
	'Opstaaet'::Livscykluskode,
	uuidregistrering_C,
	'Test Note 1000') :: registreringBase
where
a.klasse_id=new_uuid_C
;

--GET DIAGNOSTICS rows_affected = ROW_COUNT;
--raise notice 'rows_affected:%',rows_affected;
*/



update_reg_id:=as_update_klasse(
  new_uuid_B, '8762a443-2f60-49c1-bd8e-ecfdef91d48a'::uuid,'Test update'::text,
  'Slettet'::Livscykluskode,          
 registrering_B.attrEgenskaber,
  registrering_B.tilsPubliceret,
  registrering_B.relationer
  ,null
	);

/*
read_Klasse2 := as_read_Klasse(new_uuid_B,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);
*/
--raise notice 'read_Klasse2 - post update:%',to_json(read_Klasse2);

search_registrering_200 := ROW (
	/*
	ROW (
	TSTZRANGE(current_timestamp,clock_timestamp(),'[]'),
	NULL,
	NULL,
	NULL) :: registreringBase
*/
	null
	,null--ARRAY[klassePubliceret_B]::KlassePubliceretTilsType[],
	,ARRAY[
 ROW (
	null--'brugervendt_noegle_C',
   ,null--'klassebeskrivelse_C',
   ,'eksempel_faelles'
	,null--'omfang_C',
   ,null--'titel_C',
   ,null --'retskilde_C'
   ,null--'aendringsnotat_C', --aendringsnotat
    ,NULL --soegeord
   ,NULL
) :: KlasseEgenskaberAttrType
	]
	,
	NULL
	):: KlasseRegistreringType;


expected_result200:=ARRAY[new_uuid_A]::uuid[];

search_result200 :=as_search_klasse(
	null,--TOOD ??
	null,
	search_registrering_200 --registrering_A Klasseregistrering_AType
	,null
	);

--raise notice 'expected_result200:%',to_json(expected_result200);

--raise notice 'search_result200:%',to_json(search_result200);

RETURN NEXT ok(expected_result200 @> search_result200 and search_result200 @>expected_result200 and array_length(expected_result200,1)=array_length(search_result200,1), 'test if search does not included Livscykluskode [slettet] pr default.');



read_Klasse1 := as_read_Klasse(new_uuid_A,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

read_Klasse2 := as_read_Klasse(new_uuid_B,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);


read_Klasse3 := as_read_Klasse(new_uuid_C,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'read_Klasse1:%',to_json(read_Klasse1);
--raise notice 'read_Klasse2:%',to_json(read_Klasse2);
--raise notice 'read_Klasse3:%',to_json(read_Klasse3);




END;
$$;


ALTER FUNCTION test.test_as_search_klasse() OWNER TO mox;

--
-- Name: test_as_search_match_array(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_search_match_array() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
searchForArr1 text[];
searchInArr1 text[] ;
expectedRes1 boolean;
searchForArr2 text[];
searchInArr2 text[] ;
expectedRes2 boolean;
searchForArr3 text[];
searchInArr3 text[] ;
expectedRes3 boolean;
searchForArr4 text[];
searchInArr4 text[] ;
expectedRes4 boolean;
searchForArr5 text[];
searchInArr5 text[] ;
expectedRes5 boolean;
searchForArr6 text[];
searchInArr6 text[] ;
expectedRes6 boolean;
searchForArr7 text[];
searchInArr7 text[] ;
expectedRes7 boolean;
searchForArr8 text[];
searchInArr8 text[] ;
expectedRes8 boolean;
searchForArr9 text[];
searchInArr9 text[] ;
expectedRes9 boolean;
BEGIN



expectedRes1:=true;

RETURN NEXT is(_as_search_match_array(searchForArr1,searchInArr1),expectedRes1,'search for null in null matches');

expectedRes2:=false;

searchForArr2:=ARRAY['test'];

RETURN NEXT is(_as_search_match_array(searchForArr2,searchInArr2),expectedRes2,'search for one element in null fails');


expectedRes3:=false;

searchForArr3:=ARRAY['test','test2'];

RETURN NEXT is(_as_search_match_array(searchForArr3,searchInArr3),expectedRes3,'search for 2 element in null fails');


expectedRes4:=false;

searchForArr4:=ARRAY['test','test2'];
searchInArr4:=ARRAY[]::text[];
RETURN NEXT is(_as_search_match_array(searchForArr4,searchInArr4),expectedRes4,'search for 1 element in empty* arr fails');

expectedRes5:=false;

searchForArr5:=ARRAY[]::text[];
searchInArr5:=ARRAY['test','test2'];


RETURN NEXT is(_as_search_match_array(searchForArr5,searchInArr5),expectedRes5,'search for 0 elements in non-empty arr fails');


expectedRes6:=true;
searchInArr6:=ARRAY['test','test2'];
searchForArr6:=ARRAY['test']::text[];
RETURN NEXT is(_as_search_match_array(searchForArr6,searchInArr6),expectedRes6,'search for 1 matching non-wildcard element in arr succeeds');

expectedRes7:=true;
searchInArr7:=ARRAY['test','tes'];
searchForArr7:=ARRAY['test%']::text[];
RETURN NEXT is(_as_search_match_array(searchForArr7,searchInArr7),expectedRes7,'search for 1 matching wildcard element in arr succeeds');


expectedRes8:=false;
searchInArr8:=ARRAY['btest','btes'];
searchForArr8:=ARRAY['test%']::text[];
RETURN NEXT is(_as_search_match_array(searchForArr8,searchInArr8),expectedRes8,'search for 1 non-matching wildcard element in arr fails');



expectedRes8:=false;
searchInArr8:=ARRAY['btest','btes'];
searchForArr8:=ARRAY['test%','btes']::text[];
RETURN NEXT is(_as_search_match_array(searchForArr8,searchInArr8),expectedRes8,'search for 1 non-matching wildcard and 1 matching element in arr fails');


expectedRes9:=false;
searchInArr9:=ARRAY['btest','btes','ctest'];
searchForArr9:=ARRAY['%test%','btes']::text[];
RETURN NEXT is(_as_search_match_array(searchForArr8,searchInArr8),expectedRes8,'search for 1 matching wildcard and 1 matching element in arr succeeds');



END;
$$;


ALTER FUNCTION test.test_as_search_match_array() OWNER TO mox;

--
-- Name: test_as_search_sag(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_search_sag() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	registrering1 sagRegistreringType;
	new_uuid2 uuid;
	registrering2 sagRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkPrimaerklasse Virkning;
	virkSekundaerpart1 Virkning;
	virkSekundaerpart2 Virkning;
	virkAndresager1 Virkning;
	virkAndresager2 Virkning;
	virkPubliceret Virkning;
	sagEgenskab sagEgenskaberAttrType;
	sagFremdrift sagFremdriftTilsType;
	sagRelPrimaerklasse sagRelationType;
	sagRelSekundaerpart1 sagRelationType;
	sagRelSekundaerpart2 sagRelationType;
	sagRelAndresager1 sagRelationType;
	sagRelAndresager2 sagRelationType;
	virkJournalNotat1 Virkning;
	uuidJournalNotat1  uuid :='97109356-e87e-4b10-ad5d-36de6e3ee011'::uuid;
	sagJournalNotat1 sagRelationType;
	virkJournalNotat2 Virkning;
	uuidJournalNotat2  uuid :='82109356-e87e-4b10-ad5d-36de6e3ee082'::uuid;
	sagJournalNotat2 sagRelationType;
	virkJournalNotat3 Virkning;
	uuidJournalNotat3  uuid :='27109356-e87e-4b10-ad5d-36de6e3ee015'::uuid;
	sagJournalNotat3 sagRelationType;

	virkJournalNotat4 Virkning;
	uuidJournalNotat4  uuid :='62109356-e87e-4b10-ad5d-36de6e3ee019'::uuid;
	sagJournalNotat4 sagRelationType;
	virkJournalNotat5 Virkning;
	uuidJournalNotat5  uuid :='80109356-e87e-4b10-ad5d-36de6e3ee007'::uuid;
	sagJournalNotat5 sagRelationType;

	virkJournalNotat6 Virkning;
	uuidJournalNotat6  uuid :='90109356-e87e-4b10-ad5d-36de6e3ee009'::uuid;
	sagJournalNotat6 sagRelationType;

	virkJournalNotat7 Virkning;
	uuidJournalNotat7  uuid :='92109356-e87e-4b10-ad5d-36de6e3ee011'::uuid;
	sagJournalNotat7 sagRelationType;

	uuidPrimaerklasse uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	uuidSekundaerpart1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;


	--uuidSekundaerpart2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	urnSekundaerpart2 text:='urn:isbn:0451450523'::text;
	uuidAndresager1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidAndresager2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	actual_publiceret_virk virkning;
	actual_publiceret_value sagFremdriftTils;
	actual_publiceret sagFremdriftTilsType;
	actual_relationer sagRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	read_Sag1 SagType;
	expected_sag1 SagType;

	actual_search_res_1 uuid[];
	actual_search_res_2 uuid[];
	actual_search_res_3 uuid[];
	actual_search_res_4 uuid[];
	actual_search_res_5 uuid[];
	actual_search_res_6 uuid[];

	expected_search_res_1 uuid[];
	expected_search_res_2 uuid[];
	expected_search_res_3 uuid[];
	expected_search_res_4 uuid[];
	expected_search_res_5 uuid[];
	expected_search_res_6 uuid[];

BEGIN




virkJournalNotat1 :=	ROW (
	'[2014-05-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat1,
          'Bruger',
          'NoteEx1233'
          ) :: Virkning
;


virkJournalNotat2 :=	ROW (
	'[2014-06-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat2,
          'Bruger',
          'NoteEx12331'
          ) :: Virkning
;

virkJournalNotat3 :=	ROW (
	'[2014-07-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat3,
          'Bruger',
          'NoteEx12332'
          ) :: Virkning
;

virkJournalNotat4 :=	ROW (
	'[2014-08-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat4,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkJournalNotat5 :=	ROW (
	'[2014-09-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat5,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;

virkJournalNotat6 :=	ROW (
	'[2014-02-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat5,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;

virkJournalNotat7 :=	ROW (
	'[2014-09-19, infinity)' :: TSTZRANGE,
          uuidJournalNotat5,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkPrimaerklasse :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkSekundaerpart1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkSekundaerpart2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkAndresager1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkAndresager2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

sagRelPrimaerklasse := ROW (
	'ansvarlig'::sagRelationKode
	,virkPrimaerklasse
	,uuidPrimaerklasse
	,null
	,'Klasse'
	,567 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;


sagRelSekundaerpart1 := ROW (
	'sekundaerpart'::sagRelationKode,
		virkSekundaerpart1,
	uuidSekundaerpart1,
	null,
	'Person'
	,768 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;



sagRelSekundaerpart2 := ROW (
	'sekundaerpart'::sagRelationKode,
		virkSekundaerpart2,
	null,
	urnSekundaerpart2,
	'Person'
	,800 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;



sagRelAndresager1 := ROW (
	'andresager'::sagRelationKode,
		virkAndresager1,
	uuidAndresager1,
	null,
	'Person'
	,7268 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;



sagRelAndresager2 := ROW (
	'andresager'::sagRelationKode,
		virkAndresager2,
	uuidAndresager2,
	null,
	'Person'
	,3 --NOTICE: Should be replace in by import function
	,null 
	,ROW(null,null,null)::JournalNotatType 
	,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
) :: sagRelationType
;


sagJournalNotat1:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat1,
					uuidJournalNotat1,
					null,
					'Person'
					,4  --NOTICE: Should be replace in by import function
					,'journalnotat'::SagRelationJournalPostSpecifikKode
					, ROW('journal_txt1','journal_notat1','journal_format1')::JournalNotatType --journalNotat
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);


sagJournalNotat2:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat2,
					uuidJournalNotat2,
					null,
					'Person'
					,5  --NOTICE: Should be replace in by import function
					,'journalnotat'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,'journal_format2')::JournalNotatType --journalNotat
					,null --journalDokumentAttr
				);


sagJournalNotat3:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat3,
					uuidJournalNotat3,
					null,
					'Person'
					,6  --NOTICE: Should be replace in by import function
					,'journalnotat'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);


sagJournalNotat4:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat4,
					uuidJournalNotat4,
					null,
					'Person'
					,19  --NOTICE: Should be replace in by import function
					,'vedlagtdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW('vedlagt_titel_1', ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);

sagJournalNotat5:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat5,
					uuidJournalNotat5,
					null,
					'Person'
					,20  --NOTICE: Should be replace in by import function
					,'tilakteretdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(NULL, ROW('AlternativTitel_1','Hjemmel_1')::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);

sagJournalNotat6:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat6,
					uuidJournalNotat6,
					null,
					'Person'
					,21  --NOTICE: Should be replace in by import function
					,'tilakteretdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(NULL, ROW('AlternativTitel_2',NULL)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);

sagJournalNotat7:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat7,
					uuidJournalNotat7,
					null,
					'Person'
					,22  --NOTICE: Should be replace in by import function
					,'tilakteretdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(NULL, ROW(NULL,'Hjemmel_3')::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);

sagFremdrift := ROW (
virkPubliceret,
'Opstaaet'
):: sagFremdriftTilsType
;


sagEgenskab := ROW (
'brugervendtnoegle_sag_1' --text, 
 ,false --'afleveret_sag_1'-- boolean,
,'beskrivelse_sag_1'-- text,
, 'hjemmel_sag_1'-- text,
, 'kassationskode_sag_1'-- text,
,ROW( 
	'alternativTitel_sag_1'
	,'hjemmel_sag_1'
 )::offentlighedundtagettype
, true --principiel boolean,
,'sagsnummer_1' -- text,
, 'titel_sag_1'-- text,
,virkEgenskaber
) :: sagEgenskaberAttrType
;


registrering1 := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
ARRAY[sagFremdrift]::sagFremdriftTilsType[],
ARRAY[sagEgenskab]::sagEgenskaberAttrType[],
ARRAY[sagRelPrimaerklasse,sagRelSekundaerpart1,sagRelSekundaerpart2,sagRelAndresager1,sagRelAndresager2,sagJournalNotat2,sagJournalNotat3,sagJournalNotat4,sagJournalNotat5,sagJournalNotat6]
) :: sagRegistreringType
;


new_uuid1 := as_create_or_import_sag(registrering1);



/************************************/

registrering2 := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
ARRAY[sagFremdrift]::sagFremdriftTilsType[],
ARRAY[sagEgenskab]::sagEgenskaberAttrType[],
ARRAY[sagRelPrimaerklasse,sagRelSekundaerpart1,sagRelSekundaerpart2,sagRelAndresager1,sagRelAndresager2,sagJournalNotat1,sagJournalNotat2,sagJournalNotat4,sagJournalNotat7]
) :: sagRegistreringType
;


new_uuid2 := as_create_or_import_sag(registrering2);

/************************************************/

expected_search_res_1:=array[new_uuid1,new_uuid2];

actual_search_res_1:=as_search_sag(null,null,
		ROW(
				null --registrering RegistreringBase,
				,array[] :: SagFremdriftTilsType[]
				,null --attrEgenskaber SagEgenskaberAttrType[],
				,ARRAY[
				ROW (
					'journalpost'::sagRelationKode
					,null --	virkJournalNotat4
					,null --uuidJournalNotat4
					,null
					,null --'Person'
					,null --19  --NOTICE: Should be replace in by import function
					,'vedlagtdokument'::SagRelationJournalPostSpecifikKode
					,null-- ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW('vedlagt_titel_1', null) ::JournalPostDokumentAttrType --journalDokumentAttr
				) ::sagRelationType
				] ::sagRelationType[]
			)::SagRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_1 @> actual_search_res_1 and actual_search_res_1 @>expected_search_res_1 and array_length(expected_search_res_1,1)=array_length(actual_search_res_1,1), 'search sag reltion extra meta data #1.');

/************************************************/
expected_search_res_2:=array[]::uuid[];

actual_search_res_2:=as_search_sag(null,null,
		ROW(
				null --registrering RegistreringBase,
				,array[] :: SagFremdriftTilsType[]
				,null --attrEgenskaber SagEgenskaberAttrType[],
				,ARRAY[
				ROW (
					'journalpost'::sagRelationKode
					,null --	virkJournalNotat4
					,null --uuidJournalNotat4
					,null
					,null --'Person'
					,null --29  --NOTICE: Should be replace in by import function
					,'vedlagtdokument'::SagRelationJournalPostSpecifikKode
					,null-- ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW('vedlagt_titel_2', null) ::JournalPostDokumentAttrType --journalDokumentAttr
				) ::sagRelationType
				] ::sagRelationType[]
			)::SagRegistreringType	
		,null
);

RETURN NEXT ok(coalesce(array_length(expected_search_res_2,1),0)=coalesce(array_length(actual_search_res_2,1),0), 'search sag reltion extra meta data #2.');



/************************************************/
expected_search_res_3:=array[new_uuid2]::uuid[];

actual_search_res_3:=as_search_sag(null,null,
		ROW(
				null --registrering RegistreringBase,
				,array[] :: SagFremdriftTilsType[]
				,null --attrEgenskaber SagEgenskaberAttrType[],
				,ARRAY[
				ROW (
					'journalpost'::sagRelationKode
					,null --	virkJournalNotat4
					,null --uuidJournalNotat4
					,null
					,null --'Person'
					,null --39  --NOTICE: Should be replace in by import function
					,'tilakteretdokument'::SagRelationJournalPostSpecifikKode
					,null-- ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(NULL, ROW(NULL,'Hjemmel_3')::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				) ::sagRelationType
				] ::sagRelationType[]
			)::SagRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_3 @> actual_search_res_3 and actual_search_res_3 @>expected_search_res_3 and coalesce(array_length(expected_search_res_3,1),0)=coalesce(array_length(actual_search_res_3,1),0), 'search sag reltion extra meta data #3.');

/************************************************/
expected_search_res_4:=array[new_uuid1]::uuid[];

actual_search_res_4:=as_search_sag(null,null,
		ROW(
				null --registrering RegistreringBase,
				,array[] :: SagFremdriftTilsType[]
				,null --attrEgenskaber SagEgenskaberAttrType[],
				,ARRAY[
				ROW (
					'journalpost'::sagRelationKode
					,null --	virkJournalNotat4
					,null --uuidJournalNotat4
					,null
					,null --'Person'
					,null --49  --NOTICE: Should be replace in by import function
					,'tilakteretdokument'::SagRelationJournalPostSpecifikKode
					,null-- ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(NULL, ROW('AlternativTitel_1',null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				) ::sagRelationType
				] ::sagRelationType[]
			)::SagRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_4 @> actual_search_res_4 and actual_search_res_4 @>expected_search_res_4 and coalesce(array_length(expected_search_res_4,1),0)=coalesce(array_length(actual_search_res_4,1),0), 'search sag reltion extra meta data #4.');


/************************************************/
expected_search_res_5:=array[new_uuid2]::uuid[];

actual_search_res_5:=as_search_sag(null,null,
		ROW(
				null --registrering RegistreringBase,
				,array[] :: SagFremdriftTilsType[]
				,null --attrEgenskaber SagEgenskaberAttrType[],
				,ARRAY[
				ROW (
					'journalpost'::sagRelationKode
					,null--	virkJournalNotat1,
					,null--uuidJournalNotat1,
					,null
					,null --'Person'
					,null --4  --NOTICE: Should be replace in by import function
					,'journalnotat'::SagRelationJournalPostSpecifikKode
					, ROW('journal_txt1','journal_notat1','journal_format1')::JournalNotatType --journalNotat
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				) ::sagRelationType
				] ::sagRelationType[]
			)::SagRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_5 @> actual_search_res_5 and actual_search_res_5 @>expected_search_res_5 and coalesce(array_length(expected_search_res_5,1),0)=coalesce(array_length(actual_search_res_5,1),0), 'search sag reltion extra meta data #5.');


/************************************************/
expected_search_res_6:=array[new_uuid1,new_uuid2]::uuid[];

actual_search_res_6:=as_search_sag(null,null,
		ROW(
				null --registrering RegistreringBase,
				,array[] :: SagFremdriftTilsType[]
				,null --attrEgenskaber SagEgenskaberAttrType[],
				,ARRAY[
				ROW (
					'journalpost'::sagRelationKode
					,null--	virkJournalNotat1,
					,null--uuidJournalNotat1,
					,null
					,null --'Person'
					,null --4  --NOTICE: Should be replace in by import function
					,'journalnotat'::SagRelationJournalPostSpecifikKode
					, ROW(null,null,'journal_format2')::JournalNotatType --journalNotat
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				) ::sagRelationType
				] ::sagRelationType[]
			)::SagRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_6 @> actual_search_res_6 and actual_search_res_6 @>expected_search_res_6 and coalesce(array_length(expected_search_res_6,1),0)=coalesce(array_length(actual_search_res_6,1),0), 'search sag reltion extra meta data #6.');



END;
$$;


ALTER FUNCTION test.test_as_search_sag() OWNER TO mox;

--
-- Name: test_as_search_tilstand(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_search_tilstand() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	new_uuid2 uuid;
	new_uuid3 uuid;
	registrering tilstandRegistreringType;
	registrering2 tilstandRegistreringType;
	registrering3 tilstandRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkTilstandsobjekt Virkning;
	virkTilstandsvaerdi1 Virkning;
	virkTilstandsvaerdi2 Virkning;
	virkTilstandskvalitet1 Virkning;
	virkTilstandskvalitet2 Virkning;
	virkPubliceret Virkning;
	virkStatus Virkning;
	tilstandEgenskab tilstandEgenskaberAttrType;
	tilstandStatus tilstandStatusTilsType;
	tilstandPubliceret tilstandPubliceretTilsType;
	tilstandRelTilstandsobjekt tilstandRelationType;
	tilstandRelTilstandsvaerdi1 tilstandRelationType;
	tilstandRelTilstandsvaerdi2 tilstandRelationType;
	tilstandRelTilstandskvalitet1 tilstandRelationType;
	tilstandRelTilstandskvalitet2 tilstandRelationType;
	
	uuidTilstandsobjekt uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	--uuidTilstandsvaerdi1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;


	uuidTilstandsvaerdi2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	--urnTilstandsvaerdi2 text:='urn:isbn:0451450523'::text;
	uuidTilstandskvalitet1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidTilstandskvalitet2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	actual_publiceret_virk virkning;
	actual_publiceret_value tilstandStatusTils;
	actual_publiceret tilstandStatusTilsType;
	actual_relationer tilstandRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	read_Tilstand1 TilstandType;
	expected_tilstand1 TilstandType;
	read_Tilstand2 TilstandType;
	expected_tilstand2 TilstandType;

	expected_search_res_1 uuid[];
	expected_search_res_2 uuid[];
	expected_search_res_3 uuid[];
	expected_search_res_4 uuid[];

	actual_search_res_1 uuid[];
	actual_search_res_2 uuid[];
	actual_search_res_3 uuid[];
	actual_search_res_4 uuid[];
BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkTilstandsobjekt :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkTilstandsvaerdi1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkTilstandsvaerdi2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkstatus := ROW (
	'[2016-12-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx20'
) :: Virkning
;

virkTilstandskvalitet1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkTilstandskvalitet2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

tilstandRelTilstandsobjekt := ROW (
	'tilstandsobjekt'::tilstandRelationKode
	,virkTilstandsobjekt
	,uuidTilstandsobjekt
	,null
	,'Person'
	,900 --NOTICE: Should be replace in by import function
	,null --TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;


tilstandRelTilstandsvaerdi1 := ROW (
	'tilstandsvaerdi'::tilstandRelationKode,
		virkTilstandsvaerdi1,
	null,
	null,
	null
	,768 --NOTICE: Should be replace in by import function
	,ROW(true,'82')::TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;



tilstandRelTilstandsvaerdi2 := ROW (
	'tilstandsvaerdi'::tilstandRelationKode,
		virkTilstandsvaerdi2,
	uuidTilstandsvaerdi2,
	null,--urnTilstandsvaerdi2
	'Klasse'
	,800 --NOTICE: Should be replace in by import function
	, null --TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;



tilstandRelTilstandskvalitet1 := ROW (
	'tilstandskvalitet'::tilstandRelationKode,
		virkTilstandskvalitet1,
	uuidTilstandskvalitet1,
	null,
	'Klasse'
	,7268 --NOTICE: Should be replace in by import function
	, null --TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;



tilstandRelTilstandskvalitet2 := ROW (
	'tilstandskvalitet'::tilstandRelationKode,
		virkTilstandskvalitet2,
	uuidTilstandskvalitet2,
	null,
	'Klasse'
	,3 --NOTICE: Should be replace in by import function
	,null --TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;



tilstandStatus := ROW (
virkStatus,
'Aktiv'::TilstandStatusTils
):: tilstandStatusTilsType
;

tilstandPubliceret := ROW (
virkPubliceret,
'Normal'::TilstandPubliceretTils
)::tilstandPubliceretTilsType;

tilstandEgenskab := ROW (
'brugervendtnoegle_tilstand_1' --text, 
,'beskrivelse_tilstand_flles'-- text,
,virkEgenskaber
) :: tilstandEgenskaberAttrType
;


registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[tilstandStatus]::tilstandStatusTilsType[],
	ARRAY[tilstandPubliceret]::TilstandPubliceretTilsType[],
ARRAY[tilstandEgenskab]::tilstandEgenskaberAttrType[],
ARRAY[tilstandRelTilstandsobjekt,tilstandRelTilstandsvaerdi1,tilstandRelTilstandsvaerdi2,tilstandRelTilstandskvalitet1,tilstandRelTilstandskvalitet2]) :: tilstandRegistreringType
;


--raise notice 'to be written tilstand 1:%',to_json(registrering);

new_uuid1 := as_create_or_import_tilstand(registrering);


RETURN NEXT ok(true,'No errors running as_create_or_import_tilstand1');

/*********************************/

registrering2:=ROW (
	ROW(
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 5') :: RegistreringBase
	,
	ARRAY[tilstandStatus]::tilstandStatusTilsType[],
	ARRAY[tilstandPubliceret]::TilstandPubliceretTilsType[],
ARRAY[
ROW (
'brugervendtnoegle_tilstand_2' --text, 
,'beskrivelse_tilstand_flles'-- text,
,ROW( '[2016-01-01, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
) :: tilstandEgenskaberAttrType ]::tilstandEgenskaberAttrType[],
ARRAY[tilstandRelTilstandsobjekt]) :: tilstandRegistreringType

;

new_uuid2 := as_create_or_import_tilstand(registrering2);

RETURN NEXT ok(true,'No errors running as_create_or_import_tilstand2');

/*********************************/
registrering3:=ROW (
	ROW(
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 6' ):: RegistreringBase
	,
	ARRAY[tilstandStatus]::tilstandStatusTilsType[],
	ARRAY[tilstandPubliceret]::TilstandPubliceretTilsType[],
ARRAY[
ROW (
'brugervendtnoegle_tilstand_3' --text, 
,'beskrivelse_tilstand_flles'-- text,
,ROW( '[2016-06-01, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
) :: tilstandEgenskaberAttrType ]::tilstandEgenskaberAttrType[],
ARRAY[tilstandRelTilstandsobjekt]) :: tilstandRegistreringType
;

new_uuid3 := as_create_or_import_tilstand(registrering3);

RETURN NEXT ok(true,'No errors running as_create_or_import_tilstand3');

/*********************************/

expected_search_res_1:=array[new_uuid2]::uuid[];

actual_search_res_1:=as_search_tilstand(null,null,
		ROW(
			null,
			null,-- TilstandStatusTilsType[],
			null,-- TilstandPubliceretTilsType[],
			ARRAY[ ROW (
				'brugervendtnoegle_tilstand_2' --text, 
				,null
				,null) :: tilstandEgenskaberAttrType ]::tilstandEgenskaberAttrType[],
			null-- TilstandRelationType[]
			)::tilstandRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_1 @> actual_search_res_1 and actual_search_res_1 @>expected_search_res_1 and coalesce(array_length(expected_search_res_1,1),0)=coalesce(array_length(actual_search_res_1,1),0), 'search tilstand #1.');


/*********************************/
expected_search_res_2:=array[new_uuid1,new_uuid2,new_uuid3]::uuid[];

actual_search_res_2:=as_search_tilstand(null,null,
		ROW(
			null,
			null,-- TilstandStatusTilsType[],
			null,-- TilstandPubliceretTilsType[],
			ARRAY[ ROW (
				null --text, 
				,'beskrivelse_tilstand_flles'
				,null) :: tilstandEgenskaberAttrType ]::tilstandEgenskaberAttrType[],
			null-- TilstandRelationType[]
			)::tilstandRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_2 @> actual_search_res_2 and actual_search_res_2 @>expected_search_res_2 and coalesce(array_length(expected_search_res_2,1),0)=coalesce(array_length(actual_search_res_2,1),0), 'search tilstand #2.');
/*********************************/

expected_search_res_3:=array[new_uuid1]::uuid[];

actual_search_res_3:=as_search_tilstand(null,null,
		ROW(
			null,
			null,-- TilstandStatusTilsType[],
			null,-- TilstandPubliceretTilsType[],
			null, -- attr egenskaber
			ARRAY[ROW (
				'tilstandsvaerdi'::tilstandRelationKode,
					virkTilstandsvaerdi1,
				null,
				null,
				null
				,null
				,ROW(null,'82')::TilstandVaerdiRelationAttrType
			) :: tilstandRelationType] ::TilstandRelationType[]
			)::tilstandRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_3 @> actual_search_res_3 and actual_search_res_3 @>expected_search_res_3 and coalesce(array_length(expected_search_res_3,1),0)=coalesce(array_length(actual_search_res_3,1),0), 'search tilstand #3.');
/*********************************/


expected_search_res_4:=array[]::uuid[];

actual_search_res_4:=as_search_tilstand(null,null,
		ROW(
			null,
			null,-- TilstandStatusTilsType[],
			null,-- TilstandPubliceretTilsType[],
			null, -- attr egenskaber
			ARRAY[ROW (
				'tilstandsvaerdi'::tilstandRelationKode,
					virkTilstandsvaerdi1,
				null,
				null,
				null
				,null
				,ROW(false,'82')::TilstandVaerdiRelationAttrType
			) :: tilstandRelationType] ::TilstandRelationType[]
			)::tilstandRegistreringType	
		,null
);

RETURN NEXT ok(expected_search_res_4 @> actual_search_res_4 and actual_search_res_4 @>expected_search_res_4 and coalesce(array_length(expected_search_res_4,1),0)=coalesce(array_length(actual_search_res_4,1),0), 'search tilstand #4.');
/*********************************/


END;
$$;


ALTER FUNCTION test.test_as_search_tilstand() OWNER TO mox;

--
-- Name: test_as_update_aktivitet(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_update_aktivitet() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	registrering aktivitetRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkEgenskaber2 Virkning;
	virkAnsvarligklasse Virkning;
	virkResultatklasse1 Virkning;
	virkResultatklasse2 Virkning;
	virkDeltagerklasse1 Virkning;
	virkDeltagerklasse2 Virkning;
	virkUdfoerer1 Virkning;
	virkUdfoerer2 Virkning;
	virkUdfoerer2B Virkning;
	virkUdfoerer3 Virkning;
	virkGeoobjekt Virkning;
	virkPubliceret Virkning;
	virkStatus Virkning;
	virkStatus1B Virkning;
	aktivitetEgenskab aktivitetEgenskaberAttrType;
	aktivitetEgenskab2 aktivitetEgenskaberAttrType;
	aktivitetEgenskab2B aktivitetEgenskaberAttrType;
	aktivitetStatus aktivitetStatusTilsType;
	aktivitetStatus1B aktivitetStatusTilsType;
	aktivitetPubliceret aktivitetPubliceretTilsType;
	aktivitetRelAnsvarligklasse aktivitetRelationType;
	aktivitetRelResultatklasse1 aktivitetRelationType;
	aktivitetRelResultatklasse2 aktivitetRelationType;
	aktivitetRelDeltagerklasse1 aktivitetRelationType;
	aktivitetRelDeltagerklasse2 aktivitetRelationType;
	aktivitetRelUdfoerer1 aktivitetRelationType;
	aktivitetRelUdfoerer2 aktivitetRelationType;
	aktivitetRelUdfoerer2B aktivitetRelationType;
	aktivitetRelUdfoerer3 aktivitetRelationType;
	aktivitetRelGeoobjekt aktivitetRelationType;
	uuidAnsvarligklasse uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	uuidResultatklasse1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	uuidVirkStatusAktoerRef uuid :='995e00fa-8675-479d-a0e0-272a85047954'::uuid;

	--uuidResultatklasse2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	urnResultatklasse2 text:='urn:isbn:0451450523'::text;
	uuidDeltagerklasse1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidDeltagerklasse2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidUdfoerer1  uuid :='884d99f6-568f-4772-8766-fac6d40f9cb0'::uuid;
	uuidUdfoerer2  uuid :='b6bb8e41-b47b-4420-b2a3-d1c38d86a1ad'::uuid;
	uuidUdfoerer3  uuid :='30323d2f-3b3d-41ff-81dc-bbbc1d77d4f9'::uuid;
	uuidGeoobjekt  uuid :='17da4471-fdf4-4b92-ba71-be60eaa6aa42'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	repraesentation_uuid uuid :='0e3ed41a-08f2-4967-8689-dce625f93029'::uuid;
	repraesentation_urn text :='isbn:97800232324'::text;
	repraesentation_urn2 text :='isbn:97800800045'::text;
	actual_publiceret_virk virkning;
	actual_publiceret_value aktivitetStatusTils;
	actual_publiceret aktivitetStatusTilsType;
	actual_relationer aktivitetRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	update_reg_id_1 int;
	update_reg_id_2 int;
	read_Aktivitet1 AktivitetType;
	expected_aktivitet1 AktivitetType;
BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, 2015-06-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaber2 :=	ROW (
	'[2015-06-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx90'
          ) :: Virkning
;

virkAnsvarligklasse :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkUdfoerer1 :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx342'
          ) :: Virkning
;

virkUdfoerer2 :=	ROW (
	'[2016-04-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx350'
          ) :: Virkning
;



virkResultatklasse1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkResultatklasse2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkstatus := ROW (
	'[2016-12-18, infinity)' :: TSTZRANGE,
          uuidVirkStatusAktoerRef,
          'Bruger',
          'NoteEx20'
) :: Virkning
;

virkDeltagerklasse1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkDeltagerklasse2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

aktivitetRelAnsvarligklasse := ROW (
	'ansvarligklasse'::aktivitetRelationKode
	,virkAnsvarligklasse
	,uuidAnsvarligklasse
	,null
	,'Klasse'
	,567 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;

aktivitetRelUdfoerer1 := ROW (
	'udfoerer'::aktivitetRelationKode
	,virkUdfoerer1
	,uuidUdfoerer1
	,null
	,'Person'
	,3 --NOTICE: Should be replace in by import function
	,ROW (
		 'valgfri'::AktivitetAktoerAttrObligatoriskKode,
  		'foreloebigt'::AktivitetAktoerAttrAccepteretKode,
  repraesentation_uuid,
  null 
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
;


aktivitetRelUdfoerer2 := ROW (
	'udfoerer'::aktivitetRelationKode
	,virkUdfoerer2
	,uuidUdfoerer2
	,null
	,'Person'
	,3 --NOTICE: Should be replace in by import function
	,ROW (
		 'noedvendig'::AktivitetAktoerAttrObligatoriskKode,
  		'accepteret'::AktivitetAktoerAttrAccepteretKode,
  null,
  repraesentation_urn
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
;


aktivitetRelResultatklasse1 := ROW (
	'resultatklasse'::aktivitetRelationKode,
		virkResultatklasse1,
	uuidResultatklasse1,
	null,
	'Klasse'
	,768 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;



aktivitetRelResultatklasse2 := ROW (
	'resultatklasse'::aktivitetRelationKode,
		virkResultatklasse2,
	null,
	urnResultatklasse2,
	'Klasse'
	,800 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;



aktivitetRelDeltagerklasse1 := ROW (
	'deltagerklasse'::aktivitetRelationKode,
		virkDeltagerklasse1,
	uuidDeltagerklasse1,
	null,
	'Klasse'
	,7268 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;



aktivitetRelDeltagerklasse2 := ROW (
	'deltagerklasse'::aktivitetRelationKode,
		virkDeltagerklasse2,
	uuidDeltagerklasse2,
	null,
	'Klasse'
	,3 --NOTICE: Should be replace in by import function
	,null --aktoerAttr
) :: aktivitetRelationType
;



aktivitetStatus := ROW (
virkStatus,
'Aktiv'::AktivitetStatusTils
):: aktivitetStatusTilsType
;

aktivitetPubliceret := ROW (
virkPubliceret,
'Normal'::AktivitetPubliceretTils
)::aktivitetPubliceretTilsType;


aktivitetEgenskab := ROW (
 'aktivitet_1_brugervendtnoegle',
 'aktivitet_1_aktivitetnavn',
 'aktivitet_1_beskrivelse',
 '2017-02-25 17:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
'2017-02-27 08:00'::timestamptz, -- sluttidspunkt,
  INTERVAL '0000-00 03 02:30:00.0', --tidsforbrug
 'aktivitet_1_formaal'
,virkEgenskaber
) :: aktivitetEgenskaberAttrType
;

aktivitetEgenskab2 := ROW (
 'aktivitet_2_brugervendtnoegle',
 'aktivitet_2_aktivitetnavn',
 'aktivitet_2_beskrivelse',
 '2016-04-20 10:00'::timestamptz,  --'starttidspunkt_aktivitet_1' --text
'2017-02-27 12:00'::timestamptz, -- sluttidspunkt,
  INTERVAL '0000-00 01 04:00:01.0', --tidsforbrug
 'aktivitet_2_formaal'
,virkEgenskaber2
) :: aktivitetEgenskaberAttrType
;


registrering := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[aktivitetStatus]::aktivitetStatusTilsType[],
	ARRAY[aktivitetPubliceret]::AktivitetPubliceretTilsType[],
ARRAY[aktivitetEgenskab,aktivitetEgenskab2]::aktivitetEgenskaberAttrType[],
ARRAY[aktivitetRelAnsvarligklasse,aktivitetRelResultatklasse1,aktivitetRelResultatklasse2,aktivitetRelDeltagerklasse1,aktivitetRelDeltagerklasse2,aktivitetRelUdfoerer1,aktivitetRelUdfoerer2]) :: aktivitetRegistreringType
;


--raise notice 'to be written aktivitet 1:%',to_json(registrering);

new_uuid1 := as_create_or_import_aktivitet(registrering);


/*************************************************************************************************************/

virkUdfoerer2B :=	ROW (
	'[2016-05-20, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx350'
          ) :: Virkning
;

aktivitetRelUdfoerer2B := ROW (
	'udfoerer'::aktivitetRelationKode
	,virkUdfoerer2B
	,uuidUdfoerer2
	,null
	,'Person'
	,2 
	,ROW (
		 'valgfri'::AktivitetAktoerAttrObligatoriskKode,
  		'foreloebigt'::AktivitetAktoerAttrAccepteretKode,
  null,
  repraesentation_urn
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
;


virkUdfoerer3 :=	ROW (
	'[2017-10-30, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx7800'
          ) :: Virkning
;

aktivitetRelUdfoerer3 := ROW (
	'udfoerer'::aktivitetRelationKode
	,virkUdfoerer3
	,uuidUdfoerer3
	,null
	,'Person'
	,null
	,ROW (
		 'noedvendig'::AktivitetAktoerAttrObligatoriskKode,
  		'afslaaet'::AktivitetAktoerAttrAccepteretKode,
  null,
  repraesentation_urn2
	)::AktivitetAktoerAttr
) :: aktivitetRelationType
;


virkGeoobjekt :=ROW (
	'[2016-03-25, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx7001'
          ) :: Virkning
;

aktivitetRelGeoobjekt:= ROW (
	'geoobjekt'::aktivitetRelationKode
	,virkGeoobjekt
	,uuidGeoobjekt
	,null
	,'Geoobjekt'
	,null
	,ROW (
		 'valgfri'::AktivitetAktoerAttrObligatoriskKode,
  		'foreloebigt'::AktivitetAktoerAttrAccepteretKode,
  null,
  repraesentation_urn
	)::AktivitetAktoerAttr --Notice: Should be discarded for relations of the 'wrong' types like this type
) :: aktivitetRelationType
;


virkStatus1B := ROW (
	'[2017-05-20, 2017-07-30]' :: TSTZRANGE,
          uuidVirkStatusAktoerRef,
          'Bruger',
          'NoteEx500'
) :: Virkning
;

aktivitetStatus1B := ROW (
virkStatus1B,
'Inaktiv'::AktivitetStatusTils
):: aktivitetStatusTilsType
;


aktivitetEgenskab2B := ROW (
 null, --'aktivitet_2_brugervendtnoegle',
 null, --'aktivitet_2_aktivitetnavn',
 null,--'aktivitet_2_beskrivelse',
 ''::text,  --'starttidspunkt_aktivitet_1' --text
null, --'2017-02-27 12:00'::timestamptz, -- sluttidspunkt,
 ''::text,-- INTERVAL '0000-00 01 04:00:01.0', --tidsforbrug
 null--'aktivitet_2_formaal'
,virkEgenskaber2
) :: aktivitetEgenskaberAttrType
;


update_reg_id_1:=as_update_aktivitet(
  new_uuid1, '5f368584-4c3e-4ba4-837b-da2b1eee37c4'::uuid,'Test update 20'::text,
  'Rettet'::Livscykluskode,          
  array[aktivitetEgenskab2B]::aktivitetEgenskaberAttrType[],
   array[aktivitetStatus1B]::aktivitetStatusTilsType[],
 null,
  array[aktivitetRelUdfoerer2B,aktivitetRelUdfoerer3,aktivitetRelGeoobjekt]::AktivitetRelationType[]
	);



read_Aktivitet1 := as_read_aktivitet(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'read_updated_Aktivitet1:%',to_json(read_Aktivitet1);


expected_aktivitet1:=ROW(
		new_uuid1,
		ARRAY[
			ROW(
			(read_Aktivitet1.registrering[1]).registrering
			,ARRAY[
				aktivitetStatus1B
				,ROW (
							ROW (
				'[2016-12-18, 2017-05-20)' :: TSTZRANGE,
					uuidVirkStatusAktoerRef,
					'Bruger',
					'NoteEx20'
			) :: Virkning,
				'Aktiv'::AktivitetStatusTils
				):: aktivitetStatusTilsType
			,	
			ROW (
							ROW (
				'(2017-07-30, infinity)' :: TSTZRANGE,
					uuidVirkStatusAktoerRef,
					'Bruger',
					'NoteEx20'
			) :: Virkning,
				'Aktiv'::AktivitetStatusTils
				):: aktivitetStatusTilsType
			]::aktivitetStatusTilsType[]
			,ARRAY[aktivitetPubliceret]::aktivitetPubliceretTilsType[]
			,ARRAY[aktivitetEgenskab,
							ROW (
				'aktivitet_2_brugervendtnoegle',
				'aktivitet_2_aktivitetnavn',
				'aktivitet_2_beskrivelse',
				Row(null,null)::ClearableTimestamptz,  --was cleared
				'2017-02-27 12:00'::timestamptz, -- sluttidspunkt,
				Row(null,null)::ClearableInterval, --was cleared
				'aktivitet_2_formaal'
				,virkEgenskaber2
				) :: aktivitetEgenskaberAttrType
			]::aktivitetEgenskaberAttrType[]
			,ARRAY[
					ROW ( --Notice: Was added
						'geoobjekt'::aktivitetRelationKode
						,virkGeoobjekt
						,uuidGeoobjekt
						,null
						,'Geoobjekt'
						,1
						,ROW (null,null,null,null)::AktivitetAktoerAttr --Notice: Should be discarded for relations of the 'wrong' types like this type
					) :: aktivitetRelationType
					,
				ROW (
				'deltagerklasse'::aktivitetRelationKode,
					virkDeltagerklasse2,
				uuidDeltagerklasse2,
				null,
				'Klasse'
				,2 --NOTICE: Should be replace in by import function
				,ROW (null,null,null,null)::AktivitetAktoerAttr   --NOTICE: empty composites will be removed in python layer --aktoerAttr
			) :: aktivitetRelationType
			,
							ROW (
					'udfoerer'::aktivitetRelationKode
					,virkUdfoerer3
					,uuidUdfoerer3
					,null
					,'Person'
					,3
					,ROW (
						'noedvendig'::AktivitetAktoerAttrObligatoriskKode,
						'afslaaet'::AktivitetAktoerAttrAccepteretKode,
				null,
				repraesentation_urn2
					)::AktivitetAktoerAttr
				) :: aktivitetRelationType
			,	
			ROW (
					'udfoerer'::aktivitetRelationKode
					,virkUdfoerer1
					,uuidUdfoerer1
					,null
					,'Person'
					,1 --NOTICE: was replaced by import function
					,ROW (
						'valgfri'::AktivitetAktoerAttrObligatoriskKode,
						'foreloebigt'::AktivitetAktoerAttrAccepteretKode,
				repraesentation_uuid,
				null 
					)::AktivitetAktoerAttr
				) :: aktivitetRelationType
				,
				ROW ( --NOTICE: Was updated
					'udfoerer'::aktivitetRelationKode
					,virkUdfoerer2B
					,uuidUdfoerer2
					,null
					,'Person'
					,2 
					,ROW (
						'valgfri'::AktivitetAktoerAttrObligatoriskKode,
						'foreloebigt'::AktivitetAktoerAttrAccepteretKode,
				null,
				repraesentation_urn
					)::AktivitetAktoerAttr
				) :: aktivitetRelationType
				,
				ROW (
					'resultatklasse'::aktivitetRelationKode,
						virkResultatklasse1,
					uuidResultatklasse1,
					null,
					'Klasse'
					,1 --NOTICE: Was replaced
					,ROW (null,null,null,null)::AktivitetAktoerAttr  --aktoerAttr
				) :: aktivitetRelationType
				,
				ROW (
				'deltagerklasse'::aktivitetRelationKode,
					virkDeltagerklasse1,
				uuidDeltagerklasse1,
				null,
				'Klasse'
				,1 --NOTICE: Was replaced  by import function
				,ROW (null,null,null,null)::AktivitetAktoerAttr  --aktoerAttr
			) :: aktivitetRelationType,

				ROW (
				'ansvarligklasse'::aktivitetRelationKode
				,virkAnsvarligklasse
				,uuidAnsvarligklasse
				,null
				,'Klasse'
				,NULL --NOTICE: Was replaced
				,ROW (null,null,null,null)::AktivitetAktoerAttr  --aktoerAttr
			) :: aktivitetRelationType
			,ROW (
				'resultatklasse'::aktivitetRelationKode,
					virkResultatklasse2,
				null,
				urnResultatklasse2,
				'Klasse'
				,2 --NOTICE: Was replaced
				,ROW (null,null,null,null)::AktivitetAktoerAttr  --aktoerAttr
			) :: aktivitetRelationType

				]::AktivitetRelationType[]
			)::AktivitetRegistreringType
			]::AktivitetRegistreringType[]
		)::AktivitetType
;

--raise notice 'expected_updated_aktivitet1:%',to_json(expected_aktivitet1);



RETURN NEXT IS(
	read_Aktivitet1,
	expected_aktivitet1
	,'test update aktivitet #1'
);


--TODO: Test: To delete / clear a relation with a given index, you specify a blank uuid and/or a blank urn for that particular index.

/******************************************************/

--Test if providing empty arguments will trigger exception as expected 
BEGIN

update_reg_id_2:=as_update_aktivitet(
  new_uuid1, '5f368584-4c3e-4ba4-837b-da2b1eee37c4'::uuid,'Test update 20'::text,
  'Rettet'::Livscykluskode,          
  null,
  null,
  null,
  null
	);

RETURN NEXT ok(false,'as_update_aktivitet empty arguments: Should throw MO400 exception');
EXCEPTION  
WHEN sqlstate 'MO400' THEN
	RETURN NEXT ok(true,'as_update_aktivitet empty arguments: Throws MO400 exception (as it should)');

END;







END;
$$;


ALTER FUNCTION test.test_as_update_aktivitet() OWNER TO mox;

--
-- Name: test_as_update_dokument(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_update_dokument() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 

doc1_new_uuid uuid;
	doc1_registrering dokumentRegistreringType;
	doc1_virkEgenskaber1 Virkning;
	doc1_virkEgenskaber2 Virkning;
	doc1_virkAnsvarlig Virkning;
	doc1_virkBesvarelser1 Virkning;
	doc1_virkBesvarelser2 Virkning;
	doc1_virkFremdrift Virkning;
	doc1_dokumentEgenskab1 dokumentEgenskaberAttrType;
	doc1_dokumentEgenskab2 dokumentEgenskaberAttrType;
	doc1_dokumentFremdrift dokumentFremdriftTilsType;
	doc1_dokumentRelAnsvarlig dokumentRelationType;
	doc1_dokumentRelBesvarelser1 dokumentRelationType;
	doc1_dokumentRelBesvarelser2 dokumentRelationType;
	doc1_uuidAnsvarlig uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	doc1_uuidBesvarelser1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	--uuidBesvarelser2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	doc1_urnBesvarelser2 text:='urn:isbn:0451450523'::text;
	doc1_uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	doc1_docVariant1 DokumentVariantType;
	doc1_docVariant2 DokumentVariantType;
	doc1_docVariantEgenskaber1A DokumentVariantEgenskaberType;
	doc1_docVariantEgenskaber1AVirkning Virkning;
	doc1_docVariantEgenskaber1B DokumentVariantEgenskaberType;
	doc1_docVariantEgenskaber1BVirkning Virkning;
	doc1_docVariantEgenskaber2A DokumentVariantEgenskaberType;
	doc1_docVariantEgenskaber2AVirkning Virkning;	
	doc1_docDel1A DokumentDelType;
	doc1_docDel1B DokumentDelType;
	doc1_docDel2A DokumentDelType;
	doc1_docDel2B DokumentDelType;
	doc1_docDel1AEgenskaber DokumentDelEgenskaberType;
	doc1_docDel1A2Egenskaber DokumentDelEgenskaberType;
	doc1_docDel1AEgenskaberVirkning Virkning;
	doc1_docDel1A2EgenskaberVirkning Virkning;
	doc1_docDel1BEgenskaber DokumentDelEgenskaberType;
	doc1_docDel1BEgenskaberVirkning Virkning;
	doc1_docDel2AEgenskaber DokumentDelEgenskaberType;
	doc1_docDel2AEgenskaberVirkning Virkning;
	doc1_docDel1Arelation1 DokumentdelRelationType;
	doc1_docDel1Arelation1Virkning Virkning;
	doc1_docDel2Brelation1 DokumentdelRelationType;
	doc1_docDel2Brelation1Virkning Virkning;
	doc1_docDel2Brelation2 DokumentdelRelationType;
	doc1_docDel2Brelation2Virkning Virkning;

	doc1_extraRel1 DokumentdelRelationType;
	doc1_extraRel2 DokumentdelRelationType;
	doc1_extraRelVirkning1 Virkning;
	doc1_extraRelVirkning2 Virkning;

	doc2_registrering dokumentRegistreringType;

	doc2_virkEgenskaber1 Virkning;
	doc2_virkEgenskaber2 Virkning;
	doc2_virkAnsvarlig Virkning;
	doc2_virkBesvarelser1 Virkning;
	doc2_virkBesvarelser2 Virkning;
	doc2_virkFremdrift Virkning;
	doc2_dokumentEgenskab1 dokumentEgenskaberAttrType;
	doc2_dokumentEgenskab2 dokumentEgenskaberAttrType;
	doc2_dokumentFremdrift dokumentFremdriftTilsType;
	doc2_dokumentRelAnsvarlig dokumentRelationType;
	doc2_dokumentRelBesvarelser1 dokumentRelationType;
	doc2_dokumentRelBesvarelser2 dokumentRelationType;
	doc2_uuidAnsvarlig uuid :='17109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	doc2_uuidBesvarelser1 uuid :='27160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	--uuidBesvarelser2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	doc2_urnBesvarelser2 text:='urn:isbn:9451450523'::text;
	doc2_uuidRegistrering uuid :='3f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	doc2_docVariant1 DokumentVariantType;
	doc2_docVariant2 DokumentVariantType;
	doc2_docVariantEgenskaber1A DokumentVariantEgenskaberType;
	doc2_docVariantEgenskaber1AVirkning Virkning;
	doc2_docVariantEgenskaber1B DokumentVariantEgenskaberType;
	doc2_docVariantEgenskaber1BVirkning Virkning;
	doc2_docVariantEgenskaber2A DokumentVariantEgenskaberType;
	doc2_docVariantEgenskaber2AVirkning Virkning;	


	doc2_docDel1A DokumentDelType;
	doc2_docDel1B DokumentDelType;
	doc2_docDel2A DokumentDelType;
	doc2_docDel2B DokumentDelType;
	doc2_docDel1AEgenskaber DokumentDelEgenskaberType;
	doc2_docDel1A2Egenskaber DokumentDelEgenskaberType;
	doc2_docDel1AEgenskaberVirkning Virkning;
	doc2_docDel1A2EgenskaberVirkning Virkning;
	doc2_docDel1BEgenskaber DokumentDelEgenskaberType;
	doc2_docDel1BEgenskaberVirkning Virkning;
	doc2_docDel2AEgenskaber DokumentDelEgenskaberType;
	doc2_docDel2AEgenskaberVirkning Virkning;
	doc2_docDel1Arelation1 DokumentdelRelationType;
	doc2_docDel1Arelation1Virkning Virkning;
	doc2_docDel2Brelation1 DokumentdelRelationType;
	doc2_docDel2Brelation1Virkning Virkning;
	doc2_docDel2Brelation2 DokumentdelRelationType;
	doc2_docDel2Brelation2Virkning Virkning;

	updated_reg_id bigint;

	read_dokument1 DokumentType;
	expected_dokument1 DokumentType;
BEGIN 

doc1_virkEgenskaber1 :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          'd71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;


doc1_virkEgenskaber2 :=	ROW (
	'[2014-05-12, 2015-05-12)' :: TSTZRANGE,
          'e71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;


doc1_virkAnsvarlig :=	ROW (
	'[2014-05-11, infinity)' :: TSTZRANGE,
          'f71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

doc1_virkBesvarelser1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          'c71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


doc1_virkBesvarelser2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          'b71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

doc1_virkFremdrift := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          'a71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx10'
) :: Virkning
;

doc1_dokumentRelAnsvarlig := ROW (
	'ansvarlig'::dokumentRelationKode,
		doc1_virkAnsvarlig,
	doc1_uuidAnsvarlig,
	null,
	'Aktr'
) :: dokumentRelationType
;


doc1_dokumentRelBesvarelser1 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc1_virkBesvarelser1,
	doc1_uuidBesvarelser1,
	null,
	null
) :: dokumentRelationType
;



doc1_dokumentRelBesvarelser2 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc1_virkBesvarelser2,
	null,
	doc1_urnBesvarelser2,
	null
) :: dokumentRelationType
;


doc1_dokumentFremdrift := ROW (
doc1_virkFremdrift,
'Underreview'
):: dokumentFremdriftTilsType
;


doc1_dokumentEgenskab1 := ROW (
'doc_brugervendtnoegle1',
'doc_beskrivelse1', 
'10-31-2015'::date,
'doc_kassationskode1', 
4, --major int
9, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel1',
'doc_dokumenttype1',
   doc1_virkEgenskaber1
) :: dokumentEgenskaberAttrType
;

doc1_dokumentEgenskab2 := ROW (
'doc_brugervendtnoegle2',
'doc_beskrivelse2', 
'09-20-2014'::date,
'doc_kassationskode2', 
5, --major int
10, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel2','doc_Offentlighedundtaget_Hjemmel2') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel2',
'doc_dokumenttype2',
   doc1_virkEgenskaber2
) :: dokumentEgenskaberAttrType
;




doc1_docDel2Brelation2Virkning :=	ROW (
	'(2014-02-24, 2015-10-01]' :: TSTZRANGE,
          '971cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;

doc1_docDel2Brelation1Virkning :=	ROW (
	'[2012-05-08, infinity)' :: TSTZRANGE,
          '871cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;


doc1_docDel1Arelation1Virkning :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          '771cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx71'
          ) :: Virkning
;


doc1_docVariantEgenskaber2AVirkning :=	ROW (
	'[2014-07-12, infinity)' :: TSTZRANGE,
          '671cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx281'
          ) :: Virkning
;

doc1_docVariantEgenskaber1BVirkning :=	ROW (
	'[2015-01-01, infinity)' :: TSTZRANGE,
          '571cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx291'
          ) :: Virkning
;


doc1_docVariantEgenskaber1AVirkning :=	ROW (
	'[2013-02-27, 2015-01-01)' :: TSTZRANGE,
          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx191'
          ) :: Virkning
;

doc1_docDel1AEgenskaberVirkning :=	ROW (
	'[2014-03-30, infinity)' :: TSTZRANGE,
          '371cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;

doc1_docDel1A2EgenskaberVirkning :=	ROW (
	'[2010-01-20, 2014-03-20)' :: TSTZRANGE,
          '271cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx113'
          ) :: Virkning
;


doc1_docDel1BEgenskaberVirkning :=	ROW (
	'[2015-10-11, infinity)' :: TSTZRANGE,
          '171cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

doc1_docDel2AEgenskaberVirkning :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '901cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx13'
          ) :: Virkning
;

doc1_extraRelVirkning1 :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '120cc58a-3149-414a-9392-dcbcbbccddd9'::uuid,
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;
doc1_extraRelVirkning2 :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '280cc58a-3149-414a-9392-dcbcbbccddc0'::uuid,
          'Bruger',
          'NoteEx143'
          ) :: Virkning
;


doc1_docVariantEgenskaber1A:=
ROW(
true, --arkivering boolean, 
false, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
false, --produktion boolean,
 doc1_docVariantEgenskaber1AVirkning
)::DokumentVariantEgenskaberType;

doc1_docVariantEgenskaber1B:=
ROW(
false, --arkivering boolean, 
false, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
true, --produktion boolean,
 doc1_docVariantEgenskaber1BVirkning
)::DokumentVariantEgenskaberType;


doc1_docVariantEgenskaber2A:=
ROW(
false, --arkivering boolean, 
true, --delvisscannet boolean, 
false, --offentliggoerelse boolean, 
true, --produktion boolean,
 doc1_docVariantEgenskaber2AVirkning
)::DokumentVariantEgenskaberType;


doc1_docDel2Brelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_docDel2Brelation1Virkning,
  'a24a2dd4-415f-4104-b7a7-84607488c096'::uuid,
  null, --urn,
  'Bruger'
)::DokumentdelRelationType;


doc1_docDel2Brelation2:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_docDel2Brelation2Virkning,
  null,
  'urn:cpr 8883394', 
  'Bruger'
)::DokumentdelRelationType;


doc1_docDel1Arelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_docDel1Arelation1Virkning,
  'b24a2dd4-415f-4104-b7a7-84607488c091'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;

doc1_extraRel1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_extraRelVirkning1,
  '009a2dd4-415f-4104-b7a7-84607488c027'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;


doc1_extraRel2:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc1_extraRelVirkning2,
  '889a2dd4-415f-4104-b7a7-84607488c019'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;



doc1_docDel1AEgenskaber:= ROW(
1, --indeks int,
'del_indhold1', 
'del_lokation1', 
'del_mimetype1',
 doc1_docDel1AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc1_docDel1A2Egenskaber:=ROW(
2, --indeks int,
'del_indhold4', 
'del_lokation4', 
'del_mimetype4',
 doc1_docDel1A2EgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc1_docDel1BEgenskaber:= ROW(
98, --indeks int,
'del_indhold2', 
'del_lokation2', 
'del_mimetype2',
 doc1_docDel1BEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc1_docDel2AEgenskaber:= ROW(
8, --indeks int,
'del_indhold3', 
'del_lokation3', 
'del_mimetype3',
 doc1_docDel2AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;


doc1_docDel1A:=
ROW(
'doc_deltekst1A',
  ARRAY[doc1_docDel1AEgenskaber,doc1_docDel1A2Egenskaber],
  ARRAY[doc1_docDel1Arelation1]
)::DokumentDelType;

doc1_docDel1B:=
ROW(
'doc_deltekst1B',
  ARRAY[doc1_docDel1BEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc1_docDel2A:=
ROW(
'doc_deltekst2A',
  ARRAY[doc1_docDel2AEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc1_docDel2B:=
ROW(
'doc_deltekst2B',
  null,--ARRAY[]::DokumentDelEgenskaberType[],
  ARRAY[doc1_docDel2Brelation1,doc1_docDel2Brelation2]
)::DokumentDelType;


doc1_docVariant1 := ROW (
	'doc_varianttekst2_1',
  	ARRAY[doc1_docVariantEgenskaber1B,doc1_docVariantEgenskaber1A],
  	ARRAY[doc1_docDel1A,
  	ROW(
  		'doc_deltekst1B',
  		ARRAY[doc1_docDel1BEgenskaber],
  		ARRAY[doc1_extraRel1,doc1_extraRel2]
  		)::DokumentDelType
  	]
)::DokumentVariantType;


doc1_docVariant2 := ROW (
	'doc_varianttekst2',
  ARRAY[doc1_docVariantEgenskaber2A],
  ARRAY[doc1_docDel2A,doc1_docDel2B]
)::DokumentVariantType;

doc1_registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	doc1_uuidRegistrering,
	'Test Note 85') :: RegistreringBase
	,
ARRAY[doc1_dokumentFremdrift]::dokumentFremdriftTilsType[],
ARRAY[doc1_dokumentEgenskab1,doc1_dokumentEgenskab2]::dokumentEgenskaberAttrType[],
ARRAY[doc1_dokumentRelBesvarelser1,doc1_dokumentRelAnsvarlig,doc1_dokumentRelBesvarelser2],
ARRAY[doc1_docVariant1,doc1_docVariant2]
) :: dokumentRegistreringType
;


doc1_new_uuid := as_create_or_import_dokument(doc1_registrering);



/**************************************************************/
/*						Create doc 2						  */
/**************************************************************/


doc2_virkEgenskaber1 :=	ROW (
	'[2014-06-20, 2015-06-30)' :: TSTZRANGE,
          'c71cc58a-3149-414a-9392-dcbcbbccddfe'::uuid,
          'Bruger',
          'NoteEx13'
          ) :: Virkning
;


doc2_virkEgenskaber2 :=	ROW (
	'[2013-11-30, 2014-02-20)' :: TSTZRANGE,
          'd71cc58a-3149-414a-9392-dcbcbbccddf7'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;


doc2_virkAnsvarlig :=	ROW (
	'[2014-12-31, infinity)' :: TSTZRANGE,
          'a71cc58a-3149-414a-9392-dcbcbbccddf7'::uuid,
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;

doc2_virkBesvarelser1 :=	ROW (
	'[2015-12-09, infinity)' :: TSTZRANGE,
          '371cc58a-3149-414a-9392-dcbcbbccddf9'::uuid,
          'Bruger',
          'NoteEx239'
          ) :: Virkning
;


doc2_virkBesvarelser2 :=	ROW (
	'[2015-04-10, 2017-05-10)' :: TSTZRANGE,
          'c71cc58a-3149-414a-9392-dcbcbbccddf1'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

doc2_virkFremdrift := ROW (
	'[2011-04-20, 2014-03-08)' :: TSTZRANGE,
          'a71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx10'
) :: Virkning
;

doc2_dokumentRelAnsvarlig := ROW (
	'ansvarlig'::dokumentRelationKode,
		doc2_virkAnsvarlig,
	doc2_uuidAnsvarlig,
	null,
	'Aktr'
) :: dokumentRelationType
;


doc2_dokumentRelBesvarelser1 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc2_virkBesvarelser1,
	doc2_uuidBesvarelser1,
	null,
	null
) :: dokumentRelationType
;



doc2_dokumentRelBesvarelser2 := ROW (
	'besvarelser'::dokumentRelationKode,
		doc2_virkBesvarelser2,
	null,
	doc2_urnBesvarelser2,
	null
) :: dokumentRelationType
;


doc2_dokumentFremdrift := ROW (
doc2_virkFremdrift,
'Fordelt'
):: dokumentFremdriftTilsType
;


doc2_dokumentEgenskab1 := ROW (
'doc_brugervendtnoegle2_1',
'doc_beskrivelse2_1', 
'01-10-2014'::date,
null, --'doc_kassationskode2_1', 
null, --major int
''::text, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel2_1','doc_Offentlighedundtaget_Hjemmel2_1') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel2_1',
'doc_dokumenttype2_1',
   doc2_virkEgenskaber1
) :: dokumentEgenskaberAttrType
;

doc2_dokumentEgenskab2 := ROW (
'doc_brugervendtnoegle2_2',
'doc_beskrivelse2_2', 
'08-28-2013'::date,
'doc_kassationskode2_2', 
12, --major int
6, --minor int
ROW('doc_Offentlighedundtaget_AlternativTitel2_2','doc_Offentlighedundtaget_Hjemmel2_2') ::OffentlighedundtagetType, --offentlighedundtagettype,
'doc_titel2_2',
'doc_dokumenttype2_2',
   doc2_virkEgenskaber2
) :: dokumentEgenskaberAttrType
;




doc2_docDel2Brelation2Virkning :=	ROW (
	'(2012-07-12, 2014-10-01]' :: TSTZRANGE,
          '071cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;

doc2_docDel2Brelation1Virkning :=	ROW (
	'[2013-05-07, infinity)' :: TSTZRANGE,
          '171cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx70'
          ) :: Virkning
;


doc2_docDel1Arelation1Virkning :=	ROW (
	'[2013-10-15, infinity)' :: TSTZRANGE,
          '271cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx71'
          ) :: Virkning
;


doc2_docVariantEgenskaber2AVirkning :=	ROW (
	'[2014-07-12, infinity)' :: TSTZRANGE,
          '371cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx281'
          ) :: Virkning
;

doc2_docVariantEgenskaber1BVirkning :=	ROW (
	'[2015-03-01, infinity)' :: TSTZRANGE,
          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx291'
          ) :: Virkning
;


doc2_docVariantEgenskaber1AVirkning :=	ROW (
	'[2013-03-27, 2014-05-11)' :: TSTZRANGE,
          '571cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx191'
          ) :: Virkning
;

doc2_docDel1AEgenskaberVirkning :=	ROW (
	'[2014-05-19, infinity)' :: TSTZRANGE,
          '671cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning
;

doc2_docDel1A2EgenskaberVirkning :=	ROW (
	'[2010-06-25, 2014-01-10)' :: TSTZRANGE,
          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx113'
          ) :: Virkning
;


doc2_docDel1BEgenskaberVirkning :=	ROW (
	'[2015-10-11, infinity)' :: TSTZRANGE,
          '871cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

doc2_docDel2AEgenskaberVirkning :=	ROW (
	'[2013-02-28, infinity)' :: TSTZRANGE,
          '001cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx13'
          ) :: Virkning
;


doc2_docVariantEgenskaber1A:=
ROW(
false, --arkivering boolean, 
NULL, --delvisscannet boolean, 
true, --offentliggoerelse boolean, 
true, --produktion boolean,
 doc2_docVariantEgenskaber1AVirkning
)::DokumentVariantEgenskaberType;

doc2_docVariantEgenskaber1B:=
ROW(
true, --arkivering boolean, 
false, --delvisscannet boolean, 
''::text, --offentliggoerelse boolean, 
true, --produktion boolean,
 doc2_docVariantEgenskaber1BVirkning
)::DokumentVariantEgenskaberType;


doc2_docVariantEgenskaber2A:=
ROW(
false, --arkivering boolean, 
false, --delvisscannet boolean, 
false, --offentliggoerelse boolean, 
false, --produktion boolean,
 doc2_docVariantEgenskaber2AVirkning
)::DokumentVariantEgenskaberType;


doc2_docDel2Brelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc2_docDel2Brelation1Virkning,
  '124a2dd4-415f-4104-b7a7-84607488c096'::uuid,
  null, --urn,
  'Bruger'
)::DokumentdelRelationType;


doc2_docDel2Brelation2:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc2_docDel2Brelation2Virkning,
  null,
  'urn:cpr 8883394', 
  'Bruger'
)::DokumentdelRelationType;


doc2_docDel1Arelation1:=
ROW (
  'underredigeringaf'::DokumentdelRelationKode,
  doc2_docDel2Brelation2Virkning,
  '524a2dd4-415f-4104-b7a7-84607488c091'::uuid,
  null, 
  'Bruger'
)::DokumentdelRelationType;


doc2_docDel1AEgenskaber:= ROW(
''::text, --indeks int,
null, 
'del_lokation2_1', 
'del_mimetype2_1',
 doc2_docDel1AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc2_docDel1A2Egenskaber:=ROW(
2, --indeks int,
'del_indhold2_4', 
'del_lokation2_4', 
'del_mimetype2_4',
 doc2_docDel1A2EgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc2_docDel1BEgenskaber:= ROW(
98, --indeks int,
'del_indhold2_2', 
'del_lokation2_2', 
'del_mimetype2_2',
 doc2_docDel1BEgenskaberVirkning 
)::DokumentDelEgenskaberType
;

doc2_docDel2AEgenskaber:= ROW(
8, --indeks int,
'del_indhold2_3', 
'del_lokation2_3', 
'del_mimetype2_3',
 doc2_docDel2AEgenskaberVirkning 
)::DokumentDelEgenskaberType
;


doc2_docDel1A:=
ROW(
'doc_deltekst1A', --NOTICE!
  ARRAY[doc2_docDel1AEgenskaber,doc2_docDel1A2Egenskaber],
  null--ARRAY[doc2_docDel1Arelation1]
)::DokumentDelType;

doc2_docDel1B:=
ROW(
'doc_deltekst2_1B',
  ARRAY[doc2_docDel1BEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc2_docDel2A:=
ROW(
'doc_deltekst2_2A',
  ARRAY[doc2_docDel2AEgenskaber],
  null--ARRAY[]::DokumentdelRelationType[]
)::DokumentDelType;

doc2_docDel2B:=
ROW(
'doc_deltekst2_2B',
  null,--ARRAY[]::DokumentDelEgenskaberType[],
  ARRAY[doc2_docDel2Brelation1,doc2_docDel2Brelation2]
)::DokumentDelType;


doc2_docVariant1 := ROW (
	'doc_varianttekst2_1',
  	ARRAY[doc2_docVariantEgenskaber1A,doc2_docVariantEgenskaber1B],
  	ARRAY[doc2_docDel1A,doc2_docDel1B, 
  	ROW(
  		'doc_deltekst1B',
  		ARRAY[ROW(
			''::text, --indeks int,
			''::text, 
			''::text, 
			''::text,
			ROW (
	'(-infinity, infinity)' :: TSTZRANGE,
          '550cc58a-3149-414a-9392-dcbcbbccdd90'::uuid,
          'Bruger',
          'NoteEx6000'
          ) :: Virkning 
		)::DokumentDelEgenskaberType],
  		ARRAY[]::DokumentdelRelationType[]
  		)::DokumentDelType

  	]
)::DokumentVariantType;


doc2_docVariant2 := ROW (
	'doc_varianttekst2_2',
  ARRAY[doc2_docVariantEgenskaber2A],
  ARRAY[doc2_docDel2A,doc2_docDel2B]
)::DokumentVariantType;

read_dokument1 := as_read_dokument(doc1_new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--RAISE NOTICE 'read_dokument1 pre update:,%',read_dokument1::json;

updated_reg_id:=as_update_dokument(
  doc1_new_uuid,
  doc2_uuidRegistrering,
  'Test Note 80',
  'Rettet'::Livscykluskode,           
  ARRAY[doc2_dokumentEgenskab1,doc2_dokumentEgenskab2],
  ARRAY[doc2_dokumentFremdrift],
  ARRAY[doc2_dokumentRelAnsvarlig,doc2_dokumentRelBesvarelser1,doc2_dokumentRelBesvarelser2],
  ARRAY[doc2_docVariant1,doc2_docVariant2,

 ROW (
	'doc_varianttekst1',
  	ARRAY[
		ROW(
		true, --arkivering boolean, 
		null, --delvisscannet boolean, 
		null, --offentliggoerelse boolean, 
		false, --produktion boolean,
		 	ROW (
		'[2015-02-01, 2016-12-20]' :: TSTZRANGE,
          '571cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
          'Bruger',
          'NoteEx300'
          ) :: Virkning
		)::DokumentVariantEgenskaberType
,	
	ROW(
	true, --arkivering boolean, 
	false, --delvisscannet boolean, 
	false, --offentliggoerelse boolean, 
	true, --produktion boolean,
	 ROW (
		'[2014-02-27, 2015-02-01)' :: TSTZRANGE,
	          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
	          'Bruger',
	          'NoteEx198'
	          ) :: Virkning
	)::DokumentVariantEgenskaberType
 			],
  	ARRAY[doc1_docDel1A,doc1_docDel1B]
  	)::DokumentVariantType
  	,
  	 ROW (
	'doc_varianttekst2',
  ARRAY[doc1_docVariantEgenskaber2A],
  ARRAY[doc1_docDel2A,doc1_docDel2B]
	)::DokumentVariantType

  ],
  null
);


read_dokument1 := as_read_dokument(doc1_new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

expected_dokument1:=ROW(

	doc1_new_uuid,
   ARRAY[
   		ROW(
   			ROW(((read_dokument1.registrering[1]).registrering).timeperiod,
			'Rettet'::Livscykluskode,-- livscykluskode,
			doc2_uuidRegistrering,-- uuid,
			'Test Note 80')::RegistreringBase ,
			ARRAY[
				ROW (
					ROW (
					'[2011-04-20, 2014-03-08)' :: TSTZRANGE,
				          'a71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
				          'Bruger',
				          'NoteEx10'
						) :: Virkning,
				'Fordelt'
					):: dokumentFremdriftTilsType,
				 ROW (
					ROW (
						'[2015-05-18, infinity)' :: TSTZRANGE,
					    'a71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
					    'Bruger',
					    'NoteEx10'
					) :: Virkning,
				'Underreview'
				):: dokumentFremdriftTilsType
				
			]::DokumentFremdriftTilsType[],
			ARRAY[
			ROW (
				'doc_brugervendtnoegle1',
				'doc_beskrivelse1', 
				'10-31-2015'::date,
				'doc_kassationskode1', 
				4, --major int
				9, --minor int
				ROW('doc_Offentlighedundtaget_AlternativTitel1','doc_Offentlighedundtaget_Hjemmel1') ::OffentlighedundtagetType, --offentlighedundtagettype,
				'doc_titel1',
				'doc_dokumenttype1',
				ROW( '[2015-06-30, infinity)' :: TSTZRANGE,
				          'd71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
				          'Bruger',
				          'NoteEx1'
				   	) :: Virkning
				)::DokumentEgenskaberAttrType,
				ROW (
				'doc_brugervendtnoegle2',
				'doc_beskrivelse2', 
				'09-20-2014'::date,
				'doc_kassationskode2', 
				5, --major int
				10, --minor int
				ROW('doc_Offentlighedundtaget_AlternativTitel2','doc_Offentlighedundtaget_Hjemmel2') ::OffentlighedundtagetType, --offentlighedundtagettype,
				'doc_titel2',
				'doc_dokumenttype2',
				ROW(
				   '[2014-05-12, 2014-06-20)' :: TSTZRANGE,
         			'e71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
         			'Bruger',
          			'NoteEx11'
          			) :: Virkning
				) :: DokumentEgenskaberAttrType,
				ROW (
					'doc_brugervendtnoegle2_1',
					'doc_beskrivelse2_1', 
					'01-10-2014'::date,
					'doc_kassationskode1', --'doc_kassationskode2_1', 
					4, --major int
					ROW(null,null)::ClearableInt, --minor int
					ROW('doc_Offentlighedundtaget_AlternativTitel2_1','doc_Offentlighedundtaget_Hjemmel2_1') ::OffentlighedundtagetType, --offentlighedundtagettype,
					'doc_titel2_1',
					'doc_dokumenttype2_1',
					ROW (
						'[2015-05-12, 2015-06-30)' :: TSTZRANGE,
					          'c71cc58a-3149-414a-9392-dcbcbbccddfe'::uuid,
					          'Bruger',
					          'NoteEx13'
					) :: Virkning
				) :: DokumentEgenskaberAttrType
				,ROW (
					'doc_brugervendtnoegle2_1',
					'doc_beskrivelse2_1', 
					'01-10-2014'::date,
					'doc_kassationskode2', --'doc_kassationskode2_1', 
					5, --major int
					ROW(null,null)::ClearableInt, --minor int
					ROW('doc_Offentlighedundtaget_AlternativTitel2_1','doc_Offentlighedundtaget_Hjemmel2_1') ::OffentlighedundtagetType, --offentlighedundtagettype,
					'doc_titel2_1',
					'doc_dokumenttype2_1',
					   ROW (
							'[2014-06-20, 2015-05-12)' :: TSTZRANGE,
						    'c71cc58a-3149-414a-9392-dcbcbbccddfe'::uuid,
						    'Bruger',
						    'NoteEx13'
						    ) :: Virkning
					) :: DokumentEgenskaberAttrType
				,ROW (
					'doc_brugervendtnoegle2_2',
					'doc_beskrivelse2_2', 
					'08-28-2013'::date,
					'doc_kassationskode2_2', 
					12, --major int
					6, --minor int
					ROW('doc_Offentlighedundtaget_AlternativTitel2_2','doc_Offentlighedundtaget_Hjemmel2_2') ::OffentlighedundtagetType, --offentlighedundtagettype,
					'doc_titel2_2',
					'doc_dokumenttype2_2',
					   	ROW (
							'[2013-11-30, 2014-02-20)' :: TSTZRANGE,
						    'd71cc58a-3149-414a-9392-dcbcbbccddf7'::uuid,
						    'Bruger',
						    'NoteEx11'
						    ) :: Virkning
					) :: dokumentEgenskaberAttrType
			]::DokumentEgenskaberAttrType[],
			ARRAY[
			ROW (
				'ansvarlig'::dokumentRelationKode,
					ROW (
					'[2014-12-31, infinity)' :: TSTZRANGE,
				          'a71cc58a-3149-414a-9392-dcbcbbccddf7'::uuid,
				          'Bruger',
				          'NoteEx23'
				          ) :: Virkning,
				doc2_uuidAnsvarlig,
				null,
				'Aktr'
			) :: dokumentRelationType

			,ROW (
				'ansvarlig'::dokumentRelationKode,
					ROW (
						'[2014-05-11, 2014-12-31)' :: TSTZRANGE,
					    'f71cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
					    'Bruger',
					    'NoteEx2'
          			) :: Virkning,
				doc1_uuidAnsvarlig,
				null,
				'Aktr'
			) :: dokumentRelationType
			 ,doc2_dokumentRelBesvarelser1
			 ,doc2_dokumentRelBesvarelser2
			]::DokumentRelationType[],
			ARRAY[
					 ROW (
						'doc_varianttekst2_1',
					  	ARRAY[
					  		ROW(
								false, --arkivering boolean, 
								false, --delvisscannet boolean, 
								true, --offentliggoerelse boolean, 
								true, --produktion boolean,
								 ROW (
								'[2013-03-27, 2014-05-11)' :: TSTZRANGE,
							          '571cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
							          'Bruger',
							          'NoteEx191'
							          ) :: Virkning
							)::DokumentVariantEgenskaberType
					  		,ROW(
								false, --arkivering boolean, 
								false, --delvisscannet boolean, 
								true, --offentliggoerelse boolean, 
								true, --produktion boolean,
								ROW(
								 '[2015-01-01, 2015-03-01)' :: TSTZRANGE,
						          '571cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
						          'Bruger',
						          'NoteEx291'
						          ) :: Virkning

							)
							,ROW(
							true, --arkivering boolean, 
							false, --delvisscannet boolean, 
							true, --offentliggoerelse boolean, 
							false, --produktion boolean,
							 ROW (
								'[2013-02-27, 2013-03-27)' :: TSTZRANGE,
							          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
							          'Bruger',
							          'NoteEx191'
							          ) :: Virkning
							)::DokumentVariantEgenskaberType
							,ROW(
							true, --arkivering boolean, 
							false, --delvisscannet boolean, 
							true, --offentliggoerelse boolean, 
							false, --produktion boolean,
							 ROW (
								'[2014-05-11, 2015-01-01)' :: TSTZRANGE,
							          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
							          'Bruger',
							          'NoteEx191'
							          ) :: Virkning
							 )::DokumentVariantEgenskaberType
							,ROW(
							true, --arkivering boolean, 
							false, --delvisscannet boolean, 
							row(null,null)::ClearableBoolean, --offentliggoerelse boolean, 
							true, --produktion boolean,
							 ROW (
								'[2015-03-01, infinity)' :: TSTZRANGE,
							          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
							          'Bruger',
							          'NoteEx291'
							          ) :: Virkning
							 )::DokumentVariantEgenskaberType
							]::DokumentVariantEgenskaberType[]
					  	,ARRAY[

					  	
					  	ROW(
					  		'doc_deltekst1A',
					  		 ARRAY[
					  		 ROW(
									1, --indeks int,
									'del_indhold1', 
									'del_lokation1', 
									'del_mimetype1',
									 ROW (
										'[2014-03-30, 2014-05-19)' :: TSTZRANGE,
									          '371cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
									          'Bruger',
									          'NoteEx11'
									     ) :: Virkning
								 	)::DokumentDelEgenskaberType
					  		 	,
					  		 	ROW(
									2, --indeks int,
									'del_indhold2_4', 
									'del_lokation2_4', 
									'del_mimetype2_4',
									 ROW (
										'[2010-06-25, 2014-01-10)' :: TSTZRANGE,
									          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
									          'Bruger',
									          'NoteEx113'
									          ) :: Virkning
									 )::DokumentDelEgenskaberType
					  		 	,

					  		 	ROW(
									2, --indeks int,
									'del_indhold4', 
									'del_lokation4', 
									'del_mimetype4',
 									ROW (
									'[2010-01-20, 2010-06-25)' :: TSTZRANGE,
								          '271cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
								          'Bruger',
								          'NoteEx113'
								          ) :: Virkning
					  		  		)::DokumentDelEgenskaberType
					  			,
					  			ROW(
									2, --indeks int,
									'del_indhold4', 
									'del_lokation4', 
									'del_mimetype4',
									 ROW (
										'[2014-01-10, 2014-03-20)' :: TSTZRANGE,
								    	'271cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
								        'Bruger',
								        'NoteEx113'
								          ) :: Virkning 
									)::DokumentDelEgenskaberType
					  			,ROW(
									ROW(null,null)::ClearableInt, --indeks int,
									'del_indhold1', 
									'del_lokation2_1', 
									'del_mimetype2_1',
									 ROW (
									'[2014-05-19, infinity)' :: TSTZRANGE,
								          '671cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
								          'Bruger',
								          'NoteEx11'
								          ) :: Virkning 
									)::DokumentDelEgenskaberType
					  		 	],
					  		
  							 ARRAY[doc1_docDel1Arelation1]
					  		)::DokumentDelType
						,ROW(
					  		'doc_deltekst1B',
					  		ARRAY[ROW(
								ROW(null,null)::ClearableInt, --indeks int,
								''::text, 
								''::text, 
								''::text,
								ROW (
						'(-infinity, infinity)' :: TSTZRANGE,
					          '550cc58a-3149-414a-9392-dcbcbbccdd90'::uuid,
					          'Bruger',
					          'NoteEx6000'
					          ) :: Virkning 
							)::DokumentDelEgenskaberType],
					  		null --ARRAY[]::DokumentdelRelationType[]
					  		)::DokumentDelType
					  	,doc2_docDel1B]
					)::DokumentVariantType,
					doc2_docVariant2,
					 ROW (
						'doc_varianttekst1',
					  	ARRAY[
							ROW(
							true, --arkivering boolean, 
							false, --delvisscannet boolean, 
							false, --offentliggoerelse boolean, 
							true, --produktion boolean,
							 ROW (
								'[2014-02-27, 2015-02-01)' :: TSTZRANGE,
							          '471cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
							          'Bruger',
							          'NoteEx198'
							          ) :: Virkning
							)::DokumentVariantEgenskaberType
							,
							ROW(
							true, --arkivering boolean, 
							ROW(null,null)::ClearableBoolean, --delvisscannet boolean, 
							ROW(null,null)::ClearableBoolean, --offentliggoerelse boolean, 
							false, --produktion boolean,
							 	ROW (
							'[2015-02-01, 2016-12-20]' :: TSTZRANGE,
					          '571cc58a-3149-414a-9392-dcbcbbccddf8'::uuid,
					          'Bruger',
					          'NoteEx300'
					          ) :: Virkning
							)::DokumentVariantEgenskaberType
					 		],
					  	ARRAY[doc1_docDel1A,doc1_docDel1B]
					  	)::DokumentVariantType
						,ROW (
						'doc_varianttekst2',
					  	ARRAY[doc1_docVariantEgenskaber2A],
					  	ARRAY[doc1_docDel2A,doc1_docDel2B]
						)::DokumentVariantType
					]::DokumentVariantType[]
   		)::DokumentRegistreringType
   ]::DokumentRegistreringType[]


)::DokumentType;

--RAISE NOTICE 'expected_doc1,%',expected_dokument1::json;

--RAISE NOTICE 'read_dokument1 post update:,%',read_dokument1::json;




RETURN NEXT is(read_dokument1::json::text,expected_dokument1::json::text,'test update document #1');
















END;
$$;


ALTER FUNCTION test.test_as_update_dokument() OWNER TO mox;

--
-- Name: test_as_update_facet(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_update_facet() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid uuid;
	registrering FacetRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkEgenskaberB Virkning;
	virkEgenskaberC Virkning;
	virkEgenskaberD Virkning;
	virkAnsvarlig Virkning;
	virkansvarligB Virkning;
	virkRedaktoer1 Virkning;
	virkRedaktoer2 Virkning;
	virkPubliceret Virkning;
	virkPubliceretB Virkning;
	virkPubliceretC Virkning;
	facetEgenskabA FacetEgenskaberAttrType;
	facetEgenskabB FacetEgenskaberAttrType;
	facetEgenskabC FacetEgenskaberAttrType;
	facetEgenskabD FacetEgenskaberAttrType;
	facetPubliceret FacetPubliceretTilsType;
	facetPubliceretB FacetPubliceretTilsType;
	facetPubliceretC FacetPubliceretTilsType;
	facetRelAnsvarlig FacetRelationType;
	facetRelRedaktoer1 FacetRelationType;
	facetRelRedaktoer2 FacetRelationType;
	facetRelAnsvarligB FacetRelationType;
	uuidAnsvarlig uuid := 'b5a4ed96-5120-435e-af96-3fb1e0747536'::uuid;
	uuidAnsvarligB uuid := 'c5a4ed96-5120-435e-af96-3fb1e0747539'::uuid;
	uuidRedaktoer1 uuid :='3768c4e6-28b0-4472-a805-1efe15f21286'::uuid;
	--uuidRedaktoer2 uuid :='e6bb8f99-e3a5-47f5-9ff3-588fcb0638fb'::uuid;
	urnRedaktoer2 text:='urn:isbn:0451450523'::text;
	uuidRegistrering uuid :='e12e46b3-6f67-4bfd-a5bb-768844cbbe71'::uuid;
	update_reg_id bigint;
	update_reg_id2 bigint;
	update_reg_id3 bigint;
	actual_relationer FacetRelationType[];
	actual_publiceret FacetPubliceretTilsType[];
	actual_egenskaber FacetEgenskaberAttrType[];
BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaberB :=	ROW (
	'[2014-05-13, 2015-01-01)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;


virkAnsvarlig :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkAnsvarligB :=	ROW (
	'[2014-03-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
          ) :: Virkning
;

virkRedaktoer1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;


virkPubliceret:=	ROW (
	'[2015-05-01, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx8'
          ) :: Virkning
;

virkPubliceretB:=	ROW (
	'[2014-05-13, 2015-05-01)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;



facetRelAnsvarlig := ROW (
	'ansvarlig'::FacetRelationKode,
		virkAnsvarlig,
	uuidAnsvarlig,
	null,
	null
) :: FacetRelationType
;


facetRelRedaktoer1 := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer1,
	uuidRedaktoer1,
	null,
	null
) :: FacetRelationType
;



facetRelRedaktoer2 := ROW (
	'redaktoerer'::FacetRelationKode,
		virkRedaktoer2,
	null,--uuidRedaktoer2,
	urnRedaktoer2,
	'Aktr' 
) :: FacetRelationType
;


facetPubliceret := ROW (
virkPubliceret,
'Publiceret'
):: FacetPubliceretTilsType
;

facetPubliceretB := ROW (
virkPubliceretB,
'IkkePubliceret'
):: FacetPubliceretTilsType
;

facetEgenskabA := ROW (
'brugervendt_noegle_A',
   'facetbeskrivelse_A',
   'facetopbygning_A',
	'facetophavsret_A',
   'facetplan_A',
   'facetsupplement_A',
   NULL,--'retskilde_text1',
   virkEgenskaber
) :: FacetEgenskaberAttrType
;

facetEgenskabB := ROW (
'brugervendt_noegle_B',
   'facetbeskrivelse_B',
   'facetopbygning_B',
	'facetophavsret_B',
   'facetplan_B',
   'facetsupplement_B',
   NULL, --restkilde
   virkEgenskaberB
) :: FacetEgenskaberAttrType
;


registrering := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
ARRAY[facetPubliceret,facetPubliceretB]::FacetPubliceretTilsType[],
ARRAY[facetEgenskabA,facetEgenskabB]::FacetEgenskaberAttrType[],
ARRAY[facetRelAnsvarlig,facetRelRedaktoer1,facetRelRedaktoer2]
) :: FacetRegistreringType
;

new_uuid := as_create_or_import_facet(registrering);

--***************************************
--Update the facet created above


facetRelAnsvarligB := ROW (
	'ansvarlig'::FacetRelationKode,
		virkAnsvarligB,
	uuidAnsvarligB,
	null,
	'Aktr'
) :: FacetRelationType
;

virkEgenskaberC :=	ROW (
	'[2015-01-13, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx20'
          ) :: Virkning
;

virkEgenskaberD :=	ROW (
	'[2013-06-30, 2014-06-01)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;

facetEgenskabC := ROW (
   NULL,--'brugervendt_noegle_text1',
   NULL, --'facetbeskrivelse_text1',
   NULL,--'facetopbygning_text1',
	'facetophavsret_C',
   'facetplan_C',
   'facetsupplement_C',
   'retskilde_C',
   virkEgenskaberC
) :: FacetEgenskaberAttrType
;

facetEgenskabD := ROW (
'brugervendt_noegle_D',
   'facetbeskrivelse_D',
   'facetopbygning_D',
   'facetophavsret_D',
   NULL,-- 'facetplan_D',
   'facetsupplement_D',
   NULL, --restkilde
   virkEgenskaberD
) :: FacetEgenskaberAttrType
;

virkPubliceretC:=	ROW (
	'[2015-01-01, 2015-05-01]' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
          ) :: Virkning
;



facetPubliceretC := ROW (
virkPubliceretC,
''::FacetPubliceretTils
):: FacetPubliceretTilsType
;



update_reg_id:=as_update_facet(
  new_uuid, uuid_generate_v4(),'Test update'::text,
  'Rettet'::Livscykluskode,          
  array[facetEgenskabC,facetEgenskabD]::FacetEgenskaberAttrType[],
  array[facetPubliceretC]::FacetPubliceretTilsType[],
  array[facetRelAnsvarligB]::FacetRelationType[]
	);


SELECT
array_agg(
			ROW (
					a.rel_type,
					a.virkning,
					a.rel_maal_uuid,
					a.rel_maal_urn,
					a.objekt_type 
				):: FacetRelationType
		) into actual_relationer
FROM facet_relation a
JOIN facet_registrering as b on a.facet_registrering_id=b.id
WHERE b.id=update_reg_id
;

RETURN NEXT is(
	actual_relationer,
	ARRAY[facetRelAnsvarligB,facetRelRedaktoer1,facetRelRedaktoer2]
,'relations carried over'); --ok, if all relations are present.


SELECT
array_agg(
			ROW (
					a.virkning,
					a.publiceret
				):: FacetPubliceretTilsType
		) into actual_publiceret
FROM facet_tils_publiceret a
JOIN facet_registrering as b on a.facet_registrering_id=b.id
WHERE b.id=update_reg_id
;



RETURN NEXT is(
	actual_publiceret,
ARRAY[
	facetPubliceretC,
	ROW(
		ROW (
				TSTZRANGE('2015-05-01','infinity','()')
				,(facetPubliceret.virkning).AktoerRef
				,(facetPubliceret.virkning).AktoerTypeKode
				,(facetPubliceret.virkning).NoteTekst
			) :: Virkning
		,facetPubliceret.publiceret
		)::FacetPubliceretTilsType,
	ROW(
		ROW (
				TSTZRANGE('2014-05-13','2015-01-01','[)')
				,(facetPubliceretB.virkning).AktoerRef
				,(facetPubliceretB.virkning).AktoerTypeKode
				,(facetPubliceretB.virkning).NoteTekst
			) :: Virkning
		,facetPubliceretB.publiceret
		)::FacetPubliceretTilsType
]::FacetPubliceretTilsType[]
,'publiceret value updated');


RETURN NEXT set_eq( 'SELECT

			ROW (
					a.brugervendtnoegle,
					a.beskrivelse,
					a.opbygning,
					a.ophavsret,
   					a.plan,
   					a.supplement,
   					a.retskilde,
					a.virkning
				):: FacetEgenskaberAttrType
		
FROM  facet_attr_egenskaber a
JOIN facet_registrering as b on a.facet_registrering_id=b.id
WHERE b.id=' || update_reg_id::text
,   
ARRAY[
		ROW(
				facetEgenskabD.brugervendtnoegle,
   				facetEgenskabD.beskrivelse,
   				facetEgenskabD.opbygning,
   				facetEgenskabD.ophavsret,
   				NULL, --facetEgenskabD.plan,
   				facetEgenskabD.supplement,
   				facetEgenskabD.retskilde,
					ROW(
						TSTZRANGE('2013-06-30','2014-05-13','[)'),
						(facetEgenskabD.virkning).AktoerRef,
						(facetEgenskabD.virkning).AktoerTypeKode,
						(facetEgenskabD.virkning).NoteTekst
						)::virkning
			) ::FacetEgenskaberAttrType
		,
		ROW(
			facetEgenskabD.brugervendtnoegle,
   				facetEgenskabD.beskrivelse,
   				facetEgenskabD.opbygning,
   				facetEgenskabD.ophavsret,
   				facetEgenskabB.plan, --NOTICE
   				facetEgenskabD.supplement,
   				NULL, --notice
   				ROW(
						TSTZRANGE('2014-05-13','2014-06-01','[)'),
						(facetEgenskabD.virkning).AktoerRef,
						(facetEgenskabD.virkning).AktoerTypeKode,
						(facetEgenskabD.virkning).NoteTekst
						)::virkning
		)::FacetEgenskaberAttrType
		,
		ROW(
			facetEgenskabB.brugervendtnoegle,
   				facetEgenskabB.beskrivelse,
   				facetEgenskabB.opbygning,
   				facetEgenskabB.ophavsret,
   				facetEgenskabB.plan,
   				facetEgenskabB.supplement,
   				facetEgenskabB.retskilde,
					ROW(
						TSTZRANGE('2014-06-01','2015-01-01','[)'),
						(facetEgenskabB.virkning).AktoerRef,
						(facetEgenskabB.virkning).AktoerTypeKode,
						(facetEgenskabB.virkning).NoteTekst
						)::virkning
			)::FacetEgenskaberAttrType
		,
		ROW(
			facetEgenskabC.brugervendtnoegle,
   				facetEgenskabC.beskrivelse,
   				facetEgenskabC.opbygning,
   				facetEgenskabC.ophavsret,
   				facetEgenskabC.plan,
   				facetEgenskabC.supplement,
   				facetEgenskabC.retskilde,
					ROW(
						TSTZRANGE('2015-01-13','2015-05-12','[)'),
						(facetEgenskabC.virkning).AktoerRef,
						(facetEgenskabC.virkning).AktoerTypeKode,
						(facetEgenskabC.virkning).NoteTekst
						)::virkning
			)::FacetEgenskaberAttrType
		,
		ROW(
			facetEgenskabA.brugervendtnoegle, --notice
   				facetEgenskabA.beskrivelse, --notice
   				facetEgenskabA.opbygning, --notice
   				facetEgenskabC.ophavsret,
   				facetEgenskabC.plan,
   				facetEgenskabC.supplement,
   				facetEgenskabC.retskilde,
					ROW(
						TSTZRANGE('2015-05-12','infinity','[)'),
						(facetEgenskabC.virkning).AktoerRef,
						(facetEgenskabC.virkning).AktoerTypeKode,
						(facetEgenskabC.virkning).NoteTekst
						)::virkning
			)::FacetEgenskaberAttrType

	]::FacetEgenskaberAttrType[]
    ,    'egenskaber updated' );

/*********************************************/
--Test if providing auth criteria will trigger exception as expected
BEGIN

update_reg_id2:=as_update_facet(
  new_uuid, '592fcdea-0f88-4af1-b2b5-990ae4787ecd'::uuid,'Test update 2'::text,
  'Rettet'::Livscykluskode,          
  array[facetEgenskabC,facetEgenskabD]::FacetEgenskaberAttrType[],
  array[]::FacetPubliceretTilsType[],
  array[facetRelAnsvarligB]::FacetRelationType[]
  ,null --lostUpdatePreventionTZ
  , ARRAY [ ROW (
	 	null --reg base
	 	,null --states
	 	,ARRAY[
		 	ROW (
			null --'brugervendt_noegle_B',
		   ,null--'facetbeskrivelse_B',
		   ,null --'facetopbygning_B',
			,null--'facetophavsret_BC',
		   , 'facetplan_343434'
		   ,null --'facetsupplement_B',
		   ,NULL --restkilde
		   ,null --virkning
			) :: FacetEgenskaberAttrType
	 	]::FacetEgenskaberAttrType[] 
	 	,null --relationer
	 	)::FacetRegistreringType]:: FacetRegistreringType[]
	);

RETURN NEXT ok(false,'as_update_facet test auth criteria#1: Should throw MO401 exception');
EXCEPTION  
WHEN sqlstate 'MO401' THEN
	RETURN NEXT ok(true,'as_update_facet test auth criteria#1: Throws MO401 exception (as it should)');
END;

/*********************************************/
--Test if  providing fullfilled auth criteria will NOT trigger exception as expected


update_reg_id3:=as_update_facet(
  new_uuid, '592fcdea-0f88-4af1-b2b5-990ae4787ecd'::uuid,'Test update 3'::text,
  'Rettet'::Livscykluskode,          
  array[facetEgenskabC,facetEgenskabD]::FacetEgenskaberAttrType[],
  array[]::FacetPubliceretTilsType[],
  array[facetRelAnsvarligB]::FacetRelationType[]
  ,null --lostUpdatePreventionTZ
  , ARRAY [ ROW (
	 	null --reg base
	 	,null --states
	 	,ARRAY[
		 	ROW (
				null --'brugervendt_noegle_B',
			   ,null --'facetbeskrivelse_B',
			   ,null--'facetopbygning_B',
				,'facetophavsret_C'
			   ,null --'facetplan_B',
			   ,null --'facetsupplement_B',
			   ,NULL --restkilde
			   ,null --virkEgenskaberB
			) :: FacetEgenskaberAttrType
	 	]::FacetEgenskaberAttrType[] 
	 	,null --relationer
	 	)::FacetRegistreringType]:: FacetRegistreringType[]
	);

RETURN NEXT ok(update_reg_id3<>update_reg_id,'No expetion thrown when access criteria is met');


END;
$$;


ALTER FUNCTION test.test_as_update_facet() OWNER TO mox;

--
-- Name: test_as_update_indsats(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_update_indsats() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	registrering indsatsRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkEgenskaber1B Virkning;
	virkIndsatsmodtager Virkning;
	virkIndsatsmodtager1B Virkning;
	virkIndsatssag1 Virkning;
	virkIndsatssag2 Virkning;
	virkIndsatsaktoer1 Virkning;
	virkIndsatsaktoer2 Virkning;
	virkIndsatsaktoer2B Virkning;
	virkPubliceret Virkning;
	virkFremdrift Virkning;
	indsatsEgenskab indsatsEgenskaberAttrType;
	indsatsEgenskab1B indsatsEgenskaberAttrType;
	indsatsFremdrift indsatsFremdriftTilsType;
	indsatsPubliceret indsatsPubliceretTilsType;
	indsatsRelIndsatsmodtager indsatsRelationType;
	indsatsRelIndsatsmodtager1B indsatsRelationType;
	indsatsRelIndsatssag1 indsatsRelationType;
	indsatsRelIndsatssag2 indsatsRelationType;
	indsatsRelIndsatsaktoer1 indsatsRelationType;
	indsatsRelIndsatsaktoer2 indsatsRelationType;
	indsatsRelIndsatsaktoer2B indsatsRelationType;

	uuidIndsatsmodtager uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	uuidIndsatssag1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	uuidIndsatsmodtager1B uuid:='7ce114e4-4378-4b73-95ff-fb9a5b651e70'::uuid;
	uuidVirkIndsatsmodtager uuid:='88a7a37b-5423-4a4f-af64-b2031d0aa6a4'::uuid;
	uuidVirkIndsatsmodtager1B uuid:='36171c3f-0018-4b89-accb-f0b89a41acea'::uuid;
	
	--uuidIndsatssag2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	urnIndsatssag2 text:='urn:isbn:0451450523'::text;
	uuidIndsatsaktoer1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidIndsatsaktoer2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidIndsatsaktoer2B uuid :='a9642e50-4a8e-4fda-980a-38a0a87e25a9'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	uuidVirkEgenskaber uuid :='08a9a73a-184d-4f35-8ab4-51eeb118881f'::uuid;
	uuidVirkEgenskaber1B uuid :='cbb7c86b-a915-44db-ad34-2de9f7f2aad5'::uuid;
	actual_publiceret_virk virkning;
	actual_publiceret_value indsatsFremdriftTils;
	actual_publiceret indsatsFremdriftTilsType;
	actual_relationer indsatsRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	read_Indsats1 IndsatsType;
	read_Indsats2 IndsatsType;
	expected_indsats1 IndsatsType;
	expected_indsats2 IndsatsType;

	updated_indstats_regid_1 bigint;
	updated_indstats_regid_2 bigint;
BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuidVirkEgenskaber,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkIndsatsmodtager :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuidVirkIndsatsmodtager,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkIndsatssag1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkIndsatssag2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkfremdrift := ROW (
	'[2016-12-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx20'
) :: Virkning
;

virkIndsatsaktoer1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkIndsatsaktoer2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

indsatsRelIndsatsmodtager := ROW (
	'indsatsmodtager'::indsatsRelationKode
	,virkIndsatsmodtager
	,uuidIndsatsmodtager
	,null
	,'Person'
	,567 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;


indsatsRelIndsatssag1 := ROW (
	'indsatssag'::indsatsRelationKode,
		virkIndsatssag1,
	uuidIndsatssag1,
	null,
	'Sag'
	,768 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsRelIndsatssag2 := ROW (
	'indsatssag'::indsatsRelationKode,
		virkIndsatssag2,
	null,
	urnIndsatssag2,
	'Sag'
	,800 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsRelIndsatsaktoer1 := ROW (
	'indsatsaktoer'::indsatsRelationKode,
		virkIndsatsaktoer1,
	uuidIndsatsaktoer1,
	null,
	'Person'
	,7268 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsRelIndsatsaktoer2 := ROW (
	'indsatsaktoer'::indsatsRelationKode,
		virkIndsatsaktoer2,
	uuidIndsatsaktoer2,
	null,
	'Person'
	,3 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;



indsatsFremdrift := ROW (
virkFremdrift,
'Visiteret'::IndsatsFremdriftTils
):: indsatsFremdriftTilsType
;

indsatsPubliceret := ROW (
virkPubliceret,
'Normal'::IndsatsPubliceretTils
)::indsatsPubliceretTilsType;

indsatsEgenskab := ROW (
'brugervendtnoegle_indsats_1' --text, 
,'beskrivelse_indsats_1'-- text,
, '2017-01-20 08:00'::timestamptz  -- starttidspunkt,
, '2017-01-20 12:00'::timestamptz -- sluttidspunkt,
,virkEgenskaber
) :: indsatsEgenskaberAttrType
;


registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[indsatsPubliceret]::IndsatsPubliceretTilsType[],
ARRAY[indsatsFremdrift]::indsatsFremdriftTilsType[],
ARRAY[indsatsEgenskab]::indsatsEgenskaberAttrType[],
ARRAY[indsatsRelIndsatsmodtager,indsatsRelIndsatssag1,indsatsRelIndsatssag2,indsatsRelIndsatsaktoer1,indsatsRelIndsatsaktoer2]) :: indsatsRegistreringType
;


--raise notice 'to be written indsats 1:%',to_json(registrering);

new_uuid1 := as_create_or_import_indsats(registrering);

RETURN NEXT ok(true,'No errors running as_create_or_import_indsats');




/***************************************************************/


virkEgenskaber1B :=	ROW (
	'[2017-01-01, 2017-12-31]' :: TSTZRANGE,
          uuidVirkEgenskaber1B,
          'Bruger',
          'NoteEx32'
          ) :: Virkning
;

indsatsEgenskab1B:= ROW (
null --text, 
,'beskrivelse_indsats_1A'-- text,
, ''::text
, '2017-01-20 13:00'::timestamptz -- sluttidspunkt,
,virkEgenskaber1B
) :: indsatsEgenskaberAttrType
;

 updated_indstats_regid_1:=as_update_indsats(
  new_uuid1,
  uuidRegistrering,
  'Opdatering reg note test #1',
  'Rettet'::Livscykluskode,           
  ARRAY[indsatsEgenskab1B]::IndsatsEgenskaberAttrType[],
  null,
  null,
  null
 );

read_Indsats1 := as_read_indsats(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'read_Indsats1:%',to_json(read_Indsats1);


expected_indsats1:=ROW(
		new_uuid1,
		ARRAY[
			ROW(
			(read_Indsats1.registrering[1]).registrering
			,ARRAY[indsatsPubliceret]::indsatsPubliceretTilsType[]
			,ARRAY[indsatsFremdrift]::indsatsFremdriftTilsType[]
			,ARRAY[
				ROW (
						'brugervendtnoegle_indsats_1' --text, 
						,'beskrivelse_indsats_1'-- text,
						, '2017-01-20 08:00'::timestamptz  -- starttidspunkt,
						, '2017-01-20 12:00'::timestamptz -- sluttidspunkt,
						,ROW (
							'[2015-05-12, 2017-01-01)' :: TSTZRANGE,
								uuidVirkEgenskaber,
								'Bruger',
								'NoteEx1'
								) :: Virkning
						) :: indsatsEgenskaberAttrType,
				ROW (
						'brugervendtnoegle_indsats_1' --text, 
						,'beskrivelse_indsats_1'-- text,
						, '2017-01-20 08:00'::timestamptz  -- starttidspunkt,
						, '2017-01-20 12:00'::timestamptz -- sluttidspunkt,
						,ROW (
							'(2017-12-31, infinity)' :: TSTZRANGE,
								uuidVirkEgenskaber,
								'Bruger',
								'NoteEx1'
								) :: Virkning
						) :: indsatsEgenskaberAttrType,
				ROW (
						'brugervendtnoegle_indsats_1' --text, 
						,'beskrivelse_indsats_1A'-- text,
						, row(null,null)
						, '2017-01-20 13:00'::timestamptz -- sluttidspunkt,
						,virkEgenskaber1B
						) :: indsatsEgenskaberAttrType
						
			]::indsatsEgenskaberAttrType[]
			,ARRAY[
				ROW (
				'indsatsaktoer'::indsatsRelationKode,
					virkIndsatsaktoer2,
				uuidIndsatsaktoer2,
				null,
				'Person'
				,2 
			) :: indsatsRelationType
				,
				ROW (
					'indsatssag'::indsatsRelationKode,
						virkIndsatssag1,
					uuidIndsatssag1,
					null,
					'Sag'
					,1 --NOTICE: Was replaced
				) :: indsatsRelationType
				,
				ROW (
				'indsatsaktoer'::indsatsRelationKode,
					virkIndsatsaktoer1,
				uuidIndsatsaktoer1,
				null,
				'Person'
				,1 --NOTICE: Was replaced  by import function
			) :: indsatsRelationType
			,
				ROW (
				'indsatsmodtager'::indsatsRelationKode
				,virkIndsatsmodtager
				,uuidIndsatsmodtager
				,null
				,'Person'
				,NULL --NOTICE: Was replaced
			) :: indsatsRelationType
			,ROW (
				'indsatssag'::indsatsRelationKode,
					virkIndsatssag2,
				null,
				urnIndsatssag2,
				'Sag'
				,2 --NOTICE: Was replaced
			) :: indsatsRelationType

				]::IndsatsRelationType[]
			)::IndsatsRegistreringType
			]::IndsatsRegistreringType[]
		)::IndsatsType
;

--raise notice 'expected_indsats1:%',to_json(expected_indsats1);


RETURN NEXT IS(
	read_Indsats1,
	expected_indsats1
	,'test update indsats #1'
);

/*****************************************/


virkIndsatsmodtager1B :=	ROW (
	'[2017-01-01, 2017-12-31]' :: TSTZRANGE,
          uuidVirkIndsatsmodtager1B,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

indsatsRelIndsatsmodtager1B := ROW (
	'indsatsmodtager'::indsatsRelationKode
	,virkIndsatsmodtager1B
	,uuidIndsatsmodtager1B
	,null
	,'Person'
	,600 --NOTICE: Should be replace in by import function
) :: indsatsRelationType
;

virkIndsatsaktoer2B :=	ROW (
	'[2016-03-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

indsatsRelIndsatsaktoer2B := ROW (
				'indsatsaktoer'::indsatsRelationKode,
					virkIndsatsaktoer2B,
				uuidIndsatsaktoer2B,
				null,
				'Person'
				,2 
			) :: indsatsRelationType
;


 updated_indstats_regid_2:=as_update_indsats(
  new_uuid1,
  uuidRegistrering,
  'Opdatering reg note test #2',
  'Rettet'::Livscykluskode,           
  null,
  null,
  null,
  ARRAY[indsatsRelIndsatsmodtager1B,indsatsRelIndsatsaktoer2B]
 );


read_Indsats2 := as_read_indsats(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'read_Indsats2:%',to_json(read_Indsats2);


expected_indsats2:=ROW(
		new_uuid1,
		ARRAY[
			ROW(
			(read_Indsats2.registrering[1]).registrering
			,(expected_indsats1.registrering[1]).tilsPubliceret
			,(expected_indsats1.registrering[1]).tilsFremdrift
			,(expected_indsats1.registrering[1]).attrEgenskaber
			,ARRAY[
				ROW (
					'indsatsmodtager'::indsatsRelationKode
					,virkIndsatsmodtager1B
					,uuidIndsatsmodtager1B
					,null
					,'Person'
					,null --NOTICE: Should be replace in by import function
				) :: indsatsRelationType,
				ROW (
				'indsatsaktoer'::indsatsRelationKode,
					virkIndsatsaktoer2B,
				uuidIndsatsaktoer2B,
				null,
				'Person'
				,2 
			) :: indsatsRelationType
				,
				ROW (
					'indsatssag'::indsatsRelationKode,
						virkIndsatssag1,
					uuidIndsatssag1,
					null,
					'Sag'
					,1 --NOTICE: Was replaced
				) :: indsatsRelationType
				,
				ROW (
				'indsatsaktoer'::indsatsRelationKode,
					virkIndsatsaktoer1,
				uuidIndsatsaktoer1,
				null,
				'Person'
				,1 --NOTICE: Was replaced  by import function
			) :: indsatsRelationType
			,
			 
				ROW (
				'indsatsmodtager'::indsatsRelationKode
				,ROW (
					'[2015-05-11, 2017-01-01)' :: TSTZRANGE,
						uuidVirkIndsatsmodtager,
						'Bruger',
						'NoteEx2'
						) :: Virkning
				,uuidIndsatsmodtager
				,null
				,'Person'
				,NULL 
			) :: indsatsRelationType
				,
				ROW (
				'indsatsmodtager'::indsatsRelationKode
				,ROW (
					'(2017-12-31, infinity)' :: TSTZRANGE,
						uuidVirkIndsatsmodtager,
						'Bruger',
						'NoteEx2'
						) :: Virkning
				,uuidIndsatsmodtager
				,null
				,'Person'
				,NULL 
			) :: indsatsRelationType

			,ROW (
				'indsatssag'::indsatsRelationKode,
					virkIndsatssag2,
				null,
				urnIndsatssag2,
				'Sag'
				,2 --NOTICE: Was replaced
			) :: indsatsRelationType

				]::IndsatsRelationType[]
			)::IndsatsRegistreringType
			]::IndsatsRegistreringType[]
		)::IndsatsType
;


--raise notice 'expected_indsats2:%',to_json(expected_indsats2);


RETURN NEXT IS(
	read_Indsats2,
	expected_indsats2
	,'test update indsats #2'
);


END;
$$;


ALTER FUNCTION test.test_as_update_indsats() OWNER TO mox;

--
-- Name: test_as_update_klasse(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_update_klasse() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid uuid;
	klasseReg KlasseRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkEgenskaberB Virkning;
	virkEgenskaberC Virkning;
	virkEgenskaberD Virkning;
	virkEgenskaberE Virkning;
	virkAnsvarlig Virkning;
	virkRedaktoer1 Virkning;
	virkRedaktoer2 Virkning;
	virkPubliceret Virkning;
	virkPubliceretB Virkning;
	virkPubliceretC Virkning;
	klasseEgenskabA KlasseEgenskaberAttrType;
	klasseEgenskabB KlasseEgenskaberAttrType;
	klasseEgenskabC KlasseEgenskaberAttrType;
	klasseEgenskabD KlasseEgenskaberAttrType;
	klasseEgenskabE KlasseEgenskaberAttrType;
	klassePubliceret KlassePubliceretTilsType;
	klassePubliceretB KlassePubliceretTilsType;
	klassePubliceretC KlassePubliceretTilsType;
	klasseRelAnsvarlig KlasseRelationType;
	klasseRelRedaktoer1 KlasseRelationType;
	klasseRelRedaktoer2 KlasseRelationType;
	uuidAnsvarlig uuid :='ee2616de-91b3-4f7d-8c2d-7e592dbba494'::uuid;
	uuidRedaktoer1 uuid :='de08d17d-8b4c-4d7c-a369-ef8a9e4ac32f'::uuid;
	uuidRedaktoer2 uuid :='daac7580-3073-429d-a0a7-f5eabf0c35d8'::uuid;
	uuidRegistrering uuid :='0cc293df-fa20-414d-8403-d2a95656d93f'::uuid;
	update_reg_id bigint;
	actual_relationer KlasseRelationType[];
	actual_publiceret KlassePubliceretTilsType[];
	actual_egenskaber KlasseEgenskaberAttrType[];
	klasseEgenskabA_Soegeord1 KlasseSoegeordType;
	klasseEgenskabA_Soegeord2 KlasseSoegeordType;
	klasseEgenskabB_Soegeord1 KlasseSoegeordType;
	klasseEgenskabB_Soegeord2 KlasseSoegeordType;
	klasseEgenskabB_Soegeord3 KlasseSoegeordType;
	klasseEgenskabB_Soegeord4 KlasseSoegeordType;
	klasseEgenskabC_Soegeord1 KlasseSoegeordType;
	klasseEgenskabC_Soegeord2 KlasseSoegeordType;
	klasseEgenskabC_Soegeord3 KlasseSoegeordType;
	klasseEgenskabE_Soegeord1 KlasseSoegeordType;
	klasseEgenskabE_Soegeord2 KlasseSoegeordType;
	klasseEgenskabE_Soegeord3 KlasseSoegeordType;
	klasseEgenskabE_Soegeord4 KlasseSoegeordType;
	klasseEgenskabE_Soegeord5 KlasseSoegeordType;

	klasse_read1 KlasseType;
	klasse_read2 KlasseType;
	klasse_read3 KlasseType;
	klasse_read4 KlasseType;
	klasse_read5 KlasseType;
	klasse_read6 KlasseType;
	klasse_read7 KlasseType;
	klasse_read8 KlasseType;
	klasse_read9 KlasseType;
	klasse_read10 KlasseType;
	klasse_read11 KlasseType;
	klasse_read12 KlasseType;
	klasse_read13 KlasseType;
	klasse_read14 KlasseType;
	klasse_read15 KlasseType;

	sqlStr1 text;
	sqlStr2 text;
	expected_exception_txt1 text;
	expected_exception_txt2 text;
	--tempResSoegeord KlasseSoegeordTypeWID[];
	--tempResEgenskaberAttr KlasseEgenskaberAttrTypeWID[];
	extraUuid uuid:='0e0c250c-8f00-4f8d-850e-5abf8e62012e'::uuid;
BEGIN

--------------------------------------------------------------------

sqlStr2:='SELECT as_update_klasse(''' || extraUuid ||'''::uuid,''2ac63602-6c0a-4531-8a09-ab7633f6dacd''::uuid, ''Test update''::text,''Rettet''::Livscykluskode,null,null,null,''-infinity''::TIMESTAMPTZ)';
expected_exception_txt2:='Unable to update klasse with uuid ['|| extraUuid ||'], being unable to find any previous registrations.';

--raise notice 'debug:sqlStr2:%',sqlStr2;
RETURN NEXT throws_ok(sqlStr2,expected_exception_txt2);





virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          '930d5f6f-221d-43d4-af08-b96c9b3821af'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaberB :=	ROW (
	'[2014-05-13, 2015-01-01)' :: TSTZRANGE,
          'cbe8142b-bafc-4aaf-89b6-4e90b9e08907'::uuid,
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;


virkAnsvarlig :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          'b0ba2a98-2c2e-4628-b030-e39e25c8166a'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          '65e2fc1f-268f-4c40-bec8-1ba6da4efb1e'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          '6cf27f28-8c4a-4fc6-bb6a-6b05322ed67a'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;


virkPubliceret:=	ROW (
	'[2015-05-01, infinity)' :: TSTZRANGE,
          '5df2b2c0-c75b-4e33-aa76-9be94cfcf13c'::uuid,
          'Bruger',
          'NoteEx8'
          ) :: Virkning
;

virkPubliceretB:=	ROW (
	'[2014-05-13, 2015-05-01)' :: TSTZRANGE,
          '2d0d23ea-cf5a-41b9-82e1-219b06c17d9f'::uuid,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;



klasseRelAnsvarlig := ROW (
	'ansvarlig'::KlasseRelationKode,
		virkAnsvarlig,
	uuidAnsvarlig,
	null,
	null
) :: KlasseRelationType
;


klasseRelRedaktoer1 := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer1,
	uuidRedaktoer1,
	null,
	null
) :: KlasseRelationType
;



klasseRelRedaktoer2 := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer2,
	uuidRedaktoer2,
	null,
	null
) :: KlasseRelationType
;


klassePubliceret := ROW (
virkPubliceret,
'Publiceret'
):: KlassePubliceretTilsType
;

klassePubliceretB := ROW (
virkPubliceretB,
'IkkePubliceret'
):: KlassePubliceretTilsType
;


klasseEgenskabA_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabA_Soegeord1',
'beskrivelse_klasseEgenskabA_Soegeord1',
'soegeordskategori_klasseEgenskabA_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabA_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabA_Soegeord2',
'beskrivelse_klasseEgenskabA_Soegeord2',
'soegeordskategori_klasseEgenskabA_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabA := ROW (
'brugervendt_noegle_A',
   'klassebeskrivelse_A',
   'eksempel_A',
	'omfang_A',
   'titel_A',
   'retskilde_A',
   NULL,--'aendringsnotat_text1',
   ARRAY[klasseEgenskabA_Soegeord1,klasseEgenskabA_Soegeord2]::KlasseSoegeordType[], 
   virkEgenskaber
) :: KlasseEgenskaberAttrType
;


klasseEgenskabB_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord1',
'beskrivelse_klasseEgenskabB_Soegeord1',
'soegeordskategori_klasseEgenskabB_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabB_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord2',
'beskrivelse_klasseEgenskabB_Soegeord2',
'soegeordskategori_klasseEgenskabB_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabB_Soegeord3 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord3',
'beskrivelse_klasseEgenskabB_Soegeord3',
'soegeordskategori_klasseEgenskabB_Soegeord3'
)::KlasseSoegeordType
;
klasseEgenskabB_Soegeord4 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord4',
'beskrivelse_klasseEgenskabB_Soegeord4',
'soegeordskategori_klasseEgenskabB_Soegeord4'
)::KlasseSoegeordType
;


klasseEgenskabE_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord1',
'beskrivelse_klasseEgenskabE_Soegeord1',
'soegeordskategori_klasseEgenskabE_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabE_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord2',
'beskrivelse_klasseEgenskabE_Soegeord2',
'soegeordskategori_klasseEgenskabE_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabE_Soegeord3 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord3',
'beskrivelse_klasseEgenskabE_Soegeord3',
'soegeordskategori_klasseEgenskabE_Soegeord3'
)::KlasseSoegeordType
;
klasseEgenskabE_Soegeord4 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord4',
'beskrivelse_klasseEgenskabE_Soegeord4',
'soegeordskategori_klasseEgenskabE_Soegeord4'
)::KlasseSoegeordType
;

klasseEgenskabE_Soegeord5 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord5',
'beskrivelse_klasseEgenskabE_Soegeord5',
'soegeordskategori_klasseEgenskabE_Soegeord5'
)::KlasseSoegeordType
;


klasseEgenskabB := ROW (
'brugervendt_noegle_B',
   'klassebeskrivelse_B',
   'eksempel_B',
	'omfang_B',
   'titel_B',
   'retskilde_B',
   NULL, --aendringsnotat
    ARRAY[klasseEgenskabB_Soegeord1,klasseEgenskabB_Soegeord2,klasseEgenskabB_Soegeord3,klasseEgenskabB_Soegeord4]::KlasseSoegeordType[], --soegeord
   virkEgenskaberB
) :: KlasseEgenskaberAttrType
;


klasseReg := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
ARRAY[klassePubliceret,klassePubliceretB]::KlassePubliceretTilsType[],
ARRAY[klasseEgenskabA,klasseEgenskabB]::KlasseEgenskaberAttrType[],
ARRAY[klasseRelAnsvarlig,klasseRelRedaktoer1,klasseRelRedaktoer2]
) :: KlasseRegistreringType
;

new_uuid := as_create_or_import_klasse(klasseReg);

klasse_read2:=as_read_Klasse(new_uuid,null,null);

--***************************************
--Update the klasse created above

virkEgenskaberC :=	ROW (
	'[2015-01-13, infinity)' :: TSTZRANGE,
          '7f7405f8-f56c-430c-8ff0-b8c648d1d9f5'::uuid,
          'Bruger',
          'NoteEx20'
          ) :: Virkning
;

virkEgenskaberD :=	ROW (
	'[2013-06-30, 2014-06-01)' :: TSTZRANGE,
          '880e7705-205a-4457-926b-1289632826e1'::uuid,
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;

virkEgenskaberE:=	ROW (
	'[2014-08-01, 2014-10-20)' :: TSTZRANGE,
          '28f44306-e157-426d-9a1a-2e536ef5a369'::uuid,
          'Bruger',
          'NoteEx20'
          ) :: Virkning
;

klasseEgenskabC := ROW (
   NULL,--'brugervendt_noegle_text1',
   NULL, --'klassebeskrivelse_text1',
   NULL,--'eksempel_text1',
	'omfang_C',
   'titel_C',
   'retskilde_C',
   'aendringsnotat_C',
   ARRAY[]::KlasseSoegeordType[], --soegeord
   virkEgenskaberC
) :: KlasseEgenskaberAttrType
;

klasseEgenskabD := ROW (
'brugervendt_noegle_D',
   'klassebeskrivelse_D',
   'eksempel_D',
   'omfang_D',
   NULL,-- 'titel_D',
   'retskilde_D',
   NULL, --aendringsnotat
    NULL, --soegeord
   virkEgenskaberD
) :: KlasseEgenskaberAttrType
;

klasseEgenskabE := ROW (
'brugervendt_noegle_E',
   'klassebeskrivelse_E',
   'eksempel_E',
	'omfang_E',
   'titel_E',
   'retskilde_E',
   NULL, --aendringsnotat
    ARRAY[klasseEgenskabE_Soegeord1,klasseEgenskabE_Soegeord2,klasseEgenskabE_Soegeord3,klasseEgenskabE_Soegeord4,klasseEgenskabE_Soegeord5]::KlasseSoegeordType[], --soegeord
   virkEgenskaberE
) :: KlasseEgenskaberAttrType
;

virkPubliceretC:=	ROW (
	'[2015-01-01, 2015-05-01]' :: TSTZRANGE,
          'cb011ad8-7cf3-406e-a351-faede8d740d4'::uuid,
          'Bruger',
          'NoteEx10'
          ) :: Virkning
;



klassePubliceretC := ROW (
virkPubliceretC,
''::KlassePubliceretTils
):: KlassePubliceretTilsType
;



update_reg_id:=as_update_klasse(
  new_uuid, '8762a443-2f60-49c1-bd8e-ecfdef91d48a'::uuid,'Test update'::text,
  'Rettet'::Livscykluskode,          
  array[klasseEgenskabC,klasseEgenskabD,klasseEgenskabE]::KlasseEgenskaberAttrType[],
  array[klassePubliceretC]::KlassePubliceretTilsType[],
  array[klasseRelAnsvarlig]::KlasseRelationType[]
  ,lower(((klasse_read2.registrering[1]).registrering).TimePeriod)
	);


SELECT
array_agg(
			ROW (
					a.rel_type,
					a.virkning,
					a.rel_maal_uuid,
					a.rel_maal_urn,
					a.objekt_type 
				):: KlasseRelationType
		) into actual_relationer
FROM klasse_relation a
JOIN klasse_registrering as b on a.klasse_registrering_id=b.id
WHERE b.id=update_reg_id
;

RETURN NEXT is(
	actual_relationer,
	ARRAY[klasseRelAnsvarlig,klasseRelRedaktoer1,klasseRelRedaktoer2]
,'relations carried over'); --ok, if all relations are present.


SELECT
array_agg(
			ROW (
					a.virkning,
					a.publiceret
				):: KlassePubliceretTilsType
		) into actual_publiceret
FROM klasse_tils_publiceret a
JOIN klasse_registrering as b on a.klasse_registrering_id=b.id
WHERE b.id=update_reg_id
;



RETURN NEXT is(
	actual_publiceret,
ARRAY[
	klassePubliceretC,
	ROW(
		ROW (
				TSTZRANGE('2015-05-01','infinity','()')
				,(klassePubliceret.virkning).AktoerRef
				,(klassePubliceret.virkning).AktoerTypeKode
				,(klassePubliceret.virkning).NoteTekst
			) :: Virkning
		,klassePubliceret.publiceret
		)::KlassePubliceretTilsType,
	ROW(
		ROW (
				TSTZRANGE('2014-05-13','2015-01-01','[)')
				,(klassePubliceretB.virkning).AktoerRef
				,(klassePubliceretB.virkning).AktoerTypeKode
				,(klassePubliceretB.virkning).NoteTekst
			) :: Virkning
		,klassePubliceretB.publiceret
		)::KlassePubliceretTilsType
]::KlassePubliceretTilsType[]
,'publiceret value updated');

/*
select array_agg(
   						ROW(
   							c.id,
   							c.soegeordidentifikator,
   							c.beskrivelse,
   							c.soegeordskategori,
   							c.klasse_attr_egenskaber_id
   							)::KlasseSoegeordTypeWID
						
						order by c.id
   						) into tempResSoegeord
from klasse_attr_egenskaber_soegeord c
;


select array_agg( 
ROW(
	a.id ,
a.brugervendtnoegle ,
a.beskrivelse ,
a.eksempel ,
a.omfang ,
a.titel ,
a.retskilde ,
a.aendringsnotat ,
null,
 a.virkning,
 a.klasse_registrering_id
)::KlasseEgenskaberAttrTypeWID
	) into tempResEgenskaberAttr
from klasse_attr_egenskaber a
;

#raise notice 'tempResEgenskaberAttr:%',to_json(tempResEgenskaberAttr);
#raise notice 'tempResSoegeord:%',to_json(tempResSoegeord);
*/


RETURN NEXT set_eq( 'SELECT

			ROW (
					a.brugervendtnoegle,
					a.beskrivelse,
					a.eksempel,
					a.omfang,
   					a.titel,
   					a.retskilde,
   					a.aendringsnotat,
   					array_agg(
   						CASE WHEN c.id IS NULL THEN NULL
   						ELSE
   						ROW(
   							c.soegeordidentifikator,
   							c.beskrivelse,
   							c.soegeordskategori
   							)::KlasseSoegeordType
						END
						order by c.id
   						),
					a.virkning
				):: KlasseEgenskaberAttrType
		
FROM  klasse_attr_egenskaber a
JOIN klasse_registrering as b on a.klasse_registrering_id=b.id
LEFT JOIN klasse_attr_egenskaber_soegeord c on c.klasse_attr_egenskaber_id=a.id
WHERE b.id=' || update_reg_id::text || '
GROUP BY a.id,a.brugervendtnoegle,a.beskrivelse,a.eksempel,a.omfang,a.titel,a.retskilde,a.aendringsnotat,a.virkning
order by (a.virkning).TimePeriod
'
,   
ARRAY[
		ROW(
				klasseEgenskabD.brugervendtnoegle,
   				klasseEgenskabD.beskrivelse,
   				klasseEgenskabD.eksempel,
   				klasseEgenskabD.omfang,
   				NULL, --klasseEgenskabD.titel,
   				klasseEgenskabD.retskilde,
   				klasseEgenskabD.aendringsnotat,
   				  ARRAY[NULL]::KlasseSoegeordType[], --soegeord --please notice that this should really be NULL, but because of the form of the query above, it will return an array with a null element.
					ROW(
						TSTZRANGE('2013-06-30','2014-05-13','[)'),
						(klasseEgenskabD.virkning).AktoerRef,
						(klasseEgenskabD.virkning).AktoerTypeKode,
						(klasseEgenskabD.virkning).NoteTekst
						)::virkning
			) ::KlasseEgenskaberAttrType
		,
		ROW(
			klasseEgenskabD.brugervendtnoegle,
   				klasseEgenskabD.beskrivelse,
   				klasseEgenskabD.eksempel,
   				klasseEgenskabD.omfang,
   				klasseEgenskabB.titel, --NOTICE
   				klasseEgenskabD.retskilde,
   				NULL, --notice
   				  ARRAY[klasseEgenskabB_Soegeord1,klasseEgenskabB_Soegeord2,klasseEgenskabB_Soegeord3,klasseEgenskabB_Soegeord4]::KlasseSoegeordType[], --soegeord
   				ROW(
						TSTZRANGE('2014-05-13','2014-06-01','[)'),
						(klasseEgenskabD.virkning).AktoerRef,
						(klasseEgenskabD.virkning).AktoerTypeKode,
						(klasseEgenskabD.virkning).NoteTekst
						)::virkning
		)::KlasseEgenskaberAttrType
		,
		ROW(
			klasseEgenskabB.brugervendtnoegle,
   				klasseEgenskabB.beskrivelse,
   				klasseEgenskabB.eksempel,
   				klasseEgenskabB.omfang,
   				klasseEgenskabB.titel,
   				klasseEgenskabB.retskilde,
   				klasseEgenskabB.aendringsnotat,
   				 ARRAY[klasseEgenskabB_Soegeord1,klasseEgenskabB_Soegeord2,klasseEgenskabB_Soegeord3,klasseEgenskabB_Soegeord4]::KlasseSoegeordType[], --soegeord
					ROW(
						TSTZRANGE('2014-06-01','2014-08-01','[)'),
						(klasseEgenskabB.virkning).AktoerRef,
						(klasseEgenskabB.virkning).AktoerTypeKode,
						(klasseEgenskabB.virkning).NoteTekst
						)::virkning
			)::KlasseEgenskaberAttrType
		,
		ROW(
			klasseEgenskabE.brugervendtnoegle,
   				klasseEgenskabE.beskrivelse,
   				klasseEgenskabE.eksempel,
   				klasseEgenskabE.omfang,
   				klasseEgenskabE.titel,
   				klasseEgenskabE.retskilde,
   				klasseEgenskabB.aendringsnotat, --NOTICE
   				 ARRAY[klasseEgenskabE_Soegeord1,klasseEgenskabE_Soegeord2,klasseEgenskabE_Soegeord3,klasseEgenskabE_Soegeord4,klasseEgenskabE_Soegeord5]::KlasseSoegeordType[], --soegeord
					ROW(
						TSTZRANGE('2014-08-01', '2014-10-20','[)'),
						(klasseEgenskabE.virkning).AktoerRef,
						(klasseEgenskabE.virkning).AktoerTypeKode,
						(klasseEgenskabE.virkning).NoteTekst
						)::virkning
			)::KlasseEgenskaberAttrType
		,
		ROW(
			klasseEgenskabB.brugervendtnoegle,
   				klasseEgenskabB.beskrivelse,
   				klasseEgenskabB.eksempel,
   				klasseEgenskabB.omfang,
   				klasseEgenskabB.titel,
   				klasseEgenskabB.retskilde,
   				klasseEgenskabB.aendringsnotat,
   				 ARRAY[klasseEgenskabB_Soegeord1,klasseEgenskabB_Soegeord2,klasseEgenskabB_Soegeord3,klasseEgenskabB_Soegeord4]::KlasseSoegeordType[], --soegeord
					ROW(
						TSTZRANGE('2014-10-20','2015-01-01','[)'),
						(klasseEgenskabB.virkning).AktoerRef,
						(klasseEgenskabB.virkning).AktoerTypeKode,
						(klasseEgenskabB.virkning).NoteTekst
						)::virkning
			)::KlasseEgenskaberAttrType
		,

		ROW(
			klasseEgenskabC.brugervendtnoegle,
   				klasseEgenskabC.beskrivelse,
   				klasseEgenskabC.eksempel,
   				klasseEgenskabC.omfang,
   				klasseEgenskabC.titel,
   				klasseEgenskabC.retskilde,
   				klasseEgenskabC.aendringsnotat,
   				 ARRAY[NULL]::KlasseSoegeordType[], --soegeord --please notice that this should really be NULL, but because of the form of the query above, it will return an array with a null element.
					ROW(
						TSTZRANGE('2015-01-13','2015-05-12','[)'),
						(klasseEgenskabC.virkning).AktoerRef,
						(klasseEgenskabC.virkning).AktoerTypeKode,
						(klasseEgenskabC.virkning).NoteTekst
						)::virkning
			)::KlasseEgenskaberAttrType
		,
		ROW(
			klasseEgenskabA.brugervendtnoegle, --notice
   				klasseEgenskabA.beskrivelse, --notice
   				klasseEgenskabA.eksempel, --notice
   				klasseEgenskabC.omfang,
   				klasseEgenskabC.titel,
   				klasseEgenskabC.retskilde,
   				klasseEgenskabC.aendringsnotat,
   				  ARRAY[NULL]::KlasseSoegeordType[], --soegeord
					ROW(
						TSTZRANGE('2015-05-12','infinity','[)'),
						(klasseEgenskabC.virkning).AktoerRef,
						(klasseEgenskabC.virkning).AktoerTypeKode,
						(klasseEgenskabC.virkning).NoteTekst
						)::virkning
			)::KlasseEgenskaberAttrType

	]::KlasseEgenskaberAttrType[]
    ,    'egenskaber updated' );

--------------------------------------------------------------------

klasse_read1:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);
sqlStr1:='SELECT as_update_klasse(''' || new_uuid || '''::uuid,''b0b79809-b225-4b93-80c7-d18372e7ce18''::uuid, ''Test update''::text,''Rettet''::Livscykluskode,null,null,null,''-infinity''::TIMESTAMPTZ)';

expected_exception_txt1:='Unable to update klasse with uuid [' || new_uuid || '], as the klasse seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [-infinity] does not match the timesamp of latest registration [' || lower(((klasse_read1.registrering[1]).registrering).TimePeriod) || ']).';

--raise notice 'debug:sqlStr1:%',sqlStr1;
RETURN NEXT throws_ok(sqlStr1,expected_exception_txt1);

--------------------------------------------------------------------

BEGIN

	update_reg_id:=as_update_klasse(
	  new_uuid, '8af07c7a-d8f0-439f-af3d-0dbb8b25652f'::uuid,'Test update'::text,
	  'Rettet'::Livscykluskode,          
	  array[klasseEgenskabC,klasseEgenskabD,klasseEgenskabE]::KlasseEgenskaberAttrType[],
	  array[klassePubliceretC]::KlassePubliceretTilsType[],
	  array[klasseRelAnsvarlig]::KlasseRelationType[]
	  ,lower(((klasse_read1.registrering[1]).registrering).TimePeriod)
		);

	RETURN NEXT ok(false,'test as_update_klasse - NO exception was triggered by updating klasse with no new data.'); 

	EXCEPTION WHEN sqlstate 'MO400' THEN
			RETURN NEXT ok(true,'test as_update_klasse - caught exception, triggered by updating klasse with no new data.'); 
	
END;


--------------------------------------------------------------------

update_reg_id:=as_update_klasse(
	  new_uuid, 'dc5b848d-da66-45ff-895e-37ea12c7ff5c'::uuid,'Test update'::text,
	  'Passiveret'::Livscykluskode,          
	  array[klasseEgenskabC,klasseEgenskabD,klasseEgenskabE]::KlasseEgenskaberAttrType[],
	  array[klassePubliceretC]::KlassePubliceretTilsType[],
	  array[klasseRelAnsvarlig]::KlasseRelationType[]
	  ,lower(((klasse_read1.registrering[1]).registrering).TimePeriod)
		);

klasse_read3:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

	RETURN NEXT ok(((klasse_read3.registrering[1]).registrering).livscykluskode='Passiveret'::Livscykluskode,'test as_update_klasse - update if livscykluskode is only change.');



--------------------------------------------------------------------

BEGIN

update_reg_id:=as_update_klasse(
	  new_uuid, '7518d4d2-5523-47cc-9a15-f5f5db072bc3'::uuid,'Test update'::text,
	  'Opstaaet'::Livscykluskode,          
	  array[klasseEgenskabC,klasseEgenskabD,klasseEgenskabE]::KlasseEgenskaberAttrType[],
	  array[klassePubliceretC]::KlassePubliceretTilsType[],
	  array[klasseRelAnsvarlig]::KlasseRelationType[]
	  ,lower(((klasse_read3.registrering[1]).registrering).TimePeriod)
		);
	
	RETURN NEXT ok(false,'test as_update_klasse - NO exception was triggered by updating klasse with new livscykluskode, causing an invalid transition.'); 

	EXCEPTION WHEN SQLSTATE 'MO400' THEN
			RETURN NEXT ok(true,'test as_update_klasse - caught exception was triggered by updating klasse with new livscykluskode, causing an invalid transition.'); 

END;
--------------------------------------------------------------------
--revert latest change in livscykluskode manually 

update klasse_registrering a
	set registrering.livscykluskode= 'Rettet'::Livscykluskode
	where klasse_id=new_uuid
	and upper((registrering).TimePeriod)='infinity'::TIMESTAMPTZ;

/*
update_reg_id:=as_update_klasse(
	  new_uuid, '1847ccbc-de05-401f-a7a8-736a4bc8e301'::uuid,'Test update'::text,
	  'Rettet'::Livscykluskode,          
	  array[klasseEgenskabC,klasseEgenskabD,klasseEgenskabE]::KlasseEgenskaberAttrType[],
	  array[klassePubliceretC]::KlassePubliceretTilsType[],
	  array[klasseRelAnsvarlig]::KlasseRelationType[]
	  ,lower(((klasse_read3.registrering[1]).registrering).TimePeriod)
		);


klasse_read4:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);
*/

--Test null egenskaber array will not trigger update
BEGIN

update_reg_id:=as_update_klasse(
	  new_uuid, 'cd7473d3-6ffd-4971-81cb-90b91dfe17fb'::uuid,'Test update'::text,
	  'Rettet'::Livscykluskode,          
	  null,--klasse_read4.registrering[1].attrEgenskaber,
	  klasse_read3.registrering[1].tilsPubliceret,
	  klasse_read3.registrering[1].relationer
	  ,lower(((klasse_read3.registrering[1]).registrering).TimePeriod)
		);
	
		RETURN NEXT ok(false,'Test null egenskaber array will not trigger update#1');
	EXCEPTION WHEN sqlstate 'MO400' THEN
		RETURN NEXT ok(true,'Test null egenskaber array will not trigger update #1');
END;

klasse_read6:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

RETURN NEXT ok(((klasse_read3.registrering[1]).registrering).TimePeriod=((klasse_read6.registrering[1]).registrering).TimePeriod,'Test null egenskaber array will not trigger update #2');

--Test clearing egenskaber

update_reg_id:=as_update_klasse(
	  new_uuid, 'cd7473d3-5ffd-4971-81cb-90b91dfe17fb'::uuid,'Test update'::text,
	  'Rettet'::Livscykluskode,          
	  array[]::KlasseEgenskaberAttrType[],--klasse_read4.registrering[1].attrEgenskaber,
	  klasse_read6.registrering[1].tilsPubliceret,
	  klasse_read6.registrering[1].relationer
	  ,lower(((klasse_read6.registrering[1]).registrering).TimePeriod)
		);

klasse_read5:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

RETURN NEXT ok(lower(((klasse_read5.registrering[1]).registrering).TimePeriod)<>lower(((klasse_read3.registrering[1]).registrering).TimePeriod),'Test if clearing egenskaber works.#1');
RETURN NEXT ok( coalesce(array_length((klasse_read5.registrering[1]).attrEgenskaber,1),0)=0,'Test if clearing egenskaber works.#2');

-------------------------------------------

--Test null tilstand publiceret array will not trigger update
BEGIN

update_reg_id:=as_update_klasse(
	  new_uuid, 'cd7473d3-6ffd-4971-81cb-90b91dfe17fb'::uuid,'Test update'::text,
	  'Rettet'::Livscykluskode,          
	  klasse_read5.registrering[1].attrEgenskaber,
	  null,--klasse_read4.registrering[1].tilsPubliceret,
	  klasse_read5.registrering[1].relationer
	  ,lower(((klasse_read5.registrering[1]).registrering).TimePeriod)
		);
	
		RETURN NEXT ok(false,'Test null tilstand publiceret array will not trigger update #1');
	EXCEPTION WHEN SQLSTATE 'MO400' THEN
		RETURN NEXT ok(true,'Test null tilstand publiceret array will not trigger update #1');
END;


klasse_read7:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

RETURN NEXT ok(((klasse_read7.registrering[1]).registrering).TimePeriod=((klasse_read5.registrering[1]).registrering).TimePeriod,'Test null tilstand publiceret array will not trigger update #2');


--Test clearing tilstand publiceret
--raise notice 'debug 50 klasse_read7:%',to_json(klasse_read7);
RETURN NEXT ok( coalesce(array_length((klasse_read7.registrering[1]).tilsPubliceret,1),0)=3,'Test if clearing tilstand publiceret  works.#0');

update_reg_id:=as_update_klasse(
	  new_uuid, 'cd7473d3-6ffd-4971-81cb-90b91dfe17fb'::uuid,'Test update'::text,
	  'Rettet'::Livscykluskode,          
	  klasse_read7.registrering[1].attrEgenskaber,
	  array[]::KlassePubliceretTilsType[],--klasse_read4.registrering[1].tilsPubliceret,
	  klasse_read7.registrering[1].relationer
	  ,lower(((klasse_read7.registrering[1]).registrering).TimePeriod)
		);

klasse_read8:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);


RETURN NEXT ok(((klasse_read7.registrering[1]).registrering).TimePeriod<>((klasse_read8.registrering[1]).registrering).TimePeriod,'Test if clearing tilstand publiceret works.#1');
RETURN NEXT ok( coalesce(array_length((klasse_read8.registrering[1]).tilsPubliceret,1),0)=0,'Test if clearing tilstand publiceret  works.#2');

-------------------------------------------

--restore "some" tilstande
update_reg_id:=as_update_klasse(
	  new_uuid, '1847ccbc-de05-401f-a7a8-736a4bc8e301'::uuid,'Test update'::text,
	  'Rettet'::Livscykluskode,          
	  array[klasseEgenskabC,klasseEgenskabD,klasseEgenskabE]::KlasseEgenskaberAttrType[],
	  array[klassePubliceretC]::KlassePubliceretTilsType[],
	  array[klasseRelAnsvarlig]::KlasseRelationType[]
	  ,lower(((klasse_read8.registrering[1]).registrering).TimePeriod)
		);


klasse_read9:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);


-------------------------------------------

--Test null relationer array will not trigger update
BEGIN

update_reg_id:=as_update_klasse(
	  new_uuid, 'cd7473d3-6ffd-4971-81cb-90b91dfe17fb'::uuid,'Test update'::text,
	  'Rettet'::Livscykluskode,          
	  klasse_read9.registrering[1].attrEgenskaber,
	  klasse_read9.registrering[1].tilsPubliceret,
	  null--klasse_read8.registrering[1].relationer
	  ,lower(((klasse_read9.registrering[1]).registrering).TimePeriod)
		);
	
		RETURN NEXT ok(false,'Test null relationer array will not trigger update #1');
	EXCEPTION WHEN SQLSTATE 'MO400' THEN
		RETURN NEXT ok(true,'Test null relationer array will not trigger update #1');
END;


klasse_read10:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

RETURN NEXT ok(((klasse_read10.registrering[1]).registrering).TimePeriod=((klasse_read9.registrering[1]).registrering).TimePeriod,'Test null relationer array will not trigger update #2');


--Test clearing relationer
--raise notice 'debug klasse_read10:%',to_json(klasse_read10);
RETURN NEXT ok( coalesce(array_length((klasse_read10.registrering[1]).relationer,1),0)=3,'Test if clearing relationer  works.#0');

update_reg_id:=as_update_klasse(
	  new_uuid, 'cd7473d3-6ffd-4971-81cb-90b91dfe17fb'::uuid,'Test if clearing relationer works'::text,
	  'Rettet'::Livscykluskode,          
	  klasse_read10.registrering[1].attrEgenskaber,
	  klasse_read10.registrering[1].tilsPubliceret,
	  array[]::KlasseRelationType[] --klasse_read10.registrering[1].relationer
	  ,lower(((klasse_read10.registrering[1]).registrering).TimePeriod)
		);

klasse_read11:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);


RETURN NEXT ok(((klasse_read10.registrering[1]).registrering).TimePeriod<>((klasse_read11.registrering[1]).registrering).TimePeriod,'Test if clearing relationer works.#1');
RETURN NEXT ok( coalesce(array_length((klasse_read11.registrering[1]).relationer,1),0)=0,'Test if clearing relationer  works.#2');

-----------------------------------
--restore "a" relation
update_reg_id:=as_update_klasse(
	  new_uuid, '1847ccbc-de05-401f-a7a8-736a4bc8e301'::uuid,'Restore relation'::text,
	  'Rettet'::Livscykluskode,          
	  array[klasseEgenskabC,klasseEgenskabD,klasseEgenskabE]::KlasseEgenskaberAttrType[],
	  array[klassePubliceretC]::KlassePubliceretTilsType[],
	  array[klasseRelAnsvarlig]::KlasseRelationType[]
	  ,lower(((klasse_read11.registrering[1]).registrering).TimePeriod)
		);
klasse_read12:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);


-----------------------------------
--test that nulling a single field will not trigger an update

BEGIN

update_reg_id:=as_update_klasse(
	  new_uuid, uuid_generate_v4(),'Test update'::text,
	  'Rettet'::Livscykluskode,          
	  array[
	  ROW(
		   NULL,--'brugervendt_noegle_text1',
		   NULL, --'klassebeskrivelse_text1',
		   NULL,--'eksempel_text1',
		   NULL, --NOTICE!!	'omfang_C', 
		   'titel_C',
		   'retskilde_C',
		   'aendringsnotat_C',
		   ARRAY[]::KlasseSoegeordType[], --soegeord
		   virkEgenskaberC
	  )::KlasseEgenskaberAttrType
	  ,klasseEgenskabD,klasseEgenskabE]::KlasseEgenskaberAttrType[],
	  array[klassePubliceretC]::KlassePubliceretTilsType[],
	  array[klasseRelAnsvarlig]::KlasseRelationType[]
	  ,lower(((klasse_read12.registrering[1]).registrering).TimePeriod)
		);

RETURN NEXT ok(false,'test as_update_klasse - Test that nulling a single attr egenskab field will not trigger an update #1'); 

	EXCEPTION WHEN SQLSTATE 'MO400' THEN
			RETURN NEXT ok(true,'test as_update_klasse - Test that nulling a single attr egenskab field will not trigger an update #1.'); 

--TODO: Test if nulling a value is enough to trigger update

klasse_read13:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);


RETURN NEXT ok(((klasse_read13.registrering[1]).registrering).TimePeriod=((klasse_read12.registrering[1]).registrering).TimePeriod,'Test that nulling a single attr egenskab field will not trigger an update #2');


END;

--------------------------------------------------------------------
--test that giving a previously null field a value will trigger an update


update_reg_id:=as_update_klasse(
	  new_uuid, uuid_generate_v4(),'Test update'::text,
	  'Rettet'::Livscykluskode,          
	  array[
	  ROW(
		   NULL,--'brugervendt_noegle_text1',
		   NULL, --'klassebeskrivelse_text1',
		   'eksempel_textC_new', --NOTICE--'eksempel_text1',
		   'omfang_C', -- 'omfang_C', 
		   'titel_C',
		   'retskilde_C',
		   'aendringsnotat_C',
		   ARRAY[]::KlasseSoegeordType[], --soegeord
		   virkEgenskaberC
	  )::KlasseEgenskaberAttrType
	  ,klasseEgenskabD,klasseEgenskabE]::KlasseEgenskaberAttrType[],
	  array[klassePubliceretC]::KlassePubliceretTilsType[],
	  array[klasseRelAnsvarlig]::KlasseRelationType[]
	  ,lower(((klasse_read13.registrering[1]).registrering).TimePeriod)
		);

klasse_read14:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'debug klasse_read13:%',to_json(klasse_read13);
--raise notice 'debug klasse_read14:%',to_json(klasse_read14);

RETURN NEXT ok((klasse_read14.registrering[1]).attrEgenskaber[3].eksempel='eksempel_textC_new','Test that giving a previously null field a value will trigger an update');


--------------------------------------------------------------------
--test that giving field a blank will trigger an update


update_reg_id:=as_update_klasse(
	  new_uuid, uuid_generate_v4(),'Test update'::text,
	  'Rettet'::Livscykluskode,          
	  array[
	  ROW(
		   NULL,--'brugervendt_noegle_text1',
		   NULL, --'klassebeskrivelse_text1',
		   '', --NOTICE--'eksempel_text1',
		   'omfang_C', -- 'omfang_C', 
		   'titel_C',
		   'retskilde_C',
		   'aendringsnotat_C',
		   ARRAY[]::KlasseSoegeordType[], --soegeord
		   virkEgenskaberC
	  )::KlasseEgenskaberAttrType
	  ,klasseEgenskabD,klasseEgenskabE]::KlasseEgenskaberAttrType[],
	  array[klassePubliceretC]::KlassePubliceretTilsType[],
	  array[klasseRelAnsvarlig]::KlasseRelationType[]
	  ,lower(((klasse_read14.registrering[1]).registrering).TimePeriod)
		);

klasse_read15:=as_read_Klasse(new_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'debug klasse_read13:%',to_json(klasse_read13);
--raise notice 'debug klasse_read14:%',to_json(klasse_read14);

RETURN NEXT ok((klasse_read15.registrering[1]).attrEgenskaber[3].eksempel='','Test that giving field a blank will trigger an update');


--------------------------------------------------------------------



virkEgenskaber :=	ROW (
	'[2014-05-12, 2015-05-13]' :: TSTZRANGE,
          '930d5f6f-221d-43d4-af08-b96c9b3821af'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaberB :=	ROW (
	'[2015-05-13, infinity)' :: TSTZRANGE,
          'cbe8142b-bafc-4aaf-89b6-4e90b9e08907'::uuid,
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;


klasseEgenskabA := ROW (
'brugervendt_noegle_A',
   'klassebeskrivelse_A',
   'eksempel_A',
	'omfang_A',
   'titel_A',
   'retskilde_A',
   NULL,--'aendringsnotat_text1',
   ARRAY[klasseEgenskabA_Soegeord1,klasseEgenskabA_Soegeord2]::KlasseSoegeordType[], 
   virkEgenskaber
) :: KlasseEgenskaberAttrType
;


klasseEgenskabB := ROW (
'brugervendt_noegle_B',
   'klassebeskrivelse_B',
   'eksempel_B',
	'omfang_B',
   'titel_B',
   'retskilde_B',
   NULL, --aendringsnotat
    ARRAY[klasseEgenskabB_Soegeord1,klasseEgenskabB_Soegeord2,klasseEgenskabB_Soegeord3,klasseEgenskabB_Soegeord4]::KlasseSoegeordType[], --soegeord
   virkEgenskaberB
) :: KlasseEgenskaberAttrType
;


BEGIN

update_reg_id:=as_update_klasse(
	  new_uuid, '7518d4d2-5523-47cc-9a15-f5f5db072bc3'::uuid,'Test update 89'::text,
	  'Rettet'::Livscykluskode,          
	  array[klasseEgenskabA,klasseEgenskabB]::KlasseEgenskaberAttrType[],
	  array[klassePubliceretC]::KlassePubliceretTilsType[],
	  array[klasseRelAnsvarlig]::KlasseRelationType[]
	  ,lower(((klasse_read15.registrering[1]).registrering).TimePeriod)
		);
	
	RETURN NEXT ok(false,'test as_update_klasse - NO exception was triggered by updating klasse with egenskaber with overlapping virkning.'); 

	EXCEPTION WHEN SQLSTATE 'MO400' THEN
			RETURN NEXT ok(true,'test as_update_klasse - caught exception triggered by updating klasse with egenskaber with overlapping virkning.'); 

END;



END;
$$;


ALTER FUNCTION test.test_as_update_klasse() OWNER TO mox;

--
-- Name: test_as_update_sag(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_update_sag() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	registrering sagRegistreringType;
	registreringB sagRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkPrimaerklasse Virkning;
	virkSekundaerpart1 Virkning;
	virkSekundaerpart2 Virkning;
	virkSekundaerpart3 Virkning;
	virkSekundaerpart4 Virkning;
	virkAndresager1 Virkning;
	virkAndresager2 Virkning;
	virkPubliceret Virkning;
	sagEgenskab sagEgenskaberAttrType;
	sagFremdrift sagFremdriftTilsType;
	sagRelPrimaerklasse sagRelationType;
	sagRelSekundaerpart1 sagRelationType;
	sagRelSekundaerpart2 sagRelationType;
	sagRelSekundaerpart3 sagRelationType;
	sagRelAndresager1 sagRelationType;
	sagRelAndresager2 sagRelationType;
	uuidPrimaerklasse uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	uuidSekundaerpart1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;
	uuidSekundaerpart2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	urnSekundaerpart2 text:='urn:isbn:0451450523'::text;
	urnSekundaerpart3 text:='urn:isbn:8751450519'::text;
	urnSekundaerpart4 text:='urn:isbn:7751450516'::text;
	uuidAndresager1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidAndresager2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	virkJournalNotat1 Virkning;
	uuidJournalNotat1  uuid :='97109356-e87e-4b10-ad5d-36de6e3ee011'::uuid;
	sagJournalNotat1 sagRelationType;
	virkJournalNotat5 Virkning;
	uuidJournalNotat5  uuid :='80109356-e87e-4b10-ad5d-36de6e3ee007'::uuid;
	sagJournalNotat5 sagRelationType;
	actual_publiceret_virk virkning;
	actual_publiceret_value sagFremdriftTils;
	actual_publiceret sagFremdriftTilsType;
	actual_relationer sagRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	read_Sag1 SagType;
	update_reg_id int;
	read_sag_relation_1 SagRelationType;
	read_uuidSekundaerpart2 uuid;
	read_rel_index_3 int;
BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkPrimaerklasse :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkSekundaerpart1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkSekundaerpart2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;


virkSekundaerpart3 :=	ROW (
	'[2014-05-10, 2016-03-20)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx30'
          ) :: Virkning
;

virkSekundaerpart4 :=	ROW (
	'[2013-02-25, 2016-03-21)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx40'
          ) :: Virkning
;


virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkAndresager1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkAndresager2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

virkJournalNotat1 :=	ROW (
	'[2014-05-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat1,
          'Bruger',
          'NoteEx1233'
          ) :: Virkning
;

virkJournalNotat5 :=	ROW (
	'[2014-09-12, infinity)' :: TSTZRANGE,
          uuidJournalNotat5,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;

sagRelPrimaerklasse := ROW (
	'ansvarlig'::sagRelationKode
	,virkPrimaerklasse
	,uuidPrimaerklasse
	,null
	,'Klasse'
	,567 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;


sagRelSekundaerpart1 := ROW (
	'sekundaerpart'::sagRelationKode,
		virkSekundaerpart1,
	uuidSekundaerpart1,
	null,
	'Person'
	,768 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;



sagRelSekundaerpart2 := ROW (
	'sekundaerpart'::sagRelationKode,
		virkSekundaerpart2,
	null,
	urnSekundaerpart2,
	'Person'
	,800 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;



sagRelAndresager1 := ROW (
	'andresager'::sagRelationKode,
		virkAndresager1,
	uuidAndresager1,
	null,
	'Person'
	,7268 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;



sagRelAndresager2 := ROW (
	'andresager'::sagRelationKode,
		virkAndresager2,
	uuidAndresager2,
	null,
	'Person'
	,3 --NOTICE: Should be replace in by import function
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;

sagJournalNotat1:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat1,
					uuidJournalNotat1,
					null,
					'Person'
					,4  --NOTICE: Should be replace in by import function
					,'journalnotat'::SagRelationJournalPostSpecifikKode
					, ROW('journal_txt1','journal_notat1','journal_format1')::JournalNotatType --journalNotat
					,ROW(null, ROW(null,null)::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);

sagJournalNotat5:= ROW (
					'journalpost'::sagRelationKode,
						virkJournalNotat5,
					uuidJournalNotat5,
					null,
					'Person'
					,20  --NOTICE: Should be replace in by import function
					,'tilakteretdokument'::SagRelationJournalPostSpecifikKode
					, ROW(NULL,NULL,NULL)::JournalNotatType --journalNotat
					,ROW(NULL, ROW('AlternativTitel_1','Hjemmel_1')::OffentlighedundtagetType) ::JournalPostDokumentAttrType --journalDokumentAttr
				);


sagFremdrift := ROW (
virkPubliceret,
'Opstaaet'
):: sagFremdriftTilsType
;


sagEgenskab := ROW (
'brugervendtnoegle_sag_1' --text, 
 ,false --'afleveret_sag_1'-- boolean,
,'beskrivelse_sag_1'-- text,
, 'hjemmel_sag_1'-- text,
, 'kassationskode_sag_1'-- text,
,ROW( 
	'alternativTitel_sag_1'
	,'hjemmel_sag_1'
 )::offentlighedundtagettype
, true --principiel boolean,
,'sagsnummer_1' -- text,
, 'titel_sag_1'-- text,
,virkEgenskaber
) :: sagEgenskaberAttrType
;


registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
ARRAY[sagFremdrift]::sagFremdriftTilsType[],
ARRAY[sagEgenskab]::sagEgenskaberAttrType[],
ARRAY[sagRelPrimaerklasse,sagRelSekundaerpart1,sagRelSekundaerpart2,sagRelAndresager1,sagRelAndresager2,sagJournalNotat1,sagJournalNotat5]
) :: sagRegistreringType
;


new_uuid1 := as_create_or_import_sag(registrering);



sagRelSekundaerpart2 := ROW (
	'sekundaerpart'::sagRelationKode,
		virkSekundaerpart2,
	uuidSekundaerpart2,
	null,
	'Person'
	,2 
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;


update_reg_id:=as_update_sag(
  new_uuid1, '5f368584-4c3e-4ba4-837b-da2b1eee37c4'::uuid,'Test update 20'::text,
  'Rettet'::Livscykluskode,          
  array[sagEgenskab]::SagEgenskaberAttrType[],
  array[sagFremdrift]::SagFremdriftTilsType[],
  array[sagRelSekundaerpart2]::SagRelationType[]
	);

read_Sag1 := as_read_sag(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'read_Sag_update 1:%',to_json(read_Sag1);

SELECT
uuid into read_uuidSekundaerpart2 
FROM
unnest(read_Sag1.registrering[1].relationer) a
where
a.indeks=2
and a.relType = 'sekundaerpart'::sagRelationKode
;


RETURN NEXT is(read_uuidSekundaerpart2,uuidSekundaerpart2,'Test update of sag relation based on index #1');


read_Sag1 := as_read_sag(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);


sagRelSekundaerpart3 := ROW (
	'sekundaerpart'::sagRelationKode,
		virkSekundaerpart2,
	null,
	urnSekundaerpart3,
	'Person'
	,null 
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: sagRelationType
;

update_reg_id:=as_update_sag(
  new_uuid1, '5f368584-4c3e-4ba4-837b-da2b1eee37c4'::uuid,'Test update 21'::text,
  'Rettet'::Livscykluskode,          
  null,
  null,
  array[sagRelSekundaerpart3]::SagRelationType[]
	);

read_Sag1 := as_read_sag(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);



SELECT
indeks into read_rel_index_3
FROM
unnest(read_Sag1.registrering[1].relationer) a
where
a.urn = urnSekundaerpart3
and a.relType = 'sekundaerpart'::sagRelationKode
;


RETURN NEXT is(read_rel_index_3,3,'Test update of sag relation based on index #2');


--raise notice 'read_Sag1 update:%',to_json(read_Sag1);


--TODO: Implement tests here




END;
$$;


ALTER FUNCTION test.test_as_update_sag() OWNER TO mox;

--
-- Name: test_as_update_tilstand(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_as_update_tilstand() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
	new_uuid1 uuid;
	registrering tilstandRegistreringType;
	actual_registrering RegistreringBase;
	virkEgenskaber Virkning;
	virkEgenskaber2 Virkning;
	virkTilstandsobjekt Virkning;
	virkTilstandsvaerdi1 Virkning;
	virkTilstandsvaerdi1D Virkning;
	virkTilstandsvaerdi2 Virkning;
	virkTilstandskvalitet1 Virkning;
	virkTilstandskvalitet2 Virkning;
	virkPubliceret Virkning;
	virkStatus Virkning;
	virkStatus2 Virkning;
	tilstandEgenskab tilstandEgenskaberAttrType;
	tilstandEgenskab2 tilstandEgenskaberAttrType;
	tilstandStatus tilstandStatusTilsType;
	tilstandStatus2 tilstandStatusTilsType;
	tilstandPubliceret tilstandPubliceretTilsType;
	tilstandRelTilstandsobjekt tilstandRelationType;
	tilstandRelTilstandsvaerdi1 tilstandRelationType;
	tilstandRelTilstandsvaerdi2 tilstandRelationType;
	tilstandRelTilstandskvalitet1 tilstandRelationType;
	tilstandRelTilstandskvalitet2 tilstandRelationType;
	
	uuidTilstandsobjekt uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid;
	--uuidTilstandsvaerdi1 uuid :='b7160ce6-ac92-4752-9e82-f17d9e1e52ce'::uuid;


	uuidTilstandsvaerdi2 uuid :='08533179-fedb-4aa7-8902-ab34a219eed9'::uuid;
	--urnTilstandsvaerdi2 text:='urn:isbn:0451450523'::text;
	uuidTilstandskvalitet1 uuid :='f7109356-e87e-4b10-ad5d-36de6e3ee09d'::uuid;
	uuidTilstandskvalitet2 uuid :='28533179-fedb-4aa7-8902-ab34a219eed1'::uuid;
	uuidRegistrering uuid :='1f368584-4c3e-4ba4-837b-da2b1eee37c9'::uuid;
	uuidVirkEgenskaber uuid :='6f368584-4c3e-4ba4-837b-da2b1eee37ca'::uuid;
	uuidVirkEgenskaber2 uuid :='9f368584-4c3e-4ba4-837b-da2b1eee37cb'::uuid;
	uuidVirkStatus2 uuid:='e470ce13-a546-4940-a1a8-016e4e2197de'::uuid;
	uuidVirkStatus uuid:='cd50aea8-9bef-4914-818c-8f2cfdf42ddf'::uuid;
	actual_publiceret_virk virkning;
	actual_publiceret_value tilstandStatusTils;
	actual_publiceret tilstandStatusTilsType;
	actual_relationer tilstandRelationType[];
	uuid_to_import uuid :='a1819cce-043b-447f-ba5e-92e6a75df918'::uuid;
	uuid_returned_from_import uuid;
	read_Tilstand1 TilstandType;
	read_Tilstand2 TilstandType;
	read_Tilstand3 TilstandType;
	read_Tilstand4 TilstandType;

	expected_tilstand1 TilstandType;
	expected_tilstand2 TilstandType;
	expected_tilstand3 TilstandType;
	expected_tilstand4 TilstandType;

	updated_reg_id_1 bigint;
	updated_reg_id_2 bigint;
	updated_reg_id_3 bigint;
	updated_reg_id_4 bigint;

BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          uuidVirkEgenskaber,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkTilstandsobjekt :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkTilstandsvaerdi1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkTilstandsvaerdi2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

virkPubliceret := ROW (
	'[2015-05-18, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx10'
) :: Virkning
;

virkstatus := ROW (
	'[2016-12-18, infinity)' :: TSTZRANGE,
          uuidVirkStatus,
          'Bruger',
          'NoteEx20'
) :: Virkning
;

virkTilstandskvalitet1 :=	ROW (
	'[2015-04-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx23'
          ) :: Virkning
;


virkTilstandskvalitet2 :=	ROW (
	'[2015-06-10, 2016-05-10)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'NoteEx12'
          ) :: Virkning
;

tilstandRelTilstandsobjekt := ROW (
	'tilstandsobjekt'::tilstandRelationKode
	,virkTilstandsobjekt
	,uuidTilstandsobjekt
	,null
	,'Person'
	,900 --NOTICE: Should be replace in by import function
	,null --TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;


tilstandRelTilstandsvaerdi1 := ROW (
	'tilstandsvaerdi'::tilstandRelationKode,
		virkTilstandsvaerdi1,
	null,
	null,
	null
	,768 --NOTICE: Should be replace in by import function
	,ROW(true,'82')::TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;



tilstandRelTilstandsvaerdi2 := ROW (
	'tilstandsvaerdi'::tilstandRelationKode,
		virkTilstandsvaerdi2,
	uuidTilstandsvaerdi2,
	null,--urnTilstandsvaerdi2
	'Klasse'
	,800 --NOTICE: Should be replace in by import function
	, null --TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;



tilstandRelTilstandskvalitet1 := ROW (
	'tilstandskvalitet'::tilstandRelationKode,
		virkTilstandskvalitet1,
	uuidTilstandskvalitet1,
	null,
	'Klasse'
	,7268 --NOTICE: Should be replace in by import function
	, null --TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;



tilstandRelTilstandskvalitet2 := ROW (
	'tilstandskvalitet'::tilstandRelationKode,
		virkTilstandskvalitet2,
	uuidTilstandskvalitet2,
	null,
	'Klasse'
	,3 --NOTICE: Should be replace in by import function
	,null --TilstandVaerdiRelationAttrType
) :: tilstandRelationType
;



tilstandStatus := ROW (
virkStatus,
'Aktiv'::TilstandStatusTils
):: tilstandStatusTilsType
;

tilstandPubliceret := ROW (
virkPubliceret,
'Normal'::TilstandPubliceretTils
)::tilstandPubliceretTilsType;

tilstandEgenskab := ROW (
'brugervendtnoegle_tilstand_1' --text, 
,'beskrivelse_tilstand_1'-- text,
,virkEgenskaber
) :: tilstandEgenskaberAttrType
;


registrering := ROW (

	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 4') :: RegistreringBase
	,
	ARRAY[tilstandStatus]::tilstandStatusTilsType[],
	ARRAY[tilstandPubliceret]::TilstandPubliceretTilsType[],
ARRAY[tilstandEgenskab]::tilstandEgenskaberAttrType[],
ARRAY[tilstandRelTilstandsobjekt,tilstandRelTilstandsvaerdi1,tilstandRelTilstandsvaerdi2,tilstandRelTilstandskvalitet1,tilstandRelTilstandskvalitet2]) :: tilstandRegistreringType
;


--raise notice 'to be written tilstand 1:%',to_json(registrering);

new_uuid1 := as_create_or_import_tilstand(registrering);

RETURN NEXT ok(true,'No errors running as_create_or_import_tilstand');



/******************************************************************/



virkEgenskaber2 :=	ROW (
	'[2016-05-12, infinity)' :: TSTZRANGE,
          uuidVirkEgenskaber2,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;

tilstandEgenskab2 := ROW (
'brugervendtnoegle_tilstand_1A' --text, 
,'beskrivelse_tilstand_2'-- text,
,virkEgenskaber2
) :: tilstandEgenskaberAttrType
;



updated_reg_id_1:=as_update_tilstand(
  new_uuid1,
  uuidRegistrering,
  'Test Note 5',
  'Rettet'::Livscykluskode,           
  ARRAY[tilstandEgenskab2] :: TilstandEgenskaberAttrType[],
  null, --tilsStatus TilstandStatusTilsType[],
  null, -- tilsPubliceret TilstandPubliceretTilsType[],
  null --relationer TilstandRelationType[]
	);


read_Tilstand1 := as_read_tilstand(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);
--raise notice 'read_Tilstand1:%',to_json(read_Tilstand1);

expected_tilstand1:=ROW(
		new_uuid1,
		ARRAY[
			ROW(
			(read_Tilstand1.registrering[1]).registrering
			,ARRAY[tilstandStatus]::tilstandStatusTilsType[]
			,ARRAY[tilstandPubliceret]::tilstandPubliceretTilsType[]
			,ARRAY[
				 ROW (
				'brugervendtnoegle_tilstand_1' --text, 
				,'beskrivelse_tilstand_1'-- text,
				,ROW (
					'[2015-05-12, 2016-05-12)' :: TSTZRANGE,
						uuidVirkEgenskaber,
						'Bruger',
						'NoteEx1'
						) :: Virkning
				),
				  ROW (
					'brugervendtnoegle_tilstand_1A' --text, 
					,'beskrivelse_tilstand_2'-- text,
					,virkEgenskaber2
					) :: tilstandEgenskaberAttrType
				]::tilstandEgenskaberAttrType[]
			,ARRAY[
				ROW (
				'tilstandsvaerdi'::tilstandRelationKode,
					virkTilstandsvaerdi2,
				uuidTilstandsvaerdi2,
				null,--urnTilstandsvaerdi2
				'Klasse'
				,2 --NOTICE: Was replace din by import function
				, ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
			,
				ROW (
				'tilstandskvalitet'::tilstandRelationKode,
					virkTilstandskvalitet2,
				uuidTilstandskvalitet2,
				null,
				'Klasse'
				,2 --NOTICE: Was replaced by import function
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
			,
				ROW (
				'tilstandskvalitet'::tilstandRelationKode,
					virkTilstandskvalitet1,
				uuidTilstandskvalitet1,
				null,
				'Klasse'
				,1 --NOTICE: Was replaced  by import function
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
			,
				ROW (
				'tilstandsobjekt'::tilstandRelationKode
				,virkTilstandsobjekt
				,uuidTilstandsobjekt
				,null
				,'Person'
				,NULL --NOTICE: Was replaced
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
				,
				 ROW (
					'tilstandsvaerdi'::tilstandRelationKode,
						virkTilstandsvaerdi1,
					null,
					null,
					null
					,1 --NOTICE: Was replaced by import function
					,ROW(true,'82')::TilstandVaerdiRelationAttrType
				) :: tilstandRelationType
			
				]::TilstandRelationType[]
			)::TilstandRegistreringType
			]::TilstandRegistreringType[]
		)::TilstandType
;

--raise notice 'expected_tilstand1:%',to_json(expected_tilstand1);

RETURN NEXT IS(
	read_Tilstand1,
	expected_tilstand1
	,'test update tilstand #1'
);


/*****************************************************************/

virkstatus2 := ROW (
	'[2017-01-01, 2017-01-31]' :: TSTZRANGE,
          uuidVirkStatus2,
          'Bruger',
          'NoteEx30'
) :: Virkning
;

tilstandStatus2 := ROW (
virkStatus2,
'Inaktiv'::TilstandStatusTils
):: tilstandStatusTilsType
;



updated_reg_id_2:=as_update_tilstand(
  new_uuid1,
  uuidRegistrering,
  'Test Note 28',
  'Rettet'::Livscykluskode,           
  null, --ARRAY[tilstandEgenskab2] :: TilstandEgenskaberAttrType[],
   array[tilstandStatus2], --tilsStatus TilstandStatusTilsType[],
  null, -- tilsPubliceret TilstandPubliceretTilsType[],
  null --relationer TilstandRelationType[]
	);


read_Tilstand2 := as_read_tilstand(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'read_Tilstand2:%',to_json(read_Tilstand2);



expected_tilstand2:=ROW(
		new_uuid1,
		ARRAY[
			ROW(
			(read_Tilstand2.registrering[1]).registrering
			,ARRAY[
				tilstandStatus2,
				ROW (
					ROW(
				'[2016-12-18, 2017-01-01)' :: TSTZRANGE,
				uuidVirkStatus,
				'Bruger',
				'NoteEx20'
				) :: Virkning,
				'Aktiv'::TilstandStatusTils
				):: tilstandStatusTilsType
				,
				ROW (
					ROW(
				'(2017-01-31, infinity)' :: TSTZRANGE,
				uuidVirkStatus,
				'Bruger',
				'NoteEx20'
				) :: Virkning,
				'Aktiv'::TilstandStatusTils
				):: tilstandStatusTilsType
				]::tilstandStatusTilsType[]
			,(expected_tilstand1.registrering[1]).tilsPubliceret
			,(expected_tilstand1.registrering[1]).attrEgenskaber 
			,(expected_tilstand1.registrering[1]).relationer
			)::TilstandRegistreringType
			]::TilstandRegistreringType[]
		)::TilstandType
;

--raise notice 'expected_tilstand2:%',to_json(expected_tilstand2);

RETURN NEXT IS(
	read_Tilstand2,
	expected_tilstand2
	,'test update tilstand #2'
);

/***************************************************/


updated_reg_id_3:=as_update_tilstand(
  new_uuid1,
  uuidRegistrering,
  'Test Note 45',
  'Rettet'::Livscykluskode,           
  null, --ARRAY[tilstandEgenskab2] :: TilstandEgenskaberAttrType[],
  null, --tilsStatus TilstandStatusTilsType[],
  null, -- tilsPubliceret TilstandPubliceretTilsType[],
  ARRAY[ ROW (
					'tilstandsvaerdi'::tilstandRelationKode,
						virkTilstandsvaerdi1,
					null,
					null,
					null
					,1 
					,ROW(true,'85')::TilstandVaerdiRelationAttrType ) ]::TilstandRelationType[]  --relationer TilstandRelationType[]
	);

read_Tilstand3 := as_read_tilstand(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'read_Tilstand3:%',to_json(read_Tilstand3);



expected_tilstand3:=ROW(
		new_uuid1,
		ARRAY[
			ROW(
			(read_Tilstand3.registrering[1]).registrering
			,(expected_tilstand2.registrering[1]).tilsStatus
			,(expected_tilstand2.registrering[1]).tilsPubliceret
			,(expected_tilstand2.registrering[1]).attrEgenskaber 
			,ARRAY[
				ROW (
				'tilstandsvaerdi'::tilstandRelationKode,
					virkTilstandsvaerdi2,
				uuidTilstandsvaerdi2,
				null,--urnTilstandsvaerdi2
				'Klasse'
				,2 --NOTICE: Was replace din by import function
				, ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
			,
				ROW (
				'tilstandskvalitet'::tilstandRelationKode,
					virkTilstandskvalitet2,
				uuidTilstandskvalitet2,
				null,
				'Klasse'
				,2 --NOTICE: Was replaced by import function
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
			,
				ROW (
				'tilstandskvalitet'::tilstandRelationKode,
					virkTilstandskvalitet1,
				uuidTilstandskvalitet1,
				null,
				'Klasse'
				,1 --NOTICE: Was replaced  by import function
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
			,
				ROW (
				'tilstandsobjekt'::tilstandRelationKode
				,virkTilstandsobjekt
				,uuidTilstandsobjekt
				,null
				,'Person'
				,NULL --NOTICE: Was replaced
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
				,
				 ROW (
					'tilstandsvaerdi'::tilstandRelationKode,
						virkTilstandsvaerdi1,
					null,
					null,
					null
					,1 --NOTICE: Was replaced by import function
					,ROW(true,'85')::TilstandVaerdiRelationAttrType
				) :: tilstandRelationType
			
				]::TilstandRelationType[]


			)::TilstandRegistreringType
			]::TilstandRegistreringType[]
		)::TilstandType
;

--raise notice 'expected_tilstand3:%',to_json(expected_tilstand3);

RETURN NEXT IS(
	read_Tilstand3,
	expected_tilstand3
	,'test update tilstand #3'
);

/***********************************************/

virkTilstandsvaerdi1D :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          uuid_generate_v4(),
          'Bruger',
          'Vrdien blev slettet pga. fejl i indberetning.'
          ) :: Virkning
;

updated_reg_id_4:=as_update_tilstand(
  new_uuid1,
  uuidRegistrering,
  'Test Note 50',
  'Rettet'::Livscykluskode,           
  null, --ARRAY[tilstandEgenskab2] :: TilstandEgenskaberAttrType[],
  null, --tilsStatus TilstandStatusTilsType[],
  null, -- tilsPubliceret TilstandPubliceretTilsType[],
  ARRAY[ ROW (
					'tilstandsvaerdi'::tilstandRelationKode,
						virkTilstandsvaerdi1D,
					null,
					null,
					null
					,1 
					,ROW(null,null)::TilstandVaerdiRelationAttrType ) ]::TilstandRelationType[]  --relationer TilstandRelationType[]
	);

read_Tilstand4 := as_read_tilstand(new_uuid1,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

--raise notice 'read_Tilstand4:%',to_json(read_Tilstand4);

expected_tilstand4:=ROW(
		new_uuid1,
		ARRAY[
			ROW(
			(read_Tilstand4.registrering[1]).registrering
			,(expected_tilstand2.registrering[1]).tilsStatus
			,(expected_tilstand2.registrering[1]).tilsPubliceret
			,(expected_tilstand2.registrering[1]).attrEgenskaber 
			,ARRAY[
				ROW (
				'tilstandsvaerdi'::tilstandRelationKode,
					virkTilstandsvaerdi2,
				uuidTilstandsvaerdi2,
				null,--urnTilstandsvaerdi2
				'Klasse'
				,2 --NOTICE: Was replace din by import function
				, ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
			,
				ROW (
				'tilstandskvalitet'::tilstandRelationKode,
					virkTilstandskvalitet2,
				uuidTilstandskvalitet2,
				null,
				'Klasse'
				,2 --NOTICE: Was replaced by import function
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
			,
				ROW (
				'tilstandskvalitet'::tilstandRelationKode,
					virkTilstandskvalitet1,
				uuidTilstandskvalitet1,
				null,
				'Klasse'
				,1 --NOTICE: Was replaced  by import function
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
			,
				ROW (
				'tilstandsobjekt'::tilstandRelationKode
				,virkTilstandsobjekt
				,uuidTilstandsobjekt
				,null
				,'Person'
				,NULL --NOTICE: Was replaced
				,ROW(null,null)::TilstandVaerdiRelationAttrType --will be removed in python-layer
			) :: tilstandRelationType
				,
				 ROW (
					'tilstandsvaerdi'::tilstandRelationKode,
						virkTilstandsvaerdi1D,
					null,
					null,
					null
					,1 --NOTICE: Was replaced by import function
					,ROW(null,null)::TilstandVaerdiRelationAttrType
				) :: tilstandRelationType
			
				]::TilstandRelationType[]


			)::TilstandRegistreringType
			]::TilstandRegistreringType[]
		)::TilstandType
;

--raise notice 'expected_tilstand4:%',to_json(expected_tilstand4);	

RETURN NEXT IS(
	read_Tilstand4,
	expected_tilstand4
	,'test update tilstand #4'
);

/***********************************************/

END;
$$;


ALTER FUNCTION test.test_as_update_tilstand() OWNER TO mox;

--
-- Name: test_common_types_cleable_casts(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_common_types_cleable_casts() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
clearable_int1 ClearableInt;
clearable_int2 ClearableInt;
clearable_int3 ClearableInt;
clearable_int4 ClearableInt;

clearable_int5 ClearableInt;

clearable_date1 ClearableDate;
clearable_date2 ClearableDate;
clearable_date3 ClearableDate;
clearable_date4 ClearableDate;

clearable_date5 ClearableDate;

clearable_boolean1 ClearableBoolean;
clearable_boolean2 ClearableBoolean;
clearable_boolean3 ClearableBoolean;
clearable_boolean4 ClearableBoolean;
clearable_boolean5 ClearableBoolean;
clearable_boolean6 ClearableBoolean;
clearable_boolean7 ClearableBoolean;

clearable_Timestamptz1 ClearableTimestamptz;
clearable_Timestamptz2 ClearableTimestamptz;
clearable_Timestamptz3 ClearableTimestamptz;
clearable_Timestamptz4 ClearableTimestamptz;
clearable_Timestamptz5 ClearableTimestamptz;

clearable_interval1 ClearableInterval;
clearable_interval2 ClearableInterval;
clearable_interval3 ClearableInterval;
clearable_interval4 ClearableInterval;
clearable_interval5 ClearableInterval;

BEGIN

clearable_int1:= ROW (10,true)::ClearableInt;
clearable_int2:= ROW (20,false)::ClearableInt;
clearable_int3:= ROW (30,null)::ClearableInt;
clearable_int4:= ROW (null,null)::ClearableInt;

RETURN NEXT ok(clearable_int1=10,'ClearableInt->int cast test #1');
RETURN NEXT ok(clearable_int2=20,'ClearableInt->int cast test #2');
RETURN NEXT ok(clearable_int3=30,'ClearableInt->int cast test #3');
RETURN NEXT ok(clearable_int4 IS NULL,'ClearableInt->int cast test #4');
RETURN NEXT ok(clearable_int3>29,'ClearableInt->int cast test #5');
RETURN NEXT ok(clearable_int3<31,'ClearableInt->int cast test #6');

clearable_date1:= ROW ('2015-06-01'::date,true)::ClearableDate;
clearable_date2:= ROW ('2015-07-02'::date,false)::ClearableDate;
clearable_date3:= ROW ('2015-08-03'::date,null)::ClearableDate;
clearable_date4:= ROW (null,null)::ClearableDate;

RETURN NEXT ok(clearable_date1='2015-06-01'::date,'ClearableDate->date cast test #1');
RETURN NEXT ok(clearable_date2='2015-07-02'::date,'ClearableDate->date cast test #2');
RETURN NEXT ok(clearable_date3='2015-08-03'::date,'ClearableDate->date cast test #3');
RETURN NEXT ok(clearable_date4 IS NULL,'ClearableDate->date cast test #4');
RETURN NEXT ok(clearable_date3>'2015-08-02'::date,'ClearableDate->date cast test #5');
RETURN NEXT ok(clearable_date3<'2015-08-04'::date,'ClearableDate->date cast test #6');


clearable_boolean1:= ROW (true,true)::ClearableBoolean;
clearable_boolean2:= ROW (true,false)::ClearableBoolean;
clearable_boolean3:= ROW (false,false)::ClearableBoolean;
clearable_boolean4:= ROW (false,true)::ClearableBoolean;
clearable_boolean5:= ROW (true,NULL)::ClearableBoolean;
clearable_boolean6:= ROW (NULL,NULL)::ClearableBoolean;
clearable_boolean7:= ROW (NULL,true)::ClearableBoolean;

RETURN NEXT ok( clearable_boolean1=true,'ClearableBoolean->boolean cast test #1');
RETURN NEXT ok( clearable_boolean2=true,'ClearableBoolean->boolean cast test #2');
RETURN NEXT ok( clearable_boolean3=false,'ClearableBoolean->boolean cast test #3');
RETURN NEXT ok( clearable_boolean4=false,'ClearableBoolean->boolean cast test #4');
RETURN NEXT ok( clearable_boolean5=true,'ClearableBoolean->boolean cast test #5');
RETURN NEXT ok( clearable_boolean6 IS NULL,'ClearableBoolean->boolean cast test #6');
RETURN NEXT ok( NOT (clearable_boolean7 IS NULL),'ClearableBoolean->boolean cast test #7');

clearable_timestamptz1:= ROW ('2015-06-01 14:10'::timestamptz,true)::ClearableTimestamptz;
clearable_timestamptz2:= ROW ('2015-07-02 08:10'::timestamptz,false)::ClearableTimestamptz;
clearable_timestamptz3:= ROW ('2015-08-03 09:00'::timestamptz,null)::ClearableTimestamptz;
clearable_timestamptz4:= ROW (null,null)::ClearableDate;

RETURN NEXT ok(clearable_timestamptz1='2015-06-01 14:10'::timestamptz,'ClearableTimestamptz->timestamptz cast test #1');
RETURN NEXT ok(clearable_timestamptz2='2015-07-02 08:10'::timestamptz,'ClearableTimestamptz->timestamptz cast test #2');
RETURN NEXT ok(clearable_timestamptz3='2015-08-03 09:00'::timestamptz,'ClearableTimestamptz->timestamptz cast test #3');
RETURN NEXT ok(clearable_timestamptz4 IS NULL,'ClearableTimestamptz->timestamptz cast test #4');
RETURN NEXT ok(clearable_timestamptz3>'2015-08-02'::timestamptz,'ClearableTimestamptz->timestamptz cast test #5');
RETURN NEXT ok(clearable_timestamptz3<'2015-08-04'::timestamptz,'ClearableTimestamptz->timestamptz cast test #6');

clearable_interval1:= ROW ('0001-00 03 00:00:02.0'::interval(0),true)::ClearableInterval;
clearable_interval2:= ROW ('0002-00 00 00:00:00.0'::interval(0),false)::ClearableInterval;
clearable_interval3:= ROW ('0001-02 04 00:00:00.0'::interval(0),null)::ClearableInterval;
clearable_interval4:= ROW (null,null)::ClearableInterval;

RETURN NEXT ok(clearable_Interval1='0001-00 03 00:00:02.0'::interval(0),'ClearableInterval->Interval cast test #1');
RETURN NEXT ok(clearable_Interval2='0002-00 00 00:00:00.0'::interval(0),'ClearableInterval->Interval cast test #2');
RETURN NEXT ok(clearable_Interval3='0001-02 04 00:00:00.0'::interval(0),'ClearableInterval->Interval cast test #3');
RETURN NEXT ok(clearable_Interval4 IS NULL,'ClearableInterval->Interval cast test #4');
RETURN NEXT ok(clearable_Interval3>'0000-11 04 00:00:00.0'::Interval(0),'ClearableInterval->Interval cast test #5');
RETURN NEXT ok(clearable_Interval3<'0001-02 05 00:00:00.0'::Interval(0),'ClearableInterval->Interval cast test #6');
/**/

RETURN NEXT ok( (20::ClearableInt).value=20 and (20::ClearableInt).cleared is null ,'int->ClearableInt test #1');
RETURN NEXT ok(  (('2015-08-20'::date)::ClearableDate).value='2015-08-20'::date and (('2015-08-20'::date)::ClearableDate).cleared is null ,'date->ClearableDate test #1');
RETURN NEXT ok( (false::ClearableBoolean).value=false and (false::ClearableBoolean).cleared is null ,'boolean->ClearableBoolean test #1');
RETURN NEXT ok( (true::ClearableBoolean).value=true and (false::ClearableBoolean).cleared is null ,'boolean->ClearableBoolean test #2');

/**/

clearable_int5:=(''::text)::ClearableInt;
RETURN NEXT ok(clearable_int5.value IS NULL AND clearable_int5.cleared=true,'text->ClearableInt #1');
RETURN NEXT ok( (null::text)::ClearableInt IS NULL, 'text->ClearableInt #2');

BEGIN 
clearable_int5:=('test'::text)::ClearableInt;
	RETURN NEXT ok(false,'text->ClearableInt #3 DOES NOT throw exception as it should');
EXCEPTION  WHEN data_exception THEN
	RETURN NEXT ok(true,'text->ClearableInt #3 (throws exception as it should');
END;

/**/

clearable_date5:=(''::text)::ClearableDate;
RETURN NEXT ok(clearable_date5.value IS NULL AND clearable_date5.cleared=true,'text->ClearableDate #1');
RETURN NEXT ok( (null::text)::ClearableDate IS NULL, 'text->ClearableDate #2');

BEGIN 
clearable_date5:=('test'::text)::ClearableDate;
	RETURN NEXT ok(false,'text->ClearableDate #3 DOES NOT throw exception as it should');
EXCEPTION  WHEN data_exception THEN
	RETURN NEXT ok(true,'text->ClearableDate #3 (throws exception as it should');
END;

/**/

clearable_boolean5:=(''::text)::ClearableBoolean;
RETURN NEXT ok(clearable_boolean5.value IS NULL AND clearable_boolean5.cleared=true,'text->ClearableBoolean #1');
RETURN NEXT ok( (null::text)::ClearableBoolean IS NULL, 'text->ClearableBoolean #2');

BEGIN 
clearable_boolean5:=('test'::text)::ClearableBoolean;
	RETURN NEXT ok(false,'text->ClearableBoolean #3 DOES NOT throw exception as it should');
EXCEPTION  WHEN data_exception THEN
	RETURN NEXT ok(true,'text->ClearableBoolean #3 (throws exception as it should');
END;

/**/

clearable_Timestamptz5:=(''::text)::ClearableTimestamptz;
RETURN NEXT ok(clearable_Timestamptz5.value IS NULL AND clearable_Timestamptz5.cleared=true,'text->ClearableTimestamptz #1');
RETURN NEXT ok( (null::text)::ClearableTimestamptz IS NULL, 'text->ClearableTimestamptz #2');

BEGIN 
clearable_Timestamptz5:=('test'::text)::ClearableTimestamptz;
	RETURN NEXT ok(false,'text->ClearableTimestamptz #3 DOES NOT throw exception as it should');
EXCEPTION  WHEN data_exception THEN
	RETURN NEXT ok(true,'text->ClearableTimestamptz #3 (throws exception as it should');
END;

/**/

clearable_Interval5:=(''::text)::ClearableInterval;
RETURN NEXT ok(clearable_Interval5.value IS NULL AND clearable_Interval5.cleared=true,'text->ClearableInterval #1');
RETURN NEXT ok( (null::text)::ClearableInterval IS NULL, 'text->ClearableInterval #2');

BEGIN 
clearable_Interval5:=('test'::text)::ClearableInterval;
	RETURN NEXT ok(false,'text->ClearableInterval #3 DOES NOT throw exception as it should');
EXCEPTION  WHEN data_exception THEN
	RETURN NEXT ok(true,'text->ClearableInterval #3 (throws exception as it should');
END;

/**/



END;
$$;


ALTER FUNCTION test.test_common_types_cleable_casts() OWNER TO mox;

--
-- Name: test_facet_db_schama(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_facet_db_schama() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NEXT has_table( 'facet' );
    RETURN NEXT has_table( 'facet_registrering' );
    RETURN NEXT has_table( 'facet_attr_egenskaber' );
    RETURN NEXT has_table( 'facet_tils_publiceret' );
    RETURN NEXT has_table( 'facet_relation' );

    RETURN NEXT col_is_pk(  'facet', 'id' );
    RETURN NEXT col_is_pk(  'facet_registrering', 'id' );
    RETURN NEXT col_is_pk(  'facet_attr_egenskaber', 'id' );
    RETURN NEXT col_is_pk(  'facet_tils_publiceret', 'id' );
    RETURN NEXT col_is_pk(  'facet_relation', 'id' );


	RETURN NEXT col_is_fk('facet_registrering','facet_id');
	RETURN NEXT col_is_fk('facet_attr_egenskaber','facet_registrering_id');
	RETURN NEXT col_is_fk('facet_tils_publiceret','facet_registrering_id');
	RETURN NEXT col_is_fk('facet_relation','facet_registrering_id');

	RETURN NEXT has_column( 'facet_attr_egenskaber',   'brugervendtnoegle' );
	RETURN NEXT has_column( 'facet_attr_egenskaber',   'beskrivelse' );
	RETURN NEXT has_column( 'facet_attr_egenskaber',   'plan' );
	RETURN NEXT has_column( 'facet_attr_egenskaber',   'opbygning');
	RETURN NEXT has_column( 'facet_attr_egenskaber',   'ophavsret');
	RETURN NEXT has_column( 'facet_attr_egenskaber',   'supplement');
	RETURN NEXT has_column( 'facet_attr_egenskaber',   'retskilde');

	RETURN NEXT has_column( 'facet_tils_publiceret',   'publiceret');

	RETURN NEXT has_column( 'facet_relation',   'rel_maal_uuid');
	RETURN NEXT has_column( 'facet_relation',   'rel_maal_urn');
	RETURN NEXT has_column( 'facet_relation',   'rel_type');
	RETURN NEXT has_column( 'facet_relation',   'objekt_type');



END;
$$;


ALTER FUNCTION test.test_facet_db_schama() OWNER TO mox;

--
-- Name: test_json_cast_function(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_json_cast_function() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
DECLARE 
virkEgenskaber Virkning;
virkEgenskaberB Virkning;
virkAnsvarlig Virkning;
virkRedaktoer1 Virkning;
virkRedaktoer2 Virkning;
virkPubliceret Virkning;
virkPubliceretB Virkning;
klasseRelAnsvarlig KlasseRelationType;
klasseRelRedaktoer2 KlasseRelationType;
klasserelredaktoer1 KlasseRelationType;
klassePubliceret KlassePubliceretTilsType;
klassePubliceretB KlassePubliceretTilsType;
klasseEgenskabA_Soegeord1 KlasseSoegeordType;
klasseEgenskabA_Soegeord2 KlasseSoegeordType;
klasseEgenskabA KlasseEgenskaberAttrType;
klasseEgenskabB_Soegeord1  KlasseSoegeordType;
klasseEgenskabB_Soegeord2  KlasseSoegeordType;
klasseEgenskabB_Soegeord3 KlasseSoegeordType;
klasseEgenskabB_Soegeord4 KlasseSoegeordType;

klasseEgenskabE_Soegeord1 KlasseSoegeordType;
klasseEgenskabE_Soegeord2 KlasseSoegeordType;
klasseEgenskabE_Soegeord3 KlasseSoegeordType;
klasseEgenskabE_Soegeord4 KlasseSoegeordType;
klasseEgenskabE_Soegeord5 KlasseSoegeordType;

klasseEgenskabB KlasseEgenskaberAttrType;
registreringA KlasseRegistreringType;
new_uuid uuid;
hacked_in_uuid uuid:='5d32f909-327f-479e-b98f-b6e8cbaca1ee'::uuid;
json_result json;
json_expected json;
read_Klasse KlasseType;
uuidAnsvarlig uuid :='ee2616de-91b3-4f7d-8c2d-7e592dbba494'::uuid;
uuidRedaktoer1 uuid :='de08d17d-8b4c-4d7c-a369-ef8a9e4ac32f'::uuid;
uuidRedaktoer2 uuid :='daac7580-3073-429d-a0a7-f5eabf0c35d8'::uuid;
uuidRegistrering uuid :='0cc293df-fa20-414d-8403-d2a95656d93f'::uuid;


BEGIN


virkEgenskaber :=	ROW (
	'[2015-05-12, infinity)' :: TSTZRANGE,
          '303514bc-9014-4591-a8a9-22eb37c592f9'::uuid,
          'Bruger',
          'NoteEx1'
          ) :: Virkning
;

virkEgenskaberB :=	ROW (
	'[2014-05-13, 2015-01-01)' :: TSTZRANGE,
          '858a568b-2ad0-4168-8b83-c48b8238106c'::uuid,
          'Bruger',
          'NoteEx7'
          ) :: Virkning
;


virkAnsvarlig :=	ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          '0befe457-cef5-4888-b49c-bbee77e44f99'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning
;

virkRedaktoer1 :=	ROW (
	'[2015-05-10, infinity)' :: TSTZRANGE,
          'f700e686-5bed-45b3-9d13-c09bbdf2ad1a'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning
;


virkRedaktoer2 :=	ROW (
	'[2015-05-10, 2016-05-10)' :: TSTZRANGE,
          '1c0ce5a4-02c4-4697-ab39-00b7da0b1f54'::uuid,
          'Bruger',
          'NoteEx4'
          ) :: Virkning
;


virkPubliceret:=	ROW (
	'[2015-05-01, infinity)' :: TSTZRANGE,
          '01cdb20d-1897-4966-9552-0a691f162daf'::uuid,
          'Bruger',
          'NoteEx8'
          ) :: Virkning
;

virkPubliceretB:=	ROW (
	'[2014-05-13, 2015-05-01)' :: TSTZRANGE,
          '38efbe3e-3b93-470a-956a-793ca0c8f219'::uuid,
          'Bruger',
          'NoteEx9'
          ) :: Virkning
;



klasseRelAnsvarlig := ROW (
	'ansvarlig'::KlasseRelationKode,
		virkAnsvarlig,
	uuidAnsvarlig,
	null,
	null
) :: KlasseRelationType
;


klasseRelRedaktoer1 := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer1,
	uuidRedaktoer1,
	null,
	null
) :: KlasseRelationType
;



klasseRelRedaktoer2 := ROW (
	'redaktoerer'::KlasseRelationKode,
		virkRedaktoer2,
	uuidRedaktoer2,
	null,
	null
) :: KlasseRelationType
;


klassePubliceret := ROW (
virkPubliceret,
'Publiceret'
):: KlassePubliceretTilsType
;

klassePubliceretB := ROW (
virkPubliceretB,
'IkkePubliceret'
):: KlassePubliceretTilsType
;


klasseEgenskabA_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabA_Soegeord1',
'beskrivelse_klasseEgenskabA_Soegeord1',
'soegeordskategori_klasseEgenskabA_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabA_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabA_Soegeord2',
'beskrivelse_klasseEgenskabA_Soegeord2',
'soegeordskategori_klasseEgenskabA_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabA := ROW (
'brugervendt_noegle_A',
   'klassebeskrivelse_A',
   'eksempel_A',
	'omfang_A',
   'titel_A',
   'retskilde_A',
   NULL,--'aendringsnotat_text1',
   ARRAY[klasseEgenskabA_Soegeord1,klasseEgenskabA_Soegeord2]::KlasseSoegeordType[], 
   virkEgenskaber
) :: KlasseEgenskaberAttrType
;


klasseEgenskabB_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord1',
'beskrivelse_klasseEgenskabB_Soegeord1',
'soegeordskategori_klasseEgenskabB_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabB_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord2',
'beskrivelse_klasseEgenskabB_Soegeord2',
'soegeordskategori_klasseEgenskabB_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabB_Soegeord3 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord3',
'beskrivelse_klasseEgenskabB_Soegeord3',
'soegeordskategori_klasseEgenskabB_Soegeord3'
)::KlasseSoegeordType
;
klasseEgenskabB_Soegeord4 := ROW(
'soegeordidentifikator_klasseEgenskabB_Soegeord4',
'beskrivelse_klasseEgenskabB_Soegeord4',
'soegeordskategori_klasseEgenskabB_Soegeord4'
)::KlasseSoegeordType
;


klasseEgenskabE_Soegeord1 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord1',
'beskrivelse_klasseEgenskabE_Soegeord1',
'soegeordskategori_klasseEgenskabE_Soegeord1'
)::KlasseSoegeordType
;
klasseEgenskabE_Soegeord2 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord2',
'beskrivelse_klasseEgenskabE_Soegeord2',
'soegeordskategori_klasseEgenskabE_Soegeord2'
)::KlasseSoegeordType
;

klasseEgenskabE_Soegeord3 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord3',
'beskrivelse_klasseEgenskabE_Soegeord3',
'soegeordskategori_klasseEgenskabE_Soegeord3'
)::KlasseSoegeordType
;
klasseEgenskabE_Soegeord4 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord4',
'beskrivelse_klasseEgenskabE_Soegeord4',
'soegeordskategori_klasseEgenskabE_Soegeord4'
)::KlasseSoegeordType
;

klasseEgenskabE_Soegeord5 := ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord5',
'beskrivelse_klasseEgenskabE_Soegeord5',
'soegeordskategori_klasseEgenskabE_Soegeord5'
)::KlasseSoegeordType
;


klasseEgenskabB := ROW (
'brugervendt_noegle_B',
   'klassebeskrivelse_B',
   'eksempel_B',
	'omfang_B',
   'titel_B',
   'retskilde_B',
   NULL, --aendringsnotat
    ARRAY[klasseEgenskabB_Soegeord1,klasseEgenskabB_Soegeord2,klasseEgenskabB_Soegeord3,klasseEgenskabB_Soegeord4]::KlasseSoegeordType[], --soegeord
   virkEgenskaberB
) :: KlasseEgenskaberAttrType
;


registreringA := ROW (
	ROW (
	NULL,
	'Opstaaet'::Livscykluskode,
	uuidRegistrering,
	'Test Note 54') :: RegistreringBase
	,
ARRAY[klassePubliceret,klassePubliceretB]::KlassePubliceretTilsType[],
ARRAY[klasseEgenskabA,klasseEgenskabB]::KlasseEgenskaberAttrType[],
ARRAY[klasseRelRedaktoer2,klasseRelRedaktoer1,klasseRelAnsvarlig]
) :: KlasseRegistreringType
;

new_uuid := as_create_or_import_klasse(registreringA);

--json_result:=


--hacks to ease comparison 

insert into klasse (id) values (hacked_in_uuid)
;

update klasse_registrering 
	set registrering.timeperiod = TSTZRANGE('2015-07-30 10:18:42.079076+02','infinity','[)')
	where klasse_id=new_uuid
	AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
;

update klasse_registrering
set klasse_id=hacked_in_uuid
where klasse_id=new_uuid
;

delete from klasse
where id=new_uuid
;


read_Klasse := as_read_Klasse(hacked_in_uuid,
	null, --registrering_tstzrange
	null --virkning_tstzrange
	);

json_result:=read_Klasse::json;
json_expected:=$json_txt${"id":"5d32f909-327f-479e-b98f-b6e8cbaca1ee","registreringer":[{"fratidspunkt":{"tidsstempeldatotid":"2015-07-30 10:18:42.079076+02","graenseindikator":true},"tiltidspunkt":{"tidsstempeldatotid":"infinity","graenseindikator":false},"livscykluskode":"Opstaaet","note":"Test Note 54","brugerref":"0cc293df-fa20-414d-8403-d2a95656d93f","attributter":{"klasseegenskaber":[{"brugervendtnoegle":"brugervendt_noegle_A","beskrivelse":"klassebeskrivelse_A","eksempel":"eksempel_A","omfang":"omfang_A","titel":"titel_A","retskilde":"retskilde_A","aendringsnotat":null,"soegeord":[{"soegeordidentifikator":"soegeordidentifikator_klasseEgenskabA_Soegeord1","beskrivelse":"beskrivelse_klasseEgenskabA_Soegeord1","soegeordskategori":"soegeordskategori_klasseEgenskabA_Soegeord1"},{"soegeordidentifikator":"soegeordidentifikator_klasseEgenskabA_Soegeord2","beskrivelse":"beskrivelse_klasseEgenskabA_Soegeord2","soegeordskategori":"soegeordskategori_klasseEgenskabA_Soegeord2"}],"virkning":{"timeperiod":"[\"2015-05-12 00:00:00+02\",infinity)","aktoerref":"303514bc-9014-4591-a8a9-22eb37c592f9","aktoertypekode":"Bruger","notetekst":"NoteEx1"}},{"brugervendtnoegle":"brugervendt_noegle_B","beskrivelse":"klassebeskrivelse_B","eksempel":"eksempel_B","omfang":"omfang_B","titel":"titel_B","retskilde":"retskilde_B","aendringsnotat":null,"soegeord":[{"soegeordidentifikator":"soegeordidentifikator_klasseEgenskabB_Soegeord1","beskrivelse":"beskrivelse_klasseEgenskabB_Soegeord1","soegeordskategori":"soegeordskategori_klasseEgenskabB_Soegeord1"},{"soegeordidentifikator":"soegeordidentifikator_klasseEgenskabB_Soegeord2","beskrivelse":"beskrivelse_klasseEgenskabB_Soegeord2","soegeordskategori":"soegeordskategori_klasseEgenskabB_Soegeord2"},{"soegeordidentifikator":"soegeordidentifikator_klasseEgenskabB_Soegeord3","beskrivelse":"beskrivelse_klasseEgenskabB_Soegeord3","soegeordskategori":"soegeordskategori_klasseEgenskabB_Soegeord3"},{"soegeordidentifikator":"soegeordidentifikator_klasseEgenskabB_Soegeord4","beskrivelse":"beskrivelse_klasseEgenskabB_Soegeord4","soegeordskategori":"soegeordskategori_klasseEgenskabB_Soegeord4"}],"virkning":{"timeperiod":"[\"2014-05-13 00:00:00+02\",\"2015-01-01 00:00:00+01\")","aktoerref":"858a568b-2ad0-4168-8b83-c48b8238106c","aktoertypekode":"Bruger","notetekst":"NoteEx7"}}]},"tilstande":{"klassepubliceret":[{"virkning":{"timeperiod":"[\"2015-05-01 00:00:00+02\",infinity)","aktoerref":"01cdb20d-1897-4966-9552-0a691f162daf","aktoertypekode":"Bruger","notetekst":"NoteEx8"},"publiceret":"Publiceret"},{"virkning":{"timeperiod":"[\"2014-05-13 00:00:00+02\",\"2015-05-01 00:00:00+02\")","aktoerref":"38efbe3e-3b93-470a-956a-793ca0c8f219","aktoertypekode":"Bruger","notetekst":"NoteEx9"},"publiceret":"IkkePubliceret"}]},"relationer":{"ansvarlig":[{"virkning":{"timeperiod":"[\"2015-05-11 00:00:00+02\",infinity)","aktoerref":"0befe457-cef5-4888-b49c-bbee77e44f99","aktoertypekode":"Bruger","notetekst":"NoteEx2"},"uuid":"ee2616de-91b3-4f7d-8c2d-7e592dbba494","urn":null,"objekttype":null}],"redaktoerer":[{"virkning":{"timeperiod":"[\"2015-05-10 00:00:00+02\",\"2016-05-10 00:00:00+02\")","aktoerref":"1c0ce5a4-02c4-4697-ab39-00b7da0b1f54","aktoertypekode":"Bruger","notetekst":"NoteEx4"},"uuid":"daac7580-3073-429d-a0a7-f5eabf0c35d8","urn":null,"objekttype":null},{"virkning":{"timeperiod":"[\"2015-05-10 00:00:00+02\",infinity)","aktoerref":"f700e686-5bed-45b3-9d13-c09bbdf2ad1a","aktoertypekode":"Bruger","notetekst":"NoteEx3"},"uuid":"de08d17d-8b4c-4d7c-a369-ef8a9e4ac32f","urn":null,"objekttype":null}]}}]}$json_txt$::json; --format json in eclipse or similar to debug/inspect

--raise notice 'read_Klasse - pre json:%',read_Klasse;
--raise notice 'json_result:%',to_json(json_result);
--raise notice 'json_expected:%',to_json(json_expected);


return next ok(json_result::text=json_expected::text,'Json cast test#1');


END;
$_$;


ALTER FUNCTION test.test_json_cast_function() OWNER TO mox;

--
-- Name: test_json_object_delete_keys(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_json_object_delete_keys() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 
sagRelType1 SagRelationType;	
resultJson json;
actualCount1 int;
actualCount2 int;
BEGIN

sagRelType1 := ROW (
	'ansvarlig'::sagRelationKode
	,null --virkning
	,'f7109356-e87e-4b10-ad5d-36de6e3ee09f'::uuid
	,null --urn
	,'Klasse' --objekttype
	,567   --indeks
	,null --relTypeSpec
	,null --journalNotat
	,null --journalDokumentAttr
) :: SagRelationType
;

resultJson:=_json_object_delete_keys(row_to_json(sagRelType1),ARRAY['reltypespec','journalnotat','journaldokumentattr']);
select count(*) into actualCount1 from json_each(resultJson);
select count(*) into actualCount2 from json_each(resultJson) where key = ANY(ARRAY['reltypespec','journalnotat','journaldokumentattr','urn']) ;
return next is(actualCount1,6,'Test for number of json fields, after delete #1.');
return next is(actualCount2,1,'Test for number of json fields, after delete #2.');





END;
$$;


ALTER FUNCTION test.test_json_object_delete_keys() OWNER TO mox;

--
-- Name: test_remove_nulls_in_array_klasse(); Type: FUNCTION; Schema: test; Owner: mox
--

CREATE FUNCTION test_remove_nulls_in_array_klasse() RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
DECLARE 

relationerArr	KlasseRelationType[];
relationerArr2	KlasseRelationType[];
relationerArr3	KlasseRelationType[];
relationerArr4	KlasseRelationType[];
resultRelationerArr	KlasseRelationType[];
resultRelationerArr2	KlasseRelationType[];
resultRelationerArr3	KlasseRelationType[];
resultRelationerArr4	KlasseRelationType[];
resultRelationerArr5	KlasseRelationType[];
publiceretArr	KlassePubliceretTilsType[];
publiceretArr2	KlassePubliceretTilsType[];
publiceretArr3	KlassePubliceretTilsType[];
publiceretArr4	KlassePubliceretTilsType[];
resultpubliceretArr	KlassePubliceretTilsType[];
resultpubliceretArr2	KlassePubliceretTilsType[];
resultpubliceretArr3	KlassePubliceretTilsType[];
resultpubliceretArr4	KlassePubliceretTilsType[];
resultpubliceretArr5	KlassePubliceretTilsType[];
egenskaberArr	KlasseegenskaberAttrType[];
egenskaberArr2	KlasseegenskaberAttrType[];
egenskaberArr3	KlasseegenskaberAttrType[];
egenskaberArr4	KlasseegenskaberAttrType[];
resultegenskaberArr	KlasseegenskaberAttrType[];
resultegenskaberArr2	KlasseegenskaberAttrType[];
resultegenskaberArr3	KlasseegenskaberAttrType[];
resultegenskaberArr4	KlasseegenskaberAttrType[];
resultegenskaberArr5	KlasseegenskaberAttrType[];
soegeordArr	KlasseSoegeordType[];
soegeordArr2	KlasseSoegeordType[];
soegeordArr3	KlasseSoegeordType[];
soegeordArr4	KlasseSoegeordType[];
resultsoegeordArr	KlasseSoegeordType[];
resultsoegeordArr2	KlasseSoegeordType[];
resultsoegeordArr3	KlasseSoegeordType[];
resultsoegeordArr4	KlasseSoegeordType[];
resultsoegeordArr5	KlasseSoegeordType[];

BEGIN

relationerArr:=array_append(relationerArr,
 ROW (
	'ansvarlig'::KlasseRelationKode,
		ROW (
	'[2015-05-11, infinity)' :: TSTZRANGE,
          'b0ba2a98-2c2e-4628-b030-e39e25c8166a'::uuid,
          'Bruger',
          'NoteEx2'
          ) :: Virkning,
	  'cbe8142b-bafc-4aaf-89b6-4e90b9e08907'::uuid,
	  null,
	  null
) :: KlasseRelationType
)
;

relationerArr:=array_append(relationerArr,
 ROW (
	'ansvarlig'::KlasseRelationKode,
		ROW (
	'[2015-05-14, infinity)' :: TSTZRANGE,
          'b0ba2a98-2c2e-4628-b030-e39e25c8166a'::uuid,
          'Bruger',
          'NoteEx3'
          ) :: Virkning,
	  'fbe8142b-bafc-4aaf-89b6-4e90b9e08908'::uuid,
	  null,
	  null
) :: KlasseRelationType
)
;

relationerArr:=array_append(relationerArr,
 ROW (
	'ansvarlig'::KlasseRelationKode,
		ROW (
	'[2015-05-19, infinity)' :: TSTZRANGE,
          'c0ba2a98-2c2e-4628-b030-e39e25c81664'::uuid,
          'Bruger',
          'NoteEx10'
          ) :: Virkning,
	  'ebe8142b-bafc-4aaf-89b6-4e90b9e08909'::uuid,
	  null,
	  null
) :: KlasseRelationType
)
;

relationerArr:=array_append(relationerArr,
 ROW (
	'ansvarlig'::KlasseRelationKode,
		ROW (
	'[2015-05-13, infinity)' :: TSTZRANGE,
          'd0ba2a98-2c2e-4628-b030-e39e25c81662'::uuid,
          'Bruger',
          'NoteEx11'
          ) :: Virkning,
	  'cee8142b-bafc-4aaf-89b6-4e90b9e08900'::uuid,
	  null,
	  null
) :: KlasseRelationType
)
;

relationerArr:=array_append(relationerArr,
 ROW (
	'ansvarlig'::KlasseRelationKode,
		ROW (
	'[2015-04-13, infinity)' :: TSTZRANGE,
          '30ba2a98-2c2e-4628-b030-e39e25c81669'::uuid,
          'Bruger',
          'NoteEx30'
          ) :: Virkning,
	  '3ee8142b-bafc-4aaf-89b6-4e90b9e08908'::uuid,
	  null,
	  null
) :: KlasseRelationType
)
;



IF NOT coalesce(array_length(relationerArr,1),0)=5 THEN
	RAISE EXCEPTION 'Test assumption 1 failed. #relationer';
END IF;

resultRelationerArr:=_remove_nulls_in_array(relationerArr);

RETURN NEXT is(relationerArr,resultRelationerArr,'Test if non null elements and order is preserved #relationer');


relationerArr2:=array_append(relationerArr,null);
relationerArr2:=array_append(relationerArr2,null);
relationerArr2:=array_prepend(null,relationerArr2);
relationerArr2:=array_prepend(null,relationerArr2);

IF NOT coalesce(array_length(relationerArr2,1),0)=9 THEN
	RAISE EXCEPTION 'Test assumption 2 failed. #relationer';
END IF;

resultRelationerArr2:=_remove_nulls_in_array(relationerArr2);

RETURN NEXT is(resultRelationerArr2,relationerArr,'Test if null values are removed #relationer');

relationerArr3:=array_append(relationerArr,
	 ROW (
		null--'ansvarlig'::KlasseRelationKode,
		,null	/*ROW (
		'[2015-04-13, infinity)' :: TSTZRANGE,
	          '30ba2a98-2c2e-4628-b030-e39e25c81669'::uuid,
	          'Bruger',
	          'NoteEx30'
	          ) :: Virkning,*/
		,null--  '3ee8142b-bafc-4aaf-89b6-4e90b9e08908'::uuid
		,null
		,null
	) :: KlasseRelationType	
);

IF NOT coalesce(array_length(relationerArr3,1),0)=6 THEN
	RAISE EXCEPTION 'Test assumption 3 failed.';
END IF;

resultRelationerArr3:=_remove_nulls_in_array(relationerArr3);

RETURN NEXT is(resultRelationerArr3,relationerArr,'Test if element with only null values are removed #relationer');

resultRelationerArr4:='{}'::KlasseRelationType[];

RETURN NEXT is(_remove_nulls_in_array(resultRelationerArr4),null,'Test that empty arrays, gets converted to null #relationer');

resultRelationerArr5:=null;

RETURN NEXT is(_remove_nulls_in_array(resultRelationerArr5),null,'Test that null arrays stays null #relationer');


------------------------------------------------------------


publiceretArr:=array_append(publiceretArr,
ROW(
	ROW (
	'[2015-04-13, infinity)' :: TSTZRANGE,
          '30ba2a98-2c2e-4628-b030-e39e25c81669'::uuid,
          'Bruger',
          'NoteEx30'
          ) :: Virkning,
'Publiceret'
):: klassePubliceretTilsType
);

publiceretArr:=array_append(publiceretArr,
ROW(
	ROW (
	'[2014-04-13, infinity)' :: TSTZRANGE,
          '50ba2a98-2c2e-4628-b030-e39e25c81669'::uuid,
          'Bruger',
          'NoteEx40'
          ) :: Virkning,
'IkkePubliceret'
):: klassePubliceretTilsType
);


publiceretArr:=array_append(publiceretArr,
ROW(
	ROW (
	'[2014-05-13, infinity)' :: TSTZRANGE,
          '30ba2a98-2c2e-4628-b030-e39e25c81669'::uuid,
          'Bruger',
          'NoteEx50'
          ) :: Virkning,
''
):: klassePubliceretTilsType
);

publiceretArr:=array_append(publiceretArr,
ROW(
	ROW (
	'[2014-05-13, infinity)' :: TSTZRANGE,
          '60ba2a98-2c2e-4628-b030-e39e25c81669'::uuid,
          'Bruger',
          'NoteEx60'
          ) :: Virkning,
'Publiceret'
):: klassePubliceretTilsType
);



IF NOT coalesce(array_length(publiceretArr,1),0)=4 THEN
	RAISE EXCEPTION 'Test publiceret assumption 1 failed. # publiceret';
END IF;

resultpubliceretArr:=_remove_nulls_in_array(publiceretArr);

RETURN NEXT is(publiceretArr,resultpubliceretArr,'Test if non null elements and order is preserved # publiceret');


publiceretArr2:=array_append(publiceretArr,null);
publiceretArr2:=array_append(publiceretArr2,null);
publiceretArr2:=array_prepend(null,publiceretArr2);
publiceretArr2:=array_prepend(null,publiceretArr2);

IF NOT coalesce(array_length(publiceretArr2,1),0)=8 THEN
	RAISE EXCEPTION 'Test publiceret assumption 2 failed. # publiceret';
END IF;

resultpubliceretArr2:=_remove_nulls_in_array(publiceretArr2);

RETURN NEXT is(resultpubliceretArr2,publiceretArr,'Test if null values are removed # publiceret');

publiceretArr3:=array_append(publiceretArr,
	 ROW (
		null
		,null	
	) :: KlassePubliceretTilsType
);

IF NOT coalesce(array_length(publiceretArr3,1),0)=5 THEN
	RAISE EXCEPTION 'Test assumption 3 failed. # publiceret';
END IF;

resultpubliceretArr3:=_remove_nulls_in_array(publiceretArr3);

RETURN NEXT is(resultpubliceretArr3,publiceretArr,'Test if element with only null values are removed # publiceret');

resultpubliceretArr4:='{}'::KlassePubliceretTilsType[];

RETURN NEXT is(_remove_nulls_in_array(resultpubliceretArr4),null,'Test that empty arrays, gets converted to null # publiceret');

resultpubliceretArr5:=null;

RETURN NEXT is(_remove_nulls_in_array(resultpubliceretArr5),null,'Test that null arrays stays null # publiceret');

------------------------------------------------------------


egenskaberArr:=array_append(egenskaberArr,
ROW(
	'brugervendt_noegle_E',
   'klassebeskrivelse_E',
   'eksempel_E',
	'omfang_E',
   'titel_E',
   'retskilde_E',
   'aendringsnotat', 
    ARRAY[ROW('soegeordidentifikator_klasseEgenskabE_Soegeord1','beskrivelse_klasseEgenskabE_Soegeord1','soegeordskategori_klasseEgenskabE_Soegeord1')::KlasseSoegeordType]
	,ROW ('[2015-04-13, infinity)' :: TSTZRANGE,'30ba2a98-2c2e-4628-b030-e39e25c81669'::uuid,'Bruger','NoteEx30') :: Virkning
):: KlasseEgenskaberAttrType
);


egenskaberArr:=array_append(egenskaberArr,
ROW(
	'brugervendt_noegle_A',
   'klassebeskrivelse_A',
   'eksempel_A',
	'omfang_A',
   'titel_A',
   'retskilde_A',
   'aendringsnotat_A', 
    ARRAY[ROW('soegeordidentifikator_klasseEgenskabA_Soegeord1','beskrivelse_klasseEgenskabA_Soegeord1','soegeordskategori_klasseEgenskabA_Soegeord1')::KlasseSoegeordType]
	,ROW ('[2015-04-12, infinity)' :: TSTZRANGE,'50ba2a98-2c2e-4628-b030-e39e25c81669'::uuid,'Bruger','NoteEx40') :: Virkning
):: KlasseEgenskaberAttrType
);


egenskaberArr:=array_append(egenskaberArr,
ROW(
	'brugervendt_noegle_C',
   'klassebeskrivelse_C',
   'eksempel_C',
	'omfang_C',
   'titel_C',
   'retskilde_C',
   'aendringsnotat_C', 
    ARRAY[]::KlasseSoegeordType[]
	,ROW ('[2015-04-12, infinity)' :: TSTZRANGE,'50ba2a98-2c2e-4628-b030-e39e25c81669'::uuid,'Bruger','NoteEx40') :: Virkning
):: KlasseEgenskaberAttrType
);

egenskaberArr:=array_append(egenskaberArr,
ROW(
	'brugervendt_noegle_D',
   'klassebeskrivelse_D',
   'eksempel_D',
	'omfang_D',
   'titel_D',
   'retskilde_D',
   'aendringsnotat_D', 
    ARRAY[]::KlasseSoegeordType[]
	,ROW ('[2015-04-12, infinity)' :: TSTZRANGE,'50ba2a98-2D2e-4628-b030-e39e25D81669'::uuid,'Bruger','NoteEx70') :: Virkning
):: KlasseEgenskaberAttrType
);


IF NOT coalesce(array_length(egenskaberArr,1),0)=4 THEN
	RAISE EXCEPTION 'Test egenskaber assumption 1 failed. # egenskaber';
END IF;

resultegenskaberArr:=_remove_nulls_in_array(egenskaberArr);

RETURN NEXT is(egenskaberArr,resultegenskaberArr,'Test if non null elements and order is preserved # egenskaber');


egenskaberArr2:=array_append(egenskaberArr,null);
egenskaberArr2:=array_append(egenskaberArr2,null);
egenskaberArr2:=array_prepend(null,egenskaberArr2);
egenskaberArr2:=array_prepend(null,egenskaberArr2);

IF NOT coalesce(array_length(egenskaberArr2,1),0)=8 THEN
	RAISE EXCEPTION 'Test egenskaber assumption 2 failed. # egenskaber';
END IF;

resultegenskaberArr2:=_remove_nulls_in_array(egenskaberArr2);

RETURN NEXT is(resultegenskaberArr2,egenskaberArr,'Test if null values are removed # egenskaber');

egenskaberArr3:=array_append(egenskaberArr,
	 ROW (
		null,
   null,
   null,
	null,
   null,
   null,
   null, 
    ARRAY[]::KlasseSoegeordType[]
	,null
	) :: KlasseEgenskaberAttrType
);

egenskaberArr3:=array_append(egenskaberArr3,
	 ROW (
		null,
   null,
   null,
	null,
   null,
   null,
   null, 
    null--ARRAY[]::KlasseSoegeordType[]
	,null
	) :: KlasseEgenskaberAttrType
);

IF NOT coalesce(array_length(egenskaberArr3,1),0)=6 THEN
	RAISE EXCEPTION 'Test assumption 3 failed. # egenskaber';
END IF;

resultegenskaberArr3:=_remove_nulls_in_array(egenskaberArr3);

RETURN NEXT is(resultegenskaberArr3,egenskaberArr,'Test if element with only null values are removed # egenskaber');

resultegenskaberArr4:='{}'::KlasseegenskaberAttrType[];

RETURN NEXT is(_remove_nulls_in_array(resultegenskaberArr4),null,'Test that empty arrays, gets converted to null # egenskaber');

resultegenskaberArr5:=null;

RETURN NEXT is(_remove_nulls_in_array(resultegenskaberArr5),null,'Test that null arrays stays null # egenskaber');


------------------------------------------------------------




soegeordArr:=array_append(soegeordArr,
ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord2',
'beskrivelse_klasseEgenskabE_Soegeord2',
'soegeordskategori_klasseEgenskabE_Soegeord2'
)::KlasseSoegeordType
);


soegeordArr:=array_append(soegeordArr,
ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord1',
'beskrivelse_klasseEgenskabE_Soegeord1',
'soegeordskategori_klasseEgenskabE_Soegeord1'
)::KlasseSoegeordType
);

soegeordArr:=array_append(soegeordArr,
ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord3',
'beskrivelse_klasseEgenskabE_Soegeord3',
'soegeordskategori_klasseEgenskabE_Soegeord3'
)::KlasseSoegeordType
);

soegeordArr:=array_append(soegeordArr,
ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord5',
'beskrivelse_klasseEgenskabE_Soegeord5',
'soegeordskategori_klasseEgenskabE_Soegeord5'
)::KlasseSoegeordType
);

soegeordArr:=array_append(soegeordArr,
ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord4',
'beskrivelse_klasseEgenskabE_Soegeord4',
'soegeordskategori_klasseEgenskabE_Soegeord4'
)::KlasseSoegeordType
);
soegeordArr:=array_append(soegeordArr,
ROW(
'soegeordidentifikator_klasseEgenskabE_Soegeord6',
'beskrivelse_klasseEgenskabE_Soegeord6',
'soegeordskategori_klasseEgenskabE_Soegeord6'
)::KlasseSoegeordType
);


IF NOT coalesce(array_length(soegeordArr,1),0)=6 THEN
	RAISE EXCEPTION 'Test soegeord assumption 1 failed. # soegeord';
END IF;

resultsoegeordArr:=_remove_nulls_in_array(soegeordArr);

RETURN NEXT is(soegeordArr,resultsoegeordArr,'Test if non null elements and order is preserved # soegeord');


soegeordArr2:=array_append(soegeordArr,null);
soegeordArr2:=array_append(soegeordArr2,null);
soegeordArr2:=array_prepend(null,soegeordArr2);
soegeordArr2:=array_prepend(null,soegeordArr2);

IF NOT coalesce(array_length(soegeordArr2,1),0)=10 THEN
	RAISE EXCEPTION 'Test soegeord assumption 2 failed. # soegeord';
END IF;

resultsoegeordArr2:=_remove_nulls_in_array(soegeordArr2);

RETURN NEXT is(resultsoegeordArr2,soegeordArr,'Test if null values are removed # soegeord');

soegeordArr3:=array_append(soegeordArr,
	 ROW (
		null
		,null
		,null	
	) :: KlasseSoegeordType
);

IF NOT coalesce(array_length(soegeordArr3,1),0)=7 THEN
	RAISE EXCEPTION 'Test assumption 3 failed. # soegeord';
END IF;

resultsoegeordArr3:=_remove_nulls_in_array(soegeordArr3);

RETURN NEXT is(resultsoegeordArr3,soegeordArr,'Test if element with only null values are removed # soegeord');

resultsoegeordArr4:='{}'::KlasseSoegeordType[];

RETURN NEXT is(_remove_nulls_in_array(resultsoegeordArr4),null,'Test that empty arrays, gets converted to null # soegeord');

resultsoegeordArr5:=null;

RETURN NEXT is(_remove_nulls_in_array(resultsoegeordArr5),null,'Test that null arrays stays null # soegeord');



END;
$$;


ALTER FUNCTION test.test_remove_nulls_in_array_klasse() OWNER TO mox;

SET search_path = pg_catalog;

--
-- Name: CAST (actual_state.aktivitetregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.aktivitetregistreringtype AS json) WITH FUNCTION actual_state._cast_aktivitetregistreringtype_to_json(actual_state.aktivitetregistreringtype);


--
-- Name: CAST (actual_state.aktivitettype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.aktivitettype AS json) WITH FUNCTION actual_state._cast_aktivitettype_to_json(actual_state.aktivitettype);


--
-- Name: CAST (boolean AS actual_state.clearableboolean); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (boolean AS actual_state.clearableboolean) WITH FUNCTION actual_state._cast_boolean_to_clearableboolean(boolean) AS IMPLICIT;


--
-- Name: CAST (actual_state.brugerregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.brugerregistreringtype AS json) WITH FUNCTION actual_state._cast_brugerregistreringtype_to_json(actual_state.brugerregistreringtype);


--
-- Name: CAST (actual_state.brugertype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.brugertype AS json) WITH FUNCTION actual_state._cast_brugertype_to_json(actual_state.brugertype);


--
-- Name: CAST (actual_state.clearableboolean AS boolean); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.clearableboolean AS boolean) WITH FUNCTION actual_state._cast_clearableboolean_to_boolean(actual_state.clearableboolean) AS IMPLICIT;


--
-- Name: CAST (actual_state.clearabledate AS date); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.clearabledate AS date) WITH FUNCTION actual_state._cast_clearabledate_to_date(actual_state.clearabledate) AS IMPLICIT;


--
-- Name: CAST (actual_state.clearableint AS integer); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.clearableint AS integer) WITH FUNCTION actual_state._cast_clearableint_to_int(actual_state.clearableint) AS IMPLICIT;


--
-- Name: CAST (actual_state.clearableinterval AS interval); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.clearableinterval AS interval) WITH FUNCTION actual_state._cast_clearableinterval_to_interval(actual_state.clearableinterval) AS IMPLICIT;


--
-- Name: CAST (actual_state.clearabletimestamptz AS timestamp with time zone); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.clearabletimestamptz AS timestamp with time zone) WITH FUNCTION actual_state._cast_clearabletimestamptz_to_timestamptz(actual_state.clearabletimestamptz) AS IMPLICIT;


--
-- Name: CAST (date AS actual_state.clearabledate); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (date AS actual_state.clearabledate) WITH FUNCTION actual_state._cast_date_to_clearabledate(date) AS IMPLICIT;


--
-- Name: CAST (actual_state.dokumentregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.dokumentregistreringtype AS json) WITH FUNCTION actual_state._cast_dokumentregistreringtype_to_json(actual_state.dokumentregistreringtype);


--
-- Name: CAST (actual_state.dokumenttype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.dokumenttype AS json) WITH FUNCTION actual_state._cast_dokumenttype_to_json(actual_state.dokumenttype);


--
-- Name: CAST (actual_state.facetregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.facetregistreringtype AS json) WITH FUNCTION actual_state._cast_facetregistreringtype_to_json(actual_state.facetregistreringtype);


--
-- Name: CAST (actual_state.facettype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.facettype AS json) WITH FUNCTION actual_state._cast_facettype_to_json(actual_state.facettype);


--
-- Name: CAST (actual_state.indsatsregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.indsatsregistreringtype AS json) WITH FUNCTION actual_state._cast_indsatsregistreringtype_to_json(actual_state.indsatsregistreringtype);


--
-- Name: CAST (actual_state.indsatstype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.indsatstype AS json) WITH FUNCTION actual_state._cast_indsatstype_to_json(actual_state.indsatstype);


--
-- Name: CAST (integer AS actual_state.clearableint); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (integer AS actual_state.clearableint) WITH FUNCTION actual_state._cast_int_to_clearableint(integer) AS IMPLICIT;


--
-- Name: CAST (actual_state.interessefaellesskabregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.interessefaellesskabregistreringtype AS json) WITH FUNCTION actual_state._cast_interessefaellesskabregistreringtype_to_json(actual_state.interessefaellesskabregistreringtype);


--
-- Name: CAST (actual_state.interessefaellesskabtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.interessefaellesskabtype AS json) WITH FUNCTION actual_state._cast_interessefaellesskabtype_to_json(actual_state.interessefaellesskabtype);


--
-- Name: CAST (interval AS actual_state.clearableinterval); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (interval AS actual_state.clearableinterval) WITH FUNCTION actual_state._cast_interval_to_clearableinterval(interval) AS IMPLICIT;


--
-- Name: CAST (actual_state.itsystemregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.itsystemregistreringtype AS json) WITH FUNCTION actual_state._cast_itsystemregistreringtype_to_json(actual_state.itsystemregistreringtype);


--
-- Name: CAST (actual_state.itsystemtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.itsystemtype AS json) WITH FUNCTION actual_state._cast_itsystemtype_to_json(actual_state.itsystemtype);


--
-- Name: CAST (actual_state.klasseregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.klasseregistreringtype AS json) WITH FUNCTION actual_state._cast_klasseregistreringtype_to_json(actual_state.klasseregistreringtype);


--
-- Name: CAST (actual_state.klassetype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.klassetype AS json) WITH FUNCTION actual_state._cast_klassetype_to_json(actual_state.klassetype);


--
-- Name: CAST (actual_state.klassifikationregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.klassifikationregistreringtype AS json) WITH FUNCTION actual_state._cast_klassifikationregistreringtype_to_json(actual_state.klassifikationregistreringtype);


--
-- Name: CAST (actual_state.klassifikationtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.klassifikationtype AS json) WITH FUNCTION actual_state._cast_klassifikationtype_to_json(actual_state.klassifikationtype);


--
-- Name: CAST (actual_state.loghaendelseregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.loghaendelseregistreringtype AS json) WITH FUNCTION actual_state._cast_loghaendelseregistreringtype_to_json(actual_state.loghaendelseregistreringtype);


--
-- Name: CAST (actual_state.loghaendelsetype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.loghaendelsetype AS json) WITH FUNCTION actual_state._cast_loghaendelsetype_to_json(actual_state.loghaendelsetype);


--
-- Name: CAST (actual_state.organisationenhedregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.organisationenhedregistreringtype AS json) WITH FUNCTION actual_state._cast_organisationenhedregistreringtype_to_json(actual_state.organisationenhedregistreringtype);


--
-- Name: CAST (actual_state.organisationenhedtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.organisationenhedtype AS json) WITH FUNCTION actual_state._cast_organisationenhedtype_to_json(actual_state.organisationenhedtype);


--
-- Name: CAST (actual_state.organisationfunktionregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.organisationfunktionregistreringtype AS json) WITH FUNCTION actual_state._cast_organisationfunktionregistreringtype_to_json(actual_state.organisationfunktionregistreringtype);


--
-- Name: CAST (actual_state.organisationfunktiontype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.organisationfunktiontype AS json) WITH FUNCTION actual_state._cast_organisationfunktiontype_to_json(actual_state.organisationfunktiontype);


--
-- Name: CAST (actual_state.organisationregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.organisationregistreringtype AS json) WITH FUNCTION actual_state._cast_organisationregistreringtype_to_json(actual_state.organisationregistreringtype);


--
-- Name: CAST (actual_state.organisationtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.organisationtype AS json) WITH FUNCTION actual_state._cast_organisationtype_to_json(actual_state.organisationtype);


--
-- Name: CAST (actual_state.sagregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.sagregistreringtype AS json) WITH FUNCTION actual_state._cast_sagregistreringtype_to_json(actual_state.sagregistreringtype);


--
-- Name: CAST (actual_state.sagtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.sagtype AS json) WITH FUNCTION actual_state._cast_sagtype_to_json(actual_state.sagtype);


--
-- Name: CAST (text AS actual_state.clearableboolean); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (text AS actual_state.clearableboolean) WITH FUNCTION actual_state._cast_text_to_clearableboolean(text) AS IMPLICIT;


--
-- Name: CAST (text AS actual_state.clearabledate); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (text AS actual_state.clearabledate) WITH FUNCTION actual_state._cast_text_to_clearabledate(text) AS IMPLICIT;


--
-- Name: CAST (text AS actual_state.clearableint); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (text AS actual_state.clearableint) WITH FUNCTION actual_state._cast_text_to_clearableint(text) AS IMPLICIT;


--
-- Name: CAST (text AS actual_state.clearableinterval); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (text AS actual_state.clearableinterval) WITH FUNCTION actual_state._cast_text_to_clearableinterval(text) AS IMPLICIT;


--
-- Name: CAST (text AS actual_state.clearabletimestamptz); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (text AS actual_state.clearabletimestamptz) WITH FUNCTION actual_state._cast_text_to_clearabletimestamptz(text) AS IMPLICIT;


--
-- Name: CAST (actual_state.tilstandregistreringtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.tilstandregistreringtype AS json) WITH FUNCTION actual_state._cast_tilstandregistreringtype_to_json(actual_state.tilstandregistreringtype);


--
-- Name: CAST (actual_state.tilstandtype AS json); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (actual_state.tilstandtype AS json) WITH FUNCTION actual_state._cast_tilstandtype_to_json(actual_state.tilstandtype);


--
-- Name: CAST (timestamp with time zone AS actual_state.clearabletimestamptz); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (timestamp with time zone AS actual_state.clearabletimestamptz) WITH FUNCTION actual_state._cast_timestamptz_to_clearabletimestamptz(timestamp with time zone) AS IMPLICIT;


SET search_path = actual_state, pg_catalog;

--
-- Name: aktivitet; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE aktivitet (
    id uuid NOT NULL
);


ALTER TABLE aktivitet OWNER TO mox;

--
-- Name: aktivitet_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE aktivitet_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aktivitet_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: aktivitet_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE aktivitet_attr_egenskaber (
    id bigint DEFAULT nextval('aktivitet_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    aktivitetnavn text,
    beskrivelse text,
    starttidspunkt timestamp with time zone,
    sluttidspunkt timestamp with time zone,
    tidsforbrug interval(0),
    formaal text,
    virkning virkning NOT NULL,
    aktivitet_registrering_id bigint NOT NULL,
    CONSTRAINT aktivitet_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE aktivitet_attr_egenskaber OWNER TO mox;

--
-- Name: aktivitet_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE aktivitet_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aktivitet_relation_id_seq OWNER TO mox;

--
-- Name: aktivitet_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE aktivitet_relation (
    id bigint DEFAULT nextval('aktivitet_relation_id_seq'::regclass) NOT NULL,
    aktivitet_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type aktivitetrelationkode NOT NULL,
    objekt_type text,
    rel_index integer,
    aktoer_attr aktivitetaktoerattr,
    CONSTRAINT aktivitet_relation_aktoer_repr_either_uri_or_urn CHECK (((aktoer_attr IS NULL) OR ((_aktivitet_aktoer_attr_repr_uuid_to_text(aktoer_attr) IS NULL) AND (_aktivitet_aktoer_attr_repr_urn_to_text(aktoer_attr) IS NULL)) OR (((_aktivitet_aktoer_attr_repr_urn_to_text(aktoer_attr) IS NOT NULL) AND (_aktivitet_aktoer_attr_repr_uuid_to_text(aktoer_attr) IS NULL)) OR ((_aktivitet_aktoer_attr_repr_urn_to_text(aktoer_attr) IS NULL) AND (_aktivitet_aktoer_attr_repr_uuid_to_text(aktoer_attr) IS NOT NULL))))),
    CONSTRAINT aktivitet_relation_check_aktoer_attr_rel_type CHECK (((aktoer_attr IS NULL) OR (rel_type = 'udfoerer'::aktivitetrelationkode) OR (rel_type = 'deltager'::aktivitetrelationkode) OR (rel_type = 'ansvarlig'::aktivitetrelationkode))),
    CONSTRAINT aktivitet_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT aktivitet_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE aktivitet_relation OWNER TO mox;

--
-- Name: aktivitet_tils_publiceret_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE aktivitet_tils_publiceret_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aktivitet_tils_publiceret_id_seq OWNER TO mox;

--
-- Name: aktivitet_tils_publiceret; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE aktivitet_tils_publiceret (
    id bigint DEFAULT nextval('aktivitet_tils_publiceret_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    publiceret aktivitetpublicerettils NOT NULL,
    aktivitet_registrering_id bigint NOT NULL,
    CONSTRAINT aktivitet_tils_publiceret_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE aktivitet_tils_publiceret OWNER TO mox;

--
-- Name: aktivitet_tils_status_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE aktivitet_tils_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aktivitet_tils_status_id_seq OWNER TO mox;

--
-- Name: aktivitet_tils_status; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE aktivitet_tils_status (
    id bigint DEFAULT nextval('aktivitet_tils_status_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    status aktivitetstatustils NOT NULL,
    aktivitet_registrering_id bigint NOT NULL,
    CONSTRAINT aktivitet_tils_status_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE aktivitet_tils_status OWNER TO mox;

--
-- Name: bruger; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE bruger (
    id uuid NOT NULL
);


ALTER TABLE bruger OWNER TO mox;

--
-- Name: bruger_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE bruger_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE bruger_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: bruger_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE bruger_attr_egenskaber (
    id bigint DEFAULT nextval('bruger_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    brugernavn text,
    brugertype text,
    virkning virkning NOT NULL,
    bruger_registrering_id bigint NOT NULL,
    CONSTRAINT bruger_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE bruger_attr_egenskaber OWNER TO mox;

--
-- Name: bruger_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE bruger_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE bruger_relation_id_seq OWNER TO mox;

--
-- Name: bruger_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE bruger_relation (
    id bigint DEFAULT nextval('bruger_relation_id_seq'::regclass) NOT NULL,
    bruger_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type brugerrelationkode NOT NULL,
    objekt_type text,
    CONSTRAINT bruger_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT bruger_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE bruger_relation OWNER TO mox;

--
-- Name: bruger_tils_gyldighed_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE bruger_tils_gyldighed_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE bruger_tils_gyldighed_id_seq OWNER TO mox;

--
-- Name: bruger_tils_gyldighed; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE bruger_tils_gyldighed (
    id bigint DEFAULT nextval('bruger_tils_gyldighed_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    gyldighed brugergyldighedtils NOT NULL,
    bruger_registrering_id bigint NOT NULL,
    CONSTRAINT bruger_tils_gyldighed_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE bruger_tils_gyldighed OWNER TO mox;

--
-- Name: dokument; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE dokument (
    id uuid NOT NULL
);


ALTER TABLE dokument OWNER TO mox;

--
-- Name: dokument_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE dokument_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dokument_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: dokument_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE dokument_attr_egenskaber (
    id bigint DEFAULT nextval('dokument_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    beskrivelse text,
    brevdato date,
    kassationskode text,
    major integer,
    minor integer,
    offentlighedundtaget offentlighedundtagettype,
    titel text,
    dokumenttype text,
    virkning virkning NOT NULL,
    dokument_registrering_id bigint NOT NULL,
    CONSTRAINT dokument_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE dokument_attr_egenskaber OWNER TO mox;

--
-- Name: dokument_del_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE dokument_del_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dokument_del_id_seq OWNER TO mox;

--
-- Name: dokument_del; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE dokument_del (
    id bigint DEFAULT nextval('dokument_del_id_seq'::regclass) NOT NULL,
    deltekst text NOT NULL,
    variant_id bigint NOT NULL
);


ALTER TABLE dokument_del OWNER TO mox;

--
-- Name: dokument_del_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE dokument_del_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dokument_del_egenskaber_id_seq OWNER TO mox;

--
-- Name: dokument_del_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE dokument_del_egenskaber (
    id bigint DEFAULT nextval('dokument_del_egenskaber_id_seq'::regclass) NOT NULL,
    del_id bigint NOT NULL,
    indeks integer,
    indhold text,
    lokation text,
    mimetype text,
    virkning virkning NOT NULL,
    CONSTRAINT dokument_del_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE dokument_del_egenskaber OWNER TO mox;

--
-- Name: dokument_del_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE dokument_del_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dokument_del_relation_id_seq OWNER TO mox;

--
-- Name: dokument_del_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE dokument_del_relation (
    id bigint DEFAULT nextval('dokument_del_relation_id_seq'::regclass) NOT NULL,
    del_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type dokumentdelrelationkode NOT NULL,
    objekt_type text,
    CONSTRAINT dokument_del_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT dokument_del_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE dokument_del_relation OWNER TO mox;

--
-- Name: dokument_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE dokument_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dokument_relation_id_seq OWNER TO mox;

--
-- Name: dokument_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE dokument_relation (
    id bigint DEFAULT nextval('dokument_relation_id_seq'::regclass) NOT NULL,
    dokument_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type dokumentrelationkode NOT NULL,
    objekt_type text,
    CONSTRAINT dokument_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT dokument_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE dokument_relation OWNER TO mox;

--
-- Name: dokument_tils_fremdrift_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE dokument_tils_fremdrift_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dokument_tils_fremdrift_id_seq OWNER TO mox;

--
-- Name: dokument_tils_fremdrift; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE dokument_tils_fremdrift (
    id bigint DEFAULT nextval('dokument_tils_fremdrift_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    fremdrift dokumentfremdrifttils NOT NULL,
    dokument_registrering_id bigint NOT NULL,
    CONSTRAINT dokument_tils_fremdrift_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE dokument_tils_fremdrift OWNER TO mox;

--
-- Name: dokument_variant_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE dokument_variant_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dokument_variant_id_seq OWNER TO mox;

--
-- Name: dokument_variant; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE dokument_variant (
    id bigint DEFAULT nextval('dokument_variant_id_seq'::regclass) NOT NULL,
    varianttekst text NOT NULL,
    dokument_registrering_id bigint NOT NULL
);


ALTER TABLE dokument_variant OWNER TO mox;

--
-- Name: dokument_variant_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE dokument_variant_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dokument_variant_egenskaber_id_seq OWNER TO mox;

--
-- Name: dokument_variant_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE dokument_variant_egenskaber (
    id bigint DEFAULT nextval('dokument_variant_egenskaber_id_seq'::regclass) NOT NULL,
    variant_id bigint NOT NULL,
    arkivering boolean,
    delvisscannet boolean,
    offentliggoerelse boolean,
    produktion boolean,
    virkning virkning NOT NULL,
    CONSTRAINT dokument_variant_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE dokument_variant_egenskaber OWNER TO mox;

--
-- Name: facet; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE facet (
    id uuid NOT NULL
);


ALTER TABLE facet OWNER TO mox;

--
-- Name: facet_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE facet_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE facet_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: facet_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE facet_attr_egenskaber (
    id bigint DEFAULT nextval('facet_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    beskrivelse text,
    opbygning text,
    ophavsret text,
    plan text,
    supplement text,
    retskilde text,
    virkning virkning NOT NULL,
    facet_registrering_id bigint NOT NULL,
    CONSTRAINT facet_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE facet_attr_egenskaber OWNER TO mox;

--
-- Name: facet_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE facet_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE facet_relation_id_seq OWNER TO mox;

--
-- Name: facet_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE facet_relation (
    id bigint DEFAULT nextval('facet_relation_id_seq'::regclass) NOT NULL,
    facet_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type facetrelationkode NOT NULL,
    objekt_type text,
    CONSTRAINT facet_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT facet_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE facet_relation OWNER TO mox;

--
-- Name: facet_tils_publiceret_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE facet_tils_publiceret_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE facet_tils_publiceret_id_seq OWNER TO mox;

--
-- Name: facet_tils_publiceret; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE facet_tils_publiceret (
    id bigint DEFAULT nextval('facet_tils_publiceret_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    publiceret facetpublicerettils NOT NULL,
    facet_registrering_id bigint NOT NULL,
    CONSTRAINT facet_tils_publiceret_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE facet_tils_publiceret OWNER TO mox;

--
-- Name: indsats; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE indsats (
    id uuid NOT NULL
);


ALTER TABLE indsats OWNER TO mox;

--
-- Name: indsats_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE indsats_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE indsats_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: indsats_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE indsats_attr_egenskaber (
    id bigint DEFAULT nextval('indsats_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    beskrivelse text,
    starttidspunkt timestamp with time zone,
    sluttidspunkt timestamp with time zone,
    virkning virkning NOT NULL,
    indsats_registrering_id bigint NOT NULL,
    CONSTRAINT indsats_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE indsats_attr_egenskaber OWNER TO mox;

--
-- Name: indsats_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE indsats_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE indsats_relation_id_seq OWNER TO mox;

--
-- Name: indsats_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE indsats_relation (
    id bigint DEFAULT nextval('indsats_relation_id_seq'::regclass) NOT NULL,
    indsats_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type indsatsrelationkode NOT NULL,
    objekt_type text,
    rel_index integer,
    CONSTRAINT indsats_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT indsats_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE indsats_relation OWNER TO mox;

--
-- Name: indsats_tils_fremdrift_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE indsats_tils_fremdrift_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE indsats_tils_fremdrift_id_seq OWNER TO mox;

--
-- Name: indsats_tils_fremdrift; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE indsats_tils_fremdrift (
    id bigint DEFAULT nextval('indsats_tils_fremdrift_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    fremdrift indsatsfremdrifttils NOT NULL,
    indsats_registrering_id bigint NOT NULL,
    CONSTRAINT indsats_tils_fremdrift_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE indsats_tils_fremdrift OWNER TO mox;

--
-- Name: indsats_tils_publiceret_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE indsats_tils_publiceret_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE indsats_tils_publiceret_id_seq OWNER TO mox;

--
-- Name: indsats_tils_publiceret; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE indsats_tils_publiceret (
    id bigint DEFAULT nextval('indsats_tils_publiceret_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    publiceret indsatspublicerettils NOT NULL,
    indsats_registrering_id bigint NOT NULL,
    CONSTRAINT indsats_tils_publiceret_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE indsats_tils_publiceret OWNER TO mox;

--
-- Name: interessefaellesskab; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE interessefaellesskab (
    id uuid NOT NULL
);


ALTER TABLE interessefaellesskab OWNER TO mox;

--
-- Name: interessefaellesskab_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE interessefaellesskab_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE interessefaellesskab_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: interessefaellesskab_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE interessefaellesskab_attr_egenskaber (
    id bigint DEFAULT nextval('interessefaellesskab_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    interessefaellesskabsnavn text,
    interessefaellesskabstype text,
    virkning virkning NOT NULL,
    interessefaellesskab_registrering_id bigint NOT NULL,
    CONSTRAINT interessefaellesskab_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE interessefaellesskab_attr_egenskaber OWNER TO mox;

--
-- Name: interessefaellesskab_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE interessefaellesskab_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE interessefaellesskab_relation_id_seq OWNER TO mox;

--
-- Name: interessefaellesskab_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE interessefaellesskab_relation (
    id bigint DEFAULT nextval('interessefaellesskab_relation_id_seq'::regclass) NOT NULL,
    interessefaellesskab_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type interessefaellesskabrelationkode NOT NULL,
    objekt_type text,
    CONSTRAINT interessefaellesskab_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT interessefaellesskab_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE interessefaellesskab_relation OWNER TO mox;

--
-- Name: interessefaellesskab_tils_gyldighed_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE interessefaellesskab_tils_gyldighed_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE interessefaellesskab_tils_gyldighed_id_seq OWNER TO mox;

--
-- Name: interessefaellesskab_tils_gyldighed; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE interessefaellesskab_tils_gyldighed (
    id bigint DEFAULT nextval('interessefaellesskab_tils_gyldighed_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    gyldighed interessefaellesskabgyldighedtils NOT NULL,
    interessefaellesskab_registrering_id bigint NOT NULL,
    CONSTRAINT interessefaellesskab_tils_gyldighed_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE interessefaellesskab_tils_gyldighed OWNER TO mox;

--
-- Name: itsystem; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE itsystem (
    id uuid NOT NULL
);


ALTER TABLE itsystem OWNER TO mox;

--
-- Name: itsystem_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE itsystem_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE itsystem_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: itsystem_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE itsystem_attr_egenskaber (
    id bigint DEFAULT nextval('itsystem_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    itsystemnavn text,
    itsystemtype text,
    konfigurationreference text[],
    virkning virkning NOT NULL,
    itsystem_registrering_id bigint NOT NULL,
    CONSTRAINT itsystem_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE itsystem_attr_egenskaber OWNER TO mox;

--
-- Name: itsystem_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE itsystem_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE itsystem_relation_id_seq OWNER TO mox;

--
-- Name: itsystem_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE itsystem_relation (
    id bigint DEFAULT nextval('itsystem_relation_id_seq'::regclass) NOT NULL,
    itsystem_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type itsystemrelationkode NOT NULL,
    objekt_type text,
    CONSTRAINT itsystem_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT itsystem_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE itsystem_relation OWNER TO mox;

--
-- Name: itsystem_tils_gyldighed_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE itsystem_tils_gyldighed_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE itsystem_tils_gyldighed_id_seq OWNER TO mox;

--
-- Name: itsystem_tils_gyldighed; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE itsystem_tils_gyldighed (
    id bigint DEFAULT nextval('itsystem_tils_gyldighed_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    gyldighed itsystemgyldighedtils NOT NULL,
    itsystem_registrering_id bigint NOT NULL,
    CONSTRAINT itsystem_tils_gyldighed_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE itsystem_tils_gyldighed OWNER TO mox;

--
-- Name: klasse; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE klasse (
    id uuid NOT NULL
);


ALTER TABLE klasse OWNER TO mox;

--
-- Name: klasse_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE klasse_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE klasse_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: klasse_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE klasse_attr_egenskaber (
    id bigint DEFAULT nextval('klasse_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    beskrivelse text,
    eksempel text,
    omfang text,
    titel text,
    retskilde text,
    aendringsnotat text,
    virkning virkning NOT NULL,
    klasse_registrering_id bigint NOT NULL,
    CONSTRAINT klasse_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE klasse_attr_egenskaber OWNER TO mox;

--
-- Name: klasse_attr_egenskaber_soegeord_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE klasse_attr_egenskaber_soegeord_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE klasse_attr_egenskaber_soegeord_id_seq OWNER TO mox;

--
-- Name: klasse_attr_egenskaber_soegeord; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE klasse_attr_egenskaber_soegeord (
    id bigint DEFAULT nextval('klasse_attr_egenskaber_soegeord_id_seq'::regclass) NOT NULL,
    soegeordidentifikator text,
    beskrivelse text,
    soegeordskategori text,
    klasse_attr_egenskaber_id bigint NOT NULL,
    CONSTRAINT klasse_attr_egenskaber_soegeord_chk_not_all_null CHECK ((NOT ((soegeordidentifikator IS NULL) AND (beskrivelse IS NULL) AND (soegeordskategori IS NULL))))
);


ALTER TABLE klasse_attr_egenskaber_soegeord OWNER TO mox;

--
-- Name: klasse_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE klasse_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE klasse_relation_id_seq OWNER TO mox;

--
-- Name: klasse_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE klasse_relation (
    id bigint DEFAULT nextval('klasse_relation_id_seq'::regclass) NOT NULL,
    klasse_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type klasserelationkode NOT NULL,
    objekt_type text,
    CONSTRAINT klasse_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT klasse_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE klasse_relation OWNER TO mox;

--
-- Name: klasse_tils_publiceret_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE klasse_tils_publiceret_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE klasse_tils_publiceret_id_seq OWNER TO mox;

--
-- Name: klasse_tils_publiceret; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE klasse_tils_publiceret (
    id bigint DEFAULT nextval('klasse_tils_publiceret_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    publiceret klassepublicerettils NOT NULL,
    klasse_registrering_id bigint NOT NULL,
    CONSTRAINT klasse_tils_publiceret_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE klasse_tils_publiceret OWNER TO mox;

--
-- Name: klassifikation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE klassifikation (
    id uuid NOT NULL
);


ALTER TABLE klassifikation OWNER TO mox;

--
-- Name: klassifikation_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE klassifikation_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE klassifikation_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: klassifikation_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE klassifikation_attr_egenskaber (
    id bigint DEFAULT nextval('klassifikation_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    beskrivelse text,
    kaldenavn text,
    ophavsret text,
    virkning virkning NOT NULL,
    klassifikation_registrering_id bigint NOT NULL,
    CONSTRAINT klassifikation_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE klassifikation_attr_egenskaber OWNER TO mox;

--
-- Name: klassifikation_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE klassifikation_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE klassifikation_relation_id_seq OWNER TO mox;

--
-- Name: klassifikation_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE klassifikation_relation (
    id bigint DEFAULT nextval('klassifikation_relation_id_seq'::regclass) NOT NULL,
    klassifikation_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type klassifikationrelationkode NOT NULL,
    objekt_type text,
    CONSTRAINT klassifikation_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT klassifikation_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE klassifikation_relation OWNER TO mox;

--
-- Name: klassifikation_tils_publiceret_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE klassifikation_tils_publiceret_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE klassifikation_tils_publiceret_id_seq OWNER TO mox;

--
-- Name: klassifikation_tils_publiceret; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE klassifikation_tils_publiceret (
    id bigint DEFAULT nextval('klassifikation_tils_publiceret_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    publiceret klassifikationpublicerettils NOT NULL,
    klassifikation_registrering_id bigint NOT NULL,
    CONSTRAINT klassifikation_tils_publiceret_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE klassifikation_tils_publiceret OWNER TO mox;

--
-- Name: loghaendelse; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE loghaendelse (
    id uuid NOT NULL
);


ALTER TABLE loghaendelse OWNER TO mox;

--
-- Name: loghaendelse_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE loghaendelse_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE loghaendelse_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: loghaendelse_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE loghaendelse_attr_egenskaber (
    id bigint DEFAULT nextval('loghaendelse_attr_egenskaber_id_seq'::regclass) NOT NULL,
    service text,
    klasse text,
    tidspunkt text,
    operation text,
    objekttype text,
    returkode text,
    returtekst text,
    note text,
    virkning virkning NOT NULL,
    loghaendelse_registrering_id bigint NOT NULL,
    CONSTRAINT loghaendelse_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE loghaendelse_attr_egenskaber OWNER TO mox;

--
-- Name: loghaendelse_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE loghaendelse_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE loghaendelse_relation_id_seq OWNER TO mox;

--
-- Name: loghaendelse_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE loghaendelse_relation (
    id bigint DEFAULT nextval('loghaendelse_relation_id_seq'::regclass) NOT NULL,
    loghaendelse_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type loghaendelserelationkode NOT NULL,
    objekt_type text,
    CONSTRAINT loghaendelse_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT loghaendelse_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE loghaendelse_relation OWNER TO mox;

--
-- Name: loghaendelse_tils_gyldighed_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE loghaendelse_tils_gyldighed_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE loghaendelse_tils_gyldighed_id_seq OWNER TO mox;

--
-- Name: loghaendelse_tils_gyldighed; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE loghaendelse_tils_gyldighed (
    id bigint DEFAULT nextval('loghaendelse_tils_gyldighed_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    gyldighed loghaendelsegyldighedtils NOT NULL,
    loghaendelse_registrering_id bigint NOT NULL,
    CONSTRAINT loghaendelse_tils_gyldighed_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE loghaendelse_tils_gyldighed OWNER TO mox;

--
-- Name: organisation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisation (
    id uuid NOT NULL
);


ALTER TABLE organisation OWNER TO mox;

--
-- Name: organisation_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE organisation_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE organisation_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: organisation_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisation_attr_egenskaber (
    id bigint DEFAULT nextval('organisation_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    organisationsnavn text,
    virkning virkning NOT NULL,
    organisation_registrering_id bigint NOT NULL,
    CONSTRAINT organisation_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE organisation_attr_egenskaber OWNER TO mox;

--
-- Name: organisation_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE organisation_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE organisation_relation_id_seq OWNER TO mox;

--
-- Name: organisation_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisation_relation (
    id bigint DEFAULT nextval('organisation_relation_id_seq'::regclass) NOT NULL,
    organisation_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type organisationrelationkode NOT NULL,
    objekt_type text,
    CONSTRAINT organisation_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT organisation_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE organisation_relation OWNER TO mox;

--
-- Name: organisation_tils_gyldighed_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE organisation_tils_gyldighed_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE organisation_tils_gyldighed_id_seq OWNER TO mox;

--
-- Name: organisation_tils_gyldighed; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisation_tils_gyldighed (
    id bigint DEFAULT nextval('organisation_tils_gyldighed_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    gyldighed organisationgyldighedtils NOT NULL,
    organisation_registrering_id bigint NOT NULL,
    CONSTRAINT organisation_tils_gyldighed_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE organisation_tils_gyldighed OWNER TO mox;

--
-- Name: organisationenhed; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisationenhed (
    id uuid NOT NULL
);


ALTER TABLE organisationenhed OWNER TO mox;

--
-- Name: organisationenhed_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE organisationenhed_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE organisationenhed_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: organisationenhed_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisationenhed_attr_egenskaber (
    id bigint DEFAULT nextval('organisationenhed_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    enhedsnavn text,
    virkning virkning NOT NULL,
    organisationenhed_registrering_id bigint NOT NULL,
    CONSTRAINT organisationenhed_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE organisationenhed_attr_egenskaber OWNER TO mox;

--
-- Name: organisationenhed_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE organisationenhed_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE organisationenhed_relation_id_seq OWNER TO mox;

--
-- Name: organisationenhed_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisationenhed_relation (
    id bigint DEFAULT nextval('organisationenhed_relation_id_seq'::regclass) NOT NULL,
    organisationenhed_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type organisationenhedrelationkode NOT NULL,
    objekt_type text,
    CONSTRAINT organisationenhed_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT organisationenhed_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE organisationenhed_relation OWNER TO mox;

--
-- Name: organisationenhed_tils_gyldighed_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE organisationenhed_tils_gyldighed_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE organisationenhed_tils_gyldighed_id_seq OWNER TO mox;

--
-- Name: organisationenhed_tils_gyldighed; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisationenhed_tils_gyldighed (
    id bigint DEFAULT nextval('organisationenhed_tils_gyldighed_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    gyldighed organisationenhedgyldighedtils NOT NULL,
    organisationenhed_registrering_id bigint NOT NULL,
    CONSTRAINT organisationenhed_tils_gyldighed_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE organisationenhed_tils_gyldighed OWNER TO mox;

--
-- Name: organisationfunktion; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisationfunktion (
    id uuid NOT NULL
);


ALTER TABLE organisationfunktion OWNER TO mox;

--
-- Name: organisationfunktion_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE organisationfunktion_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE organisationfunktion_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: organisationfunktion_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisationfunktion_attr_egenskaber (
    id bigint DEFAULT nextval('organisationfunktion_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    funktionsnavn text,
    virkning virkning NOT NULL,
    organisationfunktion_registrering_id bigint NOT NULL,
    CONSTRAINT organisationfunktion_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE organisationfunktion_attr_egenskaber OWNER TO mox;

--
-- Name: organisationfunktion_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE organisationfunktion_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE organisationfunktion_relation_id_seq OWNER TO mox;

--
-- Name: organisationfunktion_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisationfunktion_relation (
    id bigint DEFAULT nextval('organisationfunktion_relation_id_seq'::regclass) NOT NULL,
    organisationfunktion_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type organisationfunktionrelationkode NOT NULL,
    objekt_type text,
    CONSTRAINT organisationfunktion_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT organisationfunktion_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE organisationfunktion_relation OWNER TO mox;

--
-- Name: organisationfunktion_tils_gyldighed_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE organisationfunktion_tils_gyldighed_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE organisationfunktion_tils_gyldighed_id_seq OWNER TO mox;

--
-- Name: organisationfunktion_tils_gyldighed; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE organisationfunktion_tils_gyldighed (
    id bigint DEFAULT nextval('organisationfunktion_tils_gyldighed_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    gyldighed organisationfunktiongyldighedtils NOT NULL,
    organisationfunktion_registrering_id bigint NOT NULL,
    CONSTRAINT organisationfunktion_tils_gyldighed_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE organisationfunktion_tils_gyldighed OWNER TO mox;

--
-- Name: sag; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE sag (
    id uuid NOT NULL
);


ALTER TABLE sag OWNER TO mox;

--
-- Name: sag_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE sag_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sag_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: sag_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE sag_attr_egenskaber (
    id bigint DEFAULT nextval('sag_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    afleveret boolean,
    beskrivelse text,
    hjemmel text,
    kassationskode text,
    offentlighedundtaget offentlighedundtagettype,
    principiel boolean,
    sagsnummer text,
    titel text,
    virkning virkning NOT NULL,
    sag_registrering_id bigint NOT NULL,
    CONSTRAINT sag_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE sag_attr_egenskaber OWNER TO mox;

--
-- Name: sag_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE sag_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sag_relation_id_seq OWNER TO mox;

--
-- Name: sag_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE sag_relation (
    id bigint DEFAULT nextval('sag_relation_id_seq'::regclass) NOT NULL,
    sag_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type sagrelationkode NOT NULL,
    objekt_type text,
    rel_index integer,
    rel_type_spec sagrelationjournalpostspecifikkode,
    journal_notat journalnotattype,
    journal_dokument_attr journalpostdokumentattrtype,
    CONSTRAINT sag_journal_notat_only_for_notat_type CHECK (((journal_notat IS NULL) OR (rel_type_spec = 'journalnotat'::sagrelationjournalpostspecifikkode))),
    CONSTRAINT sag_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT sag_relation_journal_dok_attr_only_vedlagtdok_tilakteretdok CHECK (((journal_dokument_attr IS NULL) OR (rel_type_spec = ANY (ARRAY['vedlagtdokument'::sagrelationjournalpostspecifikkode, 'tilakteretdokument'::sagrelationjournalpostspecifikkode])))),
    CONSTRAINT sag_relation_rel_type_spec_null_other_than_journalpost CHECK (((rel_type_spec IS NULL) OR (rel_type = 'journalpost'::sagrelationkode))),
    CONSTRAINT sag_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE sag_relation OWNER TO mox;

--
-- Name: sag_tils_fremdrift_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE sag_tils_fremdrift_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sag_tils_fremdrift_id_seq OWNER TO mox;

--
-- Name: sag_tils_fremdrift; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE sag_tils_fremdrift (
    id bigint DEFAULT nextval('sag_tils_fremdrift_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    fremdrift sagfremdrifttils NOT NULL,
    sag_registrering_id bigint NOT NULL,
    CONSTRAINT sag_tils_fremdrift_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE sag_tils_fremdrift OWNER TO mox;

--
-- Name: tilstand; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE tilstand (
    id uuid NOT NULL
);


ALTER TABLE tilstand OWNER TO mox;

--
-- Name: tilstand_attr_egenskaber_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE tilstand_attr_egenskaber_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tilstand_attr_egenskaber_id_seq OWNER TO mox;

--
-- Name: tilstand_attr_egenskaber; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE tilstand_attr_egenskaber (
    id bigint DEFAULT nextval('tilstand_attr_egenskaber_id_seq'::regclass) NOT NULL,
    brugervendtnoegle text,
    beskrivelse text,
    virkning virkning NOT NULL,
    tilstand_registrering_id bigint NOT NULL,
    CONSTRAINT tilstand_attr_egenskaber_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE tilstand_attr_egenskaber OWNER TO mox;

--
-- Name: tilstand_relation_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE tilstand_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tilstand_relation_id_seq OWNER TO mox;

--
-- Name: tilstand_relation; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE tilstand_relation (
    id bigint DEFAULT nextval('tilstand_relation_id_seq'::regclass) NOT NULL,
    tilstand_registrering_id bigint NOT NULL,
    virkning virkning NOT NULL,
    rel_maal_uuid uuid,
    rel_maal_urn text,
    rel_type tilstandrelationkode NOT NULL,
    objekt_type text,
    rel_index integer,
    tilstand_vaerdi_attr tilstandvaerdirelationattrtype,
    CONSTRAINT tilstand_relation_either_uri_or_urn CHECK ((NOT ((rel_maal_uuid IS NOT NULL) AND ((rel_maal_urn IS NOT NULL) AND (rel_maal_urn <> ''::text))))),
    CONSTRAINT tilstand_relation_nominel_vaerdi_relevant_null_check CHECK (((tilstand_vaerdi_attr IS NULL) OR (rel_type = 'tilstandsvaerdi'::tilstandrelationkode))),
    CONSTRAINT tilstand_relation_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE tilstand_relation OWNER TO mox;

--
-- Name: tilstand_tils_publiceret_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE tilstand_tils_publiceret_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tilstand_tils_publiceret_id_seq OWNER TO mox;

--
-- Name: tilstand_tils_publiceret; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE tilstand_tils_publiceret (
    id bigint DEFAULT nextval('tilstand_tils_publiceret_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    publiceret tilstandpublicerettils NOT NULL,
    tilstand_registrering_id bigint NOT NULL,
    CONSTRAINT tilstand_tils_publiceret_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE tilstand_tils_publiceret OWNER TO mox;

--
-- Name: tilstand_tils_status_id_seq; Type: SEQUENCE; Schema: actual_state; Owner: mox
--

CREATE SEQUENCE tilstand_tils_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tilstand_tils_status_id_seq OWNER TO mox;

--
-- Name: tilstand_tils_status; Type: TABLE; Schema: actual_state; Owner: mox
--

CREATE TABLE tilstand_tils_status (
    id bigint DEFAULT nextval('tilstand_tils_status_id_seq'::regclass) NOT NULL,
    virkning virkning NOT NULL,
    status tilstandstatustils NOT NULL,
    tilstand_registrering_id bigint NOT NULL,
    CONSTRAINT tilstand_tils_status_virkning_check CHECK ((((virkning).timeperiod IS NOT NULL) AND (NOT isempty((virkning).timeperiod))))
);


ALTER TABLE tilstand_tils_status OWNER TO mox;

--
-- Data for Name: aktivitet; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY aktivitet (id) FROM stdin;
\.


--
-- Data for Name: aktivitet_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY aktivitet_attr_egenskaber (id, brugervendtnoegle, aktivitetnavn, beskrivelse, starttidspunkt, sluttidspunkt, tidsforbrug, formaal, virkning, aktivitet_registrering_id) FROM stdin;
\.


--
-- Name: aktivitet_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('aktivitet_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: aktivitet_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY aktivitet_registrering (id, aktivitet_id, registrering) FROM stdin;
\.


--
-- Name: aktivitet_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('aktivitet_registrering_id_seq', 1, false);


--
-- Data for Name: aktivitet_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY aktivitet_relation (id, aktivitet_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type, rel_index, aktoer_attr) FROM stdin;
\.


--
-- Name: aktivitet_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('aktivitet_relation_id_seq', 1, false);


--
-- Data for Name: aktivitet_tils_publiceret; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY aktivitet_tils_publiceret (id, virkning, publiceret, aktivitet_registrering_id) FROM stdin;
\.


--
-- Name: aktivitet_tils_publiceret_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('aktivitet_tils_publiceret_id_seq', 1, false);


--
-- Data for Name: aktivitet_tils_status; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY aktivitet_tils_status (id, virkning, status, aktivitet_registrering_id) FROM stdin;
\.


--
-- Name: aktivitet_tils_status_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('aktivitet_tils_status_id_seq', 1, false);


--
-- Data for Name: bruger; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY bruger (id) FROM stdin;
\.


--
-- Data for Name: bruger_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY bruger_attr_egenskaber (id, brugervendtnoegle, brugernavn, brugertype, virkning, bruger_registrering_id) FROM stdin;
\.


--
-- Name: bruger_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('bruger_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: bruger_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY bruger_registrering (id, bruger_id, registrering) FROM stdin;
\.


--
-- Name: bruger_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('bruger_registrering_id_seq', 1, false);


--
-- Data for Name: bruger_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY bruger_relation (id, bruger_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type) FROM stdin;
\.


--
-- Name: bruger_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('bruger_relation_id_seq', 1, false);


--
-- Data for Name: bruger_tils_gyldighed; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY bruger_tils_gyldighed (id, virkning, gyldighed, bruger_registrering_id) FROM stdin;
\.


--
-- Name: bruger_tils_gyldighed_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('bruger_tils_gyldighed_id_seq', 1, false);


--
-- Data for Name: dokument; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY dokument (id) FROM stdin;
\.


--
-- Data for Name: dokument_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY dokument_attr_egenskaber (id, brugervendtnoegle, beskrivelse, brevdato, kassationskode, major, minor, offentlighedundtaget, titel, dokumenttype, virkning, dokument_registrering_id) FROM stdin;
\.


--
-- Name: dokument_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('dokument_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: dokument_del; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY dokument_del (id, deltekst, variant_id) FROM stdin;
\.


--
-- Data for Name: dokument_del_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY dokument_del_egenskaber (id, del_id, indeks, indhold, lokation, mimetype, virkning) FROM stdin;
\.


--
-- Name: dokument_del_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('dokument_del_egenskaber_id_seq', 1, false);


--
-- Name: dokument_del_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('dokument_del_id_seq', 1, false);


--
-- Data for Name: dokument_del_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY dokument_del_relation (id, del_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type) FROM stdin;
\.


--
-- Name: dokument_del_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('dokument_del_relation_id_seq', 1, false);


--
-- Data for Name: dokument_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY dokument_registrering (id, dokument_id, registrering) FROM stdin;
\.


--
-- Name: dokument_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('dokument_registrering_id_seq', 1, false);


--
-- Data for Name: dokument_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY dokument_relation (id, dokument_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type) FROM stdin;
\.


--
-- Name: dokument_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('dokument_relation_id_seq', 1, false);


--
-- Data for Name: dokument_tils_fremdrift; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY dokument_tils_fremdrift (id, virkning, fremdrift, dokument_registrering_id) FROM stdin;
\.


--
-- Name: dokument_tils_fremdrift_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('dokument_tils_fremdrift_id_seq', 1, false);


--
-- Data for Name: dokument_variant; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY dokument_variant (id, varianttekst, dokument_registrering_id) FROM stdin;
\.


--
-- Data for Name: dokument_variant_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY dokument_variant_egenskaber (id, variant_id, arkivering, delvisscannet, offentliggoerelse, produktion, virkning) FROM stdin;
\.


--
-- Name: dokument_variant_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('dokument_variant_egenskaber_id_seq', 1, false);


--
-- Name: dokument_variant_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('dokument_variant_id_seq', 1, false);


--
-- Data for Name: facet; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY facet (id) FROM stdin;
\.


--
-- Data for Name: facet_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY facet_attr_egenskaber (id, brugervendtnoegle, beskrivelse, opbygning, ophavsret, plan, supplement, retskilde, virkning, facet_registrering_id) FROM stdin;
\.


--
-- Name: facet_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('facet_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: facet_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY facet_registrering (id, facet_id, registrering) FROM stdin;
\.


--
-- Name: facet_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('facet_registrering_id_seq', 1, false);


--
-- Data for Name: facet_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY facet_relation (id, facet_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type) FROM stdin;
\.


--
-- Name: facet_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('facet_relation_id_seq', 1, false);


--
-- Data for Name: facet_tils_publiceret; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY facet_tils_publiceret (id, virkning, publiceret, facet_registrering_id) FROM stdin;
\.


--
-- Name: facet_tils_publiceret_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('facet_tils_publiceret_id_seq', 1, false);


--
-- Data for Name: indsats; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY indsats (id) FROM stdin;
\.


--
-- Data for Name: indsats_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY indsats_attr_egenskaber (id, brugervendtnoegle, beskrivelse, starttidspunkt, sluttidspunkt, virkning, indsats_registrering_id) FROM stdin;
\.


--
-- Name: indsats_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('indsats_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: indsats_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY indsats_registrering (id, indsats_id, registrering) FROM stdin;
\.


--
-- Name: indsats_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('indsats_registrering_id_seq', 1, false);


--
-- Data for Name: indsats_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY indsats_relation (id, indsats_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type, rel_index) FROM stdin;
\.


--
-- Name: indsats_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('indsats_relation_id_seq', 1, false);


--
-- Data for Name: indsats_tils_fremdrift; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY indsats_tils_fremdrift (id, virkning, fremdrift, indsats_registrering_id) FROM stdin;
\.


--
-- Name: indsats_tils_fremdrift_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('indsats_tils_fremdrift_id_seq', 1, false);


--
-- Data for Name: indsats_tils_publiceret; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY indsats_tils_publiceret (id, virkning, publiceret, indsats_registrering_id) FROM stdin;
\.


--
-- Name: indsats_tils_publiceret_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('indsats_tils_publiceret_id_seq', 1, false);


--
-- Data for Name: interessefaellesskab; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY interessefaellesskab (id) FROM stdin;
\.


--
-- Data for Name: interessefaellesskab_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY interessefaellesskab_attr_egenskaber (id, brugervendtnoegle, interessefaellesskabsnavn, interessefaellesskabstype, virkning, interessefaellesskab_registrering_id) FROM stdin;
\.


--
-- Name: interessefaellesskab_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('interessefaellesskab_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: interessefaellesskab_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY interessefaellesskab_registrering (id, interessefaellesskab_id, registrering) FROM stdin;
\.


--
-- Name: interessefaellesskab_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('interessefaellesskab_registrering_id_seq', 1, false);


--
-- Data for Name: interessefaellesskab_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY interessefaellesskab_relation (id, interessefaellesskab_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type) FROM stdin;
\.


--
-- Name: interessefaellesskab_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('interessefaellesskab_relation_id_seq', 1, false);


--
-- Data for Name: interessefaellesskab_tils_gyldighed; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY interessefaellesskab_tils_gyldighed (id, virkning, gyldighed, interessefaellesskab_registrering_id) FROM stdin;
\.


--
-- Name: interessefaellesskab_tils_gyldighed_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('interessefaellesskab_tils_gyldighed_id_seq', 1, false);


--
-- Data for Name: itsystem; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY itsystem (id) FROM stdin;
\.


--
-- Data for Name: itsystem_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY itsystem_attr_egenskaber (id, brugervendtnoegle, itsystemnavn, itsystemtype, konfigurationreference, virkning, itsystem_registrering_id) FROM stdin;
\.


--
-- Name: itsystem_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('itsystem_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: itsystem_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY itsystem_registrering (id, itsystem_id, registrering) FROM stdin;
\.


--
-- Name: itsystem_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('itsystem_registrering_id_seq', 1, false);


--
-- Data for Name: itsystem_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY itsystem_relation (id, itsystem_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type) FROM stdin;
\.


--
-- Name: itsystem_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('itsystem_relation_id_seq', 1, false);


--
-- Data for Name: itsystem_tils_gyldighed; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY itsystem_tils_gyldighed (id, virkning, gyldighed, itsystem_registrering_id) FROM stdin;
\.


--
-- Name: itsystem_tils_gyldighed_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('itsystem_tils_gyldighed_id_seq', 1, false);


--
-- Data for Name: klasse; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY klasse (id) FROM stdin;
\.


--
-- Data for Name: klasse_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY klasse_attr_egenskaber (id, brugervendtnoegle, beskrivelse, eksempel, omfang, titel, retskilde, aendringsnotat, virkning, klasse_registrering_id) FROM stdin;
\.


--
-- Name: klasse_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('klasse_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: klasse_attr_egenskaber_soegeord; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY klasse_attr_egenskaber_soegeord (id, soegeordidentifikator, beskrivelse, soegeordskategori, klasse_attr_egenskaber_id) FROM stdin;
\.


--
-- Name: klasse_attr_egenskaber_soegeord_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('klasse_attr_egenskaber_soegeord_id_seq', 1, false);


--
-- Data for Name: klasse_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY klasse_registrering (id, klasse_id, registrering) FROM stdin;
\.


--
-- Name: klasse_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('klasse_registrering_id_seq', 1, false);


--
-- Data for Name: klasse_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY klasse_relation (id, klasse_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type) FROM stdin;
\.


--
-- Name: klasse_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('klasse_relation_id_seq', 1, false);


--
-- Data for Name: klasse_tils_publiceret; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY klasse_tils_publiceret (id, virkning, publiceret, klasse_registrering_id) FROM stdin;
\.


--
-- Name: klasse_tils_publiceret_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('klasse_tils_publiceret_id_seq', 1, false);


--
-- Data for Name: klassifikation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY klassifikation (id) FROM stdin;
\.


--
-- Data for Name: klassifikation_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY klassifikation_attr_egenskaber (id, brugervendtnoegle, beskrivelse, kaldenavn, ophavsret, virkning, klassifikation_registrering_id) FROM stdin;
\.


--
-- Name: klassifikation_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('klassifikation_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: klassifikation_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY klassifikation_registrering (id, klassifikation_id, registrering) FROM stdin;
\.


--
-- Name: klassifikation_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('klassifikation_registrering_id_seq', 1, false);


--
-- Data for Name: klassifikation_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY klassifikation_relation (id, klassifikation_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type) FROM stdin;
\.


--
-- Name: klassifikation_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('klassifikation_relation_id_seq', 1, false);


--
-- Data for Name: klassifikation_tils_publiceret; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY klassifikation_tils_publiceret (id, virkning, publiceret, klassifikation_registrering_id) FROM stdin;
\.


--
-- Name: klassifikation_tils_publiceret_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('klassifikation_tils_publiceret_id_seq', 1, false);


--
-- Data for Name: loghaendelse; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY loghaendelse (id) FROM stdin;
\.


--
-- Data for Name: loghaendelse_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY loghaendelse_attr_egenskaber (id, service, klasse, tidspunkt, operation, objekttype, returkode, returtekst, note, virkning, loghaendelse_registrering_id) FROM stdin;
\.


--
-- Name: loghaendelse_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('loghaendelse_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: loghaendelse_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY loghaendelse_registrering (id, loghaendelse_id, registrering) FROM stdin;
\.


--
-- Name: loghaendelse_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('loghaendelse_registrering_id_seq', 1, false);


--
-- Data for Name: loghaendelse_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY loghaendelse_relation (id, loghaendelse_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type) FROM stdin;
\.


--
-- Name: loghaendelse_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('loghaendelse_relation_id_seq', 1, false);


--
-- Data for Name: loghaendelse_tils_gyldighed; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY loghaendelse_tils_gyldighed (id, virkning, gyldighed, loghaendelse_registrering_id) FROM stdin;
\.


--
-- Name: loghaendelse_tils_gyldighed_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('loghaendelse_tils_gyldighed_id_seq', 1, false);


--
-- Data for Name: organisation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisation (id) FROM stdin;
\.


--
-- Data for Name: organisation_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisation_attr_egenskaber (id, brugervendtnoegle, organisationsnavn, virkning, organisation_registrering_id) FROM stdin;
\.


--
-- Name: organisation_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('organisation_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: organisation_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisation_registrering (id, organisation_id, registrering) FROM stdin;
\.


--
-- Name: organisation_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('organisation_registrering_id_seq', 1, false);


--
-- Data for Name: organisation_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisation_relation (id, organisation_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type) FROM stdin;
\.


--
-- Name: organisation_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('organisation_relation_id_seq', 1, false);


--
-- Data for Name: organisation_tils_gyldighed; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisation_tils_gyldighed (id, virkning, gyldighed, organisation_registrering_id) FROM stdin;
\.


--
-- Name: organisation_tils_gyldighed_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('organisation_tils_gyldighed_id_seq', 1, false);


--
-- Data for Name: organisationenhed; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisationenhed (id) FROM stdin;
\.


--
-- Data for Name: organisationenhed_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisationenhed_attr_egenskaber (id, brugervendtnoegle, enhedsnavn, virkning, organisationenhed_registrering_id) FROM stdin;
\.


--
-- Name: organisationenhed_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('organisationenhed_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: organisationenhed_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisationenhed_registrering (id, organisationenhed_id, registrering) FROM stdin;
\.


--
-- Name: organisationenhed_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('organisationenhed_registrering_id_seq', 1, false);


--
-- Data for Name: organisationenhed_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisationenhed_relation (id, organisationenhed_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type) FROM stdin;
\.


--
-- Name: organisationenhed_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('organisationenhed_relation_id_seq', 1, false);


--
-- Data for Name: organisationenhed_tils_gyldighed; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisationenhed_tils_gyldighed (id, virkning, gyldighed, organisationenhed_registrering_id) FROM stdin;
\.


--
-- Name: organisationenhed_tils_gyldighed_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('organisationenhed_tils_gyldighed_id_seq', 1, false);


--
-- Data for Name: organisationfunktion; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisationfunktion (id) FROM stdin;
\.


--
-- Data for Name: organisationfunktion_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisationfunktion_attr_egenskaber (id, brugervendtnoegle, funktionsnavn, virkning, organisationfunktion_registrering_id) FROM stdin;
\.


--
-- Name: organisationfunktion_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('organisationfunktion_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: organisationfunktion_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisationfunktion_registrering (id, organisationfunktion_id, registrering) FROM stdin;
\.


--
-- Name: organisationfunktion_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('organisationfunktion_registrering_id_seq', 1, false);


--
-- Data for Name: organisationfunktion_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisationfunktion_relation (id, organisationfunktion_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type) FROM stdin;
\.


--
-- Name: organisationfunktion_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('organisationfunktion_relation_id_seq', 1, false);


--
-- Data for Name: organisationfunktion_tils_gyldighed; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY organisationfunktion_tils_gyldighed (id, virkning, gyldighed, organisationfunktion_registrering_id) FROM stdin;
\.


--
-- Name: organisationfunktion_tils_gyldighed_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('organisationfunktion_tils_gyldighed_id_seq', 1, false);


--
-- Data for Name: sag; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY sag (id) FROM stdin;
\.


--
-- Data for Name: sag_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY sag_attr_egenskaber (id, brugervendtnoegle, afleveret, beskrivelse, hjemmel, kassationskode, offentlighedundtaget, principiel, sagsnummer, titel, virkning, sag_registrering_id) FROM stdin;
\.


--
-- Name: sag_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('sag_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: sag_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY sag_registrering (id, sag_id, registrering) FROM stdin;
\.


--
-- Name: sag_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('sag_registrering_id_seq', 1, false);


--
-- Data for Name: sag_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY sag_relation (id, sag_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type, rel_index, rel_type_spec, journal_notat, journal_dokument_attr) FROM stdin;
\.


--
-- Name: sag_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('sag_relation_id_seq', 1, false);


--
-- Data for Name: sag_tils_fremdrift; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY sag_tils_fremdrift (id, virkning, fremdrift, sag_registrering_id) FROM stdin;
\.


--
-- Name: sag_tils_fremdrift_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('sag_tils_fremdrift_id_seq', 1, false);


--
-- Data for Name: tilstand; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY tilstand (id) FROM stdin;
\.


--
-- Data for Name: tilstand_attr_egenskaber; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY tilstand_attr_egenskaber (id, brugervendtnoegle, beskrivelse, virkning, tilstand_registrering_id) FROM stdin;
\.


--
-- Name: tilstand_attr_egenskaber_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('tilstand_attr_egenskaber_id_seq', 1, false);


--
-- Data for Name: tilstand_registrering; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY tilstand_registrering (id, tilstand_id, registrering) FROM stdin;
\.


--
-- Name: tilstand_registrering_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('tilstand_registrering_id_seq', 1, false);


--
-- Data for Name: tilstand_relation; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY tilstand_relation (id, tilstand_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type, rel_index, tilstand_vaerdi_attr) FROM stdin;
\.


--
-- Name: tilstand_relation_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('tilstand_relation_id_seq', 1, false);


--
-- Data for Name: tilstand_tils_publiceret; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY tilstand_tils_publiceret (id, virkning, publiceret, tilstand_registrering_id) FROM stdin;
\.


--
-- Name: tilstand_tils_publiceret_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('tilstand_tils_publiceret_id_seq', 1, false);


--
-- Data for Name: tilstand_tils_status; Type: TABLE DATA; Schema: actual_state; Owner: mox
--

COPY tilstand_tils_status (id, virkning, status, tilstand_registrering_id) FROM stdin;
\.


--
-- Name: tilstand_tils_status_id_seq; Type: SEQUENCE SET; Schema: actual_state; Owner: mox
--

SELECT pg_catalog.setval('tilstand_tils_status_id_seq', 1, false);


--
-- Name: aktivitet_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_attr_egenskaber
    ADD CONSTRAINT aktivitet_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (aktivitet_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: aktivitet_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_attr_egenskaber
    ADD CONSTRAINT aktivitet_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: aktivitet_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet
    ADD CONSTRAINT aktivitet_pkey PRIMARY KEY (id);


--
-- Name: aktivitet_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_registrering
    ADD CONSTRAINT aktivitet_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(aktivitet_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: aktivitet_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_registrering
    ADD CONSTRAINT aktivitet_registrering_pkey PRIMARY KEY (id);


--
-- Name: aktivitet_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_relation
    ADD CONSTRAINT aktivitet_relation_no_virkning_overlap EXCLUDE USING gist (aktivitet_registrering_id WITH =, _as_convert_aktivitet_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE (((rel_type <> 'udfoererklasse'::aktivitetrelationkode) AND (rel_type <> 'deltagerklasse'::aktivitetrelationkode) AND (rel_type <> 'objektklasse'::aktivitetrelationkode) AND (rel_type <> 'resultatklasse'::aktivitetrelationkode) AND (rel_type <> 'grundlagklasse'::aktivitetrelationkode) AND (rel_type <> 'facilitetklasse'::aktivitetrelationkode) AND (rel_type <> 'adresse'::aktivitetrelationkode) AND (rel_type <> 'geoobjekt'::aktivitetrelationkode) AND (rel_type <> 'position'::aktivitetrelationkode) AND (rel_type <> 'facilitet'::aktivitetrelationkode) AND (rel_type <> 'lokale'::aktivitetrelationkode) AND (rel_type <> 'aktivitetdokument'::aktivitetrelationkode) AND (rel_type <> 'aktivitetgrundlag'::aktivitetrelationkode) AND (rel_type <> 'aktivitetresultat'::aktivitetrelationkode) AND (rel_type <> 'udfoerer'::aktivitetrelationkode) AND (rel_type <> 'deltager'::aktivitetrelationkode)));


--
-- Name: aktivitet_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_relation
    ADD CONSTRAINT aktivitet_relation_pkey PRIMARY KEY (id);


--
-- Name: aktivitet_tils_publiceret_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_tils_publiceret
    ADD CONSTRAINT aktivitet_tils_publiceret_exclude_virkning_overlap EXCLUDE USING gist (aktivitet_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: aktivitet_tils_publiceret_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_tils_publiceret
    ADD CONSTRAINT aktivitet_tils_publiceret_pkey PRIMARY KEY (id);


--
-- Name: aktivitet_tils_status_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_tils_status
    ADD CONSTRAINT aktivitet_tils_status_exclude_virkning_overlap EXCLUDE USING gist (aktivitet_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: aktivitet_tils_status_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_tils_status
    ADD CONSTRAINT aktivitet_tils_status_pkey PRIMARY KEY (id);


--
-- Name: bruger_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger_attr_egenskaber
    ADD CONSTRAINT bruger_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (bruger_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: bruger_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger_attr_egenskaber
    ADD CONSTRAINT bruger_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: bruger_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger
    ADD CONSTRAINT bruger_pkey PRIMARY KEY (id);


--
-- Name: bruger_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger_registrering
    ADD CONSTRAINT bruger_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(bruger_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: bruger_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger_registrering
    ADD CONSTRAINT bruger_registrering_pkey PRIMARY KEY (id);


--
-- Name: bruger_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger_relation
    ADD CONSTRAINT bruger_relation_no_virkning_overlap EXCLUDE USING gist (bruger_registrering_id WITH =, _as_convert_bruger_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE (((rel_type <> 'adresser'::brugerrelationkode) AND (rel_type <> 'brugertyper'::brugerrelationkode) AND (rel_type <> 'opgaver'::brugerrelationkode) AND (rel_type <> 'tilknyttedeenheder'::brugerrelationkode) AND (rel_type <> 'tilknyttedefunktioner'::brugerrelationkode) AND (rel_type <> 'tilknyttedeinteressefaellesskaber'::brugerrelationkode) AND (rel_type <> 'tilknyttedeorganisationer'::brugerrelationkode) AND (rel_type <> 'tilknyttedepersoner'::brugerrelationkode) AND (rel_type <> 'tilknyttedeitsystemer'::brugerrelationkode)));


--
-- Name: bruger_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger_relation
    ADD CONSTRAINT bruger_relation_pkey PRIMARY KEY (id);


--
-- Name: bruger_tils_gyldighed_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger_tils_gyldighed
    ADD CONSTRAINT bruger_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (bruger_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: bruger_tils_gyldighed_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger_tils_gyldighed
    ADD CONSTRAINT bruger_tils_gyldighed_pkey PRIMARY KEY (id);


--
-- Name: dokument_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_attr_egenskaber
    ADD CONSTRAINT dokument_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (dokument_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: dokument_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_attr_egenskaber
    ADD CONSTRAINT dokument_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: dokument_del_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_del_egenskaber
    ADD CONSTRAINT dokument_del_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (del_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: dokument_del_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_del_egenskaber
    ADD CONSTRAINT dokument_del_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: dokument_del_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_del
    ADD CONSTRAINT dokument_del_pkey PRIMARY KEY (id);


--
-- Name: dokument_del_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_del_relation
    ADD CONSTRAINT dokument_del_relation_pkey PRIMARY KEY (id);


--
-- Name: dokument_del_variant_id_deltekst_key; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_del
    ADD CONSTRAINT dokument_del_variant_id_deltekst_key UNIQUE (variant_id, deltekst);


--
-- Name: dokument_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument
    ADD CONSTRAINT dokument_pkey PRIMARY KEY (id);


--
-- Name: dokument_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_registrering
    ADD CONSTRAINT dokument_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(dokument_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: dokument_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_registrering
    ADD CONSTRAINT dokument_registrering_pkey PRIMARY KEY (id);


--
-- Name: dokument_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_relation
    ADD CONSTRAINT dokument_relation_no_virkning_overlap EXCLUDE USING gist (dokument_registrering_id WITH =, _as_convert_dokument_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE (((rel_type <> 'arkiver'::dokumentrelationkode) AND (rel_type <> 'besvarelser'::dokumentrelationkode) AND (rel_type <> 'udgangspunkter'::dokumentrelationkode) AND (rel_type <> 'kommentarer'::dokumentrelationkode) AND (rel_type <> 'bilag'::dokumentrelationkode) AND (rel_type <> 'andredokumenter'::dokumentrelationkode) AND (rel_type <> 'andreklasser'::dokumentrelationkode) AND (rel_type <> 'andrebehandlere'::dokumentrelationkode) AND (rel_type <> 'parter'::dokumentrelationkode) AND (rel_type <> 'kopiparter'::dokumentrelationkode) AND (rel_type <> 'tilknyttedesager'::dokumentrelationkode)));


--
-- Name: dokument_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_relation
    ADD CONSTRAINT dokument_relation_pkey PRIMARY KEY (id);


--
-- Name: dokument_tils_fremdrift_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_tils_fremdrift
    ADD CONSTRAINT dokument_tils_fremdrift_exclude_virkning_overlap EXCLUDE USING gist (dokument_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: dokument_tils_fremdrift_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_tils_fremdrift
    ADD CONSTRAINT dokument_tils_fremdrift_pkey PRIMARY KEY (id);


--
-- Name: dokument_variant_dokument_registrering_id_varianttekst_key; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_variant
    ADD CONSTRAINT dokument_variant_dokument_registrering_id_varianttekst_key UNIQUE (dokument_registrering_id, varianttekst);


--
-- Name: dokument_variant_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_variant_egenskaber
    ADD CONSTRAINT dokument_variant_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (variant_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: dokument_variant_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_variant_egenskaber
    ADD CONSTRAINT dokument_variant_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: dokument_variant_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_variant
    ADD CONSTRAINT dokument_variant_pkey PRIMARY KEY (id);


--
-- Name: facet_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet_attr_egenskaber
    ADD CONSTRAINT facet_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (facet_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: facet_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet_attr_egenskaber
    ADD CONSTRAINT facet_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: facet_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet
    ADD CONSTRAINT facet_pkey PRIMARY KEY (id);


--
-- Name: facet_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet_registrering
    ADD CONSTRAINT facet_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(facet_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: facet_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet_registrering
    ADD CONSTRAINT facet_registrering_pkey PRIMARY KEY (id);


--
-- Name: facet_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet_relation
    ADD CONSTRAINT facet_relation_no_virkning_overlap EXCLUDE USING gist (facet_registrering_id WITH =, _as_convert_facet_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE ((rel_type <> 'redaktoerer'::facetrelationkode));


--
-- Name: facet_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet_relation
    ADD CONSTRAINT facet_relation_pkey PRIMARY KEY (id);


--
-- Name: facet_tils_publiceret_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet_tils_publiceret
    ADD CONSTRAINT facet_tils_publiceret_exclude_virkning_overlap EXCLUDE USING gist (facet_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: facet_tils_publiceret_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet_tils_publiceret
    ADD CONSTRAINT facet_tils_publiceret_pkey PRIMARY KEY (id);


--
-- Name: indsats_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_attr_egenskaber
    ADD CONSTRAINT indsats_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (indsats_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: indsats_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_attr_egenskaber
    ADD CONSTRAINT indsats_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: indsats_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats
    ADD CONSTRAINT indsats_pkey PRIMARY KEY (id);


--
-- Name: indsats_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_registrering
    ADD CONSTRAINT indsats_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(indsats_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: indsats_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_registrering
    ADD CONSTRAINT indsats_registrering_pkey PRIMARY KEY (id);


--
-- Name: indsats_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_relation
    ADD CONSTRAINT indsats_relation_no_virkning_overlap EXCLUDE USING gist (indsats_registrering_id WITH =, _as_convert_indsats_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE (((rel_type <> 'indsatskvalitet'::indsatsrelationkode) AND (rel_type <> 'indsatsaktoer'::indsatsrelationkode) AND (rel_type <> 'samtykke'::indsatsrelationkode) AND (rel_type <> 'indsatssag'::indsatsrelationkode) AND (rel_type <> 'indsatsdokument'::indsatsrelationkode)));


--
-- Name: indsats_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_relation
    ADD CONSTRAINT indsats_relation_pkey PRIMARY KEY (id);


--
-- Name: indsats_tils_fremdrift_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_tils_fremdrift
    ADD CONSTRAINT indsats_tils_fremdrift_exclude_virkning_overlap EXCLUDE USING gist (indsats_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: indsats_tils_fremdrift_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_tils_fremdrift
    ADD CONSTRAINT indsats_tils_fremdrift_pkey PRIMARY KEY (id);


--
-- Name: indsats_tils_publiceret_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_tils_publiceret
    ADD CONSTRAINT indsats_tils_publiceret_exclude_virkning_overlap EXCLUDE USING gist (indsats_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: indsats_tils_publiceret_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_tils_publiceret
    ADD CONSTRAINT indsats_tils_publiceret_pkey PRIMARY KEY (id);


--
-- Name: interessefaellesskab_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab_attr_egenskaber
    ADD CONSTRAINT interessefaellesskab_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (interessefaellesskab_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: interessefaellesskab_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab_attr_egenskaber
    ADD CONSTRAINT interessefaellesskab_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: interessefaellesskab_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab
    ADD CONSTRAINT interessefaellesskab_pkey PRIMARY KEY (id);


--
-- Name: interessefaellesskab_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab_registrering
    ADD CONSTRAINT interessefaellesskab_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(interessefaellesskab_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: interessefaellesskab_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab_registrering
    ADD CONSTRAINT interessefaellesskab_registrering_pkey PRIMARY KEY (id);


--
-- Name: interessefaellesskab_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab_relation
    ADD CONSTRAINT interessefaellesskab_relation_no_virkning_overlap EXCLUDE USING gist (interessefaellesskab_registrering_id WITH =, _as_convert_interessefaellesskab_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE (((rel_type <> 'adresser'::interessefaellesskabrelationkode) AND (rel_type <> 'opgaver'::interessefaellesskabrelationkode) AND (rel_type <> 'tilknyttedebrugere'::interessefaellesskabrelationkode) AND (rel_type <> 'tilknyttedeenheder'::interessefaellesskabrelationkode) AND (rel_type <> 'tilknyttedefunktioner'::interessefaellesskabrelationkode) AND (rel_type <> 'tilknyttedeinteressefaellesskaber'::interessefaellesskabrelationkode) AND (rel_type <> 'tilknyttedeorganisationer'::interessefaellesskabrelationkode) AND (rel_type <> 'tilknyttedepersoner'::interessefaellesskabrelationkode) AND (rel_type <> 'tilknyttedeitsystemer'::interessefaellesskabrelationkode)));


--
-- Name: interessefaellesskab_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab_relation
    ADD CONSTRAINT interessefaellesskab_relation_pkey PRIMARY KEY (id);


--
-- Name: interessefaellesskab_tils_gyldighed_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab_tils_gyldighed
    ADD CONSTRAINT interessefaellesskab_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (interessefaellesskab_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: interessefaellesskab_tils_gyldighed_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab_tils_gyldighed
    ADD CONSTRAINT interessefaellesskab_tils_gyldighed_pkey PRIMARY KEY (id);


--
-- Name: itsystem_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem_attr_egenskaber
    ADD CONSTRAINT itsystem_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (itsystem_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: itsystem_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem_attr_egenskaber
    ADD CONSTRAINT itsystem_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: itsystem_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem
    ADD CONSTRAINT itsystem_pkey PRIMARY KEY (id);


--
-- Name: itsystem_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem_registrering
    ADD CONSTRAINT itsystem_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(itsystem_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: itsystem_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem_registrering
    ADD CONSTRAINT itsystem_registrering_pkey PRIMARY KEY (id);


--
-- Name: itsystem_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem_relation
    ADD CONSTRAINT itsystem_relation_no_virkning_overlap EXCLUDE USING gist (itsystem_registrering_id WITH =, _as_convert_itsystem_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE (((rel_type <> 'tilknyttedeorganisationer'::itsystemrelationkode) AND (rel_type <> 'tilknyttedeenheder'::itsystemrelationkode) AND (rel_type <> 'tilknyttedefunktioner'::itsystemrelationkode) AND (rel_type <> 'tilknyttedebrugere'::itsystemrelationkode) AND (rel_type <> 'tilknyttedeinteressefaellesskaber'::itsystemrelationkode) AND (rel_type <> 'tilknyttedeitsystemer'::itsystemrelationkode) AND (rel_type <> 'tilknyttedepersoner'::itsystemrelationkode) AND (rel_type <> 'systemtyper'::itsystemrelationkode) AND (rel_type <> 'opgaver'::itsystemrelationkode) AND (rel_type <> 'adresser'::itsystemrelationkode)));


--
-- Name: itsystem_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem_relation
    ADD CONSTRAINT itsystem_relation_pkey PRIMARY KEY (id);


--
-- Name: itsystem_tils_gyldighed_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem_tils_gyldighed
    ADD CONSTRAINT itsystem_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (itsystem_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: itsystem_tils_gyldighed_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem_tils_gyldighed
    ADD CONSTRAINT itsystem_tils_gyldighed_pkey PRIMARY KEY (id);


--
-- Name: klasse_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_attr_egenskaber
    ADD CONSTRAINT klasse_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (klasse_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: klasse_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_attr_egenskaber
    ADD CONSTRAINT klasse_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: klasse_attr_egenskaber_soegeord_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_attr_egenskaber_soegeord
    ADD CONSTRAINT klasse_attr_egenskaber_soegeord_pkey PRIMARY KEY (id);


--
-- Name: klasse_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse
    ADD CONSTRAINT klasse_pkey PRIMARY KEY (id);


--
-- Name: klasse_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_registrering
    ADD CONSTRAINT klasse_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(klasse_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: klasse_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_registrering
    ADD CONSTRAINT klasse_registrering_pkey PRIMARY KEY (id);


--
-- Name: klasse_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_relation
    ADD CONSTRAINT klasse_relation_no_virkning_overlap EXCLUDE USING gist (klasse_registrering_id WITH =, _as_convert_klasse_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE (((rel_type <> 'redaktoerer'::klasserelationkode) AND (rel_type <> 'sideordnede'::klasserelationkode) AND (rel_type <> 'mapninger'::klasserelationkode) AND (rel_type <> 'tilfoejelser'::klasserelationkode) AND (rel_type <> 'erstatter'::klasserelationkode) AND (rel_type <> 'lovligekombinationer'::klasserelationkode)));


--
-- Name: klasse_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_relation
    ADD CONSTRAINT klasse_relation_pkey PRIMARY KEY (id);


--
-- Name: klasse_tils_publiceret_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_tils_publiceret
    ADD CONSTRAINT klasse_tils_publiceret_exclude_virkning_overlap EXCLUDE USING gist (klasse_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: klasse_tils_publiceret_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_tils_publiceret
    ADD CONSTRAINT klasse_tils_publiceret_pkey PRIMARY KEY (id);


--
-- Name: klassifikation_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation_attr_egenskaber
    ADD CONSTRAINT klassifikation_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (klassifikation_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: klassifikation_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation_attr_egenskaber
    ADD CONSTRAINT klassifikation_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: klassifikation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation
    ADD CONSTRAINT klassifikation_pkey PRIMARY KEY (id);


--
-- Name: klassifikation_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation_registrering
    ADD CONSTRAINT klassifikation_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(klassifikation_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: klassifikation_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation_registrering
    ADD CONSTRAINT klassifikation_registrering_pkey PRIMARY KEY (id);


--
-- Name: klassifikation_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation_relation
    ADD CONSTRAINT klassifikation_relation_no_virkning_overlap EXCLUDE USING gist (klassifikation_registrering_id WITH =, _as_convert_klassifikation_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: klassifikation_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation_relation
    ADD CONSTRAINT klassifikation_relation_pkey PRIMARY KEY (id);


--
-- Name: klassifikation_tils_publiceret_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation_tils_publiceret
    ADD CONSTRAINT klassifikation_tils_publiceret_exclude_virkning_overlap EXCLUDE USING gist (klassifikation_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: klassifikation_tils_publiceret_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation_tils_publiceret
    ADD CONSTRAINT klassifikation_tils_publiceret_pkey PRIMARY KEY (id);


--
-- Name: loghaendelse_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse_attr_egenskaber
    ADD CONSTRAINT loghaendelse_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (loghaendelse_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: loghaendelse_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse_attr_egenskaber
    ADD CONSTRAINT loghaendelse_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: loghaendelse_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse
    ADD CONSTRAINT loghaendelse_pkey PRIMARY KEY (id);


--
-- Name: loghaendelse_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse_registrering
    ADD CONSTRAINT loghaendelse_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(loghaendelse_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: loghaendelse_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse_registrering
    ADD CONSTRAINT loghaendelse_registrering_pkey PRIMARY KEY (id);


--
-- Name: loghaendelse_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse_relation
    ADD CONSTRAINT loghaendelse_relation_no_virkning_overlap EXCLUDE USING gist (loghaendelse_registrering_id WITH =, _as_convert_loghaendelse_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: loghaendelse_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse_relation
    ADD CONSTRAINT loghaendelse_relation_pkey PRIMARY KEY (id);


--
-- Name: loghaendelse_tils_gyldighed_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse_tils_gyldighed
    ADD CONSTRAINT loghaendelse_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (loghaendelse_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: loghaendelse_tils_gyldighed_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse_tils_gyldighed
    ADD CONSTRAINT loghaendelse_tils_gyldighed_pkey PRIMARY KEY (id);


--
-- Name: organisation_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation_attr_egenskaber
    ADD CONSTRAINT organisation_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (organisation_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: organisation_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation_attr_egenskaber
    ADD CONSTRAINT organisation_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: organisation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation
    ADD CONSTRAINT organisation_pkey PRIMARY KEY (id);


--
-- Name: organisation_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation_registrering
    ADD CONSTRAINT organisation_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(organisation_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: organisation_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation_registrering
    ADD CONSTRAINT organisation_registrering_pkey PRIMARY KEY (id);


--
-- Name: organisation_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation_relation
    ADD CONSTRAINT organisation_relation_no_virkning_overlap EXCLUDE USING gist (organisation_registrering_id WITH =, _as_convert_organisation_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE (((rel_type <> 'adresser'::organisationrelationkode) AND (rel_type <> 'ansatte'::organisationrelationkode) AND (rel_type <> 'opgaver'::organisationrelationkode) AND (rel_type <> 'tilknyttedebrugere'::organisationrelationkode) AND (rel_type <> 'tilknyttedeenheder'::organisationrelationkode) AND (rel_type <> 'tilknyttedefunktioner'::organisationrelationkode) AND (rel_type <> 'tilknyttedeinteressefaellesskaber'::organisationrelationkode) AND (rel_type <> 'tilknyttedeorganisationer'::organisationrelationkode) AND (rel_type <> 'tilknyttedepersoner'::organisationrelationkode) AND (rel_type <> 'tilknyttedeitsystemer'::organisationrelationkode)));


--
-- Name: organisation_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation_relation
    ADD CONSTRAINT organisation_relation_pkey PRIMARY KEY (id);


--
-- Name: organisation_tils_gyldighed_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation_tils_gyldighed
    ADD CONSTRAINT organisation_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (organisation_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: organisation_tils_gyldighed_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation_tils_gyldighed
    ADD CONSTRAINT organisation_tils_gyldighed_pkey PRIMARY KEY (id);


--
-- Name: organisationenhed_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed_attr_egenskaber
    ADD CONSTRAINT organisationenhed_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (organisationenhed_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: organisationenhed_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed_attr_egenskaber
    ADD CONSTRAINT organisationenhed_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: organisationenhed_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed
    ADD CONSTRAINT organisationenhed_pkey PRIMARY KEY (id);


--
-- Name: organisationenhed_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed_registrering
    ADD CONSTRAINT organisationenhed_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(organisationenhed_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: organisationenhed_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed_registrering
    ADD CONSTRAINT organisationenhed_registrering_pkey PRIMARY KEY (id);


--
-- Name: organisationenhed_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed_relation
    ADD CONSTRAINT organisationenhed_relation_no_virkning_overlap EXCLUDE USING gist (organisationenhed_registrering_id WITH =, _as_convert_organisationenhed_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE (((rel_type <> 'adresser'::organisationenhedrelationkode) AND (rel_type <> 'ansatte'::organisationenhedrelationkode) AND (rel_type <> 'opgaver'::organisationenhedrelationkode) AND (rel_type <> 'tilknyttedebrugere'::organisationenhedrelationkode) AND (rel_type <> 'tilknyttedeenheder'::organisationenhedrelationkode) AND (rel_type <> 'tilknyttedefunktioner'::organisationenhedrelationkode) AND (rel_type <> 'tilknyttedeinteressefaellesskaber'::organisationenhedrelationkode) AND (rel_type <> 'tilknyttedeorganisationer'::organisationenhedrelationkode) AND (rel_type <> 'tilknyttedepersoner'::organisationenhedrelationkode) AND (rel_type <> 'tilknyttedeitsystemer'::organisationenhedrelationkode)));


--
-- Name: organisationenhed_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed_relation
    ADD CONSTRAINT organisationenhed_relation_pkey PRIMARY KEY (id);


--
-- Name: organisationenhed_tils_gyldighed_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed_tils_gyldighed
    ADD CONSTRAINT organisationenhed_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (organisationenhed_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: organisationenhed_tils_gyldighed_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed_tils_gyldighed
    ADD CONSTRAINT organisationenhed_tils_gyldighed_pkey PRIMARY KEY (id);


--
-- Name: organisationfunktion_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion_attr_egenskaber
    ADD CONSTRAINT organisationfunktion_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (organisationfunktion_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: organisationfunktion_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion_attr_egenskaber
    ADD CONSTRAINT organisationfunktion_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: organisationfunktion_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion
    ADD CONSTRAINT organisationfunktion_pkey PRIMARY KEY (id);


--
-- Name: organisationfunktion_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion_registrering
    ADD CONSTRAINT organisationfunktion_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(organisationfunktion_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: organisationfunktion_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion_registrering
    ADD CONSTRAINT organisationfunktion_registrering_pkey PRIMARY KEY (id);


--
-- Name: organisationfunktion_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion_relation
    ADD CONSTRAINT organisationfunktion_relation_no_virkning_overlap EXCLUDE USING gist (organisationfunktion_registrering_id WITH =, _as_convert_organisationfunktion_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE (((rel_type <> 'adresser'::organisationfunktionrelationkode) AND (rel_type <> 'opgaver'::organisationfunktionrelationkode) AND (rel_type <> 'tilknyttedebrugere'::organisationfunktionrelationkode) AND (rel_type <> 'tilknyttedeenheder'::organisationfunktionrelationkode) AND (rel_type <> 'tilknyttedeorganisationer'::organisationfunktionrelationkode) AND (rel_type <> 'tilknyttedeitsystemer'::organisationfunktionrelationkode) AND (rel_type <> 'tilknyttedeinteressefaellesskaber'::organisationfunktionrelationkode) AND (rel_type <> 'tilknyttedepersoner'::organisationfunktionrelationkode)));


--
-- Name: organisationfunktion_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion_relation
    ADD CONSTRAINT organisationfunktion_relation_pkey PRIMARY KEY (id);


--
-- Name: organisationfunktion_tils_gyldighed_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion_tils_gyldighed
    ADD CONSTRAINT organisationfunktion_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (organisationfunktion_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: organisationfunktion_tils_gyldighed_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion_tils_gyldighed
    ADD CONSTRAINT organisationfunktion_tils_gyldighed_pkey PRIMARY KEY (id);


--
-- Name: sag_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag_attr_egenskaber
    ADD CONSTRAINT sag_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (sag_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: sag_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag_attr_egenskaber
    ADD CONSTRAINT sag_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: sag_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag
    ADD CONSTRAINT sag_pkey PRIMARY KEY (id);


--
-- Name: sag_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag_registrering
    ADD CONSTRAINT sag_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(sag_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: sag_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag_registrering
    ADD CONSTRAINT sag_registrering_pkey PRIMARY KEY (id);


--
-- Name: sag_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag_relation
    ADD CONSTRAINT sag_relation_no_virkning_overlap EXCLUDE USING gist (sag_registrering_id WITH =, _as_convert_sag_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE (((rel_type <> 'andetarkiv'::sagrelationkode) AND (rel_type <> 'andrebehandlere'::sagrelationkode) AND (rel_type <> 'sekundaerpart'::sagrelationkode) AND (rel_type <> 'andresager'::sagrelationkode) AND (rel_type <> 'byggeri'::sagrelationkode) AND (rel_type <> 'fredning'::sagrelationkode) AND (rel_type <> 'journalpost'::sagrelationkode)));


--
-- Name: sag_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag_relation
    ADD CONSTRAINT sag_relation_pkey PRIMARY KEY (id);


--
-- Name: sag_tils_fremdrift_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag_tils_fremdrift
    ADD CONSTRAINT sag_tils_fremdrift_exclude_virkning_overlap EXCLUDE USING gist (sag_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: sag_tils_fremdrift_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag_tils_fremdrift
    ADD CONSTRAINT sag_tils_fremdrift_pkey PRIMARY KEY (id);


--
-- Name: tilstand_attr_egenskaber_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_attr_egenskaber
    ADD CONSTRAINT tilstand_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (tilstand_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: tilstand_attr_egenskaber_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_attr_egenskaber
    ADD CONSTRAINT tilstand_attr_egenskaber_pkey PRIMARY KEY (id);


--
-- Name: tilstand_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand
    ADD CONSTRAINT tilstand_pkey PRIMARY KEY (id);


--
-- Name: tilstand_registrering__uuid_to_text_timeperiod_excl; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_registrering
    ADD CONSTRAINT tilstand_registrering__uuid_to_text_timeperiod_excl EXCLUDE USING gist (_uuid_to_text(tilstand_id) WITH =, _composite_type_to_time_range(registrering) WITH &&);


--
-- Name: tilstand_registrering_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_registrering
    ADD CONSTRAINT tilstand_registrering_pkey PRIMARY KEY (id);


--
-- Name: tilstand_relation_no_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_relation
    ADD CONSTRAINT tilstand_relation_no_virkning_overlap EXCLUDE USING gist (tilstand_registrering_id WITH =, _as_convert_tilstand_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) WHERE (((rel_type <> 'tilstandsvaerdi'::tilstandrelationkode) AND (rel_type <> 'begrundelse'::tilstandrelationkode) AND (rel_type <> 'tilstandskvalitet'::tilstandrelationkode) AND (rel_type <> 'tilstandsvurdering'::tilstandrelationkode) AND (rel_type <> 'tilstandsaktoer'::tilstandrelationkode) AND (rel_type <> 'tilstandsudstyr'::tilstandrelationkode) AND (rel_type <> 'samtykke'::tilstandrelationkode) AND (rel_type <> 'tilstandsdokument'::tilstandrelationkode)));


--
-- Name: tilstand_relation_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_relation
    ADD CONSTRAINT tilstand_relation_pkey PRIMARY KEY (id);


--
-- Name: tilstand_tils_publiceret_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_tils_publiceret
    ADD CONSTRAINT tilstand_tils_publiceret_exclude_virkning_overlap EXCLUDE USING gist (tilstand_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: tilstand_tils_publiceret_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_tils_publiceret
    ADD CONSTRAINT tilstand_tils_publiceret_pkey PRIMARY KEY (id);


--
-- Name: tilstand_tils_status_exclude_virkning_overlap; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_tils_status
    ADD CONSTRAINT tilstand_tils_status_exclude_virkning_overlap EXCLUDE USING gist (tilstand_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&);


--
-- Name: tilstand_tils_status_pkey; Type: CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_tils_status
    ADD CONSTRAINT tilstand_tils_status_pkey PRIMARY KEY (id);


--
-- Name: aktivitet_attr_egenskaber_idx_aktivitetnavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_idx_aktivitetnavn ON aktivitet_attr_egenskaber USING btree (aktivitetnavn);


--
-- Name: aktivitet_attr_egenskaber_idx_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_idx_beskrivelse ON aktivitet_attr_egenskaber USING btree (beskrivelse);


--
-- Name: aktivitet_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_idx_brugervendtnoegle ON aktivitet_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: aktivitet_attr_egenskaber_idx_formaal; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_idx_formaal ON aktivitet_attr_egenskaber USING btree (formaal);


--
-- Name: aktivitet_attr_egenskaber_idx_sluttidspunkt; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_idx_sluttidspunkt ON aktivitet_attr_egenskaber USING btree (sluttidspunkt);


--
-- Name: aktivitet_attr_egenskaber_idx_starttidspunkt; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_idx_starttidspunkt ON aktivitet_attr_egenskaber USING btree (starttidspunkt);


--
-- Name: aktivitet_attr_egenskaber_idx_tidsforbrug; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_idx_tidsforbrug ON aktivitet_attr_egenskaber USING btree (tidsforbrug);


--
-- Name: aktivitet_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_idx_virkning_aktoerref ON aktivitet_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: aktivitet_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_idx_virkning_aktoertypekode ON aktivitet_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: aktivitet_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_idx_virkning_notetekst ON aktivitet_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: aktivitet_attr_egenskaber_pat_aktivitetnavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_pat_aktivitetnavn ON aktivitet_attr_egenskaber USING gin (aktivitetnavn public.gin_trgm_ops);


--
-- Name: aktivitet_attr_egenskaber_pat_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_pat_beskrivelse ON aktivitet_attr_egenskaber USING gin (beskrivelse public.gin_trgm_ops);


--
-- Name: aktivitet_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_pat_brugervendtnoegle ON aktivitet_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: aktivitet_attr_egenskaber_pat_formaal; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_pat_formaal ON aktivitet_attr_egenskaber USING gin (formaal public.gin_trgm_ops);


--
-- Name: aktivitet_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_attr_egenskaber_pat_virkning_notetekst ON aktivitet_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: aktivitet_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_registrering_idx_brugerref ON aktivitet_registrering USING btree (((registrering).brugerref));


--
-- Name: aktivitet_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_registrering_idx_livscykluskode ON aktivitet_registrering USING btree (((registrering).livscykluskode));


--
-- Name: aktivitet_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_registrering_idx_note ON aktivitet_registrering USING btree (((registrering).note));


--
-- Name: aktivitet_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_registrering_pat_note ON aktivitet_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: aktivitet_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_relation_idx_rel_maal_obj_urn ON aktivitet_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: aktivitet_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_relation_idx_rel_maal_obj_uuid ON aktivitet_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: aktivitet_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_relation_idx_rel_maal_urn ON aktivitet_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: aktivitet_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_relation_idx_rel_maal_urn_isolated ON aktivitet_relation USING btree (rel_maal_urn);


--
-- Name: aktivitet_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_relation_idx_rel_maal_uuid ON aktivitet_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: aktivitet_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_relation_idx_rel_maal_uuid_isolated ON aktivitet_relation USING btree (rel_maal_uuid);


--
-- Name: aktivitet_relation_idx_repr_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_relation_idx_repr_urn ON aktivitet_relation USING btree (((aktoer_attr).repraesentation_urn));


--
-- Name: aktivitet_relation_idx_repr_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_relation_idx_repr_uuid ON aktivitet_relation USING btree (((aktoer_attr).repraesentation_uuid));


--
-- Name: aktivitet_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_relation_idx_virkning_aktoerref ON aktivitet_relation USING btree (((virkning).aktoerref));


--
-- Name: aktivitet_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_relation_idx_virkning_aktoertypekode ON aktivitet_relation USING btree (((virkning).aktoertypekode));


--
-- Name: aktivitet_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_relation_idx_virkning_notetekst ON aktivitet_relation USING btree (((virkning).notetekst));


--
-- Name: aktivitet_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_relation_pat_virkning_notetekst ON aktivitet_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: aktivitet_relation_unique_index_within_type; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE UNIQUE INDEX aktivitet_relation_unique_index_within_type ON aktivitet_relation USING btree (aktivitet_registrering_id, rel_type, rel_index) WHERE (rel_type = ANY (ARRAY['udfoererklasse'::aktivitetrelationkode, 'deltagerklasse'::aktivitetrelationkode, 'objektklasse'::aktivitetrelationkode, 'resultatklasse'::aktivitetrelationkode, 'grundlagklasse'::aktivitetrelationkode, 'facilitetklasse'::aktivitetrelationkode, 'adresse'::aktivitetrelationkode, 'geoobjekt'::aktivitetrelationkode, 'position'::aktivitetrelationkode, 'facilitet'::aktivitetrelationkode, 'lokale'::aktivitetrelationkode, 'aktivitetdokument'::aktivitetrelationkode, 'aktivitetgrundlag'::aktivitetrelationkode, 'aktivitetresultat'::aktivitetrelationkode, 'udfoerer'::aktivitetrelationkode, 'deltager'::aktivitetrelationkode]));


--
-- Name: aktivitet_tils_publiceret_idx_publiceret; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_tils_publiceret_idx_publiceret ON aktivitet_tils_publiceret USING btree (publiceret);


--
-- Name: aktivitet_tils_publiceret_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_tils_publiceret_idx_virkning_aktoerref ON aktivitet_tils_publiceret USING btree (((virkning).aktoerref));


--
-- Name: aktivitet_tils_publiceret_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_tils_publiceret_idx_virkning_aktoertypekode ON aktivitet_tils_publiceret USING btree (((virkning).aktoertypekode));


--
-- Name: aktivitet_tils_publiceret_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_tils_publiceret_idx_virkning_notetekst ON aktivitet_tils_publiceret USING btree (((virkning).notetekst));


--
-- Name: aktivitet_tils_publiceret_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_tils_publiceret_pat_virkning_notetekst ON aktivitet_tils_publiceret USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: aktivitet_tils_status_idx_status; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_tils_status_idx_status ON aktivitet_tils_status USING btree (status);


--
-- Name: aktivitet_tils_status_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_tils_status_idx_virkning_aktoerref ON aktivitet_tils_status USING btree (((virkning).aktoerref));


--
-- Name: aktivitet_tils_status_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_tils_status_idx_virkning_aktoertypekode ON aktivitet_tils_status USING btree (((virkning).aktoertypekode));


--
-- Name: aktivitet_tils_status_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_tils_status_idx_virkning_notetekst ON aktivitet_tils_status USING btree (((virkning).notetekst));


--
-- Name: aktivitet_tils_status_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX aktivitet_tils_status_pat_virkning_notetekst ON aktivitet_tils_status USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: bruger_attr_egenskaber_idx_brugernavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_attr_egenskaber_idx_brugernavn ON bruger_attr_egenskaber USING btree (brugernavn);


--
-- Name: bruger_attr_egenskaber_idx_brugertype; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_attr_egenskaber_idx_brugertype ON bruger_attr_egenskaber USING btree (brugertype);


--
-- Name: bruger_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_attr_egenskaber_idx_brugervendtnoegle ON bruger_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: bruger_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_attr_egenskaber_idx_virkning_aktoerref ON bruger_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: bruger_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_attr_egenskaber_idx_virkning_aktoertypekode ON bruger_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: bruger_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_attr_egenskaber_idx_virkning_notetekst ON bruger_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: bruger_attr_egenskaber_pat_brugernavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_attr_egenskaber_pat_brugernavn ON bruger_attr_egenskaber USING gin (brugernavn public.gin_trgm_ops);


--
-- Name: bruger_attr_egenskaber_pat_brugertype; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_attr_egenskaber_pat_brugertype ON bruger_attr_egenskaber USING gin (brugertype public.gin_trgm_ops);


--
-- Name: bruger_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_attr_egenskaber_pat_brugervendtnoegle ON bruger_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: bruger_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_attr_egenskaber_pat_virkning_notetekst ON bruger_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: bruger_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_registrering_idx_brugerref ON bruger_registrering USING btree (((registrering).brugerref));


--
-- Name: bruger_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_registrering_idx_livscykluskode ON bruger_registrering USING btree (((registrering).livscykluskode));


--
-- Name: bruger_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_registrering_idx_note ON bruger_registrering USING btree (((registrering).note));


--
-- Name: bruger_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_registrering_pat_note ON bruger_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: bruger_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_relation_idx_rel_maal_obj_urn ON bruger_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: bruger_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_relation_idx_rel_maal_obj_uuid ON bruger_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: bruger_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_relation_idx_rel_maal_urn ON bruger_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: bruger_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_relation_idx_rel_maal_urn_isolated ON bruger_relation USING btree (rel_maal_urn);


--
-- Name: bruger_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_relation_idx_rel_maal_uuid ON bruger_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: bruger_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_relation_idx_rel_maal_uuid_isolated ON bruger_relation USING btree (rel_maal_uuid);


--
-- Name: bruger_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_relation_idx_virkning_aktoerref ON bruger_relation USING btree (((virkning).aktoerref));


--
-- Name: bruger_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_relation_idx_virkning_aktoertypekode ON bruger_relation USING btree (((virkning).aktoertypekode));


--
-- Name: bruger_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_relation_idx_virkning_notetekst ON bruger_relation USING btree (((virkning).notetekst));


--
-- Name: bruger_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_relation_pat_virkning_notetekst ON bruger_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: bruger_tils_gyldighed_idx_gyldighed; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_tils_gyldighed_idx_gyldighed ON bruger_tils_gyldighed USING btree (gyldighed);


--
-- Name: bruger_tils_gyldighed_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_tils_gyldighed_idx_virkning_aktoerref ON bruger_tils_gyldighed USING btree (((virkning).aktoerref));


--
-- Name: bruger_tils_gyldighed_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_tils_gyldighed_idx_virkning_aktoertypekode ON bruger_tils_gyldighed USING btree (((virkning).aktoertypekode));


--
-- Name: bruger_tils_gyldighed_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_tils_gyldighed_idx_virkning_notetekst ON bruger_tils_gyldighed USING btree (((virkning).notetekst));


--
-- Name: bruger_tils_gyldighed_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX bruger_tils_gyldighed_pat_virkning_notetekst ON bruger_tils_gyldighed USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: dokument_attr_egenskaber_idx_alternativtitel_offentlighedundtag; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_alternativtitel_offentlighedundtag ON dokument_attr_egenskaber USING btree (((offentlighedundtaget).alternativtitel));


--
-- Name: dokument_attr_egenskaber_idx_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_beskrivelse ON dokument_attr_egenskaber USING btree (beskrivelse);


--
-- Name: dokument_attr_egenskaber_idx_brevdato; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_brevdato ON dokument_attr_egenskaber USING btree (brevdato);


--
-- Name: dokument_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_brugervendtnoegle ON dokument_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: dokument_attr_egenskaber_idx_dokumenttype; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_dokumenttype ON dokument_attr_egenskaber USING btree (dokumenttype);


--
-- Name: dokument_attr_egenskaber_idx_hjemmel_offentlighedundtaget; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_hjemmel_offentlighedundtaget ON dokument_attr_egenskaber USING btree (((offentlighedundtaget).hjemmel));


--
-- Name: dokument_attr_egenskaber_idx_kassationskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_kassationskode ON dokument_attr_egenskaber USING btree (kassationskode);


--
-- Name: dokument_attr_egenskaber_idx_major; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_major ON dokument_attr_egenskaber USING btree (major);


--
-- Name: dokument_attr_egenskaber_idx_minor; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_minor ON dokument_attr_egenskaber USING btree (minor);


--
-- Name: dokument_attr_egenskaber_idx_titel; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_titel ON dokument_attr_egenskaber USING btree (titel);


--
-- Name: dokument_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_virkning_aktoerref ON dokument_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: dokument_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_virkning_aktoertypekode ON dokument_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: dokument_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_idx_virkning_notetekst ON dokument_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: dokument_attr_egenskaber_pat_alternativtitel_offentlighedundtag; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_pat_alternativtitel_offentlighedundtag ON dokument_attr_egenskaber USING gin (((offentlighedundtaget).alternativtitel) public.gin_trgm_ops);


--
-- Name: dokument_attr_egenskaber_pat_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_pat_beskrivelse ON dokument_attr_egenskaber USING gin (beskrivelse public.gin_trgm_ops);


--
-- Name: dokument_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_pat_brugervendtnoegle ON dokument_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: dokument_attr_egenskaber_pat_dokumenttype; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_pat_dokumenttype ON dokument_attr_egenskaber USING gin (dokumenttype public.gin_trgm_ops);


--
-- Name: dokument_attr_egenskaber_pat_hjemmel_offentlighedundtaget; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_pat_hjemmel_offentlighedundtaget ON dokument_attr_egenskaber USING gin (((offentlighedundtaget).hjemmel) public.gin_trgm_ops);


--
-- Name: dokument_attr_egenskaber_pat_kassationskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_pat_kassationskode ON dokument_attr_egenskaber USING gin (kassationskode public.gin_trgm_ops);


--
-- Name: dokument_attr_egenskaber_pat_titel; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_pat_titel ON dokument_attr_egenskaber USING gin (titel public.gin_trgm_ops);


--
-- Name: dokument_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_attr_egenskaber_pat_virkning_notetekst ON dokument_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: dokument_del_egenskaber_idx_indeks; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_egenskaber_idx_indeks ON dokument_del_egenskaber USING btree (indeks);


--
-- Name: dokument_del_egenskaber_idx_indhold; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_egenskaber_idx_indhold ON dokument_del_egenskaber USING btree (indhold);


--
-- Name: dokument_del_egenskaber_idx_lokation; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_egenskaber_idx_lokation ON dokument_del_egenskaber USING btree (lokation);


--
-- Name: dokument_del_egenskaber_idx_mimetype; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_egenskaber_idx_mimetype ON dokument_del_egenskaber USING btree (mimetype);


--
-- Name: dokument_del_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_egenskaber_idx_virkning_aktoerref ON dokument_del_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: dokument_del_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_egenskaber_idx_virkning_aktoertypekode ON dokument_del_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: dokument_del_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_egenskaber_idx_virkning_notetekst ON dokument_del_egenskaber USING btree (((virkning).notetekst));


--
-- Name: dokument_del_egenskaber_pat_indhold; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_egenskaber_pat_indhold ON dokument_del_egenskaber USING gin (indhold public.gin_trgm_ops);


--
-- Name: dokument_del_egenskaber_pat_lokation; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_egenskaber_pat_lokation ON dokument_del_egenskaber USING gin (lokation public.gin_trgm_ops);


--
-- Name: dokument_del_egenskaber_pat_mimetype; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_egenskaber_pat_mimetype ON dokument_del_egenskaber USING gin (mimetype public.gin_trgm_ops);


--
-- Name: dokument_del_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_egenskaber_pat_virkning_notetekst ON dokument_del_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: dokument_del_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_relation_idx_rel_maal_obj_urn ON dokument_del_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: dokument_del_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_relation_idx_rel_maal_obj_uuid ON dokument_del_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: dokument_del_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_relation_idx_rel_maal_urn ON dokument_del_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: dokument_del_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_relation_idx_rel_maal_urn_isolated ON dokument_del_relation USING btree (rel_maal_urn);


--
-- Name: dokument_del_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_relation_idx_rel_maal_uuid ON dokument_del_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: dokument_del_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_relation_idx_rel_maal_uuid_isolated ON dokument_del_relation USING btree (rel_maal_uuid);


--
-- Name: dokument_del_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_relation_idx_virkning_aktoerref ON dokument_del_relation USING btree (((virkning).aktoerref));


--
-- Name: dokument_del_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_relation_idx_virkning_aktoertypekode ON dokument_del_relation USING btree (((virkning).aktoertypekode));


--
-- Name: dokument_del_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_relation_idx_virkning_notetekst ON dokument_del_relation USING btree (((virkning).notetekst));


--
-- Name: dokument_del_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_del_relation_pat_virkning_notetekst ON dokument_del_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: dokument_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_registrering_idx_brugerref ON dokument_registrering USING btree (((registrering).brugerref));


--
-- Name: dokument_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_registrering_idx_livscykluskode ON dokument_registrering USING btree (((registrering).livscykluskode));


--
-- Name: dokument_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_registrering_idx_note ON dokument_registrering USING btree (((registrering).note));


--
-- Name: dokument_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_registrering_pat_note ON dokument_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: dokument_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_relation_idx_rel_maal_obj_urn ON dokument_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: dokument_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_relation_idx_rel_maal_obj_uuid ON dokument_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: dokument_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_relation_idx_rel_maal_urn ON dokument_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: dokument_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_relation_idx_rel_maal_urn_isolated ON dokument_relation USING btree (rel_maal_urn);


--
-- Name: dokument_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_relation_idx_rel_maal_uuid ON dokument_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: dokument_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_relation_idx_rel_maal_uuid_isolated ON dokument_relation USING btree (rel_maal_uuid);


--
-- Name: dokument_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_relation_idx_virkning_aktoerref ON dokument_relation USING btree (((virkning).aktoerref));


--
-- Name: dokument_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_relation_idx_virkning_aktoertypekode ON dokument_relation USING btree (((virkning).aktoertypekode));


--
-- Name: dokument_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_relation_idx_virkning_notetekst ON dokument_relation USING btree (((virkning).notetekst));


--
-- Name: dokument_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_relation_pat_virkning_notetekst ON dokument_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: dokument_tils_fremdrift_idx_fremdrift; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_tils_fremdrift_idx_fremdrift ON dokument_tils_fremdrift USING btree (fremdrift);


--
-- Name: dokument_tils_fremdrift_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_tils_fremdrift_idx_virkning_aktoerref ON dokument_tils_fremdrift USING btree (((virkning).aktoerref));


--
-- Name: dokument_tils_fremdrift_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_tils_fremdrift_idx_virkning_aktoertypekode ON dokument_tils_fremdrift USING btree (((virkning).aktoertypekode));


--
-- Name: dokument_tils_fremdrift_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_tils_fremdrift_idx_virkning_notetekst ON dokument_tils_fremdrift USING btree (((virkning).notetekst));


--
-- Name: dokument_tils_fremdrift_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_tils_fremdrift_pat_virkning_notetekst ON dokument_tils_fremdrift USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: dokument_variant_egenskaber_idx_arkivering; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_variant_egenskaber_idx_arkivering ON dokument_variant_egenskaber USING btree (arkivering);


--
-- Name: dokument_variant_egenskaber_idx_delvisscannet; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_variant_egenskaber_idx_delvisscannet ON dokument_variant_egenskaber USING btree (delvisscannet);


--
-- Name: dokument_variant_egenskaber_idx_offentliggoerelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_variant_egenskaber_idx_offentliggoerelse ON dokument_variant_egenskaber USING btree (offentliggoerelse);


--
-- Name: dokument_variant_egenskaber_idx_produktion; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_variant_egenskaber_idx_produktion ON dokument_variant_egenskaber USING btree (produktion);


--
-- Name: dokument_variant_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_variant_egenskaber_idx_virkning_aktoerref ON dokument_variant_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: dokument_variant_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_variant_egenskaber_idx_virkning_aktoertypekode ON dokument_variant_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: dokument_variant_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_variant_egenskaber_idx_virkning_notetekst ON dokument_variant_egenskaber USING btree (((virkning).notetekst));


--
-- Name: dokument_variant_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX dokument_variant_egenskaber_pat_virkning_notetekst ON dokument_variant_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: facet_attr_egenskaber_idx_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_idx_beskrivelse ON facet_attr_egenskaber USING btree (beskrivelse);


--
-- Name: facet_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_idx_brugervendtnoegle ON facet_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: facet_attr_egenskaber_idx_opbygning; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_idx_opbygning ON facet_attr_egenskaber USING btree (opbygning);


--
-- Name: facet_attr_egenskaber_idx_ophavsret; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_idx_ophavsret ON facet_attr_egenskaber USING btree (ophavsret);


--
-- Name: facet_attr_egenskaber_idx_plan; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_idx_plan ON facet_attr_egenskaber USING btree (plan);


--
-- Name: facet_attr_egenskaber_idx_retskilde; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_idx_retskilde ON facet_attr_egenskaber USING btree (retskilde);


--
-- Name: facet_attr_egenskaber_idx_supplement; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_idx_supplement ON facet_attr_egenskaber USING btree (supplement);


--
-- Name: facet_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_idx_virkning_aktoerref ON facet_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: facet_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_idx_virkning_aktoertypekode ON facet_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: facet_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_idx_virkning_notetekst ON facet_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: facet_attr_egenskaber_pat_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_pat_beskrivelse ON facet_attr_egenskaber USING gin (beskrivelse public.gin_trgm_ops);


--
-- Name: facet_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_pat_brugervendtnoegle ON facet_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: facet_attr_egenskaber_pat_opbygning; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_pat_opbygning ON facet_attr_egenskaber USING gin (opbygning public.gin_trgm_ops);


--
-- Name: facet_attr_egenskaber_pat_ophavsret; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_pat_ophavsret ON facet_attr_egenskaber USING gin (ophavsret public.gin_trgm_ops);


--
-- Name: facet_attr_egenskaber_pat_plan; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_pat_plan ON facet_attr_egenskaber USING gin (plan public.gin_trgm_ops);


--
-- Name: facet_attr_egenskaber_pat_retskilde; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_pat_retskilde ON facet_attr_egenskaber USING gin (retskilde public.gin_trgm_ops);


--
-- Name: facet_attr_egenskaber_pat_supplement; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_pat_supplement ON facet_attr_egenskaber USING gin (supplement public.gin_trgm_ops);


--
-- Name: facet_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_attr_egenskaber_pat_virkning_notetekst ON facet_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: facet_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_registrering_idx_brugerref ON facet_registrering USING btree (((registrering).brugerref));


--
-- Name: facet_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_registrering_idx_livscykluskode ON facet_registrering USING btree (((registrering).livscykluskode));


--
-- Name: facet_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_registrering_idx_note ON facet_registrering USING btree (((registrering).note));


--
-- Name: facet_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_registrering_pat_note ON facet_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: facet_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_relation_idx_rel_maal_obj_urn ON facet_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: facet_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_relation_idx_rel_maal_obj_uuid ON facet_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: facet_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_relation_idx_rel_maal_urn ON facet_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: facet_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_relation_idx_rel_maal_urn_isolated ON facet_relation USING btree (rel_maal_urn);


--
-- Name: facet_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_relation_idx_rel_maal_uuid ON facet_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: facet_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_relation_idx_rel_maal_uuid_isolated ON facet_relation USING btree (rel_maal_uuid);


--
-- Name: facet_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_relation_idx_virkning_aktoerref ON facet_relation USING btree (((virkning).aktoerref));


--
-- Name: facet_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_relation_idx_virkning_aktoertypekode ON facet_relation USING btree (((virkning).aktoertypekode));


--
-- Name: facet_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_relation_idx_virkning_notetekst ON facet_relation USING btree (((virkning).notetekst));


--
-- Name: facet_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_relation_pat_virkning_notetekst ON facet_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: facet_tils_publiceret_idx_publiceret; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_tils_publiceret_idx_publiceret ON facet_tils_publiceret USING btree (publiceret);


--
-- Name: facet_tils_publiceret_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_tils_publiceret_idx_virkning_aktoerref ON facet_tils_publiceret USING btree (((virkning).aktoerref));


--
-- Name: facet_tils_publiceret_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_tils_publiceret_idx_virkning_aktoertypekode ON facet_tils_publiceret USING btree (((virkning).aktoertypekode));


--
-- Name: facet_tils_publiceret_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_tils_publiceret_idx_virkning_notetekst ON facet_tils_publiceret USING btree (((virkning).notetekst));


--
-- Name: facet_tils_publiceret_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX facet_tils_publiceret_pat_virkning_notetekst ON facet_tils_publiceret USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: indsats_attr_egenskaber_idx_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_attr_egenskaber_idx_beskrivelse ON indsats_attr_egenskaber USING btree (beskrivelse);


--
-- Name: indsats_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_attr_egenskaber_idx_brugervendtnoegle ON indsats_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: indsats_attr_egenskaber_idx_sluttidspunkt; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_attr_egenskaber_idx_sluttidspunkt ON indsats_attr_egenskaber USING btree (sluttidspunkt);


--
-- Name: indsats_attr_egenskaber_idx_starttidspunkt; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_attr_egenskaber_idx_starttidspunkt ON indsats_attr_egenskaber USING btree (starttidspunkt);


--
-- Name: indsats_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_attr_egenskaber_idx_virkning_aktoerref ON indsats_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: indsats_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_attr_egenskaber_idx_virkning_aktoertypekode ON indsats_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: indsats_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_attr_egenskaber_idx_virkning_notetekst ON indsats_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: indsats_attr_egenskaber_pat_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_attr_egenskaber_pat_beskrivelse ON indsats_attr_egenskaber USING gin (beskrivelse public.gin_trgm_ops);


--
-- Name: indsats_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_attr_egenskaber_pat_brugervendtnoegle ON indsats_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: indsats_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_attr_egenskaber_pat_virkning_notetekst ON indsats_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: indsats_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_registrering_idx_brugerref ON indsats_registrering USING btree (((registrering).brugerref));


--
-- Name: indsats_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_registrering_idx_livscykluskode ON indsats_registrering USING btree (((registrering).livscykluskode));


--
-- Name: indsats_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_registrering_idx_note ON indsats_registrering USING btree (((registrering).note));


--
-- Name: indsats_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_registrering_pat_note ON indsats_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: indsats_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_relation_idx_rel_maal_obj_urn ON indsats_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: indsats_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_relation_idx_rel_maal_obj_uuid ON indsats_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: indsats_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_relation_idx_rel_maal_urn ON indsats_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: indsats_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_relation_idx_rel_maal_urn_isolated ON indsats_relation USING btree (rel_maal_urn);


--
-- Name: indsats_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_relation_idx_rel_maal_uuid ON indsats_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: indsats_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_relation_idx_rel_maal_uuid_isolated ON indsats_relation USING btree (rel_maal_uuid);


--
-- Name: indsats_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_relation_idx_virkning_aktoerref ON indsats_relation USING btree (((virkning).aktoerref));


--
-- Name: indsats_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_relation_idx_virkning_aktoertypekode ON indsats_relation USING btree (((virkning).aktoertypekode));


--
-- Name: indsats_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_relation_idx_virkning_notetekst ON indsats_relation USING btree (((virkning).notetekst));


--
-- Name: indsats_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_relation_pat_virkning_notetekst ON indsats_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: indsats_relation_unique_index_within_type; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE UNIQUE INDEX indsats_relation_unique_index_within_type ON indsats_relation USING btree (indsats_registrering_id, rel_type, rel_index) WHERE (rel_type = ANY (ARRAY['indsatskvalitet'::indsatsrelationkode, 'indsatsaktoer'::indsatsrelationkode, 'samtykke'::indsatsrelationkode, 'indsatssag'::indsatsrelationkode, 'indsatsdokument'::indsatsrelationkode]));


--
-- Name: indsats_tils_fremdrift_idx_fremdrift; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_tils_fremdrift_idx_fremdrift ON indsats_tils_fremdrift USING btree (fremdrift);


--
-- Name: indsats_tils_fremdrift_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_tils_fremdrift_idx_virkning_aktoerref ON indsats_tils_fremdrift USING btree (((virkning).aktoerref));


--
-- Name: indsats_tils_fremdrift_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_tils_fremdrift_idx_virkning_aktoertypekode ON indsats_tils_fremdrift USING btree (((virkning).aktoertypekode));


--
-- Name: indsats_tils_fremdrift_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_tils_fremdrift_idx_virkning_notetekst ON indsats_tils_fremdrift USING btree (((virkning).notetekst));


--
-- Name: indsats_tils_fremdrift_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_tils_fremdrift_pat_virkning_notetekst ON indsats_tils_fremdrift USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: indsats_tils_publiceret_idx_publiceret; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_tils_publiceret_idx_publiceret ON indsats_tils_publiceret USING btree (publiceret);


--
-- Name: indsats_tils_publiceret_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_tils_publiceret_idx_virkning_aktoerref ON indsats_tils_publiceret USING btree (((virkning).aktoerref));


--
-- Name: indsats_tils_publiceret_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_tils_publiceret_idx_virkning_aktoertypekode ON indsats_tils_publiceret USING btree (((virkning).aktoertypekode));


--
-- Name: indsats_tils_publiceret_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_tils_publiceret_idx_virkning_notetekst ON indsats_tils_publiceret USING btree (((virkning).notetekst));


--
-- Name: indsats_tils_publiceret_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX indsats_tils_publiceret_pat_virkning_notetekst ON indsats_tils_publiceret USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: interessefaellesskab_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_attr_egenskaber_idx_brugervendtnoegle ON interessefaellesskab_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: interessefaellesskab_attr_egenskaber_idx_interessefaellesskabsn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_attr_egenskaber_idx_interessefaellesskabsn ON interessefaellesskab_attr_egenskaber USING btree (interessefaellesskabsnavn);


--
-- Name: interessefaellesskab_attr_egenskaber_idx_interessefaellesskabst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_attr_egenskaber_idx_interessefaellesskabst ON interessefaellesskab_attr_egenskaber USING btree (interessefaellesskabstype);


--
-- Name: interessefaellesskab_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_attr_egenskaber_idx_virkning_aktoerref ON interessefaellesskab_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: interessefaellesskab_attr_egenskaber_idx_virkning_aktoertypekod; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_attr_egenskaber_idx_virkning_aktoertypekod ON interessefaellesskab_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: interessefaellesskab_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_attr_egenskaber_idx_virkning_notetekst ON interessefaellesskab_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: interessefaellesskab_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_attr_egenskaber_pat_brugervendtnoegle ON interessefaellesskab_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: interessefaellesskab_attr_egenskaber_pat_interessefaellesskabsn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_attr_egenskaber_pat_interessefaellesskabsn ON interessefaellesskab_attr_egenskaber USING gin (interessefaellesskabsnavn public.gin_trgm_ops);


--
-- Name: interessefaellesskab_attr_egenskaber_pat_interessefaellesskabst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_attr_egenskaber_pat_interessefaellesskabst ON interessefaellesskab_attr_egenskaber USING gin (interessefaellesskabstype public.gin_trgm_ops);


--
-- Name: interessefaellesskab_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_attr_egenskaber_pat_virkning_notetekst ON interessefaellesskab_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: interessefaellesskab_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_registrering_idx_brugerref ON interessefaellesskab_registrering USING btree (((registrering).brugerref));


--
-- Name: interessefaellesskab_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_registrering_idx_livscykluskode ON interessefaellesskab_registrering USING btree (((registrering).livscykluskode));


--
-- Name: interessefaellesskab_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_registrering_idx_note ON interessefaellesskab_registrering USING btree (((registrering).note));


--
-- Name: interessefaellesskab_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_registrering_pat_note ON interessefaellesskab_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: interessefaellesskab_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_relation_idx_rel_maal_obj_urn ON interessefaellesskab_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: interessefaellesskab_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_relation_idx_rel_maal_obj_uuid ON interessefaellesskab_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: interessefaellesskab_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_relation_idx_rel_maal_urn ON interessefaellesskab_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: interessefaellesskab_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_relation_idx_rel_maal_urn_isolated ON interessefaellesskab_relation USING btree (rel_maal_urn);


--
-- Name: interessefaellesskab_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_relation_idx_rel_maal_uuid ON interessefaellesskab_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: interessefaellesskab_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_relation_idx_rel_maal_uuid_isolated ON interessefaellesskab_relation USING btree (rel_maal_uuid);


--
-- Name: interessefaellesskab_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_relation_idx_virkning_aktoerref ON interessefaellesskab_relation USING btree (((virkning).aktoerref));


--
-- Name: interessefaellesskab_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_relation_idx_virkning_aktoertypekode ON interessefaellesskab_relation USING btree (((virkning).aktoertypekode));


--
-- Name: interessefaellesskab_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_relation_idx_virkning_notetekst ON interessefaellesskab_relation USING btree (((virkning).notetekst));


--
-- Name: interessefaellesskab_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_relation_pat_virkning_notetekst ON interessefaellesskab_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: interessefaellesskab_tils_gyldighed_idx_gyldighed; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_tils_gyldighed_idx_gyldighed ON interessefaellesskab_tils_gyldighed USING btree (gyldighed);


--
-- Name: interessefaellesskab_tils_gyldighed_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_tils_gyldighed_idx_virkning_aktoerref ON interessefaellesskab_tils_gyldighed USING btree (((virkning).aktoerref));


--
-- Name: interessefaellesskab_tils_gyldighed_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_tils_gyldighed_idx_virkning_aktoertypekode ON interessefaellesskab_tils_gyldighed USING btree (((virkning).aktoertypekode));


--
-- Name: interessefaellesskab_tils_gyldighed_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_tils_gyldighed_idx_virkning_notetekst ON interessefaellesskab_tils_gyldighed USING btree (((virkning).notetekst));


--
-- Name: interessefaellesskab_tils_gyldighed_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX interessefaellesskab_tils_gyldighed_pat_virkning_notetekst ON interessefaellesskab_tils_gyldighed USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: itsystem_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_attr_egenskaber_idx_brugervendtnoegle ON itsystem_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: itsystem_attr_egenskaber_idx_itsystemnavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_attr_egenskaber_idx_itsystemnavn ON itsystem_attr_egenskaber USING btree (itsystemnavn);


--
-- Name: itsystem_attr_egenskaber_idx_itsystemtype; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_attr_egenskaber_idx_itsystemtype ON itsystem_attr_egenskaber USING btree (itsystemtype);


--
-- Name: itsystem_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_attr_egenskaber_idx_virkning_aktoerref ON itsystem_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: itsystem_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_attr_egenskaber_idx_virkning_aktoertypekode ON itsystem_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: itsystem_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_attr_egenskaber_idx_virkning_notetekst ON itsystem_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: itsystem_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_attr_egenskaber_pat_brugervendtnoegle ON itsystem_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: itsystem_attr_egenskaber_pat_itsystemnavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_attr_egenskaber_pat_itsystemnavn ON itsystem_attr_egenskaber USING gin (itsystemnavn public.gin_trgm_ops);


--
-- Name: itsystem_attr_egenskaber_pat_itsystemtype; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_attr_egenskaber_pat_itsystemtype ON itsystem_attr_egenskaber USING gin (itsystemtype public.gin_trgm_ops);


--
-- Name: itsystem_attr_egenskaber_pat_konfigurationreference; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_attr_egenskaber_pat_konfigurationreference ON itsystem_attr_egenskaber USING gin (konfigurationreference);


--
-- Name: itsystem_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_attr_egenskaber_pat_virkning_notetekst ON itsystem_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: itsystem_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_registrering_idx_brugerref ON itsystem_registrering USING btree (((registrering).brugerref));


--
-- Name: itsystem_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_registrering_idx_livscykluskode ON itsystem_registrering USING btree (((registrering).livscykluskode));


--
-- Name: itsystem_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_registrering_idx_note ON itsystem_registrering USING btree (((registrering).note));


--
-- Name: itsystem_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_registrering_pat_note ON itsystem_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: itsystem_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_relation_idx_rel_maal_obj_urn ON itsystem_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: itsystem_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_relation_idx_rel_maal_obj_uuid ON itsystem_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: itsystem_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_relation_idx_rel_maal_urn ON itsystem_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: itsystem_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_relation_idx_rel_maal_urn_isolated ON itsystem_relation USING btree (rel_maal_urn);


--
-- Name: itsystem_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_relation_idx_rel_maal_uuid ON itsystem_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: itsystem_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_relation_idx_rel_maal_uuid_isolated ON itsystem_relation USING btree (rel_maal_uuid);


--
-- Name: itsystem_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_relation_idx_virkning_aktoerref ON itsystem_relation USING btree (((virkning).aktoerref));


--
-- Name: itsystem_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_relation_idx_virkning_aktoertypekode ON itsystem_relation USING btree (((virkning).aktoertypekode));


--
-- Name: itsystem_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_relation_idx_virkning_notetekst ON itsystem_relation USING btree (((virkning).notetekst));


--
-- Name: itsystem_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_relation_pat_virkning_notetekst ON itsystem_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: itsystem_tils_gyldighed_idx_gyldighed; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_tils_gyldighed_idx_gyldighed ON itsystem_tils_gyldighed USING btree (gyldighed);


--
-- Name: itsystem_tils_gyldighed_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_tils_gyldighed_idx_virkning_aktoerref ON itsystem_tils_gyldighed USING btree (((virkning).aktoerref));


--
-- Name: itsystem_tils_gyldighed_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_tils_gyldighed_idx_virkning_aktoertypekode ON itsystem_tils_gyldighed USING btree (((virkning).aktoertypekode));


--
-- Name: itsystem_tils_gyldighed_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_tils_gyldighed_idx_virkning_notetekst ON itsystem_tils_gyldighed USING btree (((virkning).notetekst));


--
-- Name: itsystem_tils_gyldighed_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX itsystem_tils_gyldighed_pat_virkning_notetekst ON itsystem_tils_gyldighed USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: klasse_attr_egenskaber_idx_aendringsnotat; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_idx_aendringsnotat ON klasse_attr_egenskaber USING btree (aendringsnotat);


--
-- Name: klasse_attr_egenskaber_idx_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_idx_beskrivelse ON klasse_attr_egenskaber USING btree (beskrivelse);


--
-- Name: klasse_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_idx_brugervendtnoegle ON klasse_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: klasse_attr_egenskaber_idx_eksempel; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_idx_eksempel ON klasse_attr_egenskaber USING btree (eksempel);


--
-- Name: klasse_attr_egenskaber_idx_omfang; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_idx_omfang ON klasse_attr_egenskaber USING btree (omfang);


--
-- Name: klasse_attr_egenskaber_idx_retskilde; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_idx_retskilde ON klasse_attr_egenskaber USING btree (retskilde);


--
-- Name: klasse_attr_egenskaber_idx_titel; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_idx_titel ON klasse_attr_egenskaber USING btree (titel);


--
-- Name: klasse_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_idx_virkning_aktoerref ON klasse_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: klasse_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_idx_virkning_aktoertypekode ON klasse_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: klasse_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_idx_virkning_notetekst ON klasse_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: klasse_attr_egenskaber_pat_aendringsnotat; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_pat_aendringsnotat ON klasse_attr_egenskaber USING gin (aendringsnotat public.gin_trgm_ops);


--
-- Name: klasse_attr_egenskaber_pat_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_pat_beskrivelse ON klasse_attr_egenskaber USING gin (beskrivelse public.gin_trgm_ops);


--
-- Name: klasse_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_pat_brugervendtnoegle ON klasse_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: klasse_attr_egenskaber_pat_eksempel; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_pat_eksempel ON klasse_attr_egenskaber USING gin (eksempel public.gin_trgm_ops);


--
-- Name: klasse_attr_egenskaber_pat_omfang; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_pat_omfang ON klasse_attr_egenskaber USING gin (omfang public.gin_trgm_ops);


--
-- Name: klasse_attr_egenskaber_pat_retskilde; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_pat_retskilde ON klasse_attr_egenskaber USING gin (retskilde public.gin_trgm_ops);


--
-- Name: klasse_attr_egenskaber_pat_titel; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_pat_titel ON klasse_attr_egenskaber USING gin (titel public.gin_trgm_ops);


--
-- Name: klasse_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_pat_virkning_notetekst ON klasse_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: klasse_attr_egenskaber_soegeord_idx_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_soegeord_idx_beskrivelse ON klasse_attr_egenskaber_soegeord USING btree (beskrivelse);


--
-- Name: klasse_attr_egenskaber_soegeord_idx_soegeordidentifikator; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_soegeord_idx_soegeordidentifikator ON klasse_attr_egenskaber_soegeord USING btree (soegeordidentifikator);


--
-- Name: klasse_attr_egenskaber_soegeord_idx_soegeordskategori; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_soegeord_idx_soegeordskategori ON klasse_attr_egenskaber_soegeord USING btree (soegeordskategori);


--
-- Name: klasse_attr_egenskaber_soegeord_pat_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_soegeord_pat_beskrivelse ON klasse_attr_egenskaber_soegeord USING gin (beskrivelse public.gin_trgm_ops);


--
-- Name: klasse_attr_egenskaber_soegeord_pat_soegeordidentifikator; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_soegeord_pat_soegeordidentifikator ON klasse_attr_egenskaber_soegeord USING gin (soegeordidentifikator public.gin_trgm_ops);


--
-- Name: klasse_attr_egenskaber_soegeord_pat_soegeordskategori; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_attr_egenskaber_soegeord_pat_soegeordskategori ON klasse_attr_egenskaber_soegeord USING gin (soegeordskategori public.gin_trgm_ops);


--
-- Name: klasse_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_registrering_idx_brugerref ON klasse_registrering USING btree (((registrering).brugerref));


--
-- Name: klasse_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_registrering_idx_livscykluskode ON klasse_registrering USING btree (((registrering).livscykluskode));


--
-- Name: klasse_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_registrering_idx_note ON klasse_registrering USING btree (((registrering).note));


--
-- Name: klasse_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_registrering_pat_note ON klasse_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: klasse_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_relation_idx_rel_maal_obj_urn ON klasse_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: klasse_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_relation_idx_rel_maal_obj_uuid ON klasse_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: klasse_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_relation_idx_rel_maal_urn ON klasse_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: klasse_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_relation_idx_rel_maal_urn_isolated ON klasse_relation USING btree (rel_maal_urn);


--
-- Name: klasse_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_relation_idx_rel_maal_uuid ON klasse_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: klasse_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_relation_idx_rel_maal_uuid_isolated ON klasse_relation USING btree (rel_maal_uuid);


--
-- Name: klasse_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_relation_idx_virkning_aktoerref ON klasse_relation USING btree (((virkning).aktoerref));


--
-- Name: klasse_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_relation_idx_virkning_aktoertypekode ON klasse_relation USING btree (((virkning).aktoertypekode));


--
-- Name: klasse_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_relation_idx_virkning_notetekst ON klasse_relation USING btree (((virkning).notetekst));


--
-- Name: klasse_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_relation_pat_virkning_notetekst ON klasse_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: klasse_tils_publiceret_idx_publiceret; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_tils_publiceret_idx_publiceret ON klasse_tils_publiceret USING btree (publiceret);


--
-- Name: klasse_tils_publiceret_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_tils_publiceret_idx_virkning_aktoerref ON klasse_tils_publiceret USING btree (((virkning).aktoerref));


--
-- Name: klasse_tils_publiceret_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_tils_publiceret_idx_virkning_aktoertypekode ON klasse_tils_publiceret USING btree (((virkning).aktoertypekode));


--
-- Name: klasse_tils_publiceret_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_tils_publiceret_idx_virkning_notetekst ON klasse_tils_publiceret USING btree (((virkning).notetekst));


--
-- Name: klasse_tils_publiceret_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klasse_tils_publiceret_pat_virkning_notetekst ON klasse_tils_publiceret USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: klassifikation_attr_egenskaber_idx_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_attr_egenskaber_idx_beskrivelse ON klassifikation_attr_egenskaber USING btree (beskrivelse);


--
-- Name: klassifikation_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_attr_egenskaber_idx_brugervendtnoegle ON klassifikation_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: klassifikation_attr_egenskaber_idx_kaldenavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_attr_egenskaber_idx_kaldenavn ON klassifikation_attr_egenskaber USING btree (kaldenavn);


--
-- Name: klassifikation_attr_egenskaber_idx_ophavsret; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_attr_egenskaber_idx_ophavsret ON klassifikation_attr_egenskaber USING btree (ophavsret);


--
-- Name: klassifikation_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_attr_egenskaber_idx_virkning_aktoerref ON klassifikation_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: klassifikation_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_attr_egenskaber_idx_virkning_aktoertypekode ON klassifikation_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: klassifikation_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_attr_egenskaber_idx_virkning_notetekst ON klassifikation_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: klassifikation_attr_egenskaber_pat_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_attr_egenskaber_pat_beskrivelse ON klassifikation_attr_egenskaber USING gin (beskrivelse public.gin_trgm_ops);


--
-- Name: klassifikation_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_attr_egenskaber_pat_brugervendtnoegle ON klassifikation_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: klassifikation_attr_egenskaber_pat_kaldenavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_attr_egenskaber_pat_kaldenavn ON klassifikation_attr_egenskaber USING gin (kaldenavn public.gin_trgm_ops);


--
-- Name: klassifikation_attr_egenskaber_pat_ophavsret; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_attr_egenskaber_pat_ophavsret ON klassifikation_attr_egenskaber USING gin (ophavsret public.gin_trgm_ops);


--
-- Name: klassifikation_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_attr_egenskaber_pat_virkning_notetekst ON klassifikation_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: klassifikation_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_registrering_idx_brugerref ON klassifikation_registrering USING btree (((registrering).brugerref));


--
-- Name: klassifikation_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_registrering_idx_livscykluskode ON klassifikation_registrering USING btree (((registrering).livscykluskode));


--
-- Name: klassifikation_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_registrering_idx_note ON klassifikation_registrering USING btree (((registrering).note));


--
-- Name: klassifikation_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_registrering_pat_note ON klassifikation_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: klassifikation_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_relation_idx_rel_maal_obj_urn ON klassifikation_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: klassifikation_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_relation_idx_rel_maal_obj_uuid ON klassifikation_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: klassifikation_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_relation_idx_rel_maal_urn ON klassifikation_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: klassifikation_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_relation_idx_rel_maal_urn_isolated ON klassifikation_relation USING btree (rel_maal_urn);


--
-- Name: klassifikation_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_relation_idx_rel_maal_uuid ON klassifikation_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: klassifikation_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_relation_idx_rel_maal_uuid_isolated ON klassifikation_relation USING btree (rel_maal_uuid);


--
-- Name: klassifikation_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_relation_idx_virkning_aktoerref ON klassifikation_relation USING btree (((virkning).aktoerref));


--
-- Name: klassifikation_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_relation_idx_virkning_aktoertypekode ON klassifikation_relation USING btree (((virkning).aktoertypekode));


--
-- Name: klassifikation_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_relation_idx_virkning_notetekst ON klassifikation_relation USING btree (((virkning).notetekst));


--
-- Name: klassifikation_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_relation_pat_virkning_notetekst ON klassifikation_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: klassifikation_tils_publiceret_idx_publiceret; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_tils_publiceret_idx_publiceret ON klassifikation_tils_publiceret USING btree (publiceret);


--
-- Name: klassifikation_tils_publiceret_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_tils_publiceret_idx_virkning_aktoerref ON klassifikation_tils_publiceret USING btree (((virkning).aktoerref));


--
-- Name: klassifikation_tils_publiceret_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_tils_publiceret_idx_virkning_aktoertypekode ON klassifikation_tils_publiceret USING btree (((virkning).aktoertypekode));


--
-- Name: klassifikation_tils_publiceret_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_tils_publiceret_idx_virkning_notetekst ON klassifikation_tils_publiceret USING btree (((virkning).notetekst));


--
-- Name: klassifikation_tils_publiceret_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX klassifikation_tils_publiceret_pat_virkning_notetekst ON klassifikation_tils_publiceret USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: loghaendelse_attr_egenskaber_idx_klasse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_idx_klasse ON loghaendelse_attr_egenskaber USING btree (klasse);


--
-- Name: loghaendelse_attr_egenskaber_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_idx_note ON loghaendelse_attr_egenskaber USING btree (note);


--
-- Name: loghaendelse_attr_egenskaber_idx_objekttype; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_idx_objekttype ON loghaendelse_attr_egenskaber USING btree (objekttype);


--
-- Name: loghaendelse_attr_egenskaber_idx_operation; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_idx_operation ON loghaendelse_attr_egenskaber USING btree (operation);


--
-- Name: loghaendelse_attr_egenskaber_idx_returkode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_idx_returkode ON loghaendelse_attr_egenskaber USING btree (returkode);


--
-- Name: loghaendelse_attr_egenskaber_idx_returtekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_idx_returtekst ON loghaendelse_attr_egenskaber USING btree (returtekst);


--
-- Name: loghaendelse_attr_egenskaber_idx_service; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_idx_service ON loghaendelse_attr_egenskaber USING btree (service);


--
-- Name: loghaendelse_attr_egenskaber_idx_tidspunkt; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_idx_tidspunkt ON loghaendelse_attr_egenskaber USING btree (tidspunkt);


--
-- Name: loghaendelse_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_idx_virkning_aktoerref ON loghaendelse_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: loghaendelse_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_idx_virkning_aktoertypekode ON loghaendelse_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: loghaendelse_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_idx_virkning_notetekst ON loghaendelse_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: loghaendelse_attr_egenskaber_pat_klasse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_pat_klasse ON loghaendelse_attr_egenskaber USING gin (klasse public.gin_trgm_ops);


--
-- Name: loghaendelse_attr_egenskaber_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_pat_note ON loghaendelse_attr_egenskaber USING gin (note public.gin_trgm_ops);


--
-- Name: loghaendelse_attr_egenskaber_pat_objekttype; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_pat_objekttype ON loghaendelse_attr_egenskaber USING gin (objekttype public.gin_trgm_ops);


--
-- Name: loghaendelse_attr_egenskaber_pat_operation; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_pat_operation ON loghaendelse_attr_egenskaber USING gin (operation public.gin_trgm_ops);


--
-- Name: loghaendelse_attr_egenskaber_pat_returkode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_pat_returkode ON loghaendelse_attr_egenskaber USING gin (returkode public.gin_trgm_ops);


--
-- Name: loghaendelse_attr_egenskaber_pat_returtekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_pat_returtekst ON loghaendelse_attr_egenskaber USING gin (returtekst public.gin_trgm_ops);


--
-- Name: loghaendelse_attr_egenskaber_pat_service; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_pat_service ON loghaendelse_attr_egenskaber USING gin (service public.gin_trgm_ops);


--
-- Name: loghaendelse_attr_egenskaber_pat_tidspunkt; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_pat_tidspunkt ON loghaendelse_attr_egenskaber USING gin (tidspunkt public.gin_trgm_ops);


--
-- Name: loghaendelse_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_attr_egenskaber_pat_virkning_notetekst ON loghaendelse_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: loghaendelse_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_registrering_idx_brugerref ON loghaendelse_registrering USING btree (((registrering).brugerref));


--
-- Name: loghaendelse_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_registrering_idx_livscykluskode ON loghaendelse_registrering USING btree (((registrering).livscykluskode));


--
-- Name: loghaendelse_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_registrering_idx_note ON loghaendelse_registrering USING btree (((registrering).note));


--
-- Name: loghaendelse_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_registrering_pat_note ON loghaendelse_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: loghaendelse_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_relation_idx_rel_maal_obj_urn ON loghaendelse_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: loghaendelse_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_relation_idx_rel_maal_obj_uuid ON loghaendelse_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: loghaendelse_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_relation_idx_rel_maal_urn ON loghaendelse_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: loghaendelse_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_relation_idx_rel_maal_urn_isolated ON loghaendelse_relation USING btree (rel_maal_urn);


--
-- Name: loghaendelse_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_relation_idx_rel_maal_uuid ON loghaendelse_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: loghaendelse_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_relation_idx_rel_maal_uuid_isolated ON loghaendelse_relation USING btree (rel_maal_uuid);


--
-- Name: loghaendelse_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_relation_idx_virkning_aktoerref ON loghaendelse_relation USING btree (((virkning).aktoerref));


--
-- Name: loghaendelse_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_relation_idx_virkning_aktoertypekode ON loghaendelse_relation USING btree (((virkning).aktoertypekode));


--
-- Name: loghaendelse_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_relation_idx_virkning_notetekst ON loghaendelse_relation USING btree (((virkning).notetekst));


--
-- Name: loghaendelse_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_relation_pat_virkning_notetekst ON loghaendelse_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: loghaendelse_tils_gyldighed_idx_gyldighed; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_tils_gyldighed_idx_gyldighed ON loghaendelse_tils_gyldighed USING btree (gyldighed);


--
-- Name: loghaendelse_tils_gyldighed_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_tils_gyldighed_idx_virkning_aktoerref ON loghaendelse_tils_gyldighed USING btree (((virkning).aktoerref));


--
-- Name: loghaendelse_tils_gyldighed_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_tils_gyldighed_idx_virkning_aktoertypekode ON loghaendelse_tils_gyldighed USING btree (((virkning).aktoertypekode));


--
-- Name: loghaendelse_tils_gyldighed_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_tils_gyldighed_idx_virkning_notetekst ON loghaendelse_tils_gyldighed USING btree (((virkning).notetekst));


--
-- Name: loghaendelse_tils_gyldighed_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX loghaendelse_tils_gyldighed_pat_virkning_notetekst ON loghaendelse_tils_gyldighed USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: organisation_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_attr_egenskaber_idx_brugervendtnoegle ON organisation_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: organisation_attr_egenskaber_idx_organisationsnavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_attr_egenskaber_idx_organisationsnavn ON organisation_attr_egenskaber USING btree (organisationsnavn);


--
-- Name: organisation_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_attr_egenskaber_idx_virkning_aktoerref ON organisation_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: organisation_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_attr_egenskaber_idx_virkning_aktoertypekode ON organisation_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: organisation_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_attr_egenskaber_idx_virkning_notetekst ON organisation_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: organisation_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_attr_egenskaber_pat_brugervendtnoegle ON organisation_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: organisation_attr_egenskaber_pat_organisationsnavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_attr_egenskaber_pat_organisationsnavn ON organisation_attr_egenskaber USING gin (organisationsnavn public.gin_trgm_ops);


--
-- Name: organisation_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_attr_egenskaber_pat_virkning_notetekst ON organisation_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: organisation_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_registrering_idx_brugerref ON organisation_registrering USING btree (((registrering).brugerref));


--
-- Name: organisation_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_registrering_idx_livscykluskode ON organisation_registrering USING btree (((registrering).livscykluskode));


--
-- Name: organisation_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_registrering_idx_note ON organisation_registrering USING btree (((registrering).note));


--
-- Name: organisation_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_registrering_pat_note ON organisation_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: organisation_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_relation_idx_rel_maal_obj_urn ON organisation_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: organisation_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_relation_idx_rel_maal_obj_uuid ON organisation_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: organisation_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_relation_idx_rel_maal_urn ON organisation_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: organisation_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_relation_idx_rel_maal_urn_isolated ON organisation_relation USING btree (rel_maal_urn);


--
-- Name: organisation_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_relation_idx_rel_maal_uuid ON organisation_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: organisation_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_relation_idx_rel_maal_uuid_isolated ON organisation_relation USING btree (rel_maal_uuid);


--
-- Name: organisation_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_relation_idx_virkning_aktoerref ON organisation_relation USING btree (((virkning).aktoerref));


--
-- Name: organisation_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_relation_idx_virkning_aktoertypekode ON organisation_relation USING btree (((virkning).aktoertypekode));


--
-- Name: organisation_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_relation_idx_virkning_notetekst ON organisation_relation USING btree (((virkning).notetekst));


--
-- Name: organisation_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_relation_pat_virkning_notetekst ON organisation_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: organisation_tils_gyldighed_idx_gyldighed; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_tils_gyldighed_idx_gyldighed ON organisation_tils_gyldighed USING btree (gyldighed);


--
-- Name: organisation_tils_gyldighed_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_tils_gyldighed_idx_virkning_aktoerref ON organisation_tils_gyldighed USING btree (((virkning).aktoerref));


--
-- Name: organisation_tils_gyldighed_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_tils_gyldighed_idx_virkning_aktoertypekode ON organisation_tils_gyldighed USING btree (((virkning).aktoertypekode));


--
-- Name: organisation_tils_gyldighed_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_tils_gyldighed_idx_virkning_notetekst ON organisation_tils_gyldighed USING btree (((virkning).notetekst));


--
-- Name: organisation_tils_gyldighed_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisation_tils_gyldighed_pat_virkning_notetekst ON organisation_tils_gyldighed USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: organisationenhed_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_attr_egenskaber_idx_brugervendtnoegle ON organisationenhed_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: organisationenhed_attr_egenskaber_idx_enhedsnavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_attr_egenskaber_idx_enhedsnavn ON organisationenhed_attr_egenskaber USING btree (enhedsnavn);


--
-- Name: organisationenhed_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_attr_egenskaber_idx_virkning_aktoerref ON organisationenhed_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: organisationenhed_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_attr_egenskaber_idx_virkning_aktoertypekode ON organisationenhed_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: organisationenhed_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_attr_egenskaber_idx_virkning_notetekst ON organisationenhed_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: organisationenhed_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_attr_egenskaber_pat_brugervendtnoegle ON organisationenhed_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: organisationenhed_attr_egenskaber_pat_enhedsnavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_attr_egenskaber_pat_enhedsnavn ON organisationenhed_attr_egenskaber USING gin (enhedsnavn public.gin_trgm_ops);


--
-- Name: organisationenhed_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_attr_egenskaber_pat_virkning_notetekst ON organisationenhed_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: organisationenhed_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_registrering_idx_brugerref ON organisationenhed_registrering USING btree (((registrering).brugerref));


--
-- Name: organisationenhed_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_registrering_idx_livscykluskode ON organisationenhed_registrering USING btree (((registrering).livscykluskode));


--
-- Name: organisationenhed_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_registrering_idx_note ON organisationenhed_registrering USING btree (((registrering).note));


--
-- Name: organisationenhed_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_registrering_pat_note ON organisationenhed_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: organisationenhed_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_relation_idx_rel_maal_obj_urn ON organisationenhed_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: organisationenhed_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_relation_idx_rel_maal_obj_uuid ON organisationenhed_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: organisationenhed_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_relation_idx_rel_maal_urn ON organisationenhed_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: organisationenhed_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_relation_idx_rel_maal_urn_isolated ON organisationenhed_relation USING btree (rel_maal_urn);


--
-- Name: organisationenhed_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_relation_idx_rel_maal_uuid ON organisationenhed_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: organisationenhed_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_relation_idx_rel_maal_uuid_isolated ON organisationenhed_relation USING btree (rel_maal_uuid);


--
-- Name: organisationenhed_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_relation_idx_virkning_aktoerref ON organisationenhed_relation USING btree (((virkning).aktoerref));


--
-- Name: organisationenhed_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_relation_idx_virkning_aktoertypekode ON organisationenhed_relation USING btree (((virkning).aktoertypekode));


--
-- Name: organisationenhed_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_relation_idx_virkning_notetekst ON organisationenhed_relation USING btree (((virkning).notetekst));


--
-- Name: organisationenhed_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_relation_pat_virkning_notetekst ON organisationenhed_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: organisationenhed_tils_gyldighed_idx_gyldighed; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_tils_gyldighed_idx_gyldighed ON organisationenhed_tils_gyldighed USING btree (gyldighed);


--
-- Name: organisationenhed_tils_gyldighed_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_tils_gyldighed_idx_virkning_aktoerref ON organisationenhed_tils_gyldighed USING btree (((virkning).aktoerref));


--
-- Name: organisationenhed_tils_gyldighed_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_tils_gyldighed_idx_virkning_aktoertypekode ON organisationenhed_tils_gyldighed USING btree (((virkning).aktoertypekode));


--
-- Name: organisationenhed_tils_gyldighed_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_tils_gyldighed_idx_virkning_notetekst ON organisationenhed_tils_gyldighed USING btree (((virkning).notetekst));


--
-- Name: organisationenhed_tils_gyldighed_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationenhed_tils_gyldighed_pat_virkning_notetekst ON organisationenhed_tils_gyldighed USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: organisationfunktion_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_attr_egenskaber_idx_brugervendtnoegle ON organisationfunktion_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: organisationfunktion_attr_egenskaber_idx_funktionsnavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_attr_egenskaber_idx_funktionsnavn ON organisationfunktion_attr_egenskaber USING btree (funktionsnavn);


--
-- Name: organisationfunktion_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_attr_egenskaber_idx_virkning_aktoerref ON organisationfunktion_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: organisationfunktion_attr_egenskaber_idx_virkning_aktoertypekod; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_attr_egenskaber_idx_virkning_aktoertypekod ON organisationfunktion_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: organisationfunktion_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_attr_egenskaber_idx_virkning_notetekst ON organisationfunktion_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: organisationfunktion_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_attr_egenskaber_pat_brugervendtnoegle ON organisationfunktion_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: organisationfunktion_attr_egenskaber_pat_funktionsnavn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_attr_egenskaber_pat_funktionsnavn ON organisationfunktion_attr_egenskaber USING gin (funktionsnavn public.gin_trgm_ops);


--
-- Name: organisationfunktion_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_attr_egenskaber_pat_virkning_notetekst ON organisationfunktion_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: organisationfunktion_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_registrering_idx_brugerref ON organisationfunktion_registrering USING btree (((registrering).brugerref));


--
-- Name: organisationfunktion_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_registrering_idx_livscykluskode ON organisationfunktion_registrering USING btree (((registrering).livscykluskode));


--
-- Name: organisationfunktion_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_registrering_idx_note ON organisationfunktion_registrering USING btree (((registrering).note));


--
-- Name: organisationfunktion_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_registrering_pat_note ON organisationfunktion_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: organisationfunktion_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_relation_idx_rel_maal_obj_urn ON organisationfunktion_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: organisationfunktion_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_relation_idx_rel_maal_obj_uuid ON organisationfunktion_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: organisationfunktion_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_relation_idx_rel_maal_urn ON organisationfunktion_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: organisationfunktion_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_relation_idx_rel_maal_urn_isolated ON organisationfunktion_relation USING btree (rel_maal_urn);


--
-- Name: organisationfunktion_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_relation_idx_rel_maal_uuid ON organisationfunktion_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: organisationfunktion_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_relation_idx_rel_maal_uuid_isolated ON organisationfunktion_relation USING btree (rel_maal_uuid);


--
-- Name: organisationfunktion_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_relation_idx_virkning_aktoerref ON organisationfunktion_relation USING btree (((virkning).aktoerref));


--
-- Name: organisationfunktion_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_relation_idx_virkning_aktoertypekode ON organisationfunktion_relation USING btree (((virkning).aktoertypekode));


--
-- Name: organisationfunktion_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_relation_idx_virkning_notetekst ON organisationfunktion_relation USING btree (((virkning).notetekst));


--
-- Name: organisationfunktion_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_relation_pat_virkning_notetekst ON organisationfunktion_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: organisationfunktion_tils_gyldighed_idx_gyldighed; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_tils_gyldighed_idx_gyldighed ON organisationfunktion_tils_gyldighed USING btree (gyldighed);


--
-- Name: organisationfunktion_tils_gyldighed_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_tils_gyldighed_idx_virkning_aktoerref ON organisationfunktion_tils_gyldighed USING btree (((virkning).aktoerref));


--
-- Name: organisationfunktion_tils_gyldighed_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_tils_gyldighed_idx_virkning_aktoertypekode ON organisationfunktion_tils_gyldighed USING btree (((virkning).aktoertypekode));


--
-- Name: organisationfunktion_tils_gyldighed_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_tils_gyldighed_idx_virkning_notetekst ON organisationfunktion_tils_gyldighed USING btree (((virkning).notetekst));


--
-- Name: organisationfunktion_tils_gyldighed_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX organisationfunktion_tils_gyldighed_pat_virkning_notetekst ON organisationfunktion_tils_gyldighed USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: sag_attr_egenskaber_idx_afleveret; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_afleveret ON sag_attr_egenskaber USING btree (afleveret);


--
-- Name: sag_attr_egenskaber_idx_alternativtitel_offentlighedundtaget; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_alternativtitel_offentlighedundtaget ON sag_attr_egenskaber USING btree (((offentlighedundtaget).alternativtitel));


--
-- Name: sag_attr_egenskaber_idx_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_beskrivelse ON sag_attr_egenskaber USING btree (beskrivelse);


--
-- Name: sag_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_brugervendtnoegle ON sag_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: sag_attr_egenskaber_idx_hjemmel; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_hjemmel ON sag_attr_egenskaber USING btree (hjemmel);


--
-- Name: sag_attr_egenskaber_idx_hjemmel_offentlighedundtaget; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_hjemmel_offentlighedundtaget ON sag_attr_egenskaber USING btree (((offentlighedundtaget).hjemmel));


--
-- Name: sag_attr_egenskaber_idx_kassationskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_kassationskode ON sag_attr_egenskaber USING btree (kassationskode);


--
-- Name: sag_attr_egenskaber_idx_principiel; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_principiel ON sag_attr_egenskaber USING btree (principiel);


--
-- Name: sag_attr_egenskaber_idx_sagsnummer; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_sagsnummer ON sag_attr_egenskaber USING btree (sagsnummer);


--
-- Name: sag_attr_egenskaber_idx_titel; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_titel ON sag_attr_egenskaber USING btree (titel);


--
-- Name: sag_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_virkning_aktoerref ON sag_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: sag_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_virkning_aktoertypekode ON sag_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: sag_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_idx_virkning_notetekst ON sag_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: sag_attr_egenskaber_pat_alternativtitel_offentlighedundtaget; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_pat_alternativtitel_offentlighedundtaget ON sag_attr_egenskaber USING gin (((offentlighedundtaget).alternativtitel) public.gin_trgm_ops);


--
-- Name: sag_attr_egenskaber_pat_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_pat_beskrivelse ON sag_attr_egenskaber USING gin (beskrivelse public.gin_trgm_ops);


--
-- Name: sag_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_pat_brugervendtnoegle ON sag_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: sag_attr_egenskaber_pat_hjemmel; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_pat_hjemmel ON sag_attr_egenskaber USING gin (hjemmel public.gin_trgm_ops);


--
-- Name: sag_attr_egenskaber_pat_hjemmel_offentlighedundtaget; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_pat_hjemmel_offentlighedundtaget ON sag_attr_egenskaber USING gin (((offentlighedundtaget).hjemmel) public.gin_trgm_ops);


--
-- Name: sag_attr_egenskaber_pat_kassationskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_pat_kassationskode ON sag_attr_egenskaber USING gin (kassationskode public.gin_trgm_ops);


--
-- Name: sag_attr_egenskaber_pat_sagsnummer; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_pat_sagsnummer ON sag_attr_egenskaber USING gin (sagsnummer public.gin_trgm_ops);


--
-- Name: sag_attr_egenskaber_pat_titel; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_pat_titel ON sag_attr_egenskaber USING gin (titel public.gin_trgm_ops);


--
-- Name: sag_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_attr_egenskaber_pat_virkning_notetekst ON sag_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: sag_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_registrering_idx_brugerref ON sag_registrering USING btree (((registrering).brugerref));


--
-- Name: sag_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_registrering_idx_livscykluskode ON sag_registrering USING btree (((registrering).livscykluskode));


--
-- Name: sag_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_registrering_idx_note ON sag_registrering USING btree (((registrering).note));


--
-- Name: sag_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_registrering_pat_note ON sag_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: sag_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_relation_idx_rel_maal_obj_urn ON sag_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: sag_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_relation_idx_rel_maal_obj_uuid ON sag_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: sag_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_relation_idx_rel_maal_urn ON sag_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: sag_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_relation_idx_rel_maal_urn_isolated ON sag_relation USING btree (rel_maal_urn);


--
-- Name: sag_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_relation_idx_rel_maal_uuid ON sag_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: sag_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_relation_idx_rel_maal_uuid_isolated ON sag_relation USING btree (rel_maal_uuid);


--
-- Name: sag_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_relation_idx_virkning_aktoerref ON sag_relation USING btree (((virkning).aktoerref));


--
-- Name: sag_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_relation_idx_virkning_aktoertypekode ON sag_relation USING btree (((virkning).aktoertypekode));


--
-- Name: sag_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_relation_idx_virkning_notetekst ON sag_relation USING btree (((virkning).notetekst));


--
-- Name: sag_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_relation_pat_virkning_notetekst ON sag_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: sag_relation_unique_index_within_type; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE UNIQUE INDEX sag_relation_unique_index_within_type ON sag_relation USING btree (sag_registrering_id, rel_type, rel_index) WHERE (rel_type = ANY (ARRAY['andetarkiv'::sagrelationkode, 'andrebehandlere'::sagrelationkode, 'sekundaerpart'::sagrelationkode, 'andresager'::sagrelationkode, 'byggeri'::sagrelationkode, 'fredning'::sagrelationkode, 'journalpost'::sagrelationkode]));


--
-- Name: sag_tils_fremdrift_idx_fremdrift; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_tils_fremdrift_idx_fremdrift ON sag_tils_fremdrift USING btree (fremdrift);


--
-- Name: sag_tils_fremdrift_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_tils_fremdrift_idx_virkning_aktoerref ON sag_tils_fremdrift USING btree (((virkning).aktoerref));


--
-- Name: sag_tils_fremdrift_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_tils_fremdrift_idx_virkning_aktoertypekode ON sag_tils_fremdrift USING btree (((virkning).aktoertypekode));


--
-- Name: sag_tils_fremdrift_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_tils_fremdrift_idx_virkning_notetekst ON sag_tils_fremdrift USING btree (((virkning).notetekst));


--
-- Name: sag_tils_fremdrift_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX sag_tils_fremdrift_pat_virkning_notetekst ON sag_tils_fremdrift USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: tilstand_attr_egenskaber_idx_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_attr_egenskaber_idx_beskrivelse ON tilstand_attr_egenskaber USING btree (beskrivelse);


--
-- Name: tilstand_attr_egenskaber_idx_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_attr_egenskaber_idx_brugervendtnoegle ON tilstand_attr_egenskaber USING btree (brugervendtnoegle);


--
-- Name: tilstand_attr_egenskaber_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_attr_egenskaber_idx_virkning_aktoerref ON tilstand_attr_egenskaber USING btree (((virkning).aktoerref));


--
-- Name: tilstand_attr_egenskaber_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_attr_egenskaber_idx_virkning_aktoertypekode ON tilstand_attr_egenskaber USING btree (((virkning).aktoertypekode));


--
-- Name: tilstand_attr_egenskaber_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_attr_egenskaber_idx_virkning_notetekst ON tilstand_attr_egenskaber USING btree (((virkning).notetekst));


--
-- Name: tilstand_attr_egenskaber_pat_beskrivelse; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_attr_egenskaber_pat_beskrivelse ON tilstand_attr_egenskaber USING gin (beskrivelse public.gin_trgm_ops);


--
-- Name: tilstand_attr_egenskaber_pat_brugervendtnoegle; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_attr_egenskaber_pat_brugervendtnoegle ON tilstand_attr_egenskaber USING gin (brugervendtnoegle public.gin_trgm_ops);


--
-- Name: tilstand_attr_egenskaber_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_attr_egenskaber_pat_virkning_notetekst ON tilstand_attr_egenskaber USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: tilstand_registrering_idx_brugerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_registrering_idx_brugerref ON tilstand_registrering USING btree (((registrering).brugerref));


--
-- Name: tilstand_registrering_idx_livscykluskode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_registrering_idx_livscykluskode ON tilstand_registrering USING btree (((registrering).livscykluskode));


--
-- Name: tilstand_registrering_idx_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_registrering_idx_note ON tilstand_registrering USING btree (((registrering).note));


--
-- Name: tilstand_registrering_pat_note; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_registrering_pat_note ON tilstand_registrering USING gin (((registrering).note) public.gin_trgm_ops);


--
-- Name: tilstand_relation_idx_rel_maal_obj_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_relation_idx_rel_maal_obj_urn ON tilstand_relation USING btree (rel_type, objekt_type, rel_maal_urn);


--
-- Name: tilstand_relation_idx_rel_maal_obj_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_relation_idx_rel_maal_obj_uuid ON tilstand_relation USING btree (rel_type, objekt_type, rel_maal_uuid);


--
-- Name: tilstand_relation_idx_rel_maal_urn; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_relation_idx_rel_maal_urn ON tilstand_relation USING btree (rel_type, rel_maal_urn);


--
-- Name: tilstand_relation_idx_rel_maal_urn_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_relation_idx_rel_maal_urn_isolated ON tilstand_relation USING btree (rel_maal_urn);


--
-- Name: tilstand_relation_idx_rel_maal_uuid; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_relation_idx_rel_maal_uuid ON tilstand_relation USING btree (rel_type, rel_maal_uuid);


--
-- Name: tilstand_relation_idx_rel_maal_uuid_isolated; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_relation_idx_rel_maal_uuid_isolated ON tilstand_relation USING btree (rel_maal_uuid);


--
-- Name: tilstand_relation_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_relation_idx_virkning_aktoerref ON tilstand_relation USING btree (((virkning).aktoerref));


--
-- Name: tilstand_relation_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_relation_idx_virkning_aktoertypekode ON tilstand_relation USING btree (((virkning).aktoertypekode));


--
-- Name: tilstand_relation_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_relation_idx_virkning_notetekst ON tilstand_relation USING btree (((virkning).notetekst));


--
-- Name: tilstand_relation_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_relation_pat_virkning_notetekst ON tilstand_relation USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: tilstand_relation_unique_index_within_type; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE UNIQUE INDEX tilstand_relation_unique_index_within_type ON tilstand_relation USING btree (tilstand_registrering_id, rel_type, rel_index) WHERE (rel_type = ANY (ARRAY['tilstandsvaerdi'::tilstandrelationkode, 'begrundelse'::tilstandrelationkode, 'tilstandskvalitet'::tilstandrelationkode, 'tilstandsvurdering'::tilstandrelationkode, 'tilstandsaktoer'::tilstandrelationkode, 'tilstandsudstyr'::tilstandrelationkode, 'samtykke'::tilstandrelationkode, 'tilstandsdokument'::tilstandrelationkode]));


--
-- Name: tilstand_tils_publiceret_idx_publiceret; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_tils_publiceret_idx_publiceret ON tilstand_tils_publiceret USING btree (publiceret);


--
-- Name: tilstand_tils_publiceret_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_tils_publiceret_idx_virkning_aktoerref ON tilstand_tils_publiceret USING btree (((virkning).aktoerref));


--
-- Name: tilstand_tils_publiceret_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_tils_publiceret_idx_virkning_aktoertypekode ON tilstand_tils_publiceret USING btree (((virkning).aktoertypekode));


--
-- Name: tilstand_tils_publiceret_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_tils_publiceret_idx_virkning_notetekst ON tilstand_tils_publiceret USING btree (((virkning).notetekst));


--
-- Name: tilstand_tils_publiceret_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_tils_publiceret_pat_virkning_notetekst ON tilstand_tils_publiceret USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: tilstand_tils_status_idx_status; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_tils_status_idx_status ON tilstand_tils_status USING btree (status);


--
-- Name: tilstand_tils_status_idx_virkning_aktoerref; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_tils_status_idx_virkning_aktoerref ON tilstand_tils_status USING btree (((virkning).aktoerref));


--
-- Name: tilstand_tils_status_idx_virkning_aktoertypekode; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_tils_status_idx_virkning_aktoertypekode ON tilstand_tils_status USING btree (((virkning).aktoertypekode));


--
-- Name: tilstand_tils_status_idx_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_tils_status_idx_virkning_notetekst ON tilstand_tils_status USING btree (((virkning).notetekst));


--
-- Name: tilstand_tils_status_pat_virkning_notetekst; Type: INDEX; Schema: actual_state; Owner: mox
--

CREATE INDEX tilstand_tils_status_pat_virkning_notetekst ON tilstand_tils_status USING gin (((virkning).notetekst) public.gin_trgm_ops);


--
-- Name: aktivitet_attr_egenskaber_forkey_aktivitetregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_attr_egenskaber
    ADD CONSTRAINT aktivitet_attr_egenskaber_forkey_aktivitetregistrering FOREIGN KEY (aktivitet_registrering_id) REFERENCES aktivitet_registrering(id);


--
-- Name: aktivitet_registrering_aktivitet_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_registrering
    ADD CONSTRAINT aktivitet_registrering_aktivitet_fkey FOREIGN KEY (aktivitet_id) REFERENCES aktivitet(id);


--
-- Name: aktivitet_relation_forkey_aktivitetregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_relation
    ADD CONSTRAINT aktivitet_relation_forkey_aktivitetregistrering FOREIGN KEY (aktivitet_registrering_id) REFERENCES aktivitet_registrering(id);


--
-- Name: aktivitet_tils_publiceret_forkey_aktivitetregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_tils_publiceret
    ADD CONSTRAINT aktivitet_tils_publiceret_forkey_aktivitetregistrering FOREIGN KEY (aktivitet_registrering_id) REFERENCES aktivitet_registrering(id);


--
-- Name: aktivitet_tils_status_forkey_aktivitetregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY aktivitet_tils_status
    ADD CONSTRAINT aktivitet_tils_status_forkey_aktivitetregistrering FOREIGN KEY (aktivitet_registrering_id) REFERENCES aktivitet_registrering(id);


--
-- Name: bruger_attr_egenskaber_forkey_brugerregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger_attr_egenskaber
    ADD CONSTRAINT bruger_attr_egenskaber_forkey_brugerregistrering FOREIGN KEY (bruger_registrering_id) REFERENCES bruger_registrering(id);


--
-- Name: bruger_registrering_bruger_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger_registrering
    ADD CONSTRAINT bruger_registrering_bruger_fkey FOREIGN KEY (bruger_id) REFERENCES bruger(id);


--
-- Name: bruger_relation_forkey_brugerregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger_relation
    ADD CONSTRAINT bruger_relation_forkey_brugerregistrering FOREIGN KEY (bruger_registrering_id) REFERENCES bruger_registrering(id);


--
-- Name: bruger_tils_gyldighed_forkey_brugerregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY bruger_tils_gyldighed
    ADD CONSTRAINT bruger_tils_gyldighed_forkey_brugerregistrering FOREIGN KEY (bruger_registrering_id) REFERENCES bruger_registrering(id);


--
-- Name: dokument_attr_egenskaber_forkey_dokumentregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_attr_egenskaber
    ADD CONSTRAINT dokument_attr_egenskaber_forkey_dokumentregistrering FOREIGN KEY (dokument_registrering_id) REFERENCES dokument_registrering(id);


--
-- Name: dokument_del_egenskaber_forkey_dokument_del; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_del_egenskaber
    ADD CONSTRAINT dokument_del_egenskaber_forkey_dokument_del FOREIGN KEY (del_id) REFERENCES dokument_del(id);


--
-- Name: dokument_del_forkey_variant_id; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_del
    ADD CONSTRAINT dokument_del_forkey_variant_id FOREIGN KEY (variant_id) REFERENCES dokument_variant(id);


--
-- Name: dokument_del_relation_forkey_dokument_del; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_del_relation
    ADD CONSTRAINT dokument_del_relation_forkey_dokument_del FOREIGN KEY (del_id) REFERENCES dokument_del(id);


--
-- Name: dokument_registrering_dokument_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_registrering
    ADD CONSTRAINT dokument_registrering_dokument_fkey FOREIGN KEY (dokument_id) REFERENCES dokument(id);


--
-- Name: dokument_relation_forkey_dokumentregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_relation
    ADD CONSTRAINT dokument_relation_forkey_dokumentregistrering FOREIGN KEY (dokument_registrering_id) REFERENCES dokument_registrering(id);


--
-- Name: dokument_tils_fremdrift_forkey_dokumentregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_tils_fremdrift
    ADD CONSTRAINT dokument_tils_fremdrift_forkey_dokumentregistrering FOREIGN KEY (dokument_registrering_id) REFERENCES dokument_registrering(id);


--
-- Name: dokument_variant_egenskaber_forkey_dokumentvariant; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_variant_egenskaber
    ADD CONSTRAINT dokument_variant_egenskaber_forkey_dokumentvariant FOREIGN KEY (variant_id) REFERENCES dokument_variant(id);


--
-- Name: dokument_variant_forkey_dokumentregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY dokument_variant
    ADD CONSTRAINT dokument_variant_forkey_dokumentregistrering FOREIGN KEY (dokument_registrering_id) REFERENCES dokument_registrering(id);


--
-- Name: facet_attr_egenskaber_forkey_facetregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet_attr_egenskaber
    ADD CONSTRAINT facet_attr_egenskaber_forkey_facetregistrering FOREIGN KEY (facet_registrering_id) REFERENCES facet_registrering(id);


--
-- Name: facet_registrering_facet_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet_registrering
    ADD CONSTRAINT facet_registrering_facet_fkey FOREIGN KEY (facet_id) REFERENCES facet(id);


--
-- Name: facet_relation_forkey_facetregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet_relation
    ADD CONSTRAINT facet_relation_forkey_facetregistrering FOREIGN KEY (facet_registrering_id) REFERENCES facet_registrering(id);


--
-- Name: facet_tils_publiceret_forkey_facetregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY facet_tils_publiceret
    ADD CONSTRAINT facet_tils_publiceret_forkey_facetregistrering FOREIGN KEY (facet_registrering_id) REFERENCES facet_registrering(id);


--
-- Name: indsats_attr_egenskaber_forkey_indsatsregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_attr_egenskaber
    ADD CONSTRAINT indsats_attr_egenskaber_forkey_indsatsregistrering FOREIGN KEY (indsats_registrering_id) REFERENCES indsats_registrering(id);


--
-- Name: indsats_registrering_indsats_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_registrering
    ADD CONSTRAINT indsats_registrering_indsats_fkey FOREIGN KEY (indsats_id) REFERENCES indsats(id);


--
-- Name: indsats_relation_forkey_indsatsregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_relation
    ADD CONSTRAINT indsats_relation_forkey_indsatsregistrering FOREIGN KEY (indsats_registrering_id) REFERENCES indsats_registrering(id);


--
-- Name: indsats_tils_fremdrift_forkey_indsatsregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_tils_fremdrift
    ADD CONSTRAINT indsats_tils_fremdrift_forkey_indsatsregistrering FOREIGN KEY (indsats_registrering_id) REFERENCES indsats_registrering(id);


--
-- Name: indsats_tils_publiceret_forkey_indsatsregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY indsats_tils_publiceret
    ADD CONSTRAINT indsats_tils_publiceret_forkey_indsatsregistrering FOREIGN KEY (indsats_registrering_id) REFERENCES indsats_registrering(id);


--
-- Name: interessefaellesskab_attr_egenskaber_forkey_interessefaellesska; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab_attr_egenskaber
    ADD CONSTRAINT interessefaellesskab_attr_egenskaber_forkey_interessefaellesska FOREIGN KEY (interessefaellesskab_registrering_id) REFERENCES interessefaellesskab_registrering(id);


--
-- Name: interessefaellesskab_registrering_interessefaellesskab_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab_registrering
    ADD CONSTRAINT interessefaellesskab_registrering_interessefaellesskab_fkey FOREIGN KEY (interessefaellesskab_id) REFERENCES interessefaellesskab(id);


--
-- Name: interessefaellesskab_relation_forkey_interessefaellesskabregist; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab_relation
    ADD CONSTRAINT interessefaellesskab_relation_forkey_interessefaellesskabregist FOREIGN KEY (interessefaellesskab_registrering_id) REFERENCES interessefaellesskab_registrering(id);


--
-- Name: interessefaellesskab_tils_gyldighed_forkey_interessefaellesskab; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY interessefaellesskab_tils_gyldighed
    ADD CONSTRAINT interessefaellesskab_tils_gyldighed_forkey_interessefaellesskab FOREIGN KEY (interessefaellesskab_registrering_id) REFERENCES interessefaellesskab_registrering(id);


--
-- Name: itsystem_attr_egenskaber_forkey_itsystemregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem_attr_egenskaber
    ADD CONSTRAINT itsystem_attr_egenskaber_forkey_itsystemregistrering FOREIGN KEY (itsystem_registrering_id) REFERENCES itsystem_registrering(id);


--
-- Name: itsystem_registrering_itsystem_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem_registrering
    ADD CONSTRAINT itsystem_registrering_itsystem_fkey FOREIGN KEY (itsystem_id) REFERENCES itsystem(id);


--
-- Name: itsystem_relation_forkey_itsystemregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem_relation
    ADD CONSTRAINT itsystem_relation_forkey_itsystemregistrering FOREIGN KEY (itsystem_registrering_id) REFERENCES itsystem_registrering(id);


--
-- Name: itsystem_tils_gyldighed_forkey_itsystemregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY itsystem_tils_gyldighed
    ADD CONSTRAINT itsystem_tils_gyldighed_forkey_itsystemregistrering FOREIGN KEY (itsystem_registrering_id) REFERENCES itsystem_registrering(id);


--
-- Name: klasse_attr_egenskaber_forkey_klasseregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_attr_egenskaber
    ADD CONSTRAINT klasse_attr_egenskaber_forkey_klasseregistrering FOREIGN KEY (klasse_registrering_id) REFERENCES klasse_registrering(id);


--
-- Name: klasse_attr_egenskaber_soegeord_forkey_klasse_attr_egenskaber; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_attr_egenskaber_soegeord
    ADD CONSTRAINT klasse_attr_egenskaber_soegeord_forkey_klasse_attr_egenskaber FOREIGN KEY (klasse_attr_egenskaber_id) REFERENCES klasse_attr_egenskaber(id);


--
-- Name: klasse_registrering_klasse_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_registrering
    ADD CONSTRAINT klasse_registrering_klasse_fkey FOREIGN KEY (klasse_id) REFERENCES klasse(id);


--
-- Name: klasse_relation_forkey_klasseregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_relation
    ADD CONSTRAINT klasse_relation_forkey_klasseregistrering FOREIGN KEY (klasse_registrering_id) REFERENCES klasse_registrering(id);


--
-- Name: klasse_tils_publiceret_forkey_klasseregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klasse_tils_publiceret
    ADD CONSTRAINT klasse_tils_publiceret_forkey_klasseregistrering FOREIGN KEY (klasse_registrering_id) REFERENCES klasse_registrering(id);


--
-- Name: klassifikation_attr_egenskaber_forkey_klassifikationregistrerin; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation_attr_egenskaber
    ADD CONSTRAINT klassifikation_attr_egenskaber_forkey_klassifikationregistrerin FOREIGN KEY (klassifikation_registrering_id) REFERENCES klassifikation_registrering(id);


--
-- Name: klassifikation_registrering_klassifikation_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation_registrering
    ADD CONSTRAINT klassifikation_registrering_klassifikation_fkey FOREIGN KEY (klassifikation_id) REFERENCES klassifikation(id);


--
-- Name: klassifikation_relation_forkey_klassifikationregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation_relation
    ADD CONSTRAINT klassifikation_relation_forkey_klassifikationregistrering FOREIGN KEY (klassifikation_registrering_id) REFERENCES klassifikation_registrering(id);


--
-- Name: klassifikation_tils_publiceret_forkey_klassifikationregistrerin; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY klassifikation_tils_publiceret
    ADD CONSTRAINT klassifikation_tils_publiceret_forkey_klassifikationregistrerin FOREIGN KEY (klassifikation_registrering_id) REFERENCES klassifikation_registrering(id);


--
-- Name: loghaendelse_attr_egenskaber_forkey_loghaendelseregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse_attr_egenskaber
    ADD CONSTRAINT loghaendelse_attr_egenskaber_forkey_loghaendelseregistrering FOREIGN KEY (loghaendelse_registrering_id) REFERENCES loghaendelse_registrering(id);


--
-- Name: loghaendelse_registrering_loghaendelse_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse_registrering
    ADD CONSTRAINT loghaendelse_registrering_loghaendelse_fkey FOREIGN KEY (loghaendelse_id) REFERENCES loghaendelse(id);


--
-- Name: loghaendelse_relation_forkey_loghaendelseregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse_relation
    ADD CONSTRAINT loghaendelse_relation_forkey_loghaendelseregistrering FOREIGN KEY (loghaendelse_registrering_id) REFERENCES loghaendelse_registrering(id);


--
-- Name: loghaendelse_tils_gyldighed_forkey_loghaendelseregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY loghaendelse_tils_gyldighed
    ADD CONSTRAINT loghaendelse_tils_gyldighed_forkey_loghaendelseregistrering FOREIGN KEY (loghaendelse_registrering_id) REFERENCES loghaendelse_registrering(id);


--
-- Name: organisation_attr_egenskaber_forkey_organisationregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation_attr_egenskaber
    ADD CONSTRAINT organisation_attr_egenskaber_forkey_organisationregistrering FOREIGN KEY (organisation_registrering_id) REFERENCES organisation_registrering(id);


--
-- Name: organisation_registrering_organisation_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation_registrering
    ADD CONSTRAINT organisation_registrering_organisation_fkey FOREIGN KEY (organisation_id) REFERENCES organisation(id);


--
-- Name: organisation_relation_forkey_organisationregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation_relation
    ADD CONSTRAINT organisation_relation_forkey_organisationregistrering FOREIGN KEY (organisation_registrering_id) REFERENCES organisation_registrering(id);


--
-- Name: organisation_tils_gyldighed_forkey_organisationregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisation_tils_gyldighed
    ADD CONSTRAINT organisation_tils_gyldighed_forkey_organisationregistrering FOREIGN KEY (organisation_registrering_id) REFERENCES organisation_registrering(id);


--
-- Name: organisationenhed_attr_egenskaber_forkey_organisationenhedregis; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed_attr_egenskaber
    ADD CONSTRAINT organisationenhed_attr_egenskaber_forkey_organisationenhedregis FOREIGN KEY (organisationenhed_registrering_id) REFERENCES organisationenhed_registrering(id);


--
-- Name: organisationenhed_registrering_organisationenhed_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed_registrering
    ADD CONSTRAINT organisationenhed_registrering_organisationenhed_fkey FOREIGN KEY (organisationenhed_id) REFERENCES organisationenhed(id);


--
-- Name: organisationenhed_relation_forkey_organisationenhedregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed_relation
    ADD CONSTRAINT organisationenhed_relation_forkey_organisationenhedregistrering FOREIGN KEY (organisationenhed_registrering_id) REFERENCES organisationenhed_registrering(id);


--
-- Name: organisationenhed_tils_gyldighed_forkey_organisationenhedregist; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationenhed_tils_gyldighed
    ADD CONSTRAINT organisationenhed_tils_gyldighed_forkey_organisationenhedregist FOREIGN KEY (organisationenhed_registrering_id) REFERENCES organisationenhed_registrering(id);


--
-- Name: organisationfunktion_attr_egenskaber_forkey_organisationfunktio; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion_attr_egenskaber
    ADD CONSTRAINT organisationfunktion_attr_egenskaber_forkey_organisationfunktio FOREIGN KEY (organisationfunktion_registrering_id) REFERENCES organisationfunktion_registrering(id);


--
-- Name: organisationfunktion_registrering_organisationfunktion_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion_registrering
    ADD CONSTRAINT organisationfunktion_registrering_organisationfunktion_fkey FOREIGN KEY (organisationfunktion_id) REFERENCES organisationfunktion(id);


--
-- Name: organisationfunktion_relation_forkey_organisationfunktionregist; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion_relation
    ADD CONSTRAINT organisationfunktion_relation_forkey_organisationfunktionregist FOREIGN KEY (organisationfunktion_registrering_id) REFERENCES organisationfunktion_registrering(id);


--
-- Name: organisationfunktion_tils_gyldighed_forkey_organisationfunktion; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY organisationfunktion_tils_gyldighed
    ADD CONSTRAINT organisationfunktion_tils_gyldighed_forkey_organisationfunktion FOREIGN KEY (organisationfunktion_registrering_id) REFERENCES organisationfunktion_registrering(id);


--
-- Name: sag_attr_egenskaber_forkey_sagregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag_attr_egenskaber
    ADD CONSTRAINT sag_attr_egenskaber_forkey_sagregistrering FOREIGN KEY (sag_registrering_id) REFERENCES sag_registrering(id);


--
-- Name: sag_registrering_sag_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag_registrering
    ADD CONSTRAINT sag_registrering_sag_fkey FOREIGN KEY (sag_id) REFERENCES sag(id);


--
-- Name: sag_relation_forkey_sagregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag_relation
    ADD CONSTRAINT sag_relation_forkey_sagregistrering FOREIGN KEY (sag_registrering_id) REFERENCES sag_registrering(id);


--
-- Name: sag_tils_fremdrift_forkey_sagregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY sag_tils_fremdrift
    ADD CONSTRAINT sag_tils_fremdrift_forkey_sagregistrering FOREIGN KEY (sag_registrering_id) REFERENCES sag_registrering(id);


--
-- Name: tilstand_attr_egenskaber_forkey_tilstandregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_attr_egenskaber
    ADD CONSTRAINT tilstand_attr_egenskaber_forkey_tilstandregistrering FOREIGN KEY (tilstand_registrering_id) REFERENCES tilstand_registrering(id);


--
-- Name: tilstand_registrering_tilstand_fkey; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_registrering
    ADD CONSTRAINT tilstand_registrering_tilstand_fkey FOREIGN KEY (tilstand_id) REFERENCES tilstand(id);


--
-- Name: tilstand_relation_forkey_tilstandregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_relation
    ADD CONSTRAINT tilstand_relation_forkey_tilstandregistrering FOREIGN KEY (tilstand_registrering_id) REFERENCES tilstand_registrering(id);


--
-- Name: tilstand_tils_publiceret_forkey_tilstandregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_tils_publiceret
    ADD CONSTRAINT tilstand_tils_publiceret_forkey_tilstandregistrering FOREIGN KEY (tilstand_registrering_id) REFERENCES tilstand_registrering(id);


--
-- Name: tilstand_tils_status_forkey_tilstandregistrering; Type: FK CONSTRAINT; Schema: actual_state; Owner: mox
--

ALTER TABLE ONLY tilstand_tils_status
    ADD CONSTRAINT tilstand_tils_status_forkey_tilstandregistrering FOREIGN KEY (tilstand_registrering_id) REFERENCES tilstand_registrering(id);


--
-- Name: public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO PUBLIC;


--
-- PostgreSQL database dump complete
--

