-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE AktivitetStatusTils AS ENUM ('Inaktiv','Aktiv','Aflyst',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE AktivitetStatusTilsType AS (
    virkning Virkning,
    status AktivitetStatusTils
)
;
CREATE TYPE AktivitetPubliceretTils AS ENUM ('Publiceret','IkkePubliceret','Normal',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE AktivitetPubliceretTilsType AS (
    virkning Virkning,
    publiceret AktivitetPubliceretTils
)
;



CREATE TYPE AktivitetEgenskaberAttrType AS (
brugervendtnoegle text,
aktivitetnavn text,
beskrivelse text,
starttidspunkt ClearableTimestamptz,

sluttidspunkt ClearableTimestamptz,

tidsforbrug ClearableInterval,
formaal text,

 virkning Virkning
);




CREATE TYPE AktivitetRelationKode AS ENUM  ('aktivitetstype','emne','foelsomhedklasse','ansvarligklasse','rekvirentklasse','ansvarlig','tilhoerer','udfoererklasse','deltagerklasse','objektklasse','resultatklasse','grundlagklasse','facilitetklasse','adresse','geoobjekt','position','facilitet','lokale','aktivitetdokument','aktivitetgrundlag','aktivitetresultat','udfoerer','deltager');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_aktivitet_relation_kode_to_txt is invoked.


CREATE TYPE AktivitetAktoerAttrObligatoriskKode AS ENUM ('noedvendig','valgfri');

CREATE TYPE AktivitetAktoerAttrAccepteretKode AS ENUM ('accepteret','foreloebigt','afslaaet');

CREATE TYPE AktivitetAktoerAttr AS (
  obligatorisk AktivitetAktoerAttrObligatoriskKode,
  accepteret AktivitetAktoerAttrAccepteretKode,
  repraesentation_uuid uuid,
  repraesentation_urn text 
);


CREATE TYPE AktivitetRelationType AS (
  relType AktivitetRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text,
  indeks int,
  aktoerAttr AktivitetAktoerAttr
)
;



CREATE TYPE AktivitetRegistreringType AS
(
registrering RegistreringBase,
tilsStatus AktivitetStatusTilsType[],
tilsPubliceret AktivitetPubliceretTilsType[],
attrEgenskaber AktivitetEgenskaberAttrType[],
relationer AktivitetRelationType[]
);

CREATE TYPE AktivitetType AS
(
  id uuid,
  registrering AktivitetRegistreringType[]
);  


 CREATE Type _AktivitetRelationMaxIndex AS
 (
   relType AktivitetRelationKode,
   indeks int
 );

---we'll add two small functions here, that will help with placing CHECK CONSTRAINT on the composite type AktivitetAktoerAttr in the db-table.
CREATE OR REPLACE FUNCTION _aktivitet_aktoer_attr_repr_uuid_to_text(AktivitetAktoerAttr) RETURNS TEXT AS 'SELECT $1.repraesentation_uuid::TEXT' LANGUAGE sql IMMUTABLE;
CREATE OR REPLACE FUNCTION _aktivitet_aktoer_attr_repr_urn_to_text(AktivitetAktoerAttr) RETURNS TEXT AS 'SELECT NULLIF($1.repraesentation_urn::TEXT,'''') ' LANGUAGE sql IMMUTABLE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_aktivitet_relation_kode_to_txt(
    AktivitetRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE aktivitet (
    id uuid NOT NULL,
    CONSTRAINT aktivitet_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE aktivitet
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE aktivitet_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE aktivitet_registrering_id_seq
    OWNER TO mox;


CREATE TABLE aktivitet_registrering (
   id bigint NOT NULL DEFAULT nextval('aktivitet_registrering_id_seq'::regclass),
   aktivitet_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT aktivitet_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT aktivitet_registrering_aktivitet_fkey FOREIGN KEY (aktivitet_id)
       REFERENCES aktivitet (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT aktivitet_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(aktivitet_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE aktivitet_registrering
  OWNER TO mox;


CREATE INDEX aktivitet_registrering_idx_livscykluskode
    ON aktivitet_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX aktivitet_registrering_idx_brugerref
    ON aktivitet_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX aktivitet_registrering_idx_note
    ON aktivitet_registrering
    USING btree
    (((registrering).note));


CREATE INDEX aktivitet_registrering_pat_note
    ON aktivitet_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX aktivitet_id_idx
    ON aktivitet_registrering (aktivitet_id);


CREATE TRIGGER notify_aktivitet
    AFTER INSERT OR UPDATE OR DELETE ON aktivitet_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE aktivitet_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE aktivitet_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE aktivitet_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('aktivitet_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        aktivitetnavn text  NULL,
        beskrivelse text  NULL,
        starttidspunkt timestamptz  NULL,
        sluttidspunkt timestamptz  NULL,
        tidsforbrug interval(0)  NULL,
        formaal text  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    aktivitet_registrering_id bigint NOT NULL,
    CONSTRAINT aktivitet_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT aktivitet_attr_egenskaber_forkey_aktivitetregistrering FOREIGN KEY (aktivitet_registrering_id) REFERENCES aktivitet_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT aktivitet_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (aktivitet_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE aktivitet_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX aktivitet_attr_egenskaber_pat_brugervendtnoegle
            ON aktivitet_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX aktivitet_attr_egenskaber_idx_brugervendtnoegle
            ON aktivitet_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX aktivitet_attr_egenskaber_pat_aktivitetnavn
            ON aktivitet_attr_egenskaber
            USING gin
            (aktivitetnavn gin_trgm_ops);

        CREATE INDEX aktivitet_attr_egenskaber_idx_aktivitetnavn
            ON aktivitet_attr_egenskaber
            USING btree
            (aktivitetnavn); 
 
     
        CREATE INDEX aktivitet_attr_egenskaber_pat_beskrivelse
            ON aktivitet_attr_egenskaber
            USING gin
            (beskrivelse gin_trgm_ops);

        CREATE INDEX aktivitet_attr_egenskaber_idx_beskrivelse
            ON aktivitet_attr_egenskaber
            USING btree
            (beskrivelse); 
 
    
         
             
                CREATE INDEX aktivitet_attr_egenskaber_idx_starttidspunkt
                    ON aktivitet_attr_egenskaber
                    USING btree
                    (starttidspunkt);

            
         
     
 
    
         
             
                CREATE INDEX aktivitet_attr_egenskaber_idx_sluttidspunkt
                    ON aktivitet_attr_egenskaber
                    USING btree
                    (sluttidspunkt);

            
         
     
 
    
         
             
                CREATE INDEX aktivitet_attr_egenskaber_idx_tidsforbrug
                    ON aktivitet_attr_egenskaber
                    USING btree
                    (tidsforbrug);

            
         
     
 
     
        CREATE INDEX aktivitet_attr_egenskaber_pat_formaal
            ON aktivitet_attr_egenskaber
            USING gin
            (formaal gin_trgm_ops);

        CREATE INDEX aktivitet_attr_egenskaber_idx_formaal
            ON aktivitet_attr_egenskaber
            USING btree
            (formaal); 



CREATE INDEX aktivitet_attr_egenskaber_idx_virkning_aktoerref
    ON aktivitet_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX aktivitet_attr_egenskaber_idx_virkning_aktoertypekode
    ON aktivitet_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX aktivitet_attr_egenskaber_idx_virkning_notetekst
    ON aktivitet_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX aktivitet_attr_egenskaber_pat_virkning_notetekst
    ON aktivitet_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE aktivitet_tils_status_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE aktivitet_tils_status_id_seq
    OWNER TO mox;


CREATE TABLE aktivitet_tils_status (
    id bigint NOT NULL DEFAULT nextval('aktivitet_tils_status_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    status AktivitetStatusTils NOT NULL, 
    aktivitet_registrering_id bigint not null,
    CONSTRAINT aktivitet_tils_status_pkey PRIMARY KEY (id),
    CONSTRAINT aktivitet_tils_status_forkey_aktivitetregistrering FOREIGN KEY (aktivitet_registrering_id) REFERENCES aktivitet_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT aktivitet_tils_status_exclude_virkning_overlap EXCLUDE USING gist (aktivitet_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE aktivitet_tils_status
    OWNER TO mox;


CREATE INDEX aktivitet_tils_status_idx_status
    ON aktivitet_tils_status
    USING btree
    (status);
  
CREATE INDEX aktivitet_tils_status_idx_virkning_aktoerref
    ON aktivitet_tils_status
    USING btree
    (((virkning).aktoerref));

CREATE INDEX aktivitet_tils_status_idx_virkning_aktoertypekode
    ON aktivitet_tils_status
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX aktivitet_tils_status_idx_virkning_notetekst
    ON aktivitet_tils_status
    USING btree
    (((virkning).notetekst));

CREATE INDEX aktivitet_tils_status_pat_virkning_notetekst
    ON aktivitet_tils_status
    USING gin
    (((virkning).notetekst) gin_trgm_ops);


CREATE SEQUENCE aktivitet_tils_publiceret_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE aktivitet_tils_publiceret_id_seq
    OWNER TO mox;


CREATE TABLE aktivitet_tils_publiceret (
    id bigint NOT NULL DEFAULT nextval('aktivitet_tils_publiceret_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    publiceret AktivitetPubliceretTils NOT NULL, 
    aktivitet_registrering_id bigint not null,
    CONSTRAINT aktivitet_tils_publiceret_pkey PRIMARY KEY (id),
    CONSTRAINT aktivitet_tils_publiceret_forkey_aktivitetregistrering FOREIGN KEY (aktivitet_registrering_id) REFERENCES aktivitet_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT aktivitet_tils_publiceret_exclude_virkning_overlap EXCLUDE USING gist (aktivitet_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE aktivitet_tils_publiceret
    OWNER TO mox;


CREATE INDEX aktivitet_tils_publiceret_idx_publiceret
    ON aktivitet_tils_publiceret
    USING btree
    (publiceret);
  
CREATE INDEX aktivitet_tils_publiceret_idx_virkning_aktoerref
    ON aktivitet_tils_publiceret
    USING btree
    (((virkning).aktoerref));

CREATE INDEX aktivitet_tils_publiceret_idx_virkning_aktoertypekode
    ON aktivitet_tils_publiceret
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX aktivitet_tils_publiceret_idx_virkning_notetekst
    ON aktivitet_tils_publiceret
    USING btree
    (((virkning).notetekst));

CREATE INDEX aktivitet_tils_publiceret_pat_virkning_notetekst
    ON aktivitet_tils_publiceret
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE aktivitet_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE aktivitet_relation_id_seq
    OWNER TO mox;


CREATE TABLE aktivitet_relation (
    id bigint NOT NULL DEFAULT nextval('aktivitet_relation_id_seq'::regclass),
    aktivitet_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type AktivitetRelationKode not null,
    objekt_type text null,

    
    rel_index int null,
    aktoer_attr AktivitetAktoerAttr null,
    

    CONSTRAINT aktivitet_relation_forkey_aktivitetregistrering FOREIGN KEY (aktivitet_registrering_id) REFERENCES aktivitet_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT aktivitet_relation_pkey PRIMARY KEY (id),
    CONSTRAINT aktivitet_relation_no_virkning_overlap EXCLUDE USING gist (aktivitet_registrering_id WITH =, _as_convert_aktivitet_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('udfoererklasse'::AktivitetRelationKode ) AND rel_type<>('deltagerklasse'::AktivitetRelationKode ) AND rel_type<>('objektklasse'::AktivitetRelationKode ) AND rel_type<>('resultatklasse'::AktivitetRelationKode ) AND rel_type<>('grundlagklasse'::AktivitetRelationKode ) AND rel_type<>('facilitetklasse'::AktivitetRelationKode ) AND rel_type<>('adresse'::AktivitetRelationKode ) AND rel_type<>('geoobjekt'::AktivitetRelationKode ) AND rel_type<>('position'::AktivitetRelationKode ) AND rel_type<>('facilitet'::AktivitetRelationKode ) AND rel_type<>('lokale'::AktivitetRelationKode ) AND rel_type<>('aktivitetdokument'::AktivitetRelationKode ) AND rel_type<>('aktivitetgrundlag'::AktivitetRelationKode ) AND rel_type<>('aktivitetresultat'::AktivitetRelationKode ) AND rel_type<>('udfoerer'::AktivitetRelationKode ) AND rel_type<>('deltager'::AktivitetRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT aktivitet_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>''))),
    CONSTRAINT aktivitet_relation_check_aktoer_attr_rel_type CHECK (aktoer_attr IS NULL OR rel_type=('udfoerer'::AktivitetRelationKode) OR rel_type=('deltager'::AktivitetRelationKode) OR rel_type=('ansvarlig'::AktivitetRelationKode)),
    CONSTRAINT aktivitet_relation_aktoer_repr_either_uri_or_urn CHECK (aktoer_attr IS NULL OR ( _aktivitet_aktoer_attr_repr_uuid_to_text(aktoer_attr) IS NULL AND _aktivitet_aktoer_attr_repr_urn_to_text(aktoer_attr) IS NULL ) OR ((_aktivitet_aktoer_attr_repr_urn_to_text(aktoer_attr) IS NOT NULL AND _aktivitet_aktoer_attr_repr_uuid_to_text(aktoer_attr) IS NULL ) OR (_aktivitet_aktoer_attr_repr_urn_to_text(aktoer_attr) IS NULL AND _aktivitet_aktoer_attr_repr_uuid_to_text(aktoer_attr) IS NOT NULL )))
);
ALTER TABLE aktivitet_relation
  OWNER TO mox;



CREATE UNIQUE INDEX aktivitet_relation_unique_index_within_type
    ON aktivitet_relation (aktivitet_registrering_id,rel_type,rel_index)
    WHERE ( rel_type IN ('udfoererklasse'::AktivitetRelationKode,'deltagerklasse'::AktivitetRelationKode,'objektklasse'::AktivitetRelationKode,'resultatklasse'::AktivitetRelationKode,'grundlagklasse'::AktivitetRelationKode,'facilitetklasse'::AktivitetRelationKode,'adresse'::AktivitetRelationKode,'geoobjekt'::AktivitetRelationKode,'position'::AktivitetRelationKode,'facilitet'::AktivitetRelationKode,'lokale'::AktivitetRelationKode,'aktivitetdokument'::AktivitetRelationKode,'aktivitetgrundlag'::AktivitetRelationKode,'aktivitetresultat'::AktivitetRelationKode,'udfoerer'::AktivitetRelationKode,'deltager'::AktivitetRelationKode));




CREATE INDEX aktivitet_relation_idx_rel_maal_obj_uuid
    ON aktivitet_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);


CREATE INDEX aktivitet_relation_idx_repr_uuid
    ON aktivitet_relation
    USING btree
    (((aktoer_attr).repraesentation_uuid));

CREATE INDEX aktivitet_relation_idx_repr_urn
    ON aktivitet_relation
    USING btree
    (((aktoer_attr).repraesentation_urn));


CREATE INDEX aktivitet_relation_idx_rel_maal_obj_urn
    ON aktivitet_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX aktivitet_relation_idx_rel_maal_uuid
    ON aktivitet_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX aktivitet_relation_idx_rel_maal_uuid_isolated
    ON aktivitet_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX aktivitet_relation_idx_rel_maal_urn_isolated
    ON aktivitet_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX aktivitet_relation_idx_rel_maal_urn
    ON aktivitet_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX aktivitet_relation_idx_virkning_aktoerref
    ON aktivitet_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX aktivitet_relation_idx_virkning_aktoertypekode
    ON aktivitet_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX aktivitet_relation_idx_virkning_notetekst
    ON aktivitet_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX aktivitet_relation_pat_virkning_notetekst
    ON aktivitet_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr AktivitetStatusTilsType[])
  RETURNS AktivitetStatusTilsType[] AS
  $$
  DECLARE result AktivitetStatusTilsType[];
  DECLARE element AktivitetStatusTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.status IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr AktivitetPubliceretTilsType[])
  RETURNS AktivitetPubliceretTilsType[] AS
  $$
  DECLARE result AktivitetPubliceretTilsType[];
  DECLARE element AktivitetPubliceretTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.publiceret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr AktivitetEgenskaberAttrType[])
  RETURNS AktivitetEgenskaberAttrType[] AS
  $$
  DECLARE result AktivitetEgenskaberAttrType[]; 
   DECLARE element AktivitetEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.aktivitetnavn IS NULL AND element.beskrivelse IS NULL AND element.starttidspunkt IS NULL AND element.sluttidspunkt IS NULL AND element.tidsforbrug IS NULL AND element.formaal IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr AktivitetRelationType[])
RETURNS AktivitetRelationType[] AS
$$
 DECLARE result AktivitetRelationType[];
 DECLARE element AktivitetRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.indeks IS NULL AND (element.aktoerAttr IS NULL OR ((element.aktoerAttr).obligatorisk IS NULL AND (element.aktoerAttr).accepteret IS NULL AND (element.aktoerAttr).repraesentation_uuid IS NULL AND (element.aktoerAttr).repraesentation_urn IS NULL    )) AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_aktivitet_registrering(
    aktivitet_registrering
) RETURNS aktivitet_registrering AS $BODY$
  SELECT * FROM aktivitet_registrering as a WHERE
    aktivitet_id = $1.aktivitet_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_aktivitet_registrering(
    aktivitet_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS aktivitet_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    aktivitet_registrering_id bigint;
    aktivitet_registrering    aktivitet_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE aktivitet_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE aktivitet_id = aktivitet_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating aktivitet with uuid [%], Invalid [livscyklus] transition to [%]',aktivitet_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new aktivitet registrering

    aktivitet_registrering_id := nextval('aktivitet_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    aktivitet_registrering := ROW(
        aktivitet_registrering_id,
        aktivitet_uuid,
        registreringObj
    )::aktivitet_registrering;

    INSERT INTO aktivitet_registrering SELECT aktivitet_registrering.*;

    RETURN aktivitet_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of AktivitetAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_aktivitet(
    aktivitet_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber AktivitetEgenskaberAttrType[],
    

    
    tilsStatus AktivitetStatusTilsType[],
    
    tilsPubliceret AktivitetPubliceretTilsType[],
    

    relationer AktivitetRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      AktivitetRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_aktivitet          AktivitetType;
    read_prev_aktivitet         AktivitetType;
    read_new_aktivitet_reg      AktivitetRegistreringType;
    read_prev_aktivitet_reg     AktivitetRegistreringType;
    new_aktivitet_registrering  aktivitet_registrering;
    prev_aktivitet_registrering aktivitet_registrering;
    aktivitet_relation_navn     AktivitetRelationKode;

    
    attrEgenskaberObj AktivitetEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
    rel_type_max_index_prev_rev int;
    rel_type_max_index_arr _aktivitetRelationMaxIndex[];
    aktivitet_rel_type_cardinality_unlimited aktivitetRelationKode[]:=ARRAY['udfoererklasse'::AktivitetRelationKode,'deltagerklasse'::AktivitetRelationKode,'objektklasse'::AktivitetRelationKode,'resultatklasse'::AktivitetRelationKode,'grundlagklasse'::AktivitetRelationKode,'facilitetklasse'::AktivitetRelationKode,'adresse'::AktivitetRelationKode,'geoobjekt'::AktivitetRelationKode,'position'::AktivitetRelationKode,'facilitet'::AktivitetRelationKode,'lokale'::AktivitetRelationKode,'aktivitetdokument'::AktivitetRelationKode,'aktivitetgrundlag'::AktivitetRelationKode,'aktivitetresultat'::AktivitetRelationKode,'udfoerer'::AktivitetRelationKode,'deltager'::AktivitetRelationKode]::aktivitetRelationKode[];
    aktivitet_uuid_underscores text;
    aktivitet_rel_seq_name text;
    aktivitet_rel_type_cardinality_unlimited_present_in_argument aktivitetRelationKode[];
    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from aktivitet a join aktivitet_registrering b ON b.aktivitet_id=a.id WHERE a.id=aktivitet_uuid) THEN
        RAISE EXCEPTION 'Unable to update aktivitet with uuid [%], being unable to find any previous registrations.',aktivitet_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM aktivitet a WHERE a.id=aktivitet_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_aktivitet(array[aktivitet_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[aktivitet_uuid]) THEN
      RAISE EXCEPTION 'Unable to update aktivitet with uuid [%]. Object does not met stipulated criteria:%', aktivitet_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_aktivitet_registrering := _as_create_aktivitet_registrering(aktivitet_uuid, livscykluskode, brugerref, note);
    prev_aktivitet_registrering := _as_get_prev_aktivitet_registrering(new_aktivitet_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_aktivitet_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update aktivitet with uuid [%], as the aktivitet seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', aktivitet_uuid, lostUpdatePreventionTZ, LOWER((prev_aktivitet_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    
    -- Build array with the max index values of the different types of
    -- relations of the previous registration
    
    SELECT array_agg(rel_type_max_index)::_aktivitetRelationMaxIndex[] into rel_type_max_index_arr
    
    FROM
    (
        SELECT
        
        (ROW(rel_type,coalesce(max(rel_index),0))::_aktivitetRelationMaxIndex) rel_type_max_index
        
            FROM aktivitet_relation a
           WHERE a.aktivitet_registrering_id=prev_aktivitet_registrering.id
             AND a.rel_type = ANY (aktivitet_rel_type_cardinality_unlimited)
        GROUP BY rel_type
    ) AS a;

 
    ---Create temporary sequences
    
    aktivitet_uuid_underscores:=replace(aktivitet_uuid::text, '-', '_');
    

    SELECT array_agg(DISTINCT a.RelType) INTO aktivitet_rel_type_cardinality_unlimited_present_in_argument FROM unnest(relationer) a WHERE a.RelType = ANY (aktivitet_rel_type_cardinality_unlimited);
    

    IF coalesce(array_length(aktivitet_rel_type_cardinality_unlimited_present_in_argument, 1), 0) > 0 THEN
        FOREACH aktivitet_relation_navn IN ARRAY (aktivitet_rel_type_cardinality_unlimited_present_in_argument) LOOP
            aktivitet_rel_seq_name := 'aktivitet_' || aktivitet_relation_navn::text || aktivitet_uuid_underscores;

            rel_type_max_index_prev_rev := null;

            SELECT a.indeks into rel_type_max_index_prev_rev
              FROM unnest(rel_type_max_index_arr) a(relType,indeks)
             WHERE a.relType=aktivitet_relation_navn;

            IF rel_type_max_index_prev_rev IS NULL THEN
              rel_type_max_index_prev_rev := 0;
            END IF;

            EXECUTE 'CREATE TEMPORARY SEQUENCE ' || aktivitet_rel_seq_name || '
            INCREMENT 1
            MINVALUE 1
            MAXVALUE 9223372036854775807
            START ' ||  (rel_type_max_index_prev_rev+1)::text ||'
            CACHE 1;';

        END LOOP;
    END IF;
    

    INSERT INTO aktivitet_relation (aktivitet_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type , rel_index, aktoer_attr )
    SELECT
        new_aktivitet_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType ,
            CASE WHEN a.relType = ANY (aktivitet_rel_type_cardinality_unlimited) THEN
                CASE WHEN a.indeks IS NULL
                    OR b.id IS NULL THEN
                    -- For new relations and relations with index given that
                    -- is not found in prev registrering, we'll assign new
                    -- index values.
                    nextval('aktivitet_' || a.relType::text || aktivitet_uuid_underscores)
                ELSE
                    a.indeks
                END
            ELSE
                NULL
            END,
            CASE WHEN a.relType = ('udfoerer'::AktivitetRelationKode)
                OR rel_type = ('deltager'::AktivitetRelationKode)
                OR rel_type = ('ansvarlig'::AktivitetRelationKode)
                AND NOT (a.aktoerAttr IS NULL)
                AND ((a.aktoerAttr).obligatorisk IS NOT NULL
                    OR (a.aktoerAttr).accepteret IS NOT NULL
                    OR ((a.aktoerAttr).repraesentation_uuid IS NOT NULL
                        OR ((a.aktoerAttr).repraesentation_urn IS NOT NULL
                            AND (a.aktoerAttr).repraesentation_urn <> ''))) THEN
                a.aktoerAttr
            ELSE
                NULL
            END 
        FROM
            unnest(relationer) AS a 
        LEFT JOIN aktivitet_relation b ON a.relType = ANY (aktivitet_rel_type_cardinality_unlimited) AND b.aktivitet_registrering_id = prev_aktivitet_registrering.id AND a.relType = b.rel_type AND a.indeks = b.rel_index ;

    
    -- Drop temporary sequences
    IF coalesce(array_length(aktivitet_rel_type_cardinality_unlimited_present_in_argument, 1), 0) > 0 THEN
        
        FOREACH aktivitet_relation_navn IN ARRAY (aktivitet_rel_type_cardinality_unlimited_present_in_argument)
        
        LOOP
          aktivitet_rel_seq_name := 'aktivitet_' || aktivitet_relation_navn::text || aktivitet_uuid_underscores;
          EXECUTE 'DROP SEQUENCE ' || aktivitet_rel_seq_name || ';';
        END LOOP;
    END IF;
    


    -- Ad 2)
    -- 0..1 relations

    
    -- Please notice, that for 0..1 relations for aktivitet, we're ignoring index
    -- here, and handling it the same way, that is done for other object types (like
    -- Facet, Klasse etc). That is, you only make changes for the
    -- virkningsperiod that you explicitly specify (unless you delete all relations)
    
    
    FOREACH aktivitet_relation_navn IN ARRAY ARRAY['aktivitetstype'::AktivitetRelationKode ,  'emne'::AktivitetRelationKode ,  'foelsomhedklasse'::AktivitetRelationKode ,  'ansvarligklasse'::AktivitetRelationKode ,  'rekvirentklasse'::AktivitetRelationKode ,  'ansvarlig'::AktivitetRelationKode ,  'tilhoerer'::AktivitetRelationKode  ]::AktivitetRelationKode[]  LOOP
        INSERT INTO aktivitet_relation (aktivitet_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type , rel_index, aktoer_attr )
        SELECT
            new_aktivitet_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type ,
                NULL, -- a.rel_index, rel_index is not to be used for 0..1 relations
                a.aktoer_attr 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM aktivitet_relation b
                 WHERE b.aktivitet_registrering_id = new_aktivitet_registrering.id AND b.rel_type = aktivitet_relation_navn) d
            JOIN aktivitet_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.aktivitet_registrering_id = prev_aktivitet_registrering.id AND a.rel_type = aktivitet_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
                    INSERT INTO aktivitet_relation (aktivitet_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type , rel_index, aktoer_attr )
                    SELECT
                        new_aktivitet_registrering.id,  a.virkning, a.rel_maal_uuid, a.rel_maal_urn, a.rel_type, a.objekt_type, a.rel_index, a.aktoer_attr
                        FROM aktivitet_relation a
                        LEFT JOIN aktivitet_relation b ON b.aktivitet_registrering_id = new_aktivitet_registrering.id AND b.rel_type = a.rel_type AND b.rel_index = a.rel_index
                    WHERE
                        a.aktivitet_registrering_id = prev_aktivitet_registrering.id AND a.rel_type = ANY (aktivitet_rel_type_cardinality_unlimited) AND b.id IS NULL
                        -- Don't transfer relations of prev. registrering, if
                        -- the index was specified in data given to the/this
                        -- update-function
                        ;

    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsStatus IS NOT NULL AND coalesce(array_length(tilsStatus, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Status] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- aktivitet_tils_status

        -- Ad 1)
        INSERT INTO aktivitet_tils_status(virkning, status, aktivitet_registrering_id)
             SELECT a.virkning, a.status, new_aktivitet_registrering.id
               FROM unnest(tilsStatus) AS a;

        -- Ad 2
        INSERT INTO aktivitet_tils_status(virkning, status, aktivitet_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.status,
            new_aktivitet_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- aktivitet_tils_status of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- aktivitet_tils_status of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM aktivitet_tils_status b
             WHERE b.aktivitet_registrering_id = new_aktivitet_registrering.id) d
              JOIN aktivitet_tils_status a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.aktivitet_registrering_id = prev_aktivitet_registrering.id;
    END IF;
    
    IF tilsPubliceret IS NOT NULL AND coalesce(array_length(tilsPubliceret, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Publiceret] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- aktivitet_tils_publiceret

        -- Ad 1)
        INSERT INTO aktivitet_tils_publiceret(virkning, publiceret, aktivitet_registrering_id)
             SELECT a.virkning, a.publiceret, new_aktivitet_registrering.id
               FROM unnest(tilsPubliceret) AS a;

        -- Ad 2
        INSERT INTO aktivitet_tils_publiceret(virkning, publiceret, aktivitet_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.publiceret,
            new_aktivitet_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- aktivitet_tils_publiceret of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- aktivitet_tils_publiceret of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM aktivitet_tils_publiceret b
             WHERE b.aktivitet_registrering_id = new_aktivitet_registrering.id) d
              JOIN aktivitet_tils_publiceret a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.aktivitet_registrering_id = prev_aktivitet_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- aktivitet_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrAktivitetObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.aktivitetnavn,a.beskrivelse,a.starttidspunkt,a.sluttidspunkt,a.tidsforbrug,a.formaal,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update aktivitet with uuid [%], as the aktivitet have overlapping virknings in the given egenskaber array :%', aktivitet_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).aktivitetnavn IS NULL  OR  (attrEgenskaberObj).beskrivelse IS NULL  OR  (attrEgenskaberObj).starttidspunkt IS NULL  OR  (attrEgenskaberObj).sluttidspunkt IS NULL  OR  (attrEgenskaberObj).tidsforbrug IS NULL  OR  (attrEgenskaberObj).formaal IS NULL  THEN
            
            INSERT INTO aktivitet_attr_egenskaber ( brugervendtnoegle,aktivitetnavn,beskrivelse,starttidspunkt,sluttidspunkt,tidsforbrug,formaal, virkning, aktivitet_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.aktivitetnavn, a.aktivitetnavn),
                    
                        
                        
                            coalesce(attrEgenskaberObj.beskrivelse, a.beskrivelse),
                    
                        
                        
                            CASE WHEN ((attrEgenskaberObj.starttidspunkt).cleared) THEN
                                NULL
                            ELSE
                                coalesce((attrEgenskaberObj.starttidspunkt).value, a.starttidspunkt)
                            END,
                        
                    
                        
                        
                            CASE WHEN ((attrEgenskaberObj.sluttidspunkt).cleared) THEN
                                NULL
                            ELSE
                                coalesce((attrEgenskaberObj.sluttidspunkt).value, a.sluttidspunkt)
                            END,
                        
                    
                        
                        
                            CASE WHEN ((attrEgenskaberObj.tidsforbrug).cleared) THEN
                                NULL
                            ELSE
                                coalesce((attrEgenskaberObj.tidsforbrug).value, a.tidsforbrug)
                            END,
                        
                    
                        
                        
                            coalesce(attrEgenskaberObj.formaal, a.formaal),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_aktivitet_registrering.id
                        FROM aktivitet_attr_egenskaber a
                    WHERE
                        a.aktivitet_registrering_id = prev_aktivitet_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO aktivitet_attr_egenskaber ( brugervendtnoegle,aktivitetnavn,beskrivelse,starttidspunkt,sluttidspunkt,tidsforbrug,formaal, virkning, aktivitet_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.aktivitetnavn,
                    
                     attrEgenskaberObj.beskrivelse,
                    
                     attrEgenskaberObj.starttidspunkt,
                    
                     attrEgenskaberObj.sluttidspunkt,
                    
                     attrEgenskaberObj.tidsforbrug,
                    
                     attrEgenskaberObj.formaal,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_aktivitet_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the aktivitet_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM aktivitet_attr_egenskaber b
                    WHERE b.aktivitet_registrering_id = new_aktivitet_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO aktivitet_attr_egenskaber ( brugervendtnoegle,aktivitetnavn,beskrivelse,starttidspunkt,sluttidspunkt,tidsforbrug,formaal, virkning, aktivitet_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.aktivitetnavn,  attrEgenskaberObj.beskrivelse,  attrEgenskaberObj.starttidspunkt,  attrEgenskaberObj.sluttidspunkt,  attrEgenskaberObj.tidsforbrug,  attrEgenskaberObj.formaal, attrEgenskaberObj.virkning, new_aktivitet_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO aktivitet_attr_egenskaber ( brugervendtnoegle,aktivitetnavn,beskrivelse,starttidspunkt,sluttidspunkt,tidsforbrug,formaal, virkning, aktivitet_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.aktivitetnavn,
        
            a.beskrivelse,
        
            a.starttidspunkt,
        
            a.sluttidspunkt,
        
            a.tidsforbrug,
        
            a.formaal,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_aktivitet_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- aktivitet_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- aktivitet_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                aktivitet_attr_egenskaber b
            WHERE
                b.aktivitet_registrering_id = new_aktivitet_registrering.id) d
            JOIN aktivitet_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.aktivitet_registrering_id = prev_aktivitet_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_aktivitet := as_read_aktivitet(aktivitet_uuid, (new_aktivitet_registrering.registrering).timeperiod, null);
    read_prev_aktivitet := as_read_aktivitet(aktivitet_uuid, (prev_aktivitet_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_aktivitet.registrering[1].registrering).TimePeriod) = lower((new_aktivitet_registrering.registrering).TimePeriod) and lower((read_prev_aktivitet.registrering[1].registrering).TimePeriod)=lower((prev_aktivitet_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating aktivitet with id [%]: The ordering of as_list_aktivitet should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', aktivitet_uuid, to_json(new_aktivitet_registrering), to_json(read_new_aktivitet.registrering[1].registrering), to_json(prev_aktivitet_registrering), to_json(prev_new_aktivitet.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_aktivitet_reg := ROW(
        ROW (null, (read_new_aktivitet.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_aktivitet.registrering[1]).tilsStatus ,
        (read_new_aktivitet.registrering[1]).tilsPubliceret ,
        
        (read_new_aktivitet.registrering[1]).attrEgenskaber ,
        (read_new_aktivitet.registrering[1]).relationer
    )::aktivitetRegistreringType;

    read_prev_aktivitet_reg := ROW(
        ROW(null, (read_prev_aktivitet.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_aktivitet.registrering[1]).tilsStatus ,
        (read_prev_aktivitet.registrering[1]).tilsPubliceret ,
        
        (read_prev_aktivitet.registrering[1]).attrEgenskaber ,
        (read_prev_aktivitet.registrering[1]).relationer
    )::aktivitetRegistreringType;


    IF read_prev_aktivitet_reg = read_new_aktivitet_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_aktivitet_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_aktivitet_reg);
      RAISE EXCEPTION 'Aborted updating aktivitet with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', aktivitet_uuid, to_json(read_new_aktivitet_reg), to_json(read_prev_aktivitet_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_aktivitet_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_aktivitet (
    aktivitet_registrering AktivitetRegistreringType,
    aktivitet_uuid uuid DEFAULT NULL, auth_criteria_arr
    AktivitetRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE aktivitet_registrering_id bigint;

    
    aktivitet_attr_egenskaber_obj aktivitetEgenskaberAttrType;
    

    
    aktivitet_tils_status_obj aktivitetStatusTilsType;
    
    aktivitet_tils_publiceret_obj aktivitetPubliceretTilsType;
    

    aktivitet_relationer AktivitetRelationType;

    

    auth_filtered_uuids uuid[];

    
    aktivitet_relation_kode aktivitetRelationKode;
    aktivitet_uuid_underscores text;
    aktivitet_rel_seq_name text;
    aktivitet_rel_type_cardinality_unlimited aktivitetRelationKode[]:=ARRAY['udfoererklasse'::AktivitetRelationKode,'deltagerklasse'::AktivitetRelationKode,'objektklasse'::AktivitetRelationKode,'resultatklasse'::AktivitetRelationKode,'grundlagklasse'::AktivitetRelationKode,'facilitetklasse'::AktivitetRelationKode,'adresse'::AktivitetRelationKode,'geoobjekt'::AktivitetRelationKode,'position'::AktivitetRelationKode,'facilitet'::AktivitetRelationKode,'lokale'::AktivitetRelationKode,'aktivitetdokument'::AktivitetRelationKode,'aktivitetgrundlag'::AktivitetRelationKode,'aktivitetresultat'::AktivitetRelationKode,'udfoerer'::AktivitetRelationKode,'deltager'::AktivitetRelationKode]::aktivitetRelationKode[];
    aktivitet_rel_type_cardinality_unlimited_present_in_argument aktivitetRelationKode[];
    

    does_exist boolean;
    new_aktivitet_registrering aktivitet_registrering;
BEGIN
    IF aktivitet_uuid IS NULL THEN LOOP
        aktivitet_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from aktivitet WHERE id=aktivitet_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from aktivitet WHERE id=aktivitet_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (aktivitet_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (aktivitet_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (aktivitet_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_aktivitet.',(aktivitet_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO aktivitet (ID) SELECT
        aktivitet_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        aktivitet_registrering_id:=nextval('aktivitet_registrering_id_seq');

        INSERT INTO aktivitet_registrering (id, aktivitet_id,
            registrering) SELECT aktivitet_registrering_id,
        aktivitet_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (aktivitet_registrering.registrering).livscykluskode,
        (aktivitet_registrering.registrering).brugerref,
        (aktivitet_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_aktivitet_registrering :=
            _as_create_aktivitet_registrering(aktivitet_uuid,
                (aktivitet_registrering.registrering).livscykluskode,
                (aktivitet_registrering.registrering).brugerref,
                (aktivitet_registrering.registrering).note);

            aktivitet_registrering_id := new_aktivitet_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(aktivitet_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [aktivitet]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF aktivitet_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(aktivitet_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH aktivitet_attr_egenskaber_obj IN ARRAY aktivitet_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO aktivitet_attr_egenskaber (
      
      brugervendtnoegle,
      aktivitetnavn,
      beskrivelse,
      starttidspunkt,
      sluttidspunkt,
      tidsforbrug,
      formaal,
      virkning,
      aktivitet_registrering_id
    )
    SELECT
     
     aktivitet_attr_egenskaber_obj.brugervendtnoegle,
      aktivitet_attr_egenskaber_obj.aktivitetnavn,
      aktivitet_attr_egenskaber_obj.beskrivelse,
      aktivitet_attr_egenskaber_obj.starttidspunkt,
      aktivitet_attr_egenskaber_obj.sluttidspunkt,
      aktivitet_attr_egenskaber_obj.tidsforbrug,
      aktivitet_attr_egenskaber_obj.formaal,
      aktivitet_attr_egenskaber_obj.virkning,
      aktivitet_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(aktivitet_registrering.tilsStatus, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [status] for aktivitet. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF aktivitet_registrering.tilsStatus IS NOT NULL AND coalesce(array_length(aktivitet_registrering.tilsStatus,1),0)>0 THEN
  FOREACH aktivitet_tils_status_obj IN ARRAY aktivitet_registrering.tilsStatus
  LOOP

    INSERT INTO aktivitet_tils_status (
      virkning,
      status,
      aktivitet_registrering_id
    )
    SELECT
      aktivitet_tils_status_obj.virkning,
      aktivitet_tils_status_obj.status,
      aktivitet_registrering_id;

  END LOOP;
END IF;

--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(aktivitet_registrering.tilsPubliceret, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [publiceret] for aktivitet. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF aktivitet_registrering.tilsPubliceret IS NOT NULL AND coalesce(array_length(aktivitet_registrering.tilsPubliceret,1),0)>0 THEN
  FOREACH aktivitet_tils_publiceret_obj IN ARRAY aktivitet_registrering.tilsPubliceret
  LOOP

    INSERT INTO aktivitet_tils_publiceret (
      virkning,
      publiceret,
      aktivitet_registrering_id
    )
    SELECT
      aktivitet_tils_publiceret_obj.virkning,
      aktivitet_tils_publiceret_obj.publiceret,
      aktivitet_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations


IF coalesce(array_length(aktivitet_registrering.relationer,1),0)>0 THEN

--Create temporary sequences
aktivitet_uuid_underscores:=replace(aktivitet_uuid::text, '-', '_');

SELECT array_agg(DISTINCT a.RelType) into aktivitet_rel_type_cardinality_unlimited_present_in_argument FROM unnest(aktivitet_registrering.relationer) a WHERE a.RelType = any (aktivitet_rel_type_cardinality_unlimited) ;
IF coalesce(array_length(aktivitet_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN

FOREACH aktivitet_relation_kode IN ARRAY (aktivitet_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  aktivitet_rel_seq_name := 'aktivitet_' || aktivitet_relation_kode::text || aktivitet_uuid_underscores;

  EXECUTE 'CREATE TEMPORARY SEQUENCE ' || aktivitet_rel_seq_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START 1
  CACHE 1;';

END LOOP;
END IF;


    INSERT INTO aktivitet_relation (
      aktivitet_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type,
      rel_index,
      aktoer_attr
    )
    SELECT
      aktivitet_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType,
      CASE WHEN a.relType = any (aktivitet_rel_type_cardinality_unlimited) THEN --rel_index
      nextval('aktivitet_' || a.relType::text || aktivitet_uuid_underscores)
      ELSE 
      NULL
      END,
      CASE 
        WHEN a.relType =('udfoerer'::AktivitetRelationKode)  OR a.relType=('deltager'::AktivitetRelationKode) OR a.relType=('ansvarlig'::AktivitetRelationKode) 
        AND NOT (a.aktoerAttr IS NULL)
        AND (
          (a.aktoerAttr).obligatorisk IS NOT NULL
          OR
          (a.aktoerAttr).accepteret IS NOT NULL
          OR
            (
              (a.aktoerAttr).repraesentation_uuid IS NOT NULL
              OR
              ((a.aktoerAttr).repraesentation_urn IS NOT NULL AND (a.aktoerAttr).repraesentation_urn<>'')
            )
          ) 
        THEN a.aktoerAttr
        ELSE
        NULL
      END
      
    FROM unnest(aktivitet_registrering.relationer) a
  ;



--Drop temporary sequences
IF coalesce(array_length(aktivitet_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH aktivitet_relation_kode IN ARRAY (aktivitet_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  aktivitet_rel_seq_name := 'aktivitet_' || aktivitet_relation_kode::text || aktivitet_uuid_underscores;
  EXECUTE 'DROP SEQUENCE ' || aktivitet_rel_seq_name || ';';
END LOOP;
END IF;


END IF;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_aktivitet(array[aktivitet_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[aktivitet_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import aktivitet with uuid [%]. Object does not met stipulated criteria:%',aktivitet_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN aktivitet_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_aktivitet(aktivitet_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr AktivitetRegistreringType[]=null
  )
  RETURNS AktivitetType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result AktivitetType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_aktivitet(aktivitet_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(aktivitet_uuids,1),0) AND auth_filtered_uuids @>aktivitet_uuids) THEN
  RAISE EXCEPTION 'Unable to list aktivitet with uuids [%]. All objects do not fullfill the stipulated criteria:%',aktivitet_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.aktivitetObj) into result
FROM
(
SELECT
ROW(
	a.aktivitet_id,
	array_agg(
		ROW (
			a.registrering,
			a.AktivitetTilsStatusArr,
			a.AktivitetTilsPubliceretArr,
			a.AktivitetAttrEgenskaberArr,
			a.AktivitetRelationArr
		)::AktivitetRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: AktivitetType  aktivitetObj
FROM
(
	SELECT
	a.aktivitet_id,
	a.aktivitet_registrering_id,
	a.registrering,
	a.AktivitetAttrEgenskaberArr,
	a.AktivitetTilsStatusArr,
	a.AktivitetTilsPubliceretArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type,
                b.rel_index,
                b.aktoer_attr
			):: AktivitetRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.rel_index,b.aktoer_attr,b.virkning
        
	)) AktivitetRelationArr
	FROM
	(
			SELECT
			a.aktivitet_id,
			a.aktivitet_registrering_id,
			a.registrering,
			a.AktivitetAttrEgenskaberArr,
			a.AktivitetTilsPubliceretArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.status
						) ::AktivitetStatusTilsType
					ELSE NULL
					END
					order by b.status,b.virkning
				)) AktivitetTilsStatusArr		
			FROM
			(
			SELECT
			a.aktivitet_id,
			a.aktivitet_registrering_id,
			a.registrering,
			a.AktivitetAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.publiceret
						) ::AktivitetPubliceretTilsType
					ELSE NULL
					END
					order by b.publiceret,b.virkning
				)) AktivitetTilsPubliceretArr		
			FROM
			(
					SELECT
					a.aktivitet_id,
					a.aktivitet_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.aktivitetnavn,
					 		b.beskrivelse,
					 		b.starttidspunkt,
					 		b.sluttidspunkt,
					 		b.tidsforbrug,
					 		b.formaal,
					   		b.virkning
                            
							)::AktivitetEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.aktivitetnavn,b.beskrivelse,b.starttidspunkt,b.sluttidspunkt,b.tidsforbrug,b.formaal,b.virkning
                        
					)) AktivitetAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id aktivitet_id,
					b.id aktivitet_registrering_id,
					b.registrering			
					FROM		aktivitet a
					JOIN 		aktivitet_registrering b 	ON b.aktivitet_id=a.id
					WHERE a.id = ANY (aktivitet_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN aktivitet_attr_egenskaber as b ON b.aktivitet_registrering_id=a.aktivitet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.aktivitet_id,
					a.aktivitet_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN aktivitet_tils_publiceret as b ON b.aktivitet_registrering_id=a.aktivitet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.aktivitet_id,
			a.aktivitet_registrering_id,
			a.registrering,
			a.AktivitetAttrEgenskaberArr	
			) as a
			LEFT JOIN aktivitet_tils_status as b ON b.aktivitet_registrering_id=a.aktivitet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.aktivitet_id,
			a.aktivitet_registrering_id,
			a.registrering,
			a.AktivitetAttrEgenskaberArr,
			a.AktivitetTilsPubliceretArr
	) as a
	LEFT JOIN aktivitet_relation b ON b.aktivitet_registrering_id=a.aktivitet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.aktivitet_id,
	a.aktivitet_registrering_id,
	a.registrering,
	a.AktivitetAttrEgenskaberArr,
	a.AktivitetTilsPubliceretArr,
	a.AktivitetTilsStatusArr
) as a

WHERE a.aktivitet_id IS NOT NULL
GROUP BY 
a.aktivitet_id
order by a.aktivitet_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_aktivitet(
    aktivitet_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      AktivitetRegistreringType[]=null
) RETURNS AktivitetType AS $$
DECLARE
	resArr AktivitetType[];
BEGIN
    resArr := as_list_aktivitet(ARRAY[aktivitet_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_aktivitet(
    firstResult int,--TOOD ??
    aktivitet_uuid uuid,
    registreringObj   AktivitetRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr AktivitetRegistreringType[]=null

    ,
    search_operator_greater_than_or_equal_attr_egenskaber AktivitetEgenskaberAttrType[]=null,
    search_operator_less_than_or_equal_attr_egenskaber    AktivitetEgenskaberAttrType[]=null
    

) RETURNS uuid[] AS $$
DECLARE
    aktivitet_candidates uuid[];
    aktivitet_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj AktivitetEgenskaberAttrType;

    
    tilsStatusTypeObj AktivitetStatusTilsType;
    tilsPubliceretTypeObj AktivitetPubliceretTilsType;

    relationTypeObj AktivitetRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

aktivitet_candidates_is_initialized := false;

IF aktivitet_uuid is not NULL THEN
    aktivitet_candidates:= ARRAY[aktivitet_uuid];
    aktivitet_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        aktivitet_candidates:=array(
                SELECT DISTINCT
                b.aktivitet_id
                FROM
                aktivitet a
                JOIN aktivitet_registrering b on b.aktivitet_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'aktivitet_candidates_is_initialized step 1:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 1:%',aktivitet_candidates;
--/****************************//


--RAISE NOTICE 'aktivitet_candidates_is_initialized step 2:%',aktivitet_candidates_is_initialized;
--RAISE NOTICE 'aktivitet_candidates step 2:%',aktivitet_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_aktivitet: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(aktivitet_candidates,1),0)>0 OR NOT aktivitet_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            aktivitet_candidates:=array(
            SELECT DISTINCT
            b.aktivitet_id
            FROM  aktivitet_attr_egenskaber a
            JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.aktivitetnavn IS NULL
                    OR
                    a.aktivitetnavn ILIKE attrEgenskaberTypeObj.aktivitetnavn --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.beskrivelse IS NULL
                    OR
                    a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.starttidspunkt IS NULL
                    OR
                    a.starttidspunkt = attrEgenskaberTypeObj.starttidspunkt
                )
                AND
                (
                    attrEgenskaberTypeObj.sluttidspunkt IS NULL
                    OR
                    a.sluttidspunkt = attrEgenskaberTypeObj.sluttidspunkt
                )
                AND
                (
                    attrEgenskaberTypeObj.tidsforbrug IS NULL
                    OR
                    a.tidsforbrug = attrEgenskaberTypeObj.tidsforbrug
                )
                AND
                (
                    attrEgenskaberTypeObj.formaal IS NULL
                    OR
                    a.formaal ILIKE attrEgenskaberTypeObj.formaal --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

            );


            aktivitet_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'aktivitet_candidates_is_initialized step 3:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 3:%',aktivitet_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        aktivitet_candidates:=array(

            SELECT DISTINCT
            b.aktivitet_id
            
            FROM  aktivitet_attr_egenskaber a
            JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.aktivitetnavn ILIKE anyAttrValue OR
                        a.beskrivelse ILIKE anyAttrValue OR
                                    a.starttidspunkt::text ilike anyAttrValue OR
                                    a.sluttidspunkt::text ilike anyAttrValue OR
                                    a.tidsforbrug::text ilike anyAttrValue OR
                        a.formaal ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )


        );

    aktivitet_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Status
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsStatus IS NULL THEN
    --RAISE DEBUG 'as_search_aktivitet: skipping filtration on tilsStatus';
ELSE
    IF (coalesce(array_length(aktivitet_candidates,1),0)>0 OR aktivitet_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsStatusTypeObj IN ARRAY registreringObj.tilsStatus
        LOOP
            aktivitet_candidates:=array(
            SELECT DISTINCT
            b.aktivitet_id
            FROM  aktivitet_tils_status a
            JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
            WHERE
                (
                    tilsStatusTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsStatusTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsStatusTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsStatusTypeObj.virkning).AktoerRef IS NULL OR (tilsStatusTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsStatusTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsStatusTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsStatusTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsStatusTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsStatusTypeObj.virkning) IS NULL OR (tilsStatusTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsStatusTypeObj.status IS NULL
                    OR
                    tilsStatusTypeObj.status = a.status
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

    );


            aktivitet_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;
--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
    --RAISE DEBUG 'as_search_aktivitet: skipping filtration on tilsPubliceret';
ELSE
    IF (coalesce(array_length(aktivitet_candidates,1),0)>0 OR aktivitet_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
        LOOP
            aktivitet_candidates:=array(
            SELECT DISTINCT
            b.aktivitet_id
            FROM  aktivitet_tils_publiceret a
            JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
            WHERE
                (
                    tilsPubliceretTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsPubliceretTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).AktoerRef IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsPubliceretTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsPubliceretTypeObj.virkning) IS NULL OR (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsPubliceretTypeObj.publiceret IS NULL
                    OR
                    tilsPubliceretTypeObj.publiceret = a.publiceret
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

    );


            aktivitet_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer AktivitetRelationType[]
*/


--RAISE DEBUG 'aktivitet_candidates_is_initialized step 4:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 4:%',aktivitet_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_aktivitet: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(aktivitet_candidates,1),0)>0 OR NOT aktivitet_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            aktivitet_candidates:=array(
            SELECT DISTINCT
            b.aktivitet_id
            FROM  aktivitet_relation a
            JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                AND
                (
                        relationTypeObj.indeks IS NULL
                        OR
                        relationTypeObj.indeks = a.rel_index
                )
                
                
                AND
                (
                        relationTypeObj.aktoerAttr IS NULL
                        OR
                        (
                                (
                                        (relationTypeObj.aktoerAttr).obligatorisk IS NULL
                                        OR
                                        (relationTypeObj.aktoerAttr).obligatorisk = (a.aktoer_attr).obligatorisk                                        
                                )
                                AND
                                (
                                        (relationTypeObj.aktoerAttr).accepteret IS NULL
                                        OR
                                        (relationTypeObj.aktoerAttr).accepteret = (a.aktoer_attr).accepteret
                                )
                                AND
                                (
                                        (relationTypeObj.aktoerAttr).repraesentation_uuid IS NULL
                                        OR
                                        (relationTypeObj.aktoerAttr).repraesentation_uuid = (a.aktoer_attr).repraesentation_uuid
                                )
                                AND
                                (
                                        (relationTypeObj.aktoerAttr).repraesentation_urn IS NULL
                                        OR
                                        (relationTypeObj.aktoerAttr).repraesentation_urn = (a.aktoer_attr).repraesentation_urn
                                )
                        )
                )
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

    );

            aktivitet_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        aktivitet_candidates:=array(
            SELECT DISTINCT
            b.aktivitet_id
            
            FROM  aktivitet_relation a
            JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
            WHERE
            
            (
                    anyuuid = a.rel_maal_uuid
            OR  
                    ((NOT (a.aktoer_attr IS NULL)) AND anyuuid = (a.aktoer_attr).repraesentation_uuid )
            )
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )


            );

    aktivitet_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        aktivitet_candidates:=array(
            SELECT DISTINCT
            b.aktivitet_id
            
            FROM  aktivitet_relation a
            JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
            WHERE
            
            (
            anyurn = a.rel_maal_urn
                    OR 
                   ((NOT (a.aktoer_attr IS NULL)) AND anyurn = (a.aktoer_attr).repraesentation_urn)
            )
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )


            );

    aktivitet_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 


 --/**********************************************************//
---Filtration using operator 'greather than or equal': Egenskaber
---/**********************************************************//
IF coalesce(array_length(search_operator_greater_than_or_equal_attr_egenskaber,1),0)>0 THEN
       IF (coalesce(array_length(aktivitet_candidates,1),0)>0 OR NOT aktivitet_candidates_is_initialized) THEN
               FOREACH attrEgenskaberTypeObj IN ARRAY search_operator_greater_than_or_equal_attr_egenskaber
               LOOP
                       aktivitet_candidates:=array(
                       SELECT DISTINCT
                       b.aktivitet_id 
                       FROM  aktivitet_attr_egenskaber a
                       JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
                       WHERE
                               (
                                       (
                                               attrEgenskaberTypeObj.virkning IS NULL 
                                               OR
                                               (
                                                       (
                                                               (
                                                                       (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                                               )
                                                               OR
                                                               (
                                                                       (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                                               )
                                                       )
                                                       AND
                                                       (
                                                                       (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                                                       )
                                                       AND
                                                       (
                                                                       (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                                                       )
                                                       AND
                                                       (
                                                                       (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst
                                                       )
                                               )
                                       )
                               )
                               AND
                               (
                                       (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                                       OR
                                       (
                                               virkningSoeg IS NULL
                                               OR
                                               virkningSoeg && (a.virkning).TimePeriod
                                       )
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                                       OR 
                                       a.brugervendtnoegle >= attrEgenskaberTypeObj.brugervendtnoegle 
                               )
                               
                               AND
                               (
                                       attrEgenskaberTypeObj.aktivitetnavn IS NULL
                                       OR 
                                       a.aktivitetnavn >= attrEgenskaberTypeObj.aktivitetnavn 
                               )
                               
                               AND
                               (
                                       attrEgenskaberTypeObj.beskrivelse IS NULL
                                       OR 
                                       a.beskrivelse >= attrEgenskaberTypeObj.beskrivelse 
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.starttidspunkt IS NULL
                                       OR 
                                       a.starttidspunkt >= attrEgenskaberTypeObj.starttidspunkt 
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.sluttidspunkt IS NULL
                                       OR 
                                       a.sluttidspunkt >= attrEgenskaberTypeObj.sluttidspunkt 
                               )
                               
                               AND
                               (
                                       attrEgenskaberTypeObj.tidsforbrug IS NULL
                                       OR 
                                       a.tidsforbrug >= attrEgenskaberTypeObj.tidsforbrug 
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.formaal IS NULL
                                       OR 
                                       a.formaal >= attrEgenskaberTypeObj.formaal 
                               )
                               
                               AND
                                               (
                               (registreringObj.registrering) IS NULL 
                               OR
                               (
                                       (
                                               (registreringObj.registrering).timeperiod IS NULL 
                                               OR
                                               (registreringObj.registrering).timeperiod && (b.registrering).timeperiod
                                       )
                                       AND
                                       (
                                               (registreringObj.registrering).livscykluskode IS NULL 
                                               OR
                                               (registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode                 
                                       ) 
                                       AND
                                       (
                                               (registreringObj.registrering).brugerref IS NULL
                                               OR
                                               (registreringObj.registrering).brugerref = (b.registrering).brugerref
                                       )
                                       AND
                                       (
                                               (registreringObj.registrering).note IS NULL
                                               OR
                                               (b.registrering).note ILIKE (registreringObj.registrering).note
                                       )
                       )
               )
               AND
               (
                       (
                               ((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
                               AND
                                       (
                                               (registreringObj.registrering) IS NULL 
                                               OR
                                               (registreringObj.registrering).livscykluskode IS NULL 
                                       )
                       )
                       OR
                       (
                               (NOT ((registreringObj.registrering) IS NULL))
                               AND
                               (registreringObj.registrering).livscykluskode IS NOT NULL 
                       )
               )
               AND
               (
                       (
                         (
                               (registreringObj.registrering) IS NULL
                               OR
                               (registreringObj.registrering).timeperiod IS NULL
                         )
                         AND
                         upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
                       )       
               OR
                       (
                               (NOT ((registreringObj.registrering) IS NULL))
                               AND
                               ((registreringObj.registrering).timeperiod IS NOT NULL)
                       )
               )
               AND
               ((NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

                       );
                       

                       aktivitet_candidates_is_initialized:=true;
                       
                       
                       END LOOP;
               END IF; 
       END IF;

--RAISE DEBUG 'aktivitet_candidates_is_initialized step 3:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 3:%',aktivitet_candidates;

 --/**********************************************************//
--Filtration using operator 'less than or equal': Egenskaber
--/**********************************************************//
IF coalesce(array_length(search_operator_less_than_or_equal_attr_egenskaber,1),0)>0 THEN
       IF (coalesce(array_length(aktivitet_candidates,1),0)>0 OR NOT aktivitet_candidates_is_initialized) THEN
               FOREACH attrEgenskaberTypeObj IN ARRAY search_operator_less_than_or_equal_attr_egenskaber
               LOOP
                       aktivitet_candidates:=array(
                       SELECT DISTINCT
                       b.aktivitet_id 
                       FROM  aktivitet_attr_egenskaber a
                       JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id
                       WHERE
                               (
                                       (
                                               attrEgenskaberTypeObj.virkning IS NULL 
                                               OR
                                               (
                                                       (
                                                               (
                                                                       (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                                               )
                                                               OR
                                                               (
                                                                       (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                                               )
                                                       )
                                                       AND
                                                       (
                                                                       (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                                                       )
                                                       AND
                                                       (
                                                                       (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                                                       )
                                                       AND
                                                       (
                                                                       (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                                                       )
                                               )
                                       )
                               )
                               AND
                               (
                                       (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                                       OR
                                       (
                                               virkningSoeg IS NULL
                                               OR
                                               virkningSoeg && (a.virkning).TimePeriod
                                       )
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                                       OR 
                                       a.brugervendtnoegle <= attrEgenskaberTypeObj.brugervendtnoegle 
                               )
                               
                               AND
                               (
                                       attrEgenskaberTypeObj.aktivitetnavn IS NULL
                                       OR 
                                       a.aktivitetnavn <= attrEgenskaberTypeObj.aktivitetnavn 
                               )
                               
                               AND
                               (
                                       attrEgenskaberTypeObj.beskrivelse IS NULL
                                       OR 
                                       a.beskrivelse <= attrEgenskaberTypeObj.beskrivelse 
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.starttidspunkt IS NULL
                                       OR 
                                       a.starttidspunkt <= attrEgenskaberTypeObj.starttidspunkt 
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.sluttidspunkt IS NULL
                                       OR 
                                       a.sluttidspunkt <= attrEgenskaberTypeObj.sluttidspunkt 
                               )
                               
                               AND
                               (
                                       attrEgenskaberTypeObj.tidsforbrug IS NULL
                                       OR 
                                       a.tidsforbrug <= attrEgenskaberTypeObj.tidsforbrug 
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.formaal IS NULL
                                       OR 
                                       a.formaal <= attrEgenskaberTypeObj.formaal 
                               )
                               
                               AND
                                               (
                               (registreringObj.registrering) IS NULL 
                               OR
                               (
                                       (
                                               (registreringObj.registrering).timeperiod IS NULL 
                                               OR
                                               (registreringObj.registrering).timeperiod && (b.registrering).timeperiod
                                       )
                                       AND
                                       (
                                               (registreringObj.registrering).livscykluskode IS NULL 
                                               OR
                                               (registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode                 
                                       ) 
                                       AND
                                       (
                                               (registreringObj.registrering).brugerref IS NULL
                                               OR
                                               (registreringObj.registrering).brugerref = (b.registrering).brugerref
                                       )
                                       AND
                                       (
                                               (registreringObj.registrering).note IS NULL
                                               OR
                                               (b.registrering).note ILIKE (registreringObj.registrering).note
                                       )
                       )
               )
               AND
               (
                       (
                               ((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
                               AND
                                       (
                                               (registreringObj.registrering) IS NULL 
                                               OR
                                               (registreringObj.registrering).livscykluskode IS NULL 
                                       )
                       )
                       OR
                       (
                               (NOT ((registreringObj.registrering) IS NULL))
                               AND
                               (registreringObj.registrering).livscykluskode IS NOT NULL 
                       )
               )
               AND
               (
                       (
                         (
                               (registreringObj.registrering) IS NULL
                               OR
                               (registreringObj.registrering).timeperiod IS NULL
                         )
                         AND
                         upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
                       )       
               OR
                       (
                               (NOT ((registreringObj.registrering) IS NULL))
                               AND
                               ((registreringObj.registrering).timeperiod IS NOT NULL)
                       )
               )
               AND
               ((NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

                       );
                       

                       aktivitet_candidates_is_initialized:=true;
                       
                       
                       END LOOP;
               END IF; 
       END IF;

--RAISE DEBUG 'aktivitet_candidates_is_initialized step 3:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 3:%',aktivitet_candidates;

--/**********************//



--RAISE DEBUG 'aktivitet_candidates_is_initialized step 5:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 5:%',aktivitet_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT aktivitet_candidates_is_initialized THEN
        aktivitet_candidates:=array(
        SELECT DISTINCT
            aktivitet_id
        FROM
            aktivitet_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT aktivitet_candidates_is_initialized) OR b.aktivitet_id = ANY (aktivitet_candidates) )

        )
        ;

        aktivitet_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT aktivitet_candidates_is_initialized THEN
    --No filters applied!
    aktivitet_candidates:=array(
        SELECT DISTINCT id FROM aktivitet a
    );
ELSE
    aktivitet_candidates:=array(
        SELECT DISTINCT id FROM unnest(aktivitet_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'aktivitet_candidates_is_initialized step 6:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 6:%',aktivitet_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_aktivitet(aktivitet_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_aktivitet(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_AktivitetRegistreringType_to_json(AktivitetRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END aktivitetegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsStatus,1),0)>0 THEN to_json($1.tilsStatus) 
        ELSE 
        NULL
        END aktivitetstatus
        ,
        
        CASE 
        WHEN coalesce(array_length($1.tilsPubliceret,1),0)>0 THEN to_json($1.tilsPubliceret) 
        ELSE 
        NULL
        END aktivitetpubliceret
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType,e.indeks,e.aktoerAttr)::AktivitetRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType,indeks,aktoerAttr)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (AktivitetRegistreringType as json);
create cast (AktivitetRegistreringType as json) with function actual_state._cast_AktivitetRegistreringType_to_json(AktivitetRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_aktivitetType_to_json(AktivitetType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg AktivitetRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (AktivitetType as json);
create cast (AktivitetType as json) with function actual_state._cast_aktivitetType_to_json(AktivitetType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_aktivitet(
    aktivitet_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    AktivitetRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    aktivitet_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    aktivitet_sorted_uuid:=array(
          SELECT b.aktivitet_id
            FROM aktivitet_registrering b
            JOIN aktivitet_attr_egenskaber a ON a.aktivitet_registrering_id=b.id
           WHERE b.aktivitet_id = ANY (aktivitet_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.aktivitet_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.aktivitet_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN aktivitet_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_aktivitet(
	aktivitet_uuids uuid[],
	registreringObjArr AktivitetRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	aktivitet_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	aktivitet_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj AktivitetEgenskaberAttrType;
	
  	tilsStatusTypeObj AktivitetStatusTilsType;
  	tilsPubliceretTypeObj AktivitetPubliceretTilsType;
	relationTypeObj AktivitetRelationType;
	registreringObj AktivitetRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN aktivitet_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF aktivitet_uuids IS NULL OR coalesce(array_length(aktivitet_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

aktivitet_candidates:= aktivitet_uuids;



--RAISE DEBUG 'aktivitet_candidates_is_initialized step 1:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 1:%',aktivitet_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_aktivitet: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(aktivitet_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_attr_egenskaber a 
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.aktivitetnavn IS NULL
					OR 
					a.aktivitetnavn = attrEgenskaberTypeObj.aktivitetnavn 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.starttidspunkt IS NULL
					OR 
					a.starttidspunkt = attrEgenskaberTypeObj.starttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.sluttidspunkt IS NULL
					OR 
					a.sluttidspunkt = attrEgenskaberTypeObj.sluttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.tidsforbrug IS NULL
					OR 
					a.tidsforbrug = attrEgenskaberTypeObj.tidsforbrug 
				)
				AND
				(
					attrEgenskaberTypeObj.formaal IS NULL
					OR 
					a.formaal = attrEgenskaberTypeObj.formaal 
				)
				AND b.aktivitet_id = ANY (aktivitet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'aktivitet_candidates_is_initialized step 3:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 3:%',aktivitet_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Status
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsStatus IS NULL THEN
	--RAISE DEBUG 'as_search_aktivitet: skipping filtration on tilsStatus';
ELSE
	IF coalesce(array_length(aktivitet_candidates,1),0)>0 THEN 

		FOREACH tilsStatusTypeObj IN ARRAY registreringObj.tilsStatus
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_tils_status a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsStatusTypeObj.status IS NULL
					OR
					tilsStatusTypeObj.status = a.status
				)
				AND b.aktivitet_id = ANY (aktivitet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;
--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_aktivitet: skipping filtration on tilsPubliceret';
ELSE
	IF coalesce(array_length(aktivitet_candidates,1),0)>0 THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_tils_publiceret a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND b.aktivitet_id = ANY (aktivitet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer AktivitetRelationType[]
*/


--RAISE DEBUG 'aktivitet_candidates_is_initialized step 4:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 4:%',aktivitet_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_aktivitet: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(aktivitet_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			aktivitet_candidates:=array(
			SELECT DISTINCT
			b.aktivitet_id 
			FROM  aktivitet_relation a
			JOIN aktivitet_registrering b on a.aktivitet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.aktivitet_id = ANY (aktivitet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'aktivitet_candidates_is_initialized step 5:%',aktivitet_candidates_is_initialized;
--RAISE DEBUG 'aktivitet_candidates step 5:%',aktivitet_candidates;

aktivitet_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (aktivitet_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (aktivitet_candidates) b(id)
);

--optimization 
IF coalesce(array_length(aktivitet_passed_auth_filter,1),0)=coalesce(array_length(aktivitet_uuids,1),0) AND aktivitet_passed_auth_filter @>aktivitet_uuids THEN
	RETURN aktivitet_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN aktivitet_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE BrugerGyldighedTils AS ENUM ('Aktiv','Inaktiv',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE BrugerGyldighedTilsType AS (
    virkning Virkning,
    gyldighed BrugerGyldighedTils
)
;



CREATE TYPE BrugerEgenskaberAttrType AS (
brugervendtnoegle text,
brugernavn text,
brugertype text,
integrationsdata text,

 virkning Virkning
);




CREATE TYPE BrugerRelationKode AS ENUM  ('tilhoerer','adresser','brugertyper','opgaver','tilknyttedeenheder','tilknyttedefunktioner','tilknyttedeinteressefaellesskaber','tilknyttedeorganisationer','tilknyttedepersoner','tilknyttedeitsystemer');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_bruger_relation_kode_to_txt is invoked.



CREATE TYPE BrugerRelationType AS (
  relType BrugerRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text
)
;



CREATE TYPE BrugerRegistreringType AS
(
registrering RegistreringBase,
tilsGyldighed BrugerGyldighedTilsType[],
attrEgenskaber BrugerEgenskaberAttrType[],
relationer BrugerRelationType[]
);

CREATE TYPE BrugerType AS
(
  id uuid,
  registrering BrugerRegistreringType[]
);  





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_bruger_relation_kode_to_txt(
    BrugerRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE bruger (
    id uuid NOT NULL,
    CONSTRAINT bruger_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE bruger
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE bruger_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE bruger_registrering_id_seq
    OWNER TO mox;


CREATE TABLE bruger_registrering (
   id bigint NOT NULL DEFAULT nextval('bruger_registrering_id_seq'::regclass),
   bruger_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT bruger_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT bruger_registrering_bruger_fkey FOREIGN KEY (bruger_id)
       REFERENCES bruger (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT bruger_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(bruger_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE bruger_registrering
  OWNER TO mox;


CREATE INDEX bruger_registrering_idx_livscykluskode
    ON bruger_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX bruger_registrering_idx_brugerref
    ON bruger_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX bruger_registrering_idx_note
    ON bruger_registrering
    USING btree
    (((registrering).note));


CREATE INDEX bruger_registrering_pat_note
    ON bruger_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX bruger_id_idx
    ON bruger_registrering (bruger_id);


CREATE TRIGGER notify_bruger
    AFTER INSERT OR UPDATE OR DELETE ON bruger_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE bruger_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE bruger_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE bruger_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('bruger_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        brugernavn text  NULL,
        brugertype text  NULL,
        integrationsdata text  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    bruger_registrering_id bigint NOT NULL,
    CONSTRAINT bruger_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT bruger_attr_egenskaber_forkey_brugerregistrering FOREIGN KEY (bruger_registrering_id) REFERENCES bruger_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT bruger_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (bruger_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE bruger_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX bruger_attr_egenskaber_pat_brugervendtnoegle
            ON bruger_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX bruger_attr_egenskaber_idx_brugervendtnoegle
            ON bruger_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX bruger_attr_egenskaber_pat_brugernavn
            ON bruger_attr_egenskaber
            USING gin
            (brugernavn gin_trgm_ops);

        CREATE INDEX bruger_attr_egenskaber_idx_brugernavn
            ON bruger_attr_egenskaber
            USING btree
            (brugernavn); 
 
     
        CREATE INDEX bruger_attr_egenskaber_pat_brugertype
            ON bruger_attr_egenskaber
            USING gin
            (brugertype gin_trgm_ops);

        CREATE INDEX bruger_attr_egenskaber_idx_brugertype
            ON bruger_attr_egenskaber
            USING btree
            (brugertype); 
 
     
        CREATE INDEX bruger_attr_egenskaber_pat_integrationsdata
            ON bruger_attr_egenskaber
            USING gin
            (integrationsdata gin_trgm_ops);

        CREATE INDEX bruger_attr_egenskaber_idx_integrationsdata
            ON bruger_attr_egenskaber
            USING btree
            (integrationsdata); 



CREATE INDEX bruger_attr_egenskaber_idx_virkning_aktoerref
    ON bruger_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX bruger_attr_egenskaber_idx_virkning_aktoertypekode
    ON bruger_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX bruger_attr_egenskaber_idx_virkning_notetekst
    ON bruger_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX bruger_attr_egenskaber_pat_virkning_notetekst
    ON bruger_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE bruger_tils_gyldighed_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE bruger_tils_gyldighed_id_seq
    OWNER TO mox;


CREATE TABLE bruger_tils_gyldighed (
    id bigint NOT NULL DEFAULT nextval('bruger_tils_gyldighed_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    gyldighed BrugerGyldighedTils NOT NULL, 
    bruger_registrering_id bigint not null,
    CONSTRAINT bruger_tils_gyldighed_pkey PRIMARY KEY (id),
    CONSTRAINT bruger_tils_gyldighed_forkey_brugerregistrering FOREIGN KEY (bruger_registrering_id) REFERENCES bruger_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT bruger_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (bruger_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE bruger_tils_gyldighed
    OWNER TO mox;


CREATE INDEX bruger_tils_gyldighed_idx_gyldighed
    ON bruger_tils_gyldighed
    USING btree
    (gyldighed);
  
CREATE INDEX bruger_tils_gyldighed_idx_virkning_aktoerref
    ON bruger_tils_gyldighed
    USING btree
    (((virkning).aktoerref));

CREATE INDEX bruger_tils_gyldighed_idx_virkning_aktoertypekode
    ON bruger_tils_gyldighed
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX bruger_tils_gyldighed_idx_virkning_notetekst
    ON bruger_tils_gyldighed
    USING btree
    (((virkning).notetekst));

CREATE INDEX bruger_tils_gyldighed_pat_virkning_notetekst
    ON bruger_tils_gyldighed
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE bruger_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE bruger_relation_id_seq
    OWNER TO mox;


CREATE TABLE bruger_relation (
    id bigint NOT NULL DEFAULT nextval('bruger_relation_id_seq'::regclass),
    bruger_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type BrugerRelationKode not null,
    objekt_type text null,

    

    CONSTRAINT bruger_relation_forkey_brugerregistrering FOREIGN KEY (bruger_registrering_id) REFERENCES bruger_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT bruger_relation_pkey PRIMARY KEY (id),
    CONSTRAINT bruger_relation_no_virkning_overlap EXCLUDE USING gist (bruger_registrering_id WITH =, _as_convert_bruger_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('adresser'::BrugerRelationKode ) AND rel_type<>('brugertyper'::BrugerRelationKode ) AND rel_type<>('opgaver'::BrugerRelationKode ) AND rel_type<>('tilknyttedeenheder'::BrugerRelationKode ) AND rel_type<>('tilknyttedefunktioner'::BrugerRelationKode ) AND rel_type<>('tilknyttedeinteressefaellesskaber'::BrugerRelationKode ) AND rel_type<>('tilknyttedeorganisationer'::BrugerRelationKode ) AND rel_type<>('tilknyttedepersoner'::BrugerRelationKode ) AND rel_type<>('tilknyttedeitsystemer'::BrugerRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT bruger_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE bruger_relation
  OWNER TO mox;





CREATE INDEX bruger_relation_idx_rel_maal_obj_uuid
    ON bruger_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX bruger_relation_idx_rel_maal_obj_urn
    ON bruger_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX bruger_relation_idx_rel_maal_uuid
    ON bruger_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX bruger_relation_idx_rel_maal_uuid_isolated
    ON bruger_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX bruger_relation_idx_rel_maal_urn_isolated
    ON bruger_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX bruger_relation_idx_rel_maal_urn
    ON bruger_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX bruger_relation_idx_virkning_aktoerref
    ON bruger_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX bruger_relation_idx_virkning_aktoertypekode
    ON bruger_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX bruger_relation_idx_virkning_notetekst
    ON bruger_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX bruger_relation_pat_virkning_notetekst
    ON bruger_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr BrugerGyldighedTilsType[])
  RETURNS BrugerGyldighedTilsType[] AS
  $$
  DECLARE result BrugerGyldighedTilsType[];
  DECLARE element BrugerGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr BrugerEgenskaberAttrType[])
  RETURNS BrugerEgenskaberAttrType[] AS
  $$
  DECLARE result BrugerEgenskaberAttrType[]; 
   DECLARE element BrugerEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.brugernavn IS NULL AND element.brugertype IS NULL AND element.integrationsdata IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr BrugerRelationType[])
RETURNS BrugerRelationType[] AS
$$
 DECLARE result BrugerRelationType[];
 DECLARE element BrugerRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_bruger_registrering(
    bruger_registrering
) RETURNS bruger_registrering AS $BODY$
  SELECT * FROM bruger_registrering as a WHERE
    bruger_id = $1.bruger_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_bruger_registrering(
    bruger_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS bruger_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    bruger_registrering_id bigint;
    bruger_registrering    bruger_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE bruger_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE bruger_id = bruger_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating bruger with uuid [%], Invalid [livscyklus] transition to [%]',bruger_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new bruger registrering

    bruger_registrering_id := nextval('bruger_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    bruger_registrering := ROW(
        bruger_registrering_id,
        bruger_uuid,
        registreringObj
    )::bruger_registrering;

    INSERT INTO bruger_registrering SELECT bruger_registrering.*;

    RETURN bruger_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of BrugerAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_bruger(
    bruger_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber BrugerEgenskaberAttrType[],
    

    
    tilsGyldighed BrugerGyldighedTilsType[],
    

    relationer BrugerRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      BrugerRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_bruger          BrugerType;
    read_prev_bruger         BrugerType;
    read_new_bruger_reg      BrugerRegistreringType;
    read_prev_bruger_reg     BrugerRegistreringType;
    new_bruger_registrering  bruger_registrering;
    prev_bruger_registrering bruger_registrering;
    bruger_relation_navn     BrugerRelationKode;

    
    attrEgenskaberObj BrugerEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from bruger a join bruger_registrering b ON b.bruger_id=a.id WHERE a.id=bruger_uuid) THEN
        RAISE EXCEPTION 'Unable to update bruger with uuid [%], being unable to find any previous registrations.',bruger_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM bruger a WHERE a.id=bruger_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_bruger(array[bruger_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[bruger_uuid]) THEN
      RAISE EXCEPTION 'Unable to update bruger with uuid [%]. Object does not met stipulated criteria:%', bruger_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_bruger_registrering := _as_create_bruger_registrering(bruger_uuid, livscykluskode, brugerref, note);
    prev_bruger_registrering := _as_get_prev_bruger_registrering(new_bruger_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_bruger_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update bruger with uuid [%], as the bruger seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', bruger_uuid, lostUpdatePreventionTZ, LOWER((prev_bruger_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    

    INSERT INTO bruger_relation (bruger_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
    SELECT
        new_bruger_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType 
        FROM
            unnest(relationer) AS a ;

    


    -- Ad 2)
    -- 0..1 relations

    
    
    FOREACH bruger_relation_navn IN ARRAY ARRAY['tilhoerer'::BrugerRelationKode  ]::BrugerRelationKode[]  LOOP
        INSERT INTO bruger_relation (bruger_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
        SELECT
            new_bruger_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM bruger_relation b
                 WHERE b.bruger_registrering_id = new_bruger_registrering.id AND b.rel_type = bruger_relation_navn) d
            JOIN bruger_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.bruger_registrering_id = prev_bruger_registrering.id AND a.rel_type = bruger_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
    FOREACH bruger_relation_navn IN ARRAY ARRAY['adresser'::BrugerRelationKode, 'brugertyper'::BrugerRelationKode, 'opgaver'::BrugerRelationKode, 'tilknyttedeenheder'::BrugerRelationKode, 'tilknyttedefunktioner'::BrugerRelationKode, 'tilknyttedeinteressefaellesskaber'::BrugerRelationKode, 'tilknyttedeorganisationer'::BrugerRelationKode, 'tilknyttedepersoner'::BrugerRelationKode, 'tilknyttedeitsystemer'::BrugerRelationKode]::BrugerRelationKode[] LOOP
        IF NOT EXISTS (
                    SELECT 1
                      FROM bruger_relation
                     WHERE bruger_registrering_id = new_bruger_registrering.id AND rel_type = bruger_relation_navn) THEN
                    
                    INSERT INTO bruger_relation (bruger_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
                    SELECT
                        new_bruger_registrering.id,  virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type
        FROM bruger_relation
        WHERE
            bruger_registrering_id = prev_bruger_registrering.id AND rel_type = bruger_relation_navn ;

    
        END IF;
    END LOOP;
    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- bruger_tils_gyldighed

        -- Ad 1)
        INSERT INTO bruger_tils_gyldighed(virkning, gyldighed, bruger_registrering_id)
             SELECT a.virkning, a.gyldighed, new_bruger_registrering.id
               FROM unnest(tilsGyldighed) AS a;

        -- Ad 2
        INSERT INTO bruger_tils_gyldighed(virkning, gyldighed, bruger_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.gyldighed,
            new_bruger_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- bruger_tils_gyldighed of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- bruger_tils_gyldighed of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM bruger_tils_gyldighed b
             WHERE b.bruger_registrering_id = new_bruger_registrering.id) d
              JOIN bruger_tils_gyldighed a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.bruger_registrering_id = prev_bruger_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- bruger_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrBrugerObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.brugernavn,a.brugertype,a.integrationsdata,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update bruger with uuid [%], as the bruger have overlapping virknings in the given egenskaber array :%', bruger_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).brugernavn IS NULL  OR  (attrEgenskaberObj).brugertype IS NULL  OR  (attrEgenskaberObj).integrationsdata IS NULL  THEN
            
            INSERT INTO bruger_attr_egenskaber ( brugervendtnoegle,brugernavn,brugertype,integrationsdata, virkning, bruger_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugernavn, a.brugernavn),
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugertype, a.brugertype),
                    
                        
                        
                            coalesce(attrEgenskaberObj.integrationsdata, a.integrationsdata),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_bruger_registrering.id
                        FROM bruger_attr_egenskaber a
                    WHERE
                        a.bruger_registrering_id = prev_bruger_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO bruger_attr_egenskaber ( brugervendtnoegle,brugernavn,brugertype,integrationsdata, virkning, bruger_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.brugernavn,
                    
                     attrEgenskaberObj.brugertype,
                    
                     attrEgenskaberObj.integrationsdata,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_bruger_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the bruger_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM bruger_attr_egenskaber b
                    WHERE b.bruger_registrering_id = new_bruger_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO bruger_attr_egenskaber ( brugervendtnoegle,brugernavn,brugertype,integrationsdata, virkning, bruger_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.brugernavn,  attrEgenskaberObj.brugertype,  attrEgenskaberObj.integrationsdata, attrEgenskaberObj.virkning, new_bruger_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO bruger_attr_egenskaber ( brugervendtnoegle,brugernavn,brugertype,integrationsdata, virkning, bruger_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.brugernavn,
        
            a.brugertype,
        
            a.integrationsdata,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_bruger_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- bruger_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- bruger_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                bruger_attr_egenskaber b
            WHERE
                b.bruger_registrering_id = new_bruger_registrering.id) d
            JOIN bruger_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.bruger_registrering_id = prev_bruger_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_bruger := as_read_bruger(bruger_uuid, (new_bruger_registrering.registrering).timeperiod, null);
    read_prev_bruger := as_read_bruger(bruger_uuid, (prev_bruger_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_bruger.registrering[1].registrering).TimePeriod) = lower((new_bruger_registrering.registrering).TimePeriod) and lower((read_prev_bruger.registrering[1].registrering).TimePeriod)=lower((prev_bruger_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating bruger with id [%]: The ordering of as_list_bruger should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', bruger_uuid, to_json(new_bruger_registrering), to_json(read_new_bruger.registrering[1].registrering), to_json(prev_bruger_registrering), to_json(prev_new_bruger.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_bruger_reg := ROW(
        ROW (null, (read_new_bruger.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_bruger.registrering[1]).tilsGyldighed ,
        
        (read_new_bruger.registrering[1]).attrEgenskaber ,
        (read_new_bruger.registrering[1]).relationer
    )::brugerRegistreringType;

    read_prev_bruger_reg := ROW(
        ROW(null, (read_prev_bruger.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_bruger.registrering[1]).tilsGyldighed ,
        
        (read_prev_bruger.registrering[1]).attrEgenskaber ,
        (read_prev_bruger.registrering[1]).relationer
    )::brugerRegistreringType;


    IF read_prev_bruger_reg = read_new_bruger_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_bruger_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_bruger_reg);
      RAISE EXCEPTION 'Aborted updating bruger with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', bruger_uuid, to_json(read_new_bruger_reg), to_json(read_prev_bruger_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_bruger_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_bruger (
    bruger_registrering BrugerRegistreringType,
    bruger_uuid uuid DEFAULT NULL, auth_criteria_arr
    BrugerRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE bruger_registrering_id bigint;

    
    bruger_attr_egenskaber_obj brugerEgenskaberAttrType;
    

    
    bruger_tils_gyldighed_obj brugerGyldighedTilsType;
    

    bruger_relationer BrugerRelationType;

    

    auth_filtered_uuids uuid[];

    

    does_exist boolean;
    new_bruger_registrering bruger_registrering;
BEGIN
    IF bruger_uuid IS NULL THEN LOOP
        bruger_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from bruger WHERE id=bruger_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from bruger WHERE id=bruger_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (bruger_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (bruger_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (bruger_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_bruger.',(bruger_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO bruger (ID) SELECT
        bruger_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        bruger_registrering_id:=nextval('bruger_registrering_id_seq');

        INSERT INTO bruger_registrering (id, bruger_id,
            registrering) SELECT bruger_registrering_id,
        bruger_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (bruger_registrering.registrering).livscykluskode,
        (bruger_registrering.registrering).brugerref,
        (bruger_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_bruger_registrering :=
            _as_create_bruger_registrering(bruger_uuid,
                (bruger_registrering.registrering).livscykluskode,
                (bruger_registrering.registrering).brugerref,
                (bruger_registrering.registrering).note);

            bruger_registrering_id := new_bruger_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(bruger_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [bruger]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF bruger_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(bruger_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH bruger_attr_egenskaber_obj IN ARRAY bruger_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO bruger_attr_egenskaber (
      
      brugervendtnoegle,
      brugernavn,
      brugertype,
      integrationsdata,
      virkning,
      bruger_registrering_id
    )
    SELECT
     
     bruger_attr_egenskaber_obj.brugervendtnoegle,
      bruger_attr_egenskaber_obj.brugernavn,
      bruger_attr_egenskaber_obj.brugertype,
      bruger_attr_egenskaber_obj.integrationsdata,
      bruger_attr_egenskaber_obj.virkning,
      bruger_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(bruger_registrering.tilsGyldighed, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [gyldighed] for bruger. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF bruger_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(bruger_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH bruger_tils_gyldighed_obj IN ARRAY bruger_registrering.tilsGyldighed
  LOOP

    INSERT INTO bruger_tils_gyldighed (
      virkning,
      gyldighed,
      bruger_registrering_id
    )
    SELECT
      bruger_tils_gyldighed_obj.virkning,
      bruger_tils_gyldighed_obj.gyldighed,
      bruger_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations



    INSERT INTO bruger_relation (
      bruger_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      bruger_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(bruger_registrering.relationer) a
  ;




/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_bruger(array[bruger_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[bruger_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import bruger with uuid [%]. Object does not met stipulated criteria:%',bruger_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN bruger_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_bruger(bruger_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr BrugerRegistreringType[]=null
  )
  RETURNS BrugerType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result BrugerType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_bruger(bruger_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(bruger_uuids,1),0) AND auth_filtered_uuids @>bruger_uuids) THEN
  RAISE EXCEPTION 'Unable to list bruger with uuids [%]. All objects do not fullfill the stipulated criteria:%',bruger_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.brugerObj) into result
FROM
(
SELECT
ROW(
	a.bruger_id,
	array_agg(
		ROW (
			a.registrering,
			a.BrugerTilsGyldighedArr,
			a.BrugerAttrEgenskaberArr,
			a.BrugerRelationArr
		)::BrugerRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: BrugerType  brugerObj
FROM
(
	SELECT
	a.bruger_id,
	a.bruger_registrering_id,
	a.registrering,
	a.BrugerAttrEgenskaberArr,
	a.BrugerTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type
			):: BrugerRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
        
	)) BrugerRelationArr
	FROM
	(
			SELECT
			a.bruger_id,
			a.bruger_registrering_id,
			a.registrering,
			a.BrugerAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::BrugerGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) BrugerTilsGyldighedArr		
			FROM
			(
					SELECT
					a.bruger_id,
					a.bruger_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.brugernavn,
					 		b.brugertype,
					 		b.integrationsdata,
					   		b.virkning
                            
							)::BrugerEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.brugernavn,b.brugertype,b.integrationsdata,b.virkning
                        
					)) BrugerAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id bruger_id,
					b.id bruger_registrering_id,
					b.registrering			
					FROM		bruger a
					JOIN 		bruger_registrering b 	ON b.bruger_id=a.id
					WHERE a.id = ANY (bruger_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN bruger_attr_egenskaber as b ON b.bruger_registrering_id=a.bruger_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.bruger_id,
					a.bruger_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN bruger_tils_gyldighed as b ON b.bruger_registrering_id=a.bruger_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.bruger_id,
			a.bruger_registrering_id,
			a.registrering,
			a.BrugerAttrEgenskaberArr
	) as a
	LEFT JOIN bruger_relation b ON b.bruger_registrering_id=a.bruger_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.bruger_id,
	a.bruger_registrering_id,
	a.registrering,
	a.BrugerAttrEgenskaberArr,
	a.BrugerTilsGyldighedArr
) as a

WHERE a.bruger_id IS NOT NULL
GROUP BY 
a.bruger_id
order by a.bruger_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_bruger(
    bruger_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      BrugerRegistreringType[]=null
) RETURNS BrugerType AS $$
DECLARE
	resArr BrugerType[];
BEGIN
    resArr := as_list_bruger(ARRAY[bruger_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_bruger(
    firstResult int,--TOOD ??
    bruger_uuid uuid,
    registreringObj   BrugerRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr BrugerRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    bruger_candidates uuid[];
    bruger_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj BrugerEgenskaberAttrType;

    
    tilsGyldighedTypeObj BrugerGyldighedTilsType;

    relationTypeObj BrugerRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

bruger_candidates_is_initialized := false;

IF bruger_uuid is not NULL THEN
    bruger_candidates:= ARRAY[bruger_uuid];
    bruger_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        bruger_candidates:=array(
                SELECT DISTINCT
                b.bruger_id
                FROM
                bruger a
                JOIN bruger_registrering b on b.bruger_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'bruger_candidates_is_initialized step 1:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 1:%',bruger_candidates;
--/****************************//


--RAISE NOTICE 'bruger_candidates_is_initialized step 2:%',bruger_candidates_is_initialized;
--RAISE NOTICE 'bruger_candidates step 2:%',bruger_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_bruger: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(bruger_candidates,1),0)>0 OR NOT bruger_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            bruger_candidates:=array(
            SELECT DISTINCT
            b.bruger_id
            FROM  bruger_attr_egenskaber a
            JOIN bruger_registrering b on a.bruger_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.brugernavn IS NULL
                    OR
                    a.brugernavn ILIKE attrEgenskaberTypeObj.brugernavn --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.brugertype IS NULL
                    OR
                    a.brugertype ILIKE attrEgenskaberTypeObj.brugertype --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.integrationsdata IS NULL
                    OR
                    a.integrationsdata ILIKE attrEgenskaberTypeObj.integrationsdata --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )

            );


            bruger_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'bruger_candidates_is_initialized step 3:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 3:%',bruger_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        bruger_candidates:=array(

            SELECT DISTINCT
            b.bruger_id
            
            FROM  bruger_attr_egenskaber a
            JOIN bruger_registrering b on a.bruger_registrering_id=b.id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.brugernavn ILIKE anyAttrValue OR
                        a.brugertype ILIKE anyAttrValue OR
                        a.integrationsdata ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )


        );

    bruger_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
    --RAISE DEBUG 'as_search_bruger: skipping filtration on tilsGyldighed';
ELSE
    IF (coalesce(array_length(bruger_candidates,1),0)>0 OR bruger_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
        LOOP
            bruger_candidates:=array(
            SELECT DISTINCT
            b.bruger_id
            FROM  bruger_tils_gyldighed a
            JOIN bruger_registrering b on a.bruger_registrering_id=b.id
            WHERE
                (
                    tilsGyldighedTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsGyldighedTypeObj.gyldighed IS NULL
                    OR
                    tilsGyldighedTypeObj.gyldighed = a.gyldighed
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )

    );


            bruger_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer BrugerRelationType[]
*/


--RAISE DEBUG 'bruger_candidates_is_initialized step 4:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 4:%',bruger_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_bruger: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(bruger_candidates,1),0)>0 OR NOT bruger_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            bruger_candidates:=array(
            SELECT DISTINCT
            b.bruger_id
            FROM  bruger_relation a
            JOIN bruger_registrering b on a.bruger_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )

    );

            bruger_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        bruger_candidates:=array(
            SELECT DISTINCT
            b.bruger_id
            
            FROM  bruger_relation a
            JOIN bruger_registrering b on a.bruger_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )


            );

    bruger_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        bruger_candidates:=array(
            SELECT DISTINCT
            b.bruger_id
            
            FROM  bruger_relation a
            JOIN bruger_registrering b on a.bruger_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )


            );

    bruger_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 




--RAISE DEBUG 'bruger_candidates_is_initialized step 5:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 5:%',bruger_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT bruger_candidates_is_initialized THEN
        bruger_candidates:=array(
        SELECT DISTINCT
            bruger_id
        FROM
            bruger_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT bruger_candidates_is_initialized) OR b.bruger_id = ANY (bruger_candidates) )

        )
        ;

        bruger_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT bruger_candidates_is_initialized THEN
    --No filters applied!
    bruger_candidates:=array(
        SELECT DISTINCT id FROM bruger a
    );
ELSE
    bruger_candidates:=array(
        SELECT DISTINCT id FROM unnest(bruger_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'bruger_candidates_is_initialized step 6:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 6:%',bruger_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_bruger(bruger_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_bruger(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_BrugerRegistreringType_to_json(BrugerRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END brugeregenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END brugergyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::BrugerRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (BrugerRegistreringType as json);
create cast (BrugerRegistreringType as json) with function actual_state._cast_BrugerRegistreringType_to_json(BrugerRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_brugerType_to_json(BrugerType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg BrugerRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (BrugerType as json);
create cast (BrugerType as json) with function actual_state._cast_brugerType_to_json(BrugerType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_bruger(
    bruger_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    BrugerRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    bruger_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    bruger_sorted_uuid:=array(
          SELECT b.bruger_id
            FROM bruger_registrering b
            JOIN bruger_attr_egenskaber a ON a.bruger_registrering_id=b.id
           WHERE b.bruger_id = ANY (bruger_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.bruger_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.bruger_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN bruger_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_bruger(
	bruger_uuids uuid[],
	registreringObjArr BrugerRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	bruger_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	bruger_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj BrugerEgenskaberAttrType;
	
  	tilsGyldighedTypeObj BrugerGyldighedTilsType;
	relationTypeObj BrugerRelationType;
	registreringObj BrugerRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN bruger_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF bruger_uuids IS NULL OR coalesce(array_length(bruger_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

bruger_candidates:= bruger_uuids;



--RAISE DEBUG 'bruger_candidates_is_initialized step 1:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 1:%',bruger_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_bruger: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(bruger_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			bruger_candidates:=array(
			SELECT DISTINCT
			b.bruger_id 
			FROM  bruger_attr_egenskaber a 
			JOIN bruger_registrering b on a.bruger_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.brugernavn IS NULL
					OR 
					a.brugernavn = attrEgenskaberTypeObj.brugernavn 
				)
				AND
				(
					attrEgenskaberTypeObj.brugertype IS NULL
					OR 
					a.brugertype = attrEgenskaberTypeObj.brugertype 
				)
				AND
				(
					attrEgenskaberTypeObj.integrationsdata IS NULL
					OR 
					a.integrationsdata = attrEgenskaberTypeObj.integrationsdata 
				)
				AND b.bruger_id = ANY (bruger_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'bruger_candidates_is_initialized step 3:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 3:%',bruger_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_bruger: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(bruger_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			bruger_candidates:=array(
			SELECT DISTINCT
			b.bruger_id 
			FROM  bruger_tils_gyldighed a
			JOIN bruger_registrering b on a.bruger_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.bruger_id = ANY (bruger_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer BrugerRelationType[]
*/


--RAISE DEBUG 'bruger_candidates_is_initialized step 4:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 4:%',bruger_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_bruger: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(bruger_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			bruger_candidates:=array(
			SELECT DISTINCT
			b.bruger_id 
			FROM  bruger_relation a
			JOIN bruger_registrering b on a.bruger_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.bruger_id = ANY (bruger_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'bruger_candidates_is_initialized step 5:%',bruger_candidates_is_initialized;
--RAISE DEBUG 'bruger_candidates step 5:%',bruger_candidates;

bruger_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (bruger_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (bruger_candidates) b(id)
);

--optimization 
IF coalesce(array_length(bruger_passed_auth_filter,1),0)=coalesce(array_length(bruger_uuids,1),0) AND bruger_passed_auth_filter @>bruger_uuids THEN
	RETURN bruger_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN bruger_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE DokumentFremdriftTils AS ENUM ('Modtaget','Fordelt','Underudarbejdelse','Underreview','Publiceret','Endeligt','Afleveret',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE DokumentFremdriftTilsType AS (
    virkning Virkning,
    fremdrift DokumentFremdriftTils
)
;



CREATE TYPE DokumentEgenskaberAttrType AS (
brugervendtnoegle text,
beskrivelse text,
brevdato ClearableDate,

kassationskode text,
major ClearableInt,

minor ClearableInt,

offentlighedundtaget offentlighedundtagettype,
titel text,
dokumenttype text,

 virkning Virkning
);




CREATE TYPE DokumentRelationKode AS ENUM  ('nyrevision','primaerklasse','ejer','ansvarlig','primaerbehandler','fordelttil','arkiver','besvarelser','udgangspunkter','kommentarer','bilag','andredokumenter','andreklasser','andrebehandlere','parter','kopiparter','tilknyttedesager');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_dokument_relation_kode_to_txt is invoked.



CREATE TYPE DokumentRelationType AS (
  relType DokumentRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text
)
;


/**************************************************/
/*					DokumentDel                   */
/**************************************************/

CREATE TYPE DokumentdelRelationKode AS ENUM  ('underredigeringaf');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_dokumentdel_relation_kode_to_txt is invoked.


CREATE TYPE DokumentDelEgenskaberType AS (
indeks ClearableInt,
indhold text,
lokation text,
mimetype text,
 virkning Virkning
);


CREATE TYPE DokumentdelRelationType AS (
  relType DokumentdelRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text 
)
;

CREATE TYPE DokumentDelType AS
(
  deltekst text,
  egenskaber DokumentDelEgenskaberType[],
  relationer DokumentdelRelationType[]
);  



/**************************************************/
/*					Dokumentvariant               */
/**************************************************/

CREATE TYPE DokumentVariantEgenskaberType AS (
arkivering ClearableBoolean, 
delvisscannet ClearableBoolean, 
offentliggoerelse ClearableBoolean, 
produktion ClearableBoolean,
 virkning Virkning
);


CREATE TYPE DokumentVariantType AS
(
  varianttekst text,
  egenskaber DokumentVariantEgenskaberType[],
  dele DokumentDelType[]
);  

/**************************************************/


CREATE TYPE DokumentRegistreringType AS
(
registrering RegistreringBase,
tilsFremdrift DokumentFremdriftTilsType[],
attrEgenskaber DokumentEgenskaberAttrType[],
relationer DokumentRelationType[],
varianter DokumentVariantType[]
);

CREATE TYPE DokumentType AS
(
  id uuid,
  registrering DokumentRegistreringType[]
);  


CREATE TYPE _DokumentVariantDelKey AS
(
  varianttekst text,
  deltekst text
);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_dokument_relation_kode_to_txt(
    DokumentRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE dokument (
    id uuid NOT NULL,
    CONSTRAINT dokument_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE dokument
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE dokument_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE dokument_registrering_id_seq
    OWNER TO mox;


CREATE TABLE dokument_registrering (
   id bigint NOT NULL DEFAULT nextval('dokument_registrering_id_seq'::regclass),
   dokument_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT dokument_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT dokument_registrering_dokument_fkey FOREIGN KEY (dokument_id)
       REFERENCES dokument (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT dokument_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(dokument_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE dokument_registrering
  OWNER TO mox;


CREATE INDEX dokument_registrering_idx_livscykluskode
    ON dokument_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX dokument_registrering_idx_brugerref
    ON dokument_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX dokument_registrering_idx_note
    ON dokument_registrering
    USING btree
    (((registrering).note));


CREATE INDEX dokument_registrering_pat_note
    ON dokument_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX dokument_id_idx
    ON dokument_registrering (dokument_id);


CREATE TRIGGER notify_dokument
    AFTER INSERT OR UPDATE OR DELETE ON dokument_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE dokument_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE dokument_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE dokument_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('dokument_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        beskrivelse text NOT NULL,
        brevdato date NOT NULL,
        kassationskode text  NULL,
        major int  NULL,
        minor int  NULL,
        offentlighedundtaget offentlighedundtagettype  NULL,
        titel text NOT NULL,
        dokumenttype text NOT NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    dokument_registrering_id bigint NOT NULL,
    CONSTRAINT dokument_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT dokument_attr_egenskaber_forkey_dokumentregistrering FOREIGN KEY (dokument_registrering_id) REFERENCES dokument_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT dokument_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (dokument_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE dokument_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX dokument_attr_egenskaber_pat_brugervendtnoegle
            ON dokument_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX dokument_attr_egenskaber_idx_brugervendtnoegle
            ON dokument_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX dokument_attr_egenskaber_pat_beskrivelse
            ON dokument_attr_egenskaber
            USING gin
            (beskrivelse gin_trgm_ops);

        CREATE INDEX dokument_attr_egenskaber_idx_beskrivelse
            ON dokument_attr_egenskaber
            USING btree
            (beskrivelse); 
 
    
         
             
                CREATE INDEX dokument_attr_egenskaber_idx_brevdato
                    ON dokument_attr_egenskaber
                    USING btree
                    (brevdato);

            
         
     
 
     
        CREATE INDEX dokument_attr_egenskaber_pat_kassationskode
            ON dokument_attr_egenskaber
            USING gin
            (kassationskode gin_trgm_ops);

        CREATE INDEX dokument_attr_egenskaber_idx_kassationskode
            ON dokument_attr_egenskaber
            USING btree
            (kassationskode); 
 
    
         
             
                CREATE INDEX dokument_attr_egenskaber_idx_major
                    ON dokument_attr_egenskaber
                    USING btree
                    (major);

            
         
     
 
    
         
             
                CREATE INDEX dokument_attr_egenskaber_idx_minor
                    ON dokument_attr_egenskaber
                    USING btree
                    (minor);

            
         
     
 
    
         
             
                CREATE INDEX dokument_attr_egenskaber_pat_AlternativTitel_offentlighedundtaget
                    ON dokument_attr_egenskaber
                    USING gin
                    ( ((offentlighedundtaget).AlternativTitel) gin_trgm_ops);

                CREATE INDEX dokument_attr_egenskaber_idx_AlternativTitel_offentlighedundtaget
                    ON dokument_attr_egenskaber
                    USING btree
                    (((offentlighedundtaget).AlternativTitel));

                CREATE INDEX dokument_attr_egenskaber_pat_Hjemmel_offentlighedundtaget
                    ON dokument_attr_egenskaber
                    USING gin
                    (((offentlighedundtaget).Hjemmel) gin_trgm_ops);

                CREATE INDEX dokument_attr_egenskaber_idx_Hjemmel_offentlighedundtaget
                    ON dokument_attr_egenskaber
                    USING btree
                    (((offentlighedundtaget).Hjemmel));
            
         
     
 
     
        CREATE INDEX dokument_attr_egenskaber_pat_titel
            ON dokument_attr_egenskaber
            USING gin
            (titel gin_trgm_ops);

        CREATE INDEX dokument_attr_egenskaber_idx_titel
            ON dokument_attr_egenskaber
            USING btree
            (titel); 
 
     
        CREATE INDEX dokument_attr_egenskaber_pat_dokumenttype
            ON dokument_attr_egenskaber
            USING gin
            (dokumenttype gin_trgm_ops);

        CREATE INDEX dokument_attr_egenskaber_idx_dokumenttype
            ON dokument_attr_egenskaber
            USING btree
            (dokumenttype); 



CREATE INDEX dokument_attr_egenskaber_idx_virkning_aktoerref
    ON dokument_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX dokument_attr_egenskaber_idx_virkning_aktoertypekode
    ON dokument_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX dokument_attr_egenskaber_idx_virkning_notetekst
    ON dokument_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX dokument_attr_egenskaber_pat_virkning_notetekst
    ON dokument_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE dokument_tils_fremdrift_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE dokument_tils_fremdrift_id_seq
    OWNER TO mox;


CREATE TABLE dokument_tils_fremdrift (
    id bigint NOT NULL DEFAULT nextval('dokument_tils_fremdrift_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    fremdrift DokumentFremdriftTils NOT NULL, 
    dokument_registrering_id bigint not null,
    CONSTRAINT dokument_tils_fremdrift_pkey PRIMARY KEY (id),
    CONSTRAINT dokument_tils_fremdrift_forkey_dokumentregistrering FOREIGN KEY (dokument_registrering_id) REFERENCES dokument_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT dokument_tils_fremdrift_exclude_virkning_overlap EXCLUDE USING gist (dokument_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE dokument_tils_fremdrift
    OWNER TO mox;


CREATE INDEX dokument_tils_fremdrift_idx_fremdrift
    ON dokument_tils_fremdrift
    USING btree
    (fremdrift);
  
CREATE INDEX dokument_tils_fremdrift_idx_virkning_aktoerref
    ON dokument_tils_fremdrift
    USING btree
    (((virkning).aktoerref));

CREATE INDEX dokument_tils_fremdrift_idx_virkning_aktoertypekode
    ON dokument_tils_fremdrift
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX dokument_tils_fremdrift_idx_virkning_notetekst
    ON dokument_tils_fremdrift
    USING btree
    (((virkning).notetekst));

CREATE INDEX dokument_tils_fremdrift_pat_virkning_notetekst
    ON dokument_tils_fremdrift
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE dokument_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE dokument_relation_id_seq
    OWNER TO mox;


CREATE TABLE dokument_relation (
    id bigint NOT NULL DEFAULT nextval('dokument_relation_id_seq'::regclass),
    dokument_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type DokumentRelationKode not null,
    objekt_type text null,

    

    CONSTRAINT dokument_relation_forkey_dokumentregistrering FOREIGN KEY (dokument_registrering_id) REFERENCES dokument_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT dokument_relation_pkey PRIMARY KEY (id),
    CONSTRAINT dokument_relation_no_virkning_overlap EXCLUDE USING gist (dokument_registrering_id WITH =, _as_convert_dokument_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('arkiver'::DokumentRelationKode ) AND rel_type<>('besvarelser'::DokumentRelationKode ) AND rel_type<>('udgangspunkter'::DokumentRelationKode ) AND rel_type<>('kommentarer'::DokumentRelationKode ) AND rel_type<>('bilag'::DokumentRelationKode ) AND rel_type<>('andredokumenter'::DokumentRelationKode ) AND rel_type<>('andreklasser'::DokumentRelationKode ) AND rel_type<>('andrebehandlere'::DokumentRelationKode ) AND rel_type<>('parter'::DokumentRelationKode ) AND rel_type<>('kopiparter'::DokumentRelationKode ) AND rel_type<>('tilknyttedesager'::DokumentRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT dokument_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE dokument_relation
  OWNER TO mox;





CREATE INDEX dokument_relation_idx_rel_maal_obj_uuid
    ON dokument_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX dokument_relation_idx_rel_maal_obj_urn
    ON dokument_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX dokument_relation_idx_rel_maal_uuid
    ON dokument_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX dokument_relation_idx_rel_maal_uuid_isolated
    ON dokument_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX dokument_relation_idx_rel_maal_urn_isolated
    ON dokument_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX dokument_relation_idx_rel_maal_urn
    ON dokument_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX dokument_relation_idx_virkning_aktoerref
    ON dokument_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX dokument_relation_idx_virkning_aktoertypekode
    ON dokument_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX dokument_relation_idx_virkning_notetekst
    ON dokument_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX dokument_relation_pat_virkning_notetekst
    ON dokument_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/**********************************************************************/
/*                        dokument variant                            */
/**********************************************************************/

CREATE SEQUENCE dokument_variant_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE dokument_variant_id_seq
    OWNER TO mox;


CREATE TABLE dokument_variant(
    id bigint not null DEFAULT nextval('dokument_variant_id_seq'::regclass),
    varianttekst text NOT NULL,
    dokument_registrering_id bigint not null,
    UNIQUE(dokument_registrering_id,varianttekst),
    CONSTRAINT dokument_variant_pkey PRIMARY KEY (id),
    CONSTRAINT dokument_variant_forkey_dokumentregistrering FOREIGN KEY (dokument_registrering_id) REFERENCES dokument_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
)
WITH (
  OIDS=FALSE
);

ALTER TABLE dokument_variant
  OWNER TO mox;


CREATE SEQUENCE dokument_variant_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE dokument_variant_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE dokument_variant_egenskaber(
    id bigint NOT NULL DEFAULT nextval('dokument_variant_egenskaber_id_seq'::regclass), 
    variant_id bigint not null, 
    arkivering boolean null, 
    delvisscannet boolean null, 
    offentliggoerelse boolean null, 
    produktion boolean null, 
    virkning Virkning not null CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    CONSTRAINT dokument_variant_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT dokument_variant_egenskaber_forkey_dokumentvariant FOREIGN KEY (variant_id) REFERENCES dokument_variant (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT dokument_variant_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (variant_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
  OIDS=FALSE
);
ALTER TABLE dokument_variant_egenskaber
    OWNER TO mox;

 
CREATE INDEX dokument_variant_egenskaber_idx_arkivering
    ON dokument_variant_egenskaber
    USING btree
    (arkivering); 

CREATE INDEX dokument_variant_egenskaber_idx_delvisscannet
    ON dokument_variant_egenskaber
    USING btree
    (delvisscannet); 
 
CREATE INDEX dokument_variant_egenskaber_idx_offentliggoerelse
    ON dokument_variant_egenskaber
    USING btree
    (offentliggoerelse); 
 
CREATE INDEX dokument_variant_egenskaber_idx_produktion
    ON dokument_variant_egenskaber
    USING btree
    (produktion); 

CREATE INDEX dokument_variant_egenskaber_idx_virkning_aktoerref
    ON dokument_variant_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX dokument_variant_egenskaber_idx_virkning_aktoertypekode
    ON dokument_variant_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX dokument_variant_egenskaber_idx_virkning_notetekst
    ON dokument_variant_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX dokument_variant_egenskaber_pat_virkning_notetekst
    ON dokument_variant_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);


/**********************************************************************/
/*                        dokument del                                */
/**********************************************************************/

CREATE SEQUENCE dokument_del_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE dokument_del_id_seq
    OWNER TO mox;


CREATE TABLE dokument_del(
    id bigint not null DEFAULT nextval('dokument_del_id_seq'::regclass),
    deltekst text NOT NULL,
    variant_id bigint not null,
    UNIQUE (variant_id, deltekst),
    CONSTRAINT dokument_del_forkey_variant_id FOREIGN KEY (variant_id) REFERENCES dokument_variant (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT dokument_del_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE dokument_del
    OWNER TO mox;


CREATE SEQUENCE dokument_del_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE dokument_del_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE dokument_del_egenskaber(
    id bigint NOT NULL DEFAULT nextval('dokument_del_egenskaber_id_seq'::regclass), 
    del_id bigint NOT NULL,
    indeks int null, 
    indhold text null, 
    lokation text null, 
    mimetype text null, 
    virkning Virkning not null CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    CONSTRAINT dokument_del_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT dokument_del_egenskaber_forkey_dokument_del FOREIGN KEY (del_id) REFERENCES dokument_del (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT dokument_del_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (del_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE dokument_del_egenskaber
    OWNER TO mox;

CREATE INDEX dokument_del_egenskaber_idx_indeks
    ON dokument_del_egenskaber
    USING btree
    (indeks); 
 
CREATE INDEX dokument_del_egenskaber_pat_indhold
    ON dokument_del_egenskaber
    USING gin
    (indhold gin_trgm_ops);

CREATE INDEX dokument_del_egenskaber_idx_indhold
    ON dokument_del_egenskaber
    USING btree
    (indhold); 
 
CREATE INDEX dokument_del_egenskaber_pat_lokation
    ON dokument_del_egenskaber
    USING gin
    (lokation gin_trgm_ops);

CREATE INDEX dokument_del_egenskaber_idx_lokation
    ON dokument_del_egenskaber
    USING btree
    (lokation); 
 
CREATE INDEX dokument_del_egenskaber_pat_mimetype
    ON dokument_del_egenskaber
    USING gin
    (mimetype gin_trgm_ops);

CREATE INDEX dokument_del_egenskaber_idx_mimetype
    ON dokument_del_egenskaber
    USING btree
    (mimetype); 

CREATE INDEX dokument_del_egenskaber_idx_virkning_aktoerref
    ON dokument_del_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX dokument_del_egenskaber_idx_virkning_aktoertypekode
    ON dokument_del_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX dokument_del_egenskaber_idx_virkning_notetekst
    ON dokument_del_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX dokument_del_egenskaber_pat_virkning_notetekst
    ON dokument_del_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);

CREATE SEQUENCE dokument_del_relation_id_seq
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START 1
  CACHE 1;

ALTER TABLE dokument_del_relation_id_seq
  OWNER TO mox;


CREATE TABLE dokument_del_relation (
    id bigint NOT NULL DEFAULT nextval('dokument_del_relation_id_seq'::regclass),
    del_id bigint not null,
    virkning Virkning not null CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    rel_maal_uuid uuid NULL, 
    rel_maal_urn text null,
    rel_type DokumentdelRelationKode not null,
    objekt_type text null,
    CONSTRAINT dokument_del_relation_forkey_dokument_del FOREIGN KEY (del_id) REFERENCES dokument_del (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT dokument_del_relation_pkey PRIMARY KEY (id),
    -- CONSTRAINT dokument_del_relation_no_virkning_overlap EXCLUDE USING gist (dokument_del_registrering_id WITH =, _as_convert_dokument_del_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('underredigeringaf'::dokument_delRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT dokument_del_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE dokument_del_relation
  OWNER TO mox;


CREATE INDEX dokument_del_relation_idx_rel_maal_obj_uuid
    ON dokument_del_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);

CREATE INDEX dokument_del_relation_idx_rel_maal_obj_urn
    ON dokument_del_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX dokument_del_relation_idx_rel_maal_uuid
    ON dokument_del_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX dokument_del_relation_idx_rel_maal_uuid_isolated
    ON dokument_del_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX dokument_del_relation_idx_rel_maal_urn_isolated
    ON dokument_del_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX dokument_del_relation_idx_rel_maal_urn
    ON dokument_del_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX dokument_del_relation_idx_virkning_aktoerref
    ON dokument_del_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX dokument_del_relation_idx_virkning_aktoertypekode
    ON dokument_del_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX dokument_del_relation_idx_virkning_notetekst
    ON dokument_del_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX dokument_del_relation_pat_virkning_notetekst
    ON dokument_del_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr DokumentFremdriftTilsType[])
  RETURNS DokumentFremdriftTilsType[] AS
  $$
  DECLARE result DokumentFremdriftTilsType[];
  DECLARE element DokumentFremdriftTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.fremdrift IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr DokumentEgenskaberAttrType[])
  RETURNS DokumentEgenskaberAttrType[] AS
  $$
  DECLARE result DokumentEgenskaberAttrType[]; 
   DECLARE element DokumentEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.beskrivelse IS NULL AND element.brevdato IS NULL AND element.kassationskode IS NULL AND element.major IS NULL AND element.minor IS NULL AND element.offentlighedundtaget IS NULL AND element.titel IS NULL AND element.dokumenttype IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr DokumentRelationType[])
RETURNS DokumentRelationType[] AS
$$
 DECLARE result DokumentRelationType[];
 DECLARE element DokumentRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;



/********************************************/
/* Handle document variants and parts */


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr DokumentVariantEgenskaberType[])
  RETURNS DokumentVariantEgenskaberType[] AS
  $$
  DECLARE result DokumentVariantEgenskaberType[]; 
   DECLARE element DokumentVariantEgenskaberType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.arkivering IS NULL AND element.delvisscannet IS NULL AND element.offentliggoerelse IS NULL AND element.produktion IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr DokumentDelEgenskaberType[])
  RETURNS DokumentDelEgenskaberType[] AS
  $$
  DECLARE result DokumentDelEgenskaberType[]; 
   DECLARE element DokumentDelEgenskaberType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.indeks IS NULL AND element.indhold IS NULL AND element.lokation IS NULL AND element.mimetype IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;



CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr DokumentdelRelationType[])
RETURNS DokumentdelRelationType[] AS
$$
 DECLARE result DokumentdelRelationType[];
 DECLARE element DokumentdelRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;

CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr DokumentDelType[])
RETURNS DokumentDelType[] AS
$$
 DECLARE result DokumentDelType[];
 DECLARE element DokumentDelType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR ( element.deltekst IS NULL AND (element.egenskaber IS NULL OR coalesce(array_length(element.egenskaber,1),0)=0) AND (element.relationer IS NULL OR coalesce(array_length(element.relationer,1),0)=0)  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;

CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr DokumentVariantType[])
RETURNS DokumentVariantType[] AS
$$
 DECLARE result DokumentVariantType[];
 DECLARE element DokumentVariantType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR ( element.varianttekst IS NULL AND (element.egenskaber IS NULL OR coalesce(array_length(element.egenskaber,1),0)=0) AND (element.dele IS NULL OR coalesce(array_length(element.dele,1),0)=0)  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;



-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_dokument_registrering(
    dokument_registrering
) RETURNS dokument_registrering AS $BODY$
  SELECT * FROM dokument_registrering as a WHERE
    dokument_id = $1.dokument_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_dokument_registrering(
    dokument_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS dokument_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    dokument_registrering_id bigint;
    dokument_registrering    dokument_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE dokument_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE dokument_id = dokument_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating dokument with uuid [%], Invalid [livscyklus] transition to [%]',dokument_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new dokument registrering

    dokument_registrering_id := nextval('dokument_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    dokument_registrering := ROW(
        dokument_registrering_id,
        dokument_uuid,
        registreringObj
    )::dokument_registrering;

    INSERT INTO dokument_registrering SELECT dokument_registrering.*;

    RETURN dokument_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of DokumentAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_dokument(
    dokument_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber DokumentEgenskaberAttrType[],
    

    
    tilsFremdrift DokumentFremdriftTilsType[],
    

    relationer DokumentRelationType[],

    
    varianter DokumentVariantType[],
    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      DokumentRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_dokument          DokumentType;
    read_prev_dokument         DokumentType;
    read_new_dokument_reg      DokumentRegistreringType;
    read_prev_dokument_reg     DokumentRegistreringType;
    new_dokument_registrering  dokument_registrering;
    prev_dokument_registrering dokument_registrering;
    dokument_relation_navn     DokumentRelationKode;

    
    attrEgenskaberObj DokumentEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
    dokument_variant_obj DokumentVariantType;
    dokument_variant_egenskab_obj DokumentVariantEgenskaberType;
    dokument_del_obj DokumentDelType;
    dokument_del_egenskaber_obj DokumentDelEgenskaberType;
    dokument_del_relation_obj DokumentDelRelationType;
    dokument_variant_new_id bigint;
    dokument_del_new_id bigint;
    dokument_variant_egenskaber_expl_deleted text[]:=array[]::text[];
    dokument_variant_dele_all_expl_deleted text[]:=array[]::text[];
    dokument_variant_del_egenskaber_deleted _DokumentVariantDelKey[]:=array[]::_DokumentVariantDelKey[];
    dokument_variant_del_relationer_deleted _DokumentVariantDelKey[]:=array[]::_DokumentVariantDelKey[];
    dokument_variants_prev_reg_arr text[];
    dokument_variant_egenskaber_prev_reg_varianttekst text;
    dokument_variant_id bigint;
    dokument_variant_del_prev_reg_arr _DokumentVariantDelKey[];
    dokument_variant_del_prev_reg _DokumentVariantDelKey;
    dokument_del_id bigint;
    dokument_variant_del_prev_reg_rel_transfer _DokumentVariantDelKey[];
    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from dokument a join dokument_registrering b ON b.dokument_id=a.id WHERE a.id=dokument_uuid) THEN
        RAISE EXCEPTION 'Unable to update dokument with uuid [%], being unable to find any previous registrations.',dokument_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM dokument a WHERE a.id=dokument_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_dokument(array[dokument_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[dokument_uuid]) THEN
      RAISE EXCEPTION 'Unable to update dokument with uuid [%]. Object does not met stipulated criteria:%', dokument_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_dokument_registrering := _as_create_dokument_registrering(dokument_uuid, livscykluskode, brugerref, note);
    prev_dokument_registrering := _as_get_prev_dokument_registrering(new_dokument_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_dokument_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update dokument with uuid [%], as the dokument seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', dokument_uuid, lostUpdatePreventionTZ, LOWER((prev_dokument_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    

    INSERT INTO dokument_relation (dokument_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
    SELECT
        new_dokument_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType 
        FROM
            unnest(relationer) AS a ;

    


    -- Ad 2)
    -- 0..1 relations

    
    
    FOREACH dokument_relation_navn IN ARRAY ARRAY['nyrevision'::DokumentRelationKode ,  'primaerklasse'::DokumentRelationKode ,  'ejer'::DokumentRelationKode ,  'ansvarlig'::DokumentRelationKode ,  'primaerbehandler'::DokumentRelationKode ,  'fordelttil'::DokumentRelationKode  ]::DokumentRelationKode[]  LOOP
        INSERT INTO dokument_relation (dokument_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
        SELECT
            new_dokument_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM dokument_relation b
                 WHERE b.dokument_registrering_id = new_dokument_registrering.id AND b.rel_type = dokument_relation_navn) d
            JOIN dokument_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.dokument_registrering_id = prev_dokument_registrering.id AND a.rel_type = dokument_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
    FOREACH dokument_relation_navn IN ARRAY ARRAY['arkiver'::DokumentRelationKode, 'besvarelser'::DokumentRelationKode, 'udgangspunkter'::DokumentRelationKode, 'kommentarer'::DokumentRelationKode, 'bilag'::DokumentRelationKode, 'andredokumenter'::DokumentRelationKode, 'andreklasser'::DokumentRelationKode, 'andrebehandlere'::DokumentRelationKode, 'parter'::DokumentRelationKode, 'kopiparter'::DokumentRelationKode, 'tilknyttedesager'::DokumentRelationKode]::DokumentRelationKode[] LOOP
        IF NOT EXISTS (
                    SELECT 1
                      FROM dokument_relation
                     WHERE dokument_registrering_id = new_dokument_registrering.id AND rel_type = dokument_relation_navn) THEN
                    
                    INSERT INTO dokument_relation (dokument_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
                    SELECT
                        new_dokument_registrering.id,  virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type
        FROM dokument_relation
        WHERE
            dokument_registrering_id = prev_dokument_registrering.id AND rel_type = dokument_relation_navn ;

    
        END IF;
    END LOOP;
    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsFremdrift IS NOT NULL AND coalesce(array_length(tilsFremdrift, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Fremdrift] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- dokument_tils_fremdrift

        -- Ad 1)
        INSERT INTO dokument_tils_fremdrift(virkning, fremdrift, dokument_registrering_id)
             SELECT a.virkning, a.fremdrift, new_dokument_registrering.id
               FROM unnest(tilsFremdrift) AS a;

        -- Ad 2
        INSERT INTO dokument_tils_fremdrift(virkning, fremdrift, dokument_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.fremdrift,
            new_dokument_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- dokument_tils_fremdrift of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- dokument_tils_fremdrift of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM dokument_tils_fremdrift b
             WHERE b.dokument_registrering_id = new_dokument_registrering.id) d
              JOIN dokument_tils_fremdrift a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.dokument_registrering_id = prev_dokument_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- dokument_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrDokumentObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.beskrivelse,a.brevdato,a.kassationskode,a.major,a.minor,a.offentlighedundtaget,a.titel,a.dokumenttype,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update dokument with uuid [%], as the dokument have overlapping virknings in the given egenskaber array :%', dokument_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).beskrivelse IS NULL  OR  (attrEgenskaberObj).brevdato IS NULL  OR  (attrEgenskaberObj).kassationskode IS NULL  OR  (attrEgenskaberObj).major IS NULL  OR  (attrEgenskaberObj).minor IS NULL  OR  (attrEgenskaberObj).offentlighedundtaget IS NULL  OR  (attrEgenskaberObj).titel IS NULL  OR  (attrEgenskaberObj).dokumenttype IS NULL  THEN
            
            INSERT INTO dokument_attr_egenskaber ( brugervendtnoegle,beskrivelse,brevdato,kassationskode,major,minor,offentlighedundtaget,titel,dokumenttype, virkning, dokument_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.beskrivelse, a.beskrivelse),
                    
                        
                        
                            CASE WHEN ((attrEgenskaberObj.brevdato).cleared) THEN
                                NULL
                            ELSE
                                coalesce((attrEgenskaberObj.brevdato).value, a.brevdato)
                            END,
                        
                    
                        
                        
                            coalesce(attrEgenskaberObj.kassationskode, a.kassationskode),
                    
                        
                        
                            CASE WHEN ((attrEgenskaberObj.major).cleared) THEN
                                NULL
                            ELSE
                                coalesce((attrEgenskaberObj.major).value, a.major)
                            END,
                        
                    
                        
                        
                            CASE WHEN ((attrEgenskaberObj.minor).cleared) THEN
                                NULL
                            ELSE
                                coalesce((attrEgenskaberObj.minor).value, a.minor)
                            END,
                        
                    
                        
                        
                            coalesce(attrEgenskaberObj.offentlighedundtaget, a.offentlighedundtaget),
                    
                        
                        
                            coalesce(attrEgenskaberObj.titel, a.titel),
                    
                        
                        
                            coalesce(attrEgenskaberObj.dokumenttype, a.dokumenttype),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_dokument_registrering.id
                        FROM dokument_attr_egenskaber a
                    WHERE
                        a.dokument_registrering_id = prev_dokument_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO dokument_attr_egenskaber ( brugervendtnoegle,beskrivelse,brevdato,kassationskode,major,minor,offentlighedundtaget,titel,dokumenttype, virkning, dokument_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.beskrivelse,
                    
                     attrEgenskaberObj.brevdato,
                    
                     attrEgenskaberObj.kassationskode,
                    
                     attrEgenskaberObj.major,
                    
                     attrEgenskaberObj.minor,
                    
                     attrEgenskaberObj.offentlighedundtaget,
                    
                     attrEgenskaberObj.titel,
                    
                     attrEgenskaberObj.dokumenttype,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_dokument_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the dokument_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM dokument_attr_egenskaber b
                    WHERE b.dokument_registrering_id = new_dokument_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO dokument_attr_egenskaber ( brugervendtnoegle,beskrivelse,brevdato,kassationskode,major,minor,offentlighedundtaget,titel,dokumenttype, virkning, dokument_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.beskrivelse,  attrEgenskaberObj.brevdato,  attrEgenskaberObj.kassationskode,  attrEgenskaberObj.major,  attrEgenskaberObj.minor,  attrEgenskaberObj.offentlighedundtaget,  attrEgenskaberObj.titel,  attrEgenskaberObj.dokumenttype, attrEgenskaberObj.virkning, new_dokument_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO dokument_attr_egenskaber ( brugervendtnoegle,beskrivelse,brevdato,kassationskode,major,minor,offentlighedundtaget,titel,dokumenttype, virkning, dokument_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.beskrivelse,
        
            a.brevdato,
        
            a.kassationskode,
        
            a.major,
        
            a.minor,
        
            a.offentlighedundtaget,
        
            a.titel,
        
            a.dokumenttype,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_dokument_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- dokument_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- dokument_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                dokument_attr_egenskaber b
            WHERE
                b.dokument_registrering_id = new_dokument_registrering.id) d
            JOIN dokument_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.dokument_registrering_id = prev_dokument_registrering.id ;

END IF;




/******************************************************************/
--Handling document variants and document parts

--check if the update explicitly clears all the doc variants (and parts) by explicitly giving an empty array, if so - no variant will be included in the new reg. 
IF varianter IS NOT NULL AND coalesce(array_length(varianter,1),0)=0 THEN
  --raise notice 'Skipping insertion of doc variants (and parts), as an empty array was given explicitly';
ELSE

--Check if any variants was given in the new update - otherwise we'll skip ahead to transfering the old variants
IF varianter IS NOT NULL AND coalesce(array_length(varianter,1),0)>0 THEN
  
FOREACH dokument_variant_obj IN ARRAY varianter
LOOP

dokument_variant_new_id:=_ensure_document_variant_exists_and_get(new_dokument_registrering.id,dokument_variant_obj.varianttekst);

--handle variant egenskaber
IF dokument_variant_obj.egenskaber IS NOT NULL AND coalesce(array_length(dokument_variant_obj.egenskaber,1),0)=0 THEN
dokument_variant_egenskaber_expl_deleted:=array_append(dokument_variant_egenskaber_expl_deleted, dokument_variant_obj.varianttekst);
ELSE 


IF dokument_variant_obj.egenskaber IS NOT NULL AND coalesce(array_length(dokument_variant_obj.egenskaber,1),0)>0 THEN

  --Input validation: 
  --Verify that there is no overlap in virkning in the array given

  IF EXISTS (
  SELECT
  a.*
  FROM unnest(dokument_variant_obj.egenskaber) a
  JOIN unnest(dokument_variant_obj.egenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
  GROUP BY a.arkivering,a.delvisscannet,a.offentliggoerelse,a.produktion, a.virkning
  HAVING COUNT(*)>1
  ) THEN
  RAISE EXCEPTION 'Unable to update dokument with uuid [%], as the given dokument variant [%] have overlapping virknings in the given egenskaber array :%',dokument_uuid,dokument_variant_obj.varianttekst,to_json(dokument_variant_obj.egenskaber)  USING ERRCODE = 22000;

  END IF;


FOREACH dokument_variant_egenskab_obj IN ARRAY dokument_variant_obj.egenskaber
  LOOP

   IF (dokument_variant_egenskab_obj).arkivering is null OR 
   (dokument_variant_egenskab_obj).delvisscannet is null OR 
   (dokument_variant_egenskab_obj).offentliggoerelse is null OR 
   (dokument_variant_egenskab_obj).produktion is null 
  THEN


  INSERT INTO dokument_variant_egenskaber(
    variant_id,
        arkivering, 
          delvisscannet, 
            offentliggoerelse, 
              produktion,
                virkning
      )
  SELECT
    dokument_variant_new_id, 
        CASE WHEN (dokument_variant_egenskab_obj.arkivering).cleared THEN NULL 
        ELSE coalesce((dokument_variant_egenskab_obj.arkivering).value,a.arkivering)
        END, 
          CASE WHEN (dokument_variant_egenskab_obj.delvisscannet).cleared THEN NULL 
          ELSE coalesce((dokument_variant_egenskab_obj.delvisscannet).value,a.delvisscannet)
          END,
            CASE WHEN (dokument_variant_egenskab_obj.offentliggoerelse).cleared THEN NULL 
            ELSE coalesce((dokument_variant_egenskab_obj.offentliggoerelse).value,a.offentliggoerelse)
            END,
              CASE WHEN (dokument_variant_egenskab_obj.produktion).cleared THEN NULL 
              ELSE coalesce((dokument_variant_egenskab_obj.produktion).value,a.produktion)
              END,
                ROW (
                  (a.virkning).TimePeriod * (dokument_variant_egenskab_obj.virkning).TimePeriod,
                  (dokument_variant_egenskab_obj.virkning).AktoerRef,
                  (dokument_variant_egenskab_obj.virkning).AktoerTypeKode,
                  (dokument_variant_egenskab_obj.virkning).NoteTekst
                )::Virkning
  FROM dokument_variant_egenskaber a
  JOIN dokument_variant b on a.variant_id=b.id
  WHERE
    b.dokument_registrering_id=prev_dokument_registrering.id 
    and b.varianttekst=dokument_variant_obj.varianttekst
    and (a.virkning).TimePeriod && (dokument_variant_egenskab_obj.virkning).TimePeriod
  ;


  --For any periods within the virkning of the dokument_variant_egenskab_obj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  dokument_variant_egenskaber
  (
    variant_id,
      arkivering, 
        delvisscannet, 
          offentliggoerelse, 
            produktion,
              virkning
  )
  SELECT 
    dokument_variant_new_id,
      dokument_variant_egenskab_obj.arkivering, 
        dokument_variant_egenskab_obj.delvisscannet, 
          dokument_variant_egenskab_obj.offentliggoerelse, 
            dokument_variant_egenskab_obj.produktion,
              ROW (
                   b.tz_range_leftover,
                  (dokument_variant_egenskab_obj.virkning).AktoerRef,
                  (dokument_variant_egenskab_obj.virkning).AktoerTypeKode,
                  (dokument_variant_egenskab_obj.virkning).NoteTekst
              )::Virkning
  FROM
  (
  --build an array of the timeperiod of the virkning of the dokument variant egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM dokument_variant_egenskaber b
      WHERE 
       b.variant_id=dokument_variant_new_id
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((dokument_variant_egenskab_obj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;
  ELSE 

   --insert attrEgenskaberObj raw (if there were no null-valued fields) 

   INSERT INTO
    dokument_variant_egenskaber (
      variant_id,
        arkivering, 
          delvisscannet, 
            offentliggoerelse, 
              produktion,
                virkning
    )
    VALUES (
      dokument_variant_new_id,
        dokument_variant_egenskab_obj.arkivering, 
          dokument_variant_egenskab_obj.delvisscannet, 
            dokument_variant_egenskab_obj.offentliggoerelse, 
              dokument_variant_egenskab_obj.produktion,
                dokument_variant_egenskab_obj.virkning
    );

  END IF; --else block: null elements present in -dokument_variant_obj.egenskab obj

  END LOOP; --dokument_variant_obj.egenskaber


END IF; --variant egenskaber given.

END IF; --else block: explicit empty array of variant egenskaber given


--handle variant dele
IF dokument_variant_obj.dele IS NOT NULL AND coalesce(array_length(dokument_variant_obj.dele,1),0)=0 THEN

dokument_variant_dele_all_expl_deleted :=array_append(dokument_variant_dele_all_expl_deleted, dokument_variant_obj.varianttekst);

ELSE

IF dokument_variant_obj.dele IS NOT NULL AND coalesce(array_length(dokument_variant_obj.dele,1),0)>0 THEN


FOREACH dokument_del_obj IN ARRAY dokument_variant_obj.dele
    LOOP

    dokument_del_new_id:=_ensure_document_del_exists_and_get(new_dokument_registrering.id, dokument_variant_new_id, dokument_del_obj.deltekst);

    IF dokument_del_obj.egenskaber IS NOT NULL AND coalesce(array_length(dokument_del_obj.egenskaber,1),0)=0 THEN
    dokument_variant_del_egenskaber_deleted:=array_append(dokument_variant_del_egenskaber_deleted,ROW(dokument_variant_obj.varianttekst, dokument_del_obj.deltekst)::_DokumentVariantDelKey);
    ELSE

    IF dokument_del_obj.egenskaber IS NOT NULL AND coalesce(array_length(dokument_del_obj.egenskaber,1),0)>0 THEN  

    --Input validation: 
    --Verify that there is no overlap in virkning in the array given
    IF EXISTS (
      SELECT
      a.*
      FROM unnest(dokument_del_obj.egenskaber) a
      JOIN unnest(dokument_del_obj.egenskaber) b on (a.virkning).TimePeriod && (b.virkning).TimePeriod
      GROUP BY a.indeks,a.indhold,a.lokation,a.mimetype, a.virkning
      HAVING COUNT(*)>1
    ) THEN
    RAISE EXCEPTION 'Unable to update dokument with uuid [%], as the dokument variant [%] have del [%] with overlapping virknings in the given egenskaber array :%',dokument_uuid,dokument_variant_obj.varianttekst,dokument_del_obj.deltekst,to_json(dokument_del_obj.egenskaber)  USING ERRCODE = 22000;
    END IF;



  FOREACH dokument_del_egenskaber_obj in array dokument_del_obj.egenskaber
  LOOP

  --To avoid needless fragmentation we'll check for presence of null values in the fields - and if none are present, we'll skip the merging operations
  IF (dokument_del_egenskaber_obj).indeks is null OR 
   (dokument_del_egenskaber_obj).indhold is null OR 
   (dokument_del_egenskaber_obj).lokation is null OR 
   (dokument_del_egenskaber_obj).mimetype is null 
  THEN

  INSERT INTO
  dokument_del_egenskaber
  (
    del_id,
      indeks,
        indhold,
          lokation,
            mimetype,
              virkning
  )
  SELECT 
    dokument_del_new_id, 
      CASE WHEN (dokument_del_egenskaber_obj.indeks).cleared THEN NULL 
      ELSE coalesce((dokument_del_egenskaber_obj.indeks).value,a.indeks)
      END, 
        coalesce(dokument_del_egenskaber_obj.indhold,a.indhold), 
          coalesce(dokument_del_egenskaber_obj.lokation,a.lokation), 
            coalesce(dokument_del_egenskaber_obj.mimetype,a.mimetype),
              ROW (
                (a.virkning).TimePeriod * (dokument_del_egenskaber_obj.virkning).TimePeriod,
                (dokument_del_egenskaber_obj.virkning).AktoerRef,
                (dokument_del_egenskaber_obj.virkning).AktoerTypeKode,
                (dokument_del_egenskaber_obj.virkning).NoteTekst
              )::Virkning
  FROM dokument_del_egenskaber a
  JOIN dokument_del b on a.del_id=b.id
  JOIN dokument_variant c on b.variant_id=c.id
  WHERE
    c.dokument_registrering_id=prev_dokument_registrering.id 
    and c.varianttekst=dokument_variant_obj.varianttekst
    and b.deltekst=dokument_del_obj.deltekst
    and (a.virkning).TimePeriod && (dokument_del_egenskaber_obj.virkning).TimePeriod
  ;

  --For any periods within the virkning of the dokument_del_egenskaber_obj, that is NOT covered by any "merged" rows inserted above, generate and insert rows

  INSERT INTO
  dokument_del_egenskaber
  (
    del_id,
      indeks,
        indhold,
          lokation,
            mimetype,
              virkning
  )
  SELECT 
    dokument_del_new_id,
      dokument_del_egenskaber_obj.indeks, 
        dokument_del_egenskaber_obj.indhold, 
          dokument_del_egenskaber_obj.lokation, 
            dokument_del_egenskaber_obj.mimetype,
              ROW (
                   b.tz_range_leftover,
                  (dokument_del_egenskaber_obj.virkning).AktoerRef,
                  (dokument_del_egenskaber_obj.virkning).AktoerTypeKode,
                  (dokument_del_egenskaber_obj.virkning).NoteTekst
              )::Virkning
  FROM
  (
  --build an array of the timeperiod of the virkning of the relevant dokument_del_egenskaber of the new registrering to pass to _subtract_tstzrange_arr 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM dokument_del_egenskaber b
      JOIN dokument_del c on b.del_id=c.id
      JOIN dokument_variant d on c.variant_id=d.id
      WHERE 
      d.dokument_registrering_id=new_dokument_registrering.id
      and d.varianttekst=dokument_variant_obj.varianttekst
      and c.deltekst=dokument_del_obj.deltekst
  ) as a
  JOIN unnest(_subtract_tstzrange_arr((dokument_del_egenskaber_obj.virkning).TimePeriod,a.tzranges_of_new_reg)) as b(tz_range_leftover) on true
  ;
  ELSE
     --insert dokument_del_egenskaber_obj raw (if there were no null-valued fields)

  INSERT INTO
  dokument_del_egenskaber
  (
    del_id,
      indeks,
        indhold,
          lokation,
            mimetype,
              virkning
  )
  SELECT 
    dokument_del_new_id,
      dokument_del_egenskaber_obj.indeks, 
        dokument_del_egenskaber_obj.indhold, 
          dokument_del_egenskaber_obj.lokation, 
            dokument_del_egenskaber_obj.mimetype,
              dokument_del_egenskaber_obj.virkning
  ;

  END IF; --else block: null field in del egenskaber obj pesent

  END LOOP;
    END IF; --del obj has egenskaber given.

    END IF; --else block: explicit empty array of variant del egenskaber given

     IF dokument_del_obj.relationer IS NOT NULL AND coalesce(array_length(dokument_del_obj.relationer,1),0)=0 THEN
     dokument_variant_del_relationer_deleted:=array_append(dokument_variant_del_relationer_deleted,ROW(dokument_variant_obj.varianttekst, dokument_del_obj.deltekst)::_DokumentVariantDelKey);
    
    ELSE


    INSERT INTO dokument_del_relation(
        del_id, 
          virkning, 
            rel_maal_uuid, 
              rel_maal_urn, 
                rel_type, 
                  objekt_type
        )
    SELECT
        dokument_del_new_id,
          a.virkning,
            a.uuid,
              a.urn,
                a.relType,
                  a.objektType
    FROM unnest(dokument_del_obj.relationer) a(relType,virkning,uuid,urn,objektType)
    ;

    END IF; --explicit empty array of variant del relationer given

    END LOOP; --dokument_variant_obj.dele


END IF; --dokument dele present



END IF; --else block: explicit empty array of variant dele given





END LOOP;

END IF; --variants given with this update.


/****************************************************/
--carry over any variant egenskaber of the prev. registration, unless explicitly deleted - where there is room acording to virkning


SELECT array_agg(varianttekst) into dokument_variants_prev_reg_arr
FROM
dokument_variant a
WHERE a.dokument_registrering_id=prev_dokument_registrering.id
and a.varianttekst not in (select varianttekst from unnest(dokument_variant_egenskaber_expl_deleted) b(varianttekst) )
;

IF dokument_variants_prev_reg_arr IS NOT NULL AND coalesce(array_length(dokument_variants_prev_reg_arr,1),0)>0 THEN

FOREACH dokument_variant_egenskaber_prev_reg_varianttekst IN ARRAY dokument_variants_prev_reg_arr
LOOP 


dokument_variant_id:=_ensure_document_variant_exists_and_get(new_dokument_registrering.id,dokument_variant_egenskaber_prev_reg_varianttekst);

INSERT INTO
    dokument_variant_egenskaber (
      variant_id,
        arkivering, 
          delvisscannet, 
            offentliggoerelse, 
              produktion,
                virkning 
    )
SELECT
      dokument_variant_id,
        a.arkivering,
          a.delvisscannet,
            a.offentliggoerelse,
              a.produktion,               
                ROW(
                  c.tz_range_leftover,
              (a.virkning).AktoerRef,
              (a.virkning).AktoerTypeKode,
              (a.virkning).NoteTekst
                ) :: virkning
FROM
(
 --build an array of the timeperiod of the virkning of the dokument_variant_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the dokumentvariant_attr_egenskaber of the previous registrering 
    SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
    FROM dokument_variant_egenskaber b
    WHERE 
    b.variant_id=dokument_variant_id

) d
  JOIN dokument_variant_egenskaber a ON true  
  JOIN dokument_variant e ON a.variant_id = e.id
  JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
  WHERE e.dokument_registrering_id=prev_dokument_registrering.id    
  and e.varianttekst=dokument_variant_egenskaber_prev_reg_varianttekst 
;

END LOOP; --loop dokument_variant_egenskaber_prev_reg_varianttekst
END IF;-- not null dokument_variants_prev_reg_arr


/****************************************************/
--carry over any variant del egenskaber of the prev. registration, unless explicitly deleted -  where there is room acording to virkning

  SELECT array_agg(row(a.varianttekst,a.deltekst)::_DokumentVariantDelKey) into dokument_variant_del_prev_reg_arr
  FROM
  (
  SELECT a.varianttekst,b.deltekst
  FROM
  dokument_variant a
  join dokument_del b on b.variant_id=a.id
  LEFT join unnest(dokument_variant_del_egenskaber_deleted) c(varianttekst,deltekst) on a.varianttekst=c.varianttekst and b.deltekst=c.deltekst
  LEFT JOIN unnest(dokument_variant_dele_all_expl_deleted) d(varianttekst) on d.varianttekst = a.varianttekst
  WHERE a.dokument_registrering_id=prev_dokument_registrering.id
  and d.varianttekst is null
  and (c.varianttekst is null and c.deltekst is null)
  group by a.varianttekst,b.deltekst
 ) as a
;
 

if dokument_variant_del_prev_reg_arr IS NOT NULL and coalesce(array_length(dokument_variant_del_prev_reg_arr,1),0)>0 THEN

  FOREACH dokument_variant_del_prev_reg in ARRAY dokument_variant_del_prev_reg_arr
  LOOP

  dokument_del_id:=_ensure_document_variant_and_del_exists_and_get_del(new_dokument_registrering.id,dokument_variant_del_prev_reg.varianttekst,dokument_variant_del_prev_reg.deltekst);

  INSERT INTO dokument_del_egenskaber (
      del_id,
        indeks,
          indhold,
            lokation,
              mimetype,
                virkning
    )
  SELECT
      dokument_del_id,
        a.indeks,
          a.indhold,
            a.lokation,
              a.mimetype,
                ROW(
                  c.tz_range_leftover,
                    (a.virkning).AktoerRef,
                    (a.virkning).AktoerTypeKode,
                    (a.virkning).NoteTekst
                ) :: virkning
  FROM
  (
   --build an array of the timeperiod of the virkning of the dokument_del_egenskaber of the new registrering to pass to _subtract_tstzrange_arr on the relevant dokument_del_egenskaber of the previous registrering 
      SELECT coalesce(array_agg((b.virkning).TimePeriod),array[]::TSTZRANGE[]) tzranges_of_new_reg
      FROM dokument_del_egenskaber b
      JOIN dokument_del c on b.del_id=c.id
      JOIN dokument_variant d on c.variant_id=d.id
      WHERE 
            d.dokument_registrering_id=new_dokument_registrering.id
            AND d.varianttekst=dokument_variant_del_prev_reg.varianttekst
            AND c.deltekst=dokument_variant_del_prev_reg.deltekst
  ) d
    JOIN dokument_del_egenskaber a ON true  
    JOIN dokument_del b on a.del_id=b.id
    JOIN dokument_variant e on b.variant_id=e.id
    JOIN unnest(_subtract_tstzrange_arr((a.virkning).TimePeriod,tzranges_of_new_reg)) as c(tz_range_leftover) on true
    WHERE e.dokument_registrering_id=prev_dokument_registrering.id    
    AND e.varianttekst=dokument_variant_del_prev_reg.varianttekst
    AND b.deltekst=dokument_variant_del_prev_reg.deltekst
  ;

  END LOOP;


END IF; --dokument_variant_del_prev_reg_arr not empty




/****************************************************/
--carry over any document part relations of the prev. relation if a) they were not explicitly cleared and b)no document part relations is already present for the variant del.



--3) Transfer relations of prev reg.

--Identify the variant + del combos that should have relations carried over
SELECT array_agg(ROW(e.varianttekst,e.deltekst)::_DokumentVariantDelKey) into dokument_variant_del_prev_reg_rel_transfer
FROM
(
  SELECT
  c.varianttekst,b.deltekst
  FROM dokument_del_relation a 
  JOIN dokument_del b on a.del_id=b.id
  JOIN dokument_variant c on b.variant_id=c.id
  LEFT JOIN unnest(dokument_variant_del_relationer_deleted) d(varianttekst,deltekst) on d.varianttekst=c.varianttekst and d.deltekst=b.deltekst
  WHERE c.dokument_registrering_id=prev_dokument_registrering.id
  AND (d.varianttekst IS NULL AND d.deltekst IS NULL) 
  EXCEPT
  SELECT
  c.varianttekst,b.deltekst
  FROM dokument_del_relation a 
  JOIN dokument_del b on a.del_id=b.id
  JOIN dokument_variant c on b.variant_id=c.id
  WHERE c.dokument_registrering_id=new_dokument_registrering.id
) as e
;




-- Make sure that part + variants are in place 
IF dokument_variant_del_prev_reg_rel_transfer IS NOT NULL AND coalesce(array_length(dokument_variant_del_prev_reg_rel_transfer,1),0)>0 THEN
  FOREACH dokument_variant_del_prev_reg IN array dokument_variant_del_prev_reg_rel_transfer
  LOOP
     dokument_del_id:=_ensure_document_variant_and_del_exists_and_get_del(new_dokument_registrering.id,dokument_variant_del_prev_reg.varianttekst , dokument_variant_del_prev_reg.deltekst);

--transfer relations of prev reg.
INSERT INTO dokument_del_relation(
    del_id, 
      virkning, 
        rel_maal_uuid, 
          rel_maal_urn, 
            rel_type, 
              objekt_type
    )
SELECT
    dokument_del_id,
      a.virkning,
        a.rel_maal_uuid,
          a.rel_maal_urn,
            a.rel_type,
              a.objekt_type
FROM dokument_del_relation a 
JOIN dokument_del b on a.del_id=b.id
JOIN dokument_variant c on b.variant_id=c.id
WHERE c.dokument_registrering_id=prev_dokument_registrering.id
AND c.varianttekst=dokument_variant_del_prev_reg.varianttekst
AND b.deltekst=dokument_variant_del_prev_reg.deltekst
;

END LOOP;

END IF; --block: there are relations to transfer
END IF; --else block for skip on empty array for variants.



    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_dokument := as_read_dokument(dokument_uuid, (new_dokument_registrering.registrering).timeperiod, null);
    read_prev_dokument := as_read_dokument(dokument_uuid, (prev_dokument_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_dokument.registrering[1].registrering).TimePeriod) = lower((new_dokument_registrering.registrering).TimePeriod) and lower((read_prev_dokument.registrering[1].registrering).TimePeriod)=lower((prev_dokument_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating dokument with id [%]: The ordering of as_list_dokument should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', dokument_uuid, to_json(new_dokument_registrering), to_json(read_new_dokument.registrering[1].registrering), to_json(prev_dokument_registrering), to_json(prev_new_dokument.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_dokument_reg := ROW(
        ROW (null, (read_new_dokument.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_dokument.registrering[1]).tilsFremdrift ,
        
        (read_new_dokument.registrering[1]).attrEgenskaber ,
        (read_new_dokument.registrering[1]).relationer,
        (read_new_dokument.registrering[1]).varianter
    )::dokumentRegistreringType;

    read_prev_dokument_reg := ROW(
        ROW(null, (read_prev_dokument.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_dokument.registrering[1]).tilsFremdrift ,
        
        (read_prev_dokument.registrering[1]).attrEgenskaber ,
        (read_prev_dokument.registrering[1]).relationer,
        (read_prev_dokument.registrering[1]).varianter
    )::dokumentRegistreringType;


    IF read_prev_dokument_reg = read_new_dokument_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_dokument_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_dokument_reg);
      RAISE EXCEPTION 'Aborted updating dokument with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', dokument_uuid, to_json(read_new_dokument_reg), to_json(read_prev_dokument_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_dokument_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_dokument (
    dokument_registrering DokumentRegistreringType,
    dokument_uuid uuid DEFAULT NULL, auth_criteria_arr
    DokumentRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE dokument_registrering_id bigint;

    
    dokument_attr_egenskaber_obj dokumentEgenskaberAttrType;
    

    
    dokument_tils_fremdrift_obj dokumentFremdriftTilsType;
    

    dokument_relationer DokumentRelationType;

    
    dokument_variant_obj DokumentVariantType;
    dokument_variant_egenskab_obj DokumentVariantEgenskaberType;
    dokument_del_obj DokumentDelType;
    dokument_del_egenskaber_obj DokumentDelEgenskaberType;
    dokument_del_relation_obj DokumentDelRelationType;
    dokument_variant_new_id bigint;
    dokument_del_new_id bigint;
    

    auth_filtered_uuids uuid[];

    

    does_exist boolean;
    new_dokument_registrering dokument_registrering;
BEGIN
    IF dokument_uuid IS NULL THEN LOOP
        dokument_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from dokument WHERE id=dokument_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from dokument WHERE id=dokument_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (dokument_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (dokument_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (dokument_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_dokument.',(dokument_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO dokument (ID) SELECT
        dokument_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        dokument_registrering_id:=nextval('dokument_registrering_id_seq');

        INSERT INTO dokument_registrering (id, dokument_id,
            registrering) SELECT dokument_registrering_id,
        dokument_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (dokument_registrering.registrering).livscykluskode,
        (dokument_registrering.registrering).brugerref,
        (dokument_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_dokument_registrering :=
            _as_create_dokument_registrering(dokument_uuid,
                (dokument_registrering.registrering).livscykluskode,
                (dokument_registrering.registrering).brugerref,
                (dokument_registrering.registrering).note);

            dokument_registrering_id := new_dokument_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(dokument_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [dokument]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF dokument_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(dokument_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH dokument_attr_egenskaber_obj IN ARRAY dokument_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO dokument_attr_egenskaber (
      
      brugervendtnoegle,
      beskrivelse,
      brevdato,
      kassationskode,
      major,
      minor,
      offentlighedundtaget,
      titel,
      dokumenttype,
      virkning,
      dokument_registrering_id
    )
    SELECT
     
     dokument_attr_egenskaber_obj.brugervendtnoegle,
      dokument_attr_egenskaber_obj.beskrivelse,
      dokument_attr_egenskaber_obj.brevdato,
      dokument_attr_egenskaber_obj.kassationskode,
      dokument_attr_egenskaber_obj.major,
      dokument_attr_egenskaber_obj.minor,
      dokument_attr_egenskaber_obj.offentlighedundtaget,
      dokument_attr_egenskaber_obj.titel,
      dokument_attr_egenskaber_obj.dokumenttype,
      dokument_attr_egenskaber_obj.virkning,
      dokument_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(dokument_registrering.tilsFremdrift, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [fremdrift] for dokument. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF dokument_registrering.tilsFremdrift IS NOT NULL AND coalesce(array_length(dokument_registrering.tilsFremdrift,1),0)>0 THEN
  FOREACH dokument_tils_fremdrift_obj IN ARRAY dokument_registrering.tilsFremdrift
  LOOP

    INSERT INTO dokument_tils_fremdrift (
      virkning,
      fremdrift,
      dokument_registrering_id
    )
    SELECT
      dokument_tils_fremdrift_obj.virkning,
      dokument_tils_fremdrift_obj.fremdrift,
      dokument_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations



    INSERT INTO dokument_relation (
      dokument_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      dokument_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(dokument_registrering.relationer) a
  ;



--/*********************************/
--Insert document variants (and parts)

IF dokument_registrering.varianter IS NOT NULL AND coalesce(array_length(dokument_registrering.varianter,1),0)>0 THEN
  

FOREACH dokument_variant_obj IN ARRAY dokument_registrering.varianter
LOOP

dokument_variant_new_id:=nextval('dokument_variant_id_seq'::regclass);

  INSERT INTO dokument_variant (
      id,
        varianttekst,
          dokument_registrering_id
  )
  VALUES
  (
      dokument_variant_new_id,
        dokument_variant_obj.varianttekst,
          dokument_registrering_id
  ); 


  IF dokument_variant_obj.egenskaber IS NOT NULL AND coalesce(array_length(dokument_variant_obj.egenskaber,1),0)>0 THEN

    FOREACH dokument_variant_egenskab_obj IN ARRAY dokument_variant_obj.egenskaber
    LOOP

     INSERT INTO dokument_variant_egenskaber (
      variant_id,
        arkivering, 
          delvisscannet, 
            offentliggoerelse, 
              produktion,
                virkning
      )
      SELECT
      dokument_variant_new_id,  
        dokument_variant_egenskab_obj.arkivering,
          dokument_variant_egenskab_obj.delvisscannet,
            dokument_variant_egenskab_obj.offentliggoerelse,
              dokument_variant_egenskab_obj.produktion,
                dokument_variant_egenskab_obj.virkning
      ;

    END LOOP; --variant_egenskaber
  END IF; --variant_egenskaber


  IF dokument_variant_obj.dele IS NOT NULL AND coalesce(array_length(dokument_variant_obj.dele,1),0)>0 THEN

    FOREACH dokument_del_obj IN ARRAY dokument_variant_obj.dele
    LOOP

    dokument_del_new_id:=nextval('dokument_del_id_seq'::regclass);

  INSERT INTO dokument_del (
    id,
      deltekst,
        variant_id
    )
    VALUES
    (
    dokument_del_new_id,
        dokument_del_obj.deltekst,
          dokument_variant_new_id
    )
    ;

    IF dokument_del_obj.egenskaber IS NOT NULL AND coalesce(array_length(dokument_del_obj.egenskaber,1),0)>0 THEN

    FOREACH dokument_del_egenskaber_obj IN ARRAY dokument_del_obj.egenskaber
    LOOP

    INSERT INTO
    dokument_del_egenskaber (
      del_id,
        indeks, 
          indhold, 
            lokation, 
              mimetype, 
                virkning
    )
    VALUES
    (
      dokument_del_new_id, 
        dokument_del_egenskaber_obj.indeks,
          dokument_del_egenskaber_obj.indhold,
            dokument_del_egenskaber_obj.lokation,
              dokument_del_egenskaber_obj.mimetype,
                dokument_del_egenskaber_obj.virkning
    )
    ;                

    END LOOP;--del_egenskaber
    END IF; --del_egenskaber

    IF dokument_del_obj.relationer IS NOT NULL AND coalesce(array_length(dokument_del_obj.relationer,1),0)>0 THEN

    FOREACH dokument_del_relation_obj IN ARRAY dokument_del_obj.relationer
    LOOP

      INSERT INTO dokument_del_relation (
        del_id,
          virkning,
            rel_maal_uuid, 
              rel_maal_urn,
                rel_type,
                  objekt_type
      )
      VALUES
      (
        dokument_del_new_id,
          dokument_del_relation_obj.virkning,
            dokument_del_relation_obj.uuid,
              dokument_del_relation_obj.urn,
                dokument_del_relation_obj.relType,
                  dokument_del_relation_obj.objektType
      )
      ;

    END LOOP;--del_relationer

    END IF; --dokument_del_obj.relationer

    END LOOP; --variant_dele
  END IF; 

 END LOOP; --varianter


END IF; --varianter



/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_dokument(array[dokument_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[dokument_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import dokument with uuid [%]. Object does not met stipulated criteria:%',dokument_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN dokument_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_dokument(dokument_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr DokumentRegistreringType[]=null
  )
  RETURNS DokumentType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result DokumentType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_dokument(dokument_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(dokument_uuids,1),0) AND auth_filtered_uuids @>dokument_uuids) THEN
  RAISE EXCEPTION 'Unable to list dokument with uuids [%]. All objects do not fullfill the stipulated criteria:%',dokument_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.dokumentObj) into result
FROM
(
SELECT
ROW(
	a.dokument_id,
	array_agg(
		ROW (
			a.registrering,
			a.DokumentTilsFremdriftArr,
			a.DokumentAttrEgenskaberArr,
			a.DokumentRelationArr,
            b.varianter
		)::DokumentRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: DokumentType  dokumentObj
FROM
(
	SELECT
	a.dokument_id,
	a.dokument_registrering_id,
	a.registrering,
	a.DokumentAttrEgenskaberArr,
	a.DokumentTilsFremdriftArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type
			):: DokumentRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
        
	)) DokumentRelationArr
	FROM
	(
			SELECT
			a.dokument_id,
			a.dokument_registrering_id,
			a.registrering,
			a.DokumentAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.fremdrift
						) ::DokumentFremdriftTilsType
					ELSE NULL
					END
					order by b.fremdrift,b.virkning
				)) DokumentTilsFremdriftArr		
			FROM
			(
					SELECT
					a.dokument_id,
					a.dokument_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.beskrivelse,
					 		b.brevdato,
					 		b.kassationskode,
					 		b.major,
					 		b.minor,
					 		b.offentlighedundtaget,
					 		b.titel,
					 		b.dokumenttype,
					   		b.virkning
                            
							)::DokumentEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.beskrivelse,b.brevdato,b.kassationskode,b.major,b.minor,b.offentlighedundtaget,b.titel,b.dokumenttype,b.virkning
                        
					)) DokumentAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id dokument_id,
					b.id dokument_registrering_id,
					b.registrering			
					FROM		dokument a
					JOIN 		dokument_registrering b 	ON b.dokument_id=a.id
					WHERE a.id = ANY (dokument_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN dokument_attr_egenskaber as b ON b.dokument_registrering_id=a.dokument_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.dokument_id,
					a.dokument_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN dokument_tils_fremdrift as b ON b.dokument_registrering_id=a.dokument_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.dokument_id,
			a.dokument_registrering_id,
			a.registrering,
			a.DokumentAttrEgenskaberArr
	) as a
	LEFT JOIN dokument_relation b ON b.dokument_registrering_id=a.dokument_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.dokument_id,
	a.dokument_registrering_id,
	a.registrering,
	a.DokumentAttrEgenskaberArr,
	a.DokumentTilsFremdriftArr
) as a

LEFT JOIN _as_list_dokument_varianter(dokument_uuids,registrering_tstzrange,virkning_tstzrange) b on a.dokument_registrering_id=b.dokument_registrering_id

WHERE a.dokument_id IS NOT NULL
GROUP BY 
a.dokument_id
order by a.dokument_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_dokument(
    dokument_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      DokumentRegistreringType[]=null
) RETURNS DokumentType AS $$
DECLARE
	resArr DokumentType[];
BEGIN
    resArr := as_list_dokument(ARRAY[dokument_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_dokument(
    firstResult int,--TOOD ??
    dokument_uuid uuid,
    registreringObj   DokumentRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr DokumentRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    dokument_candidates uuid[];
    dokument_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj DokumentEgenskaberAttrType;

    
    tilsFremdriftTypeObj DokumentFremdriftTilsType;

    relationTypeObj DokumentRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    
    variantTypeObj DokumentVariantType;
    variantEgenskaberTypeObj DokumentVariantEgenskaberType;
    delTypeObj DokumentDelType;
    delEgenskaberTypeObj DokumentDelEgenskaberType;
    delRelationTypeObj DokumentdelRelationType;
    variant_candidates_ids bigint[];
    variant_candidates_is_initialized boolean;
    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

dokument_candidates_is_initialized := false;

IF dokument_uuid is not NULL THEN
    dokument_candidates:= ARRAY[dokument_uuid];
    dokument_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        dokument_candidates:=array(
                SELECT DISTINCT
                b.dokument_id
                FROM
                dokument a
                JOIN dokument_registrering b on b.dokument_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'dokument_candidates_is_initialized step 1:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 1:%',dokument_candidates;
--/****************************//


--RAISE NOTICE 'dokument_candidates_is_initialized step 2:%',dokument_candidates_is_initialized;
--RAISE NOTICE 'dokument_candidates step 2:%',dokument_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_dokument: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(dokument_candidates,1),0)>0 OR NOT dokument_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            dokument_candidates:=array(
            SELECT DISTINCT
            b.dokument_id
            FROM  dokument_attr_egenskaber a
            JOIN dokument_registrering b on a.dokument_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.beskrivelse IS NULL
                    OR
                    a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.brevdato IS NULL
                    OR
                    a.brevdato = attrEgenskaberTypeObj.brevdato
                )
                AND
                (
                    attrEgenskaberTypeObj.kassationskode IS NULL
                    OR
                    a.kassationskode ILIKE attrEgenskaberTypeObj.kassationskode --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.major IS NULL
                    OR
                    a.major = attrEgenskaberTypeObj.major
                )
                AND
                (
                    attrEgenskaberTypeObj.minor IS NULL
                    OR
                    a.minor = attrEgenskaberTypeObj.minor
                )
                AND
                (
                    attrEgenskaberTypeObj.offentlighedundtaget IS NULL
                    OR
                        (
                            (
                                (attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel IS NULL
                                OR
                                (a.offentlighedundtaget).AlternativTitel ILIKE (attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel
                            )
                            AND
                            (
                                (attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel IS NULL
                                OR
                                (a.offentlighedundtaget).Hjemmel ILIKE (attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel
                            )
                        )
                )
                AND
                (
                    attrEgenskaberTypeObj.titel IS NULL
                    OR
                    a.titel ILIKE attrEgenskaberTypeObj.titel --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.dokumenttype IS NULL
                    OR
                    a.dokumenttype ILIKE attrEgenskaberTypeObj.dokumenttype --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

            );


            dokument_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'dokument_candidates_is_initialized step 3:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 3:%',dokument_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        dokument_candidates:=array(

            SELECT DISTINCT
            b.dokument_id
            
            FROM dokument_registrering b 
            LEFT JOIN dokument_attr_egenskaber a on a.dokument_registrering_id=b.id and (virkningSoeg IS NULL or virkningSoeg && (a.virkning).TimePeriod )
            LEFT JOIN dokument_variant c on c.dokument_registrering_id=b.id 
            LEFT JOIN dokument_del f on f.variant_id=c.id
            LEFT JOIN dokument_del_egenskaber d on d.del_id = f.id and (virkningSoeg IS NULL or virkningSoeg && (d.virkning).TimePeriod )
            LEFT JOIN dokument_variant_egenskaber e on e.variant_id = c.id and (virkningSoeg IS NULL or virkningSoeg && (e.virkning).TimePeriod )
            WHERE
            (
                (
                    a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.beskrivelse ILIKE anyAttrValue OR
                                    a.brevdato::text ilike anyAttrValue OR
                        a.kassationskode ILIKE anyAttrValue OR
                                    a.major::text ilike anyAttrValue OR
                                    a.minor::text ilike anyAttrValue OR
                                    (a.offentlighedundtaget).Hjemmel ilike anyAttrValue OR (a.offentlighedundtaget).AlternativTitel ilike anyAttrValue OR
                        a.titel ILIKE anyAttrValue OR
                        a.dokumenttype ILIKE anyAttrValue
                )
                OR
                (
                    (c.varianttekst ilike anyAttrValue and e.id is not null) --varianttekst handled like it is logically part of variant egenskaber
                )
                OR
                (
                    (f.deltekst ilike anyAttrValue and d.id is not null ) --deltekst handled like it is logically part of del egenskaber
                    OR
                    d.indeks::text = anyAttrValue
                    OR
                    d.indhold ILIKE anyAttrValue
                    OR
                    d.lokation ILIKE anyAttrValue
                    OR
                    d.mimetype ILIKE anyAttrValue
                )
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )


        );

    dokument_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Fremdrift
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsFremdrift IS NULL THEN
    --RAISE DEBUG 'as_search_dokument: skipping filtration on tilsFremdrift';
ELSE
    IF (coalesce(array_length(dokument_candidates,1),0)>0 OR dokument_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsFremdriftTypeObj IN ARRAY registreringObj.tilsFremdrift
        LOOP
            dokument_candidates:=array(
            SELECT DISTINCT
            b.dokument_id
            FROM  dokument_tils_fremdrift a
            JOIN dokument_registrering b on a.dokument_registrering_id=b.id
            WHERE
                (
                    tilsFremdriftTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsFremdriftTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsFremdriftTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsFremdriftTypeObj.virkning).AktoerRef IS NULL OR (tilsFremdriftTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsFremdriftTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsFremdriftTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsFremdriftTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsFremdriftTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsFremdriftTypeObj.virkning) IS NULL OR (tilsFremdriftTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsFremdriftTypeObj.fremdrift IS NULL
                    OR
                    tilsFremdriftTypeObj.fremdrift = a.fremdrift
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

    );


            dokument_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer DokumentRelationType[]
*/


--RAISE DEBUG 'dokument_candidates_is_initialized step 4:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 4:%',dokument_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_dokument: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(dokument_candidates,1),0)>0 OR NOT dokument_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            dokument_candidates:=array(
            SELECT DISTINCT
            b.dokument_id
            FROM  dokument_relation a
            JOIN dokument_registrering b on a.dokument_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

    );

            dokument_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        dokument_candidates:=array(
            SELECT DISTINCT
            b.dokument_id
            
            FROM dokument_registrering b  
            LEFT JOIN dokument_relation a on a.dokument_registrering_id=b.id and (virkningSoeg IS NULL or (virkningSoeg && (a.virkning).TimePeriod) )
            LEFT JOIN dokument_variant c on c.dokument_registrering_id=b.id
            LEFT JOIN dokument_del d on d.variant_id=c.id 
            LEFT JOIN dokument_del_relation e on d.id=e.del_id and (virkningSoeg IS NULL or (virkningSoeg && (e.virkning).TimePeriod) )
            WHERE
            (anyuuid = a.rel_maal_uuid OR anyuuid = e.rel_maal_uuid)
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )


            );

    dokument_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        dokument_candidates:=array(
            SELECT DISTINCT
            b.dokument_id
            
            FROM dokument_registrering b  
            LEFT JOIN dokument_relation a on a.dokument_registrering_id=b.id and (virkningSoeg IS NULL or virkningSoeg && (a.virkning).TimePeriod )
            LEFT JOIN dokument_variant c on c.dokument_registrering_id=b.id
            LEFT JOIN dokument_del d on d.variant_id=c.id
            LEFT JOIN dokument_del_relation e on d.id=e.del_id and (virkningSoeg IS NULL or virkningSoeg && (e.virkning).TimePeriod)
            WHERE
            (anyurn = a.rel_maal_urn OR anyurn = e.rel_maal_urn)
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )


            );

    dokument_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

--/**********************************************************//
--Filtration on variants and document parts (dele)
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).varianter IS NULL THEN
	--RAISE DEBUG 'as_search_dokument: skipping filtration on relationer';
ELSE
		IF (registreringObj).varianter IS NOT NULL AND coalesce(array_length(registreringObj.varianter,1),0)>0 THEN
		FOREACH variantTypeObj IN ARRAY registreringObj.varianter
		LOOP

		variant_candidates_ids=array[]::bigint[];
		variant_candidates_is_initialized:=false;

		IF (coalesce(array_length(dokument_candidates,1),0)>0 OR NOT dokument_candidates_is_initialized) THEN 

		--HACK: As variant_name logically can be said to be part of variant egenskaber (regarding virkning), we'll force a filter on variant egenskaber if needed
		IF coalesce(array_length(variantTypeObj.egenskaber,1),0)=0 AND variantTypeObj.varianttekst IS NOT NULL THEN
			variantTypeObj.egenskaber:=ARRAY[ROW(null,null,null,null,null)::DokumentVariantEgenskaberType]::DokumentVariantEgenskaberType[];
		END IF;

		IF coalesce(array_length(variantTypeObj.egenskaber,1),0)>0 THEN
		
		FOREACH variantEgenskaberTypeObj in ARRAY variantTypeObj.egenskaber
		LOOP

		IF (coalesce(array_length(variant_candidates_ids,1),0)>0 OR not variant_candidates_is_initialized) THEN

			IF variantTypeObj.varianttekst IS NOT NULL OR
				(
					(NOT (variantEgenskaberTypeObj.arkivering IS NULL))
					OR
					(NOT (variantEgenskaberTypeObj.delvisscannet IS NULL))
					OR
					(NOT (variantEgenskaberTypeObj.offentliggoerelse IS NULL))
					OR
					(NOT (variantEgenskaberTypeObj.produktion IS NULL))
				)
			 THEN --test if there is any data availiable for variant to filter on
			

			--part for searching on variant + egenskaber
			variant_candidates_ids:=array(
			SELECT DISTINCT
			a.id
			FROM dokument_variant a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id
			JOIN dokument_variant_egenskaber c on c.variant_id=a.id  --we require the presence egenskaber (variant name is logically part of it)
			WHERE
			(
				variantTypeObj.varianttekst IS NULL
				OR
				a.varianttekst ilike variantTypeObj.varianttekst
			)
			AND
			(
				(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (c.virkning).TimePeriod
				)
			)
			AND
			(
				(
				variantEgenskaberTypeObj.virkning IS NULL
				OR 
				(variantEgenskaberTypeObj.virkning).TimePeriod && (c.virkning).TimePeriod 
				)
			)
			AND
				(
				variantEgenskaberTypeObj.virkning IS NULL
				OR
					(
						(
								(variantEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (c.virkning).AktoerRef = (variantEgenskaberTypeObj.virkning).AktoerRef
						)
						AND
						(
								(variantEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (variantEgenskaberTypeObj.virkning).AktoerTypeKode=(c.virkning).AktoerTypeKode
						)
						AND
						(
								(variantEgenskaberTypeObj.virkning).NoteTekst IS NULL OR (c.virkning).NoteTekst ilike (variantEgenskaberTypeObj.virkning).NoteTekst
						)
					)
				)
			AND
			(
				
				(
					variantEgenskaberTypeObj.arkivering IS NULL
					OR
					variantEgenskaberTypeObj.arkivering = c.arkivering
				)
				AND
				(
					variantEgenskaberTypeObj.delvisscannet IS NULL
					OR
					variantEgenskaberTypeObj.delvisscannet = c.delvisscannet
				)
				AND
				(
					variantEgenskaberTypeObj.offentliggoerelse IS NULL 
					OR
					variantEgenskaberTypeObj.offentliggoerelse = c.offentliggoerelse
				)
				AND
				(
					variantEgenskaberTypeObj.produktion IS NULL  
					OR
					variantEgenskaberTypeObj.produktion = c.produktion
				)
				
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

			AND ((NOT variant_candidates_is_initialized) OR a.id = ANY (variant_candidates_ids) )
			);

			variant_candidates_is_initialized:=true;

			END IF; --any variant candidates left

			END IF; --variant filter criterium exists
			END LOOP; --variant egenskaber

			
			END IF;--variantTypeObj.egenskaber exists  

			/**************    Dokument Dele        ******************/

			IF coalesce(array_length(variantTypeObj.dele,1),0)>0 THEN
			
			FOREACH delTypeObj IN ARRAY variantTypeObj.dele 
			LOOP

			--HACK: As del_name logically can be said to be part of del egenskaber (regarding virkning), we'll force a filter on del egenskaber if needed
			IF coalesce(array_length(delTypeObj.egenskaber,1),0)=0 AND delTypeObj.deltekst IS NOT NULL THEN
				delTypeObj.egenskaber:=ARRAY[ROW(null,null,null,null,null)::DokumentDelEgenskaberType]::DokumentDelEgenskaberType[];
			END IF;


			/**************    Dokument Del Egenskaber    ******************/

			IF coalesce(array_length(delTypeObj.egenskaber,1),0)>0 THEN 
			
			FOREACH delEgenskaberTypeObj IN ARRAY delTypeObj.egenskaber
			LOOP
			
			IF delTypeObj.deltekst IS NOT NULL  	
			OR (NOT delEgenskaberTypeObj.indeks IS NULL)
			OR delEgenskaberTypeObj.indhold IS NOT NULL
			OR delEgenskaberTypeObj.lokation IS NOT NULL
			OR delEgenskaberTypeObj.mimetype IS NOT NULL
			THEN 

			IF (coalesce(array_length(variant_candidates_ids,1),0)>0 OR not variant_candidates_is_initialized) THEN

			variant_candidates_ids:=array(
			SELECT DISTINCT
			a.id
			FROM dokument_variant a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id
			JOIN dokument_del c on c.variant_id=a.id
			JOIN dokument_del_egenskaber d on d.del_id=c.id --we require the presence egenskaber (del name is logically part of it)
		
			WHERE
			(
				delTypeObj.deltekst IS NULL
				OR
				c.deltekst ilike delTypeObj.deltekst
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (d.virkning).TimePeriod
			)
			AND
			(
				delEgenskaberTypeObj.virkning IS NULL --NOTICE only looking at first del egenskaber object throughout
				OR 
				(delEgenskaberTypeObj.virkning).TimePeriod && (d.virkning).TimePeriod 
			)
			AND
			(
				delEgenskaberTypeObj.virkning IS NULL
				OR
					(
						(
								(delEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (d.virkning).AktoerRef = (delEgenskaberTypeObj.virkning).AktoerRef
						)
						AND
						(
								(delEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (delEgenskaberTypeObj.virkning).AktoerTypeKode=(d.virkning).AktoerTypeKode
						)
						AND
						(
								(delEgenskaberTypeObj.virkning).NoteTekst IS NULL OR (d.virkning).NoteTekst ilike (delEgenskaberTypeObj.virkning).NoteTekst
						)
					)
			)
			AND
			(
				(
					(
						delEgenskaberTypeObj.indeks IS NULL  
						OR
						delEgenskaberTypeObj.indeks = d.indeks
					)
					AND
					(
						delEgenskaberTypeObj.indhold IS NULL  
						OR
						d.indhold ilike delEgenskaberTypeObj.indhold  
					)
					AND
					(
						delEgenskaberTypeObj.lokation IS NULL 
						OR
						d.lokation ilike delEgenskaberTypeObj.lokation 
					)
					AND
					(
						delEgenskaberTypeObj.mimetype IS NULL 
						OR
						d.mimetype ilike delEgenskaberTypeObj.mimetype
					)
				)
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

			AND ((NOT variant_candidates_is_initialized) OR a.id = ANY (variant_candidates_ids) )
			);

			variant_candidates_is_initialized:=true;
			END IF; --any variant candidates left
			END IF; --del egenskaber not empty
			END LOOP; --loop del egenskaber
			END IF; -- del egenskaber exists

			/**************    Dokument Del Relationer    ******************/

			IF coalesce(array_length(delTypeObj.relationer,1),0)>0 THEN 
			
			FOREACH delRelationTypeObj IN ARRAY delTypeObj.relationer
			LOOP

			IF (coalesce(array_length(variant_candidates_ids,1),0)>0 OR not variant_candidates_is_initialized) THEN

			variant_candidates_ids:=array(
			SELECT DISTINCT
			a.id
			FROM dokument_variant a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id
			JOIN dokument_del c on c.variant_id=a.id
			JOIN dokument_del_relation d on d.del_id=c.id
			WHERE
			(
				delTypeObj.deltekst IS NULL
				OR
				c.deltekst ilike delTypeObj.deltekst
			)
			AND
			(
				virkningSoeg IS NULL
				OR
				virkningSoeg && (d.virkning).TimePeriod
			)
			AND
			(
				delRelationTypeObj.virkning IS NULL 
				OR 
				(delRelationTypeObj.virkning).TimePeriod && (d.virkning).TimePeriod 
			)
			AND
			(
				delRelationTypeObj.virkning IS NULL
				OR
					(
						(
								(delRelationTypeObj.virkning).AktoerRef IS NULL OR (d.virkning).AktoerRef = (delRelationTypeObj.virkning).AktoerRef
						)
						AND
						(
								(delRelationTypeObj.virkning).AktoerTypeKode IS NULL OR (delRelationTypeObj.virkning).AktoerTypeKode=(d.virkning).AktoerTypeKode
						)
						AND
						(
								(delRelationTypeObj.virkning).NoteTekst IS NULL OR (d.virkning).NoteTekst ilike (delRelationTypeObj.virkning).NoteTekst
						)
					)
			)
			AND
			(	
				delRelationTypeObj.relType IS NULL
				OR
				delRelationTypeObj.relType = d.rel_type
			)
			AND
			(
				delRelationTypeObj.uuid IS NULL
				OR
				delRelationTypeObj.uuid = d.rel_maal_uuid	
			)
			AND
			(
				delRelationTypeObj.objektType IS NULL
				OR
				delRelationTypeObj.objektType = d.objekt_type
			)
			AND
			(
				delRelationTypeObj.urn IS NULL
				OR
				delRelationTypeObj.urn = d.rel_maal_urn
			)
			AND
					(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

			AND ((NOT variant_candidates_is_initialized) OR a.id = ANY (variant_candidates_ids) )
			);
			
			variant_candidates_is_initialized:=true;

			END IF; --any variant candidates left

			END LOOP; --loop del relationer
			END IF; --end if del relationer exists

			END LOOP; --loop del
			END IF;--dele exists


			
			IF variant_candidates_is_initialized THEN
			--We'll then translate the collected variant ids into document ids (please notice that the resulting uuids are already a subset of dokument_candidates)

			dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
			FROM dokument_variant a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id
			WHERE
			a.id = ANY (variant_candidates_ids)
			AND
			((NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )
			);

			dokument_candidates_is_initialized:=true;
			
			END IF; --variant_candidates_is_initialized

			END IF; --no doc candidates - skipping ahead;
			END LOOP; --FOREACH variantTypeObj
		
		END IF; --varianter exists
	END IF; --array registreringObj.varianter exists 




--RAISE DEBUG 'dokument_candidates_is_initialized step 5:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 5:%',dokument_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT dokument_candidates_is_initialized THEN
        dokument_candidates:=array(
        SELECT DISTINCT
            dokument_id
        FROM
            dokument_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT dokument_candidates_is_initialized) OR b.dokument_id = ANY (dokument_candidates) )

        )
        ;

        dokument_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT dokument_candidates_is_initialized THEN
    --No filters applied!
    dokument_candidates:=array(
        SELECT DISTINCT id FROM dokument a
    );
ELSE
    dokument_candidates:=array(
        SELECT DISTINCT id FROM unnest(dokument_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'dokument_candidates_is_initialized step 6:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 6:%',dokument_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_dokument(dokument_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_dokument(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_DokumentRegistreringType_to_json(DokumentRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END dokumentegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsFremdrift,1),0)>0 THEN to_json($1.tilsFremdrift) 
        ELSE 
        NULL
        END dokumentfremdrift
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::DokumentRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer
  ,$1.varianter
  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (DokumentRegistreringType as json);
create cast (DokumentRegistreringType as json) with function actual_state._cast_DokumentRegistreringType_to_json(DokumentRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_dokumentType_to_json(DokumentType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg DokumentRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (DokumentType as json);
create cast (DokumentType as json) with function actual_state._cast_dokumentType_to_json(DokumentType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_dokument(
    dokument_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    DokumentRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    dokument_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    dokument_sorted_uuid:=array(
          SELECT b.dokument_id
            FROM dokument_registrering b
            JOIN dokument_attr_egenskaber a ON a.dokument_registrering_id=b.id
           WHERE b.dokument_id = ANY (dokument_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.dokument_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.dokument_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN dokument_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_dokument(
	dokument_uuids uuid[],
	registreringObjArr DokumentRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	dokument_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	dokument_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj DokumentEgenskaberAttrType;
	
  	tilsFremdriftTypeObj DokumentFremdriftTilsType;
	relationTypeObj DokumentRelationType;
	registreringObj DokumentRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN dokument_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF dokument_uuids IS NULL OR coalesce(array_length(dokument_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

dokument_candidates:= dokument_uuids;



--RAISE DEBUG 'dokument_candidates_is_initialized step 1:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 1:%',dokument_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_dokument: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(dokument_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
			FROM  dokument_attr_egenskaber a 
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.brevdato IS NULL
					OR 
					a.brevdato = attrEgenskaberTypeObj.brevdato 
				)
				AND
				(
					attrEgenskaberTypeObj.kassationskode IS NULL
					OR 
					a.kassationskode = attrEgenskaberTypeObj.kassationskode 
				)
				AND
				(
					attrEgenskaberTypeObj.major IS NULL
					OR 
					a.major = attrEgenskaberTypeObj.major 
				)
				AND
				(
					attrEgenskaberTypeObj.minor IS NULL
					OR 
					a.minor = attrEgenskaberTypeObj.minor 
				)
				AND
				(
					attrEgenskaberTypeObj.offentlighedundtaget IS NULL
					OR
						(
							(
								(attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel IS NULL
								OR
								(a.offentlighedundtaget).AlternativTitel = (attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel 
							)
							AND
							(
								(attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel IS NULL
								OR
								(a.offentlighedundtaget).Hjemmel = (attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel
							)
						) 
				)
				AND
				(
					attrEgenskaberTypeObj.titel IS NULL
					OR 
					a.titel = attrEgenskaberTypeObj.titel 
				)
				AND
				(
					attrEgenskaberTypeObj.dokumenttype IS NULL
					OR 
					a.dokumenttype = attrEgenskaberTypeObj.dokumenttype 
				)
				AND b.dokument_id = ANY (dokument_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'dokument_candidates_is_initialized step 3:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 3:%',dokument_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Fremdrift
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsFremdrift IS NULL THEN
	--RAISE DEBUG 'as_search_dokument: skipping filtration on tilsFremdrift';
ELSE
	IF coalesce(array_length(dokument_candidates,1),0)>0 THEN 

		FOREACH tilsFremdriftTypeObj IN ARRAY registreringObj.tilsFremdrift
		LOOP
			dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
			FROM  dokument_tils_fremdrift a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsFremdriftTypeObj.fremdrift IS NULL
					OR
					tilsFremdriftTypeObj.fremdrift = a.fremdrift
				)
				AND b.dokument_id = ANY (dokument_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer DokumentRelationType[]
*/


--RAISE DEBUG 'dokument_candidates_is_initialized step 4:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 4:%',dokument_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_dokument: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(dokument_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			dokument_candidates:=array(
			SELECT DISTINCT
			b.dokument_id 
			FROM  dokument_relation a
			JOIN dokument_registrering b on a.dokument_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.dokument_id = ANY (dokument_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'dokument_candidates_is_initialized step 5:%',dokument_candidates_is_initialized;
--RAISE DEBUG 'dokument_candidates step 5:%',dokument_candidates;

dokument_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (dokument_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (dokument_candidates) b(id)
);

--optimization 
IF coalesce(array_length(dokument_passed_auth_filter,1),0)=coalesce(array_length(dokument_uuids,1),0) AND dokument_passed_auth_filter @>dokument_uuids THEN
	RETURN dokument_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN dokument_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE FacetPubliceretTils AS ENUM ('Publiceret','IkkePubliceret',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE FacetPubliceretTilsType AS (
    virkning Virkning,
    publiceret FacetPubliceretTils
)
;



CREATE TYPE FacetEgenskaberAttrType AS (
brugervendtnoegle text,
beskrivelse text,
opbygning text,
ophavsret text,
plan text,
supplement text,
retskilde text,
integrationsdata text,

 virkning Virkning
);




CREATE TYPE FacetRelationKode AS ENUM  ('ansvarlig','ejer','facettilhoerer','redaktoerer');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_facet_relation_kode_to_txt is invoked.



CREATE TYPE FacetRelationType AS (
  relType FacetRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text
)
;



CREATE TYPE FacetRegistreringType AS
(
registrering RegistreringBase,
tilsPubliceret FacetPubliceretTilsType[],
attrEgenskaber FacetEgenskaberAttrType[],
relationer FacetRelationType[]
);

CREATE TYPE FacetType AS
(
  id uuid,
  registrering FacetRegistreringType[]
);  





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_facet_relation_kode_to_txt(
    FacetRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE facet (
    id uuid NOT NULL,
    CONSTRAINT facet_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE facet
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE facet_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE facet_registrering_id_seq
    OWNER TO mox;


CREATE TABLE facet_registrering (
   id bigint NOT NULL DEFAULT nextval('facet_registrering_id_seq'::regclass),
   facet_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT facet_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT facet_registrering_facet_fkey FOREIGN KEY (facet_id)
       REFERENCES facet (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT facet_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(facet_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE facet_registrering
  OWNER TO mox;


CREATE INDEX facet_registrering_idx_livscykluskode
    ON facet_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX facet_registrering_idx_brugerref
    ON facet_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX facet_registrering_idx_note
    ON facet_registrering
    USING btree
    (((registrering).note));


CREATE INDEX facet_registrering_pat_note
    ON facet_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX facet_id_idx
    ON facet_registrering (facet_id);


CREATE TRIGGER notify_facet
    AFTER INSERT OR UPDATE OR DELETE ON facet_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE facet_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE facet_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE facet_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('facet_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        beskrivelse text  NULL,
        opbygning text  NULL,
        ophavsret text  NULL,
        plan text  NULL,
        supplement text  NULL,
        retskilde text  NULL,
        integrationsdata text  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    facet_registrering_id bigint NOT NULL,
    CONSTRAINT facet_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT facet_attr_egenskaber_forkey_facetregistrering FOREIGN KEY (facet_registrering_id) REFERENCES facet_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT facet_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (facet_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE facet_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX facet_attr_egenskaber_pat_brugervendtnoegle
            ON facet_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX facet_attr_egenskaber_idx_brugervendtnoegle
            ON facet_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX facet_attr_egenskaber_pat_beskrivelse
            ON facet_attr_egenskaber
            USING gin
            (beskrivelse gin_trgm_ops);

        CREATE INDEX facet_attr_egenskaber_idx_beskrivelse
            ON facet_attr_egenskaber
            USING btree
            (beskrivelse); 
 
     
        CREATE INDEX facet_attr_egenskaber_pat_opbygning
            ON facet_attr_egenskaber
            USING gin
            (opbygning gin_trgm_ops);

        CREATE INDEX facet_attr_egenskaber_idx_opbygning
            ON facet_attr_egenskaber
            USING btree
            (opbygning); 
 
     
        CREATE INDEX facet_attr_egenskaber_pat_ophavsret
            ON facet_attr_egenskaber
            USING gin
            (ophavsret gin_trgm_ops);

        CREATE INDEX facet_attr_egenskaber_idx_ophavsret
            ON facet_attr_egenskaber
            USING btree
            (ophavsret); 
 
     
        CREATE INDEX facet_attr_egenskaber_pat_plan
            ON facet_attr_egenskaber
            USING gin
            (plan gin_trgm_ops);

        CREATE INDEX facet_attr_egenskaber_idx_plan
            ON facet_attr_egenskaber
            USING btree
            (plan); 
 
     
        CREATE INDEX facet_attr_egenskaber_pat_supplement
            ON facet_attr_egenskaber
            USING gin
            (supplement gin_trgm_ops);

        CREATE INDEX facet_attr_egenskaber_idx_supplement
            ON facet_attr_egenskaber
            USING btree
            (supplement); 
 
     
        CREATE INDEX facet_attr_egenskaber_pat_retskilde
            ON facet_attr_egenskaber
            USING gin
            (retskilde gin_trgm_ops);

        CREATE INDEX facet_attr_egenskaber_idx_retskilde
            ON facet_attr_egenskaber
            USING btree
            (retskilde); 
 
     
        CREATE INDEX facet_attr_egenskaber_pat_integrationsdata
            ON facet_attr_egenskaber
            USING gin
            (integrationsdata gin_trgm_ops);

        CREATE INDEX facet_attr_egenskaber_idx_integrationsdata
            ON facet_attr_egenskaber
            USING btree
            (integrationsdata); 



CREATE INDEX facet_attr_egenskaber_idx_virkning_aktoerref
    ON facet_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX facet_attr_egenskaber_idx_virkning_aktoertypekode
    ON facet_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX facet_attr_egenskaber_idx_virkning_notetekst
    ON facet_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX facet_attr_egenskaber_pat_virkning_notetekst
    ON facet_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE facet_tils_publiceret_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE facet_tils_publiceret_id_seq
    OWNER TO mox;


CREATE TABLE facet_tils_publiceret (
    id bigint NOT NULL DEFAULT nextval('facet_tils_publiceret_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    publiceret FacetPubliceretTils NOT NULL, 
    facet_registrering_id bigint not null,
    CONSTRAINT facet_tils_publiceret_pkey PRIMARY KEY (id),
    CONSTRAINT facet_tils_publiceret_forkey_facetregistrering FOREIGN KEY (facet_registrering_id) REFERENCES facet_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT facet_tils_publiceret_exclude_virkning_overlap EXCLUDE USING gist (facet_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE facet_tils_publiceret
    OWNER TO mox;


CREATE INDEX facet_tils_publiceret_idx_publiceret
    ON facet_tils_publiceret
    USING btree
    (publiceret);
  
CREATE INDEX facet_tils_publiceret_idx_virkning_aktoerref
    ON facet_tils_publiceret
    USING btree
    (((virkning).aktoerref));

CREATE INDEX facet_tils_publiceret_idx_virkning_aktoertypekode
    ON facet_tils_publiceret
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX facet_tils_publiceret_idx_virkning_notetekst
    ON facet_tils_publiceret
    USING btree
    (((virkning).notetekst));

CREATE INDEX facet_tils_publiceret_pat_virkning_notetekst
    ON facet_tils_publiceret
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE facet_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE facet_relation_id_seq
    OWNER TO mox;


CREATE TABLE facet_relation (
    id bigint NOT NULL DEFAULT nextval('facet_relation_id_seq'::regclass),
    facet_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type FacetRelationKode not null,
    objekt_type text null,

    

    CONSTRAINT facet_relation_forkey_facetregistrering FOREIGN KEY (facet_registrering_id) REFERENCES facet_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT facet_relation_pkey PRIMARY KEY (id),
    CONSTRAINT facet_relation_no_virkning_overlap EXCLUDE USING gist (facet_registrering_id WITH =, _as_convert_facet_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('redaktoerer'::FacetRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT facet_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE facet_relation
  OWNER TO mox;





CREATE INDEX facet_relation_idx_rel_maal_obj_uuid
    ON facet_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX facet_relation_idx_rel_maal_obj_urn
    ON facet_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX facet_relation_idx_rel_maal_uuid
    ON facet_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX facet_relation_idx_rel_maal_uuid_isolated
    ON facet_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX facet_relation_idx_rel_maal_urn_isolated
    ON facet_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX facet_relation_idx_rel_maal_urn
    ON facet_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX facet_relation_idx_virkning_aktoerref
    ON facet_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX facet_relation_idx_virkning_aktoertypekode
    ON facet_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX facet_relation_idx_virkning_notetekst
    ON facet_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX facet_relation_pat_virkning_notetekst
    ON facet_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr FacetPubliceretTilsType[])
  RETURNS FacetPubliceretTilsType[] AS
  $$
  DECLARE result FacetPubliceretTilsType[];
  DECLARE element FacetPubliceretTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.publiceret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr FacetEgenskaberAttrType[])
  RETURNS FacetEgenskaberAttrType[] AS
  $$
  DECLARE result FacetEgenskaberAttrType[]; 
   DECLARE element FacetEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.beskrivelse IS NULL AND element.opbygning IS NULL AND element.ophavsret IS NULL AND element.plan IS NULL AND element.supplement IS NULL AND element.retskilde IS NULL AND element.integrationsdata IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr FacetRelationType[])
RETURNS FacetRelationType[] AS
$$
 DECLARE result FacetRelationType[];
 DECLARE element FacetRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_facet_registrering(
    facet_registrering
) RETURNS facet_registrering AS $BODY$
  SELECT * FROM facet_registrering as a WHERE
    facet_id = $1.facet_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_facet_registrering(
    facet_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS facet_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    facet_registrering_id bigint;
    facet_registrering    facet_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE facet_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE facet_id = facet_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating facet with uuid [%], Invalid [livscyklus] transition to [%]',facet_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new facet registrering

    facet_registrering_id := nextval('facet_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    facet_registrering := ROW(
        facet_registrering_id,
        facet_uuid,
        registreringObj
    )::facet_registrering;

    INSERT INTO facet_registrering SELECT facet_registrering.*;

    RETURN facet_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of FacetAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_facet(
    facet_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber FacetEgenskaberAttrType[],
    

    
    tilsPubliceret FacetPubliceretTilsType[],
    

    relationer FacetRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      FacetRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_facet          FacetType;
    read_prev_facet         FacetType;
    read_new_facet_reg      FacetRegistreringType;
    read_prev_facet_reg     FacetRegistreringType;
    new_facet_registrering  facet_registrering;
    prev_facet_registrering facet_registrering;
    facet_relation_navn     FacetRelationKode;

    
    attrEgenskaberObj FacetEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from facet a join facet_registrering b ON b.facet_id=a.id WHERE a.id=facet_uuid) THEN
        RAISE EXCEPTION 'Unable to update facet with uuid [%], being unable to find any previous registrations.',facet_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM facet a WHERE a.id=facet_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_facet(array[facet_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[facet_uuid]) THEN
      RAISE EXCEPTION 'Unable to update facet with uuid [%]. Object does not met stipulated criteria:%', facet_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_facet_registrering := _as_create_facet_registrering(facet_uuid, livscykluskode, brugerref, note);
    prev_facet_registrering := _as_get_prev_facet_registrering(new_facet_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_facet_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update facet with uuid [%], as the facet seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', facet_uuid, lostUpdatePreventionTZ, LOWER((prev_facet_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    

    INSERT INTO facet_relation (facet_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
    SELECT
        new_facet_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType 
        FROM
            unnest(relationer) AS a ;

    


    -- Ad 2)
    -- 0..1 relations

    
    
    FOREACH facet_relation_navn IN ARRAY ARRAY['ansvarlig'::FacetRelationKode ,  'ejer'::FacetRelationKode ,  'facettilhoerer'::FacetRelationKode  ]::FacetRelationKode[]  LOOP
        INSERT INTO facet_relation (facet_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
        SELECT
            new_facet_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM facet_relation b
                 WHERE b.facet_registrering_id = new_facet_registrering.id AND b.rel_type = facet_relation_navn) d
            JOIN facet_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.facet_registrering_id = prev_facet_registrering.id AND a.rel_type = facet_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
    FOREACH facet_relation_navn IN ARRAY ARRAY['redaktoerer'::FacetRelationKode]::FacetRelationKode[] LOOP
        IF NOT EXISTS (
                    SELECT 1
                      FROM facet_relation
                     WHERE facet_registrering_id = new_facet_registrering.id AND rel_type = facet_relation_navn) THEN
                    
                    INSERT INTO facet_relation (facet_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
                    SELECT
                        new_facet_registrering.id,  virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type
        FROM facet_relation
        WHERE
            facet_registrering_id = prev_facet_registrering.id AND rel_type = facet_relation_navn ;

    
        END IF;
    END LOOP;
    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsPubliceret IS NOT NULL AND coalesce(array_length(tilsPubliceret, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Publiceret] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- facet_tils_publiceret

        -- Ad 1)
        INSERT INTO facet_tils_publiceret(virkning, publiceret, facet_registrering_id)
             SELECT a.virkning, a.publiceret, new_facet_registrering.id
               FROM unnest(tilsPubliceret) AS a;

        -- Ad 2
        INSERT INTO facet_tils_publiceret(virkning, publiceret, facet_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.publiceret,
            new_facet_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- facet_tils_publiceret of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- facet_tils_publiceret of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM facet_tils_publiceret b
             WHERE b.facet_registrering_id = new_facet_registrering.id) d
              JOIN facet_tils_publiceret a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.facet_registrering_id = prev_facet_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- facet_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrFacetObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.beskrivelse,a.opbygning,a.ophavsret,a.plan,a.supplement,a.retskilde,a.integrationsdata,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update facet with uuid [%], as the facet have overlapping virknings in the given egenskaber array :%', facet_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).beskrivelse IS NULL  OR  (attrEgenskaberObj).opbygning IS NULL  OR  (attrEgenskaberObj).ophavsret IS NULL  OR  (attrEgenskaberObj).plan IS NULL  OR  (attrEgenskaberObj).supplement IS NULL  OR  (attrEgenskaberObj).retskilde IS NULL  OR  (attrEgenskaberObj).integrationsdata IS NULL  THEN
            
            INSERT INTO facet_attr_egenskaber ( brugervendtnoegle,beskrivelse,opbygning,ophavsret,plan,supplement,retskilde,integrationsdata, virkning, facet_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.beskrivelse, a.beskrivelse),
                    
                        
                        
                            coalesce(attrEgenskaberObj.opbygning, a.opbygning),
                    
                        
                        
                            coalesce(attrEgenskaberObj.ophavsret, a.ophavsret),
                    
                        
                        
                            coalesce(attrEgenskaberObj.plan, a.plan),
                    
                        
                        
                            coalesce(attrEgenskaberObj.supplement, a.supplement),
                    
                        
                        
                            coalesce(attrEgenskaberObj.retskilde, a.retskilde),
                    
                        
                        
                            coalesce(attrEgenskaberObj.integrationsdata, a.integrationsdata),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_facet_registrering.id
                        FROM facet_attr_egenskaber a
                    WHERE
                        a.facet_registrering_id = prev_facet_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO facet_attr_egenskaber ( brugervendtnoegle,beskrivelse,opbygning,ophavsret,plan,supplement,retskilde,integrationsdata, virkning, facet_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.beskrivelse,
                    
                     attrEgenskaberObj.opbygning,
                    
                     attrEgenskaberObj.ophavsret,
                    
                     attrEgenskaberObj.plan,
                    
                     attrEgenskaberObj.supplement,
                    
                     attrEgenskaberObj.retskilde,
                    
                     attrEgenskaberObj.integrationsdata,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_facet_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the facet_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM facet_attr_egenskaber b
                    WHERE b.facet_registrering_id = new_facet_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO facet_attr_egenskaber ( brugervendtnoegle,beskrivelse,opbygning,ophavsret,plan,supplement,retskilde,integrationsdata, virkning, facet_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.beskrivelse,  attrEgenskaberObj.opbygning,  attrEgenskaberObj.ophavsret,  attrEgenskaberObj.plan,  attrEgenskaberObj.supplement,  attrEgenskaberObj.retskilde,  attrEgenskaberObj.integrationsdata, attrEgenskaberObj.virkning, new_facet_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO facet_attr_egenskaber ( brugervendtnoegle,beskrivelse,opbygning,ophavsret,plan,supplement,retskilde,integrationsdata, virkning, facet_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.beskrivelse,
        
            a.opbygning,
        
            a.ophavsret,
        
            a.plan,
        
            a.supplement,
        
            a.retskilde,
        
            a.integrationsdata,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_facet_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- facet_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- facet_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                facet_attr_egenskaber b
            WHERE
                b.facet_registrering_id = new_facet_registrering.id) d
            JOIN facet_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.facet_registrering_id = prev_facet_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_facet := as_read_facet(facet_uuid, (new_facet_registrering.registrering).timeperiod, null);
    read_prev_facet := as_read_facet(facet_uuid, (prev_facet_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_facet.registrering[1].registrering).TimePeriod) = lower((new_facet_registrering.registrering).TimePeriod) and lower((read_prev_facet.registrering[1].registrering).TimePeriod)=lower((prev_facet_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating facet with id [%]: The ordering of as_list_facet should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', facet_uuid, to_json(new_facet_registrering), to_json(read_new_facet.registrering[1].registrering), to_json(prev_facet_registrering), to_json(prev_new_facet.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_facet_reg := ROW(
        ROW (null, (read_new_facet.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_facet.registrering[1]).tilsPubliceret ,
        
        (read_new_facet.registrering[1]).attrEgenskaber ,
        (read_new_facet.registrering[1]).relationer
    )::facetRegistreringType;

    read_prev_facet_reg := ROW(
        ROW(null, (read_prev_facet.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_facet.registrering[1]).tilsPubliceret ,
        
        (read_prev_facet.registrering[1]).attrEgenskaber ,
        (read_prev_facet.registrering[1]).relationer
    )::facetRegistreringType;


    IF read_prev_facet_reg = read_new_facet_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_facet_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_facet_reg);
      RAISE EXCEPTION 'Aborted updating facet with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', facet_uuid, to_json(read_new_facet_reg), to_json(read_prev_facet_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_facet_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_facet (
    facet_registrering FacetRegistreringType,
    facet_uuid uuid DEFAULT NULL, auth_criteria_arr
    FacetRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE facet_registrering_id bigint;

    
    facet_attr_egenskaber_obj facetEgenskaberAttrType;
    

    
    facet_tils_publiceret_obj facetPubliceretTilsType;
    

    facet_relationer FacetRelationType;

    

    auth_filtered_uuids uuid[];

    

    does_exist boolean;
    new_facet_registrering facet_registrering;
BEGIN
    IF facet_uuid IS NULL THEN LOOP
        facet_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from facet WHERE id=facet_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from facet WHERE id=facet_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (facet_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (facet_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (facet_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_facet.',(facet_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO facet (ID) SELECT
        facet_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        facet_registrering_id:=nextval('facet_registrering_id_seq');

        INSERT INTO facet_registrering (id, facet_id,
            registrering) SELECT facet_registrering_id,
        facet_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (facet_registrering.registrering).livscykluskode,
        (facet_registrering.registrering).brugerref,
        (facet_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_facet_registrering :=
            _as_create_facet_registrering(facet_uuid,
                (facet_registrering.registrering).livscykluskode,
                (facet_registrering.registrering).brugerref,
                (facet_registrering.registrering).note);

            facet_registrering_id := new_facet_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(facet_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [facet]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF facet_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(facet_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH facet_attr_egenskaber_obj IN ARRAY facet_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO facet_attr_egenskaber (
      
      brugervendtnoegle,
      beskrivelse,
      opbygning,
      ophavsret,
      plan,
      supplement,
      retskilde,
      integrationsdata,
      virkning,
      facet_registrering_id
    )
    SELECT
     
     facet_attr_egenskaber_obj.brugervendtnoegle,
      facet_attr_egenskaber_obj.beskrivelse,
      facet_attr_egenskaber_obj.opbygning,
      facet_attr_egenskaber_obj.ophavsret,
      facet_attr_egenskaber_obj.plan,
      facet_attr_egenskaber_obj.supplement,
      facet_attr_egenskaber_obj.retskilde,
      facet_attr_egenskaber_obj.integrationsdata,
      facet_attr_egenskaber_obj.virkning,
      facet_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(facet_registrering.tilsPubliceret, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [publiceret] for facet. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF facet_registrering.tilsPubliceret IS NOT NULL AND coalesce(array_length(facet_registrering.tilsPubliceret,1),0)>0 THEN
  FOREACH facet_tils_publiceret_obj IN ARRAY facet_registrering.tilsPubliceret
  LOOP

    INSERT INTO facet_tils_publiceret (
      virkning,
      publiceret,
      facet_registrering_id
    )
    SELECT
      facet_tils_publiceret_obj.virkning,
      facet_tils_publiceret_obj.publiceret,
      facet_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations



    INSERT INTO facet_relation (
      facet_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      facet_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(facet_registrering.relationer) a
  ;




/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_facet(array[facet_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[facet_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import facet with uuid [%]. Object does not met stipulated criteria:%',facet_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN facet_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_facet(facet_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr FacetRegistreringType[]=null
  )
  RETURNS FacetType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result FacetType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_facet(facet_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(facet_uuids,1),0) AND auth_filtered_uuids @>facet_uuids) THEN
  RAISE EXCEPTION 'Unable to list facet with uuids [%]. All objects do not fullfill the stipulated criteria:%',facet_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.facetObj) into result
FROM
(
SELECT
ROW(
	a.facet_id,
	array_agg(
		ROW (
			a.registrering,
			a.FacetTilsPubliceretArr,
			a.FacetAttrEgenskaberArr,
			a.FacetRelationArr
		)::FacetRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: FacetType  facetObj
FROM
(
	SELECT
	a.facet_id,
	a.facet_registrering_id,
	a.registrering,
	a.FacetAttrEgenskaberArr,
	a.FacetTilsPubliceretArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type
			):: FacetRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
        
	)) FacetRelationArr
	FROM
	(
			SELECT
			a.facet_id,
			a.facet_registrering_id,
			a.registrering,
			a.FacetAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.publiceret
						) ::FacetPubliceretTilsType
					ELSE NULL
					END
					order by b.publiceret,b.virkning
				)) FacetTilsPubliceretArr		
			FROM
			(
					SELECT
					a.facet_id,
					a.facet_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.beskrivelse,
					 		b.opbygning,
					 		b.ophavsret,
					 		b.plan,
					 		b.supplement,
					 		b.retskilde,
					 		b.integrationsdata,
					   		b.virkning
                            
							)::FacetEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.beskrivelse,b.opbygning,b.ophavsret,b.plan,b.supplement,b.retskilde,b.integrationsdata,b.virkning
                        
					)) FacetAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id facet_id,
					b.id facet_registrering_id,
					b.registrering			
					FROM		facet a
					JOIN 		facet_registrering b 	ON b.facet_id=a.id
					WHERE a.id = ANY (facet_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN facet_attr_egenskaber as b ON b.facet_registrering_id=a.facet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.facet_id,
					a.facet_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN facet_tils_publiceret as b ON b.facet_registrering_id=a.facet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.facet_id,
			a.facet_registrering_id,
			a.registrering,
			a.FacetAttrEgenskaberArr
	) as a
	LEFT JOIN facet_relation b ON b.facet_registrering_id=a.facet_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.facet_id,
	a.facet_registrering_id,
	a.registrering,
	a.FacetAttrEgenskaberArr,
	a.FacetTilsPubliceretArr
) as a

WHERE a.facet_id IS NOT NULL
GROUP BY 
a.facet_id
order by a.facet_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_facet(
    facet_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      FacetRegistreringType[]=null
) RETURNS FacetType AS $$
DECLARE
	resArr FacetType[];
BEGIN
    resArr := as_list_facet(ARRAY[facet_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_facet(
    firstResult int,--TOOD ??
    facet_uuid uuid,
    registreringObj   FacetRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr FacetRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    facet_candidates uuid[];
    facet_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj FacetEgenskaberAttrType;

    
    tilsPubliceretTypeObj FacetPubliceretTilsType;

    relationTypeObj FacetRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

facet_candidates_is_initialized := false;

IF facet_uuid is not NULL THEN
    facet_candidates:= ARRAY[facet_uuid];
    facet_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        facet_candidates:=array(
                SELECT DISTINCT
                b.facet_id
                FROM
                facet a
                JOIN facet_registrering b on b.facet_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'facet_candidates_is_initialized step 1:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 1:%',facet_candidates;
--/****************************//


--RAISE NOTICE 'facet_candidates_is_initialized step 2:%',facet_candidates_is_initialized;
--RAISE NOTICE 'facet_candidates step 2:%',facet_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_facet: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(facet_candidates,1),0)>0 OR NOT facet_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            facet_candidates:=array(
            SELECT DISTINCT
            b.facet_id
            FROM  facet_attr_egenskaber a
            JOIN facet_registrering b on a.facet_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.beskrivelse IS NULL
                    OR
                    a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.opbygning IS NULL
                    OR
                    a.opbygning ILIKE attrEgenskaberTypeObj.opbygning --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.ophavsret IS NULL
                    OR
                    a.ophavsret ILIKE attrEgenskaberTypeObj.ophavsret --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.plan IS NULL
                    OR
                    a.plan ILIKE attrEgenskaberTypeObj.plan --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.supplement IS NULL
                    OR
                    a.supplement ILIKE attrEgenskaberTypeObj.supplement --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.retskilde IS NULL
                    OR
                    a.retskilde ILIKE attrEgenskaberTypeObj.retskilde --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.integrationsdata IS NULL
                    OR
                    a.integrationsdata ILIKE attrEgenskaberTypeObj.integrationsdata --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )

            );


            facet_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'facet_candidates_is_initialized step 3:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 3:%',facet_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        facet_candidates:=array(

            SELECT DISTINCT
            b.facet_id
            
            FROM  facet_attr_egenskaber a
            JOIN facet_registrering b on a.facet_registrering_id=b.id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.beskrivelse ILIKE anyAttrValue OR
                        a.opbygning ILIKE anyAttrValue OR
                        a.ophavsret ILIKE anyAttrValue OR
                        a.plan ILIKE anyAttrValue OR
                        a.supplement ILIKE anyAttrValue OR
                        a.retskilde ILIKE anyAttrValue OR
                        a.integrationsdata ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )


        );

    facet_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
    --RAISE DEBUG 'as_search_facet: skipping filtration on tilsPubliceret';
ELSE
    IF (coalesce(array_length(facet_candidates,1),0)>0 OR facet_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
        LOOP
            facet_candidates:=array(
            SELECT DISTINCT
            b.facet_id
            FROM  facet_tils_publiceret a
            JOIN facet_registrering b on a.facet_registrering_id=b.id
            WHERE
                (
                    tilsPubliceretTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsPubliceretTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).AktoerRef IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsPubliceretTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsPubliceretTypeObj.virkning) IS NULL OR (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsPubliceretTypeObj.publiceret IS NULL
                    OR
                    tilsPubliceretTypeObj.publiceret = a.publiceret
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )

    );


            facet_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer FacetRelationType[]
*/


--RAISE DEBUG 'facet_candidates_is_initialized step 4:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 4:%',facet_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_facet: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(facet_candidates,1),0)>0 OR NOT facet_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            facet_candidates:=array(
            SELECT DISTINCT
            b.facet_id
            FROM  facet_relation a
            JOIN facet_registrering b on a.facet_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )

    );

            facet_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        facet_candidates:=array(
            SELECT DISTINCT
            b.facet_id
            
            FROM  facet_relation a
            JOIN facet_registrering b on a.facet_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )


            );

    facet_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        facet_candidates:=array(
            SELECT DISTINCT
            b.facet_id
            
            FROM  facet_relation a
            JOIN facet_registrering b on a.facet_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )


            );

    facet_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 




--RAISE DEBUG 'facet_candidates_is_initialized step 5:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 5:%',facet_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT facet_candidates_is_initialized THEN
        facet_candidates:=array(
        SELECT DISTINCT
            facet_id
        FROM
            facet_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT facet_candidates_is_initialized) OR b.facet_id = ANY (facet_candidates) )

        )
        ;

        facet_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT facet_candidates_is_initialized THEN
    --No filters applied!
    facet_candidates:=array(
        SELECT DISTINCT id FROM facet a
    );
ELSE
    facet_candidates:=array(
        SELECT DISTINCT id FROM unnest(facet_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'facet_candidates_is_initialized step 6:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 6:%',facet_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_facet(facet_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_facet(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_FacetRegistreringType_to_json(FacetRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END facetegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsPubliceret,1),0)>0 THEN to_json($1.tilsPubliceret) 
        ELSE 
        NULL
        END facetpubliceret
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::FacetRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (FacetRegistreringType as json);
create cast (FacetRegistreringType as json) with function actual_state._cast_FacetRegistreringType_to_json(FacetRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_facetType_to_json(FacetType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg FacetRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (FacetType as json);
create cast (FacetType as json) with function actual_state._cast_facetType_to_json(FacetType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_facet(
    facet_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    FacetRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    facet_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    facet_sorted_uuid:=array(
          SELECT b.facet_id
            FROM facet_registrering b
            JOIN facet_attr_egenskaber a ON a.facet_registrering_id=b.id
           WHERE b.facet_id = ANY (facet_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.facet_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.facet_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN facet_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_facet(
	facet_uuids uuid[],
	registreringObjArr FacetRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	facet_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	facet_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj FacetEgenskaberAttrType;
	
  	tilsPubliceretTypeObj FacetPubliceretTilsType;
	relationTypeObj FacetRelationType;
	registreringObj FacetRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN facet_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF facet_uuids IS NULL OR coalesce(array_length(facet_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

facet_candidates:= facet_uuids;



--RAISE DEBUG 'facet_candidates_is_initialized step 1:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 1:%',facet_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_facet: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(facet_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			facet_candidates:=array(
			SELECT DISTINCT
			b.facet_id 
			FROM  facet_attr_egenskaber a 
			JOIN facet_registrering b on a.facet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.opbygning IS NULL
					OR 
					a.opbygning = attrEgenskaberTypeObj.opbygning 
				)
				AND
				(
					attrEgenskaberTypeObj.ophavsret IS NULL
					OR 
					a.ophavsret = attrEgenskaberTypeObj.ophavsret 
				)
				AND
				(
					attrEgenskaberTypeObj.plan IS NULL
					OR 
					a.plan = attrEgenskaberTypeObj.plan 
				)
				AND
				(
					attrEgenskaberTypeObj.supplement IS NULL
					OR 
					a.supplement = attrEgenskaberTypeObj.supplement 
				)
				AND
				(
					attrEgenskaberTypeObj.retskilde IS NULL
					OR 
					a.retskilde = attrEgenskaberTypeObj.retskilde 
				)
				AND
				(
					attrEgenskaberTypeObj.integrationsdata IS NULL
					OR 
					a.integrationsdata = attrEgenskaberTypeObj.integrationsdata 
				)
				AND b.facet_id = ANY (facet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'facet_candidates_is_initialized step 3:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 3:%',facet_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_facet: skipping filtration on tilsPubliceret';
ELSE
	IF coalesce(array_length(facet_candidates,1),0)>0 THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			facet_candidates:=array(
			SELECT DISTINCT
			b.facet_id 
			FROM  facet_tils_publiceret a
			JOIN facet_registrering b on a.facet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND b.facet_id = ANY (facet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer FacetRelationType[]
*/


--RAISE DEBUG 'facet_candidates_is_initialized step 4:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 4:%',facet_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_facet: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(facet_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			facet_candidates:=array(
			SELECT DISTINCT
			b.facet_id 
			FROM  facet_relation a
			JOIN facet_registrering b on a.facet_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.facet_id = ANY (facet_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'facet_candidates_is_initialized step 5:%',facet_candidates_is_initialized;
--RAISE DEBUG 'facet_candidates step 5:%',facet_candidates;

facet_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (facet_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (facet_candidates) b(id)
);

--optimization 
IF coalesce(array_length(facet_passed_auth_filter,1),0)=coalesce(array_length(facet_uuids,1),0) AND facet_passed_auth_filter @>facet_uuids THEN
	RETURN facet_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN facet_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE IndsatsPubliceretTils AS ENUM ('Publiceret','IkkePubliceret','Normal',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE IndsatsPubliceretTilsType AS (
    virkning Virkning,
    publiceret IndsatsPubliceretTils
)
;
CREATE TYPE IndsatsFremdriftTils AS ENUM ('Uoplyst','Visiteret','Disponeret','Leveret','Vurderet',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE IndsatsFremdriftTilsType AS (
    virkning Virkning,
    fremdrift IndsatsFremdriftTils
)
;



CREATE TYPE IndsatsEgenskaberAttrType AS (
brugervendtnoegle text,
beskrivelse text,
starttidspunkt ClearableTimestamptz,

sluttidspunkt ClearableTimestamptz,


 virkning Virkning
);




CREATE TYPE IndsatsRelationKode AS ENUM  ('indsatsmodtager','indsatstype','indsatskvalitet','indsatsaktoer','samtykke','indsatssag','indsatsdokument');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_indsats_relation_kode_to_txt is invoked.



CREATE TYPE IndsatsRelationType AS (
  relType IndsatsRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text,
indeks int
)
;



CREATE TYPE IndsatsRegistreringType AS
(
registrering RegistreringBase,
tilsPubliceret IndsatsPubliceretTilsType[],
tilsFremdrift IndsatsFremdriftTilsType[],
attrEgenskaber IndsatsEgenskaberAttrType[],
relationer IndsatsRelationType[]
);

CREATE TYPE IndsatsType AS
(
  id uuid,
  registrering IndsatsRegistreringType[]
);  


 CREATE Type _IndsatsRelationMaxIndex AS
 (
   relType IndsatsRelationKode,
   indeks int
 );




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_indsats_relation_kode_to_txt(
    IndsatsRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE indsats (
    id uuid NOT NULL,
    CONSTRAINT indsats_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE indsats
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE indsats_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE indsats_registrering_id_seq
    OWNER TO mox;


CREATE TABLE indsats_registrering (
   id bigint NOT NULL DEFAULT nextval('indsats_registrering_id_seq'::regclass),
   indsats_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT indsats_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT indsats_registrering_indsats_fkey FOREIGN KEY (indsats_id)
       REFERENCES indsats (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT indsats_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(indsats_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE indsats_registrering
  OWNER TO mox;


CREATE INDEX indsats_registrering_idx_livscykluskode
    ON indsats_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX indsats_registrering_idx_brugerref
    ON indsats_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX indsats_registrering_idx_note
    ON indsats_registrering
    USING btree
    (((registrering).note));


CREATE INDEX indsats_registrering_pat_note
    ON indsats_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX indsats_id_idx
    ON indsats_registrering (indsats_id);


CREATE TRIGGER notify_indsats
    AFTER INSERT OR UPDATE OR DELETE ON indsats_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE indsats_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE indsats_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE indsats_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('indsats_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        beskrivelse text  NULL,
        starttidspunkt timestamptz  NULL,
        sluttidspunkt timestamptz  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    indsats_registrering_id bigint NOT NULL,
    CONSTRAINT indsats_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT indsats_attr_egenskaber_forkey_indsatsregistrering FOREIGN KEY (indsats_registrering_id) REFERENCES indsats_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT indsats_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (indsats_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE indsats_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX indsats_attr_egenskaber_pat_brugervendtnoegle
            ON indsats_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX indsats_attr_egenskaber_idx_brugervendtnoegle
            ON indsats_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX indsats_attr_egenskaber_pat_beskrivelse
            ON indsats_attr_egenskaber
            USING gin
            (beskrivelse gin_trgm_ops);

        CREATE INDEX indsats_attr_egenskaber_idx_beskrivelse
            ON indsats_attr_egenskaber
            USING btree
            (beskrivelse); 
 
    
         
             
                CREATE INDEX indsats_attr_egenskaber_idx_starttidspunkt
                    ON indsats_attr_egenskaber
                    USING btree
                    (starttidspunkt);

            
         
     
 
    
         
             
                CREATE INDEX indsats_attr_egenskaber_idx_sluttidspunkt
                    ON indsats_attr_egenskaber
                    USING btree
                    (sluttidspunkt);

            
         
     



CREATE INDEX indsats_attr_egenskaber_idx_virkning_aktoerref
    ON indsats_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX indsats_attr_egenskaber_idx_virkning_aktoertypekode
    ON indsats_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX indsats_attr_egenskaber_idx_virkning_notetekst
    ON indsats_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX indsats_attr_egenskaber_pat_virkning_notetekst
    ON indsats_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE indsats_tils_publiceret_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE indsats_tils_publiceret_id_seq
    OWNER TO mox;


CREATE TABLE indsats_tils_publiceret (
    id bigint NOT NULL DEFAULT nextval('indsats_tils_publiceret_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    publiceret IndsatsPubliceretTils NOT NULL, 
    indsats_registrering_id bigint not null,
    CONSTRAINT indsats_tils_publiceret_pkey PRIMARY KEY (id),
    CONSTRAINT indsats_tils_publiceret_forkey_indsatsregistrering FOREIGN KEY (indsats_registrering_id) REFERENCES indsats_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT indsats_tils_publiceret_exclude_virkning_overlap EXCLUDE USING gist (indsats_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE indsats_tils_publiceret
    OWNER TO mox;


CREATE INDEX indsats_tils_publiceret_idx_publiceret
    ON indsats_tils_publiceret
    USING btree
    (publiceret);
  
CREATE INDEX indsats_tils_publiceret_idx_virkning_aktoerref
    ON indsats_tils_publiceret
    USING btree
    (((virkning).aktoerref));

CREATE INDEX indsats_tils_publiceret_idx_virkning_aktoertypekode
    ON indsats_tils_publiceret
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX indsats_tils_publiceret_idx_virkning_notetekst
    ON indsats_tils_publiceret
    USING btree
    (((virkning).notetekst));

CREATE INDEX indsats_tils_publiceret_pat_virkning_notetekst
    ON indsats_tils_publiceret
    USING gin
    (((virkning).notetekst) gin_trgm_ops);


CREATE SEQUENCE indsats_tils_fremdrift_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE indsats_tils_fremdrift_id_seq
    OWNER TO mox;


CREATE TABLE indsats_tils_fremdrift (
    id bigint NOT NULL DEFAULT nextval('indsats_tils_fremdrift_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    fremdrift IndsatsFremdriftTils NOT NULL, 
    indsats_registrering_id bigint not null,
    CONSTRAINT indsats_tils_fremdrift_pkey PRIMARY KEY (id),
    CONSTRAINT indsats_tils_fremdrift_forkey_indsatsregistrering FOREIGN KEY (indsats_registrering_id) REFERENCES indsats_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT indsats_tils_fremdrift_exclude_virkning_overlap EXCLUDE USING gist (indsats_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE indsats_tils_fremdrift
    OWNER TO mox;


CREATE INDEX indsats_tils_fremdrift_idx_fremdrift
    ON indsats_tils_fremdrift
    USING btree
    (fremdrift);
  
CREATE INDEX indsats_tils_fremdrift_idx_virkning_aktoerref
    ON indsats_tils_fremdrift
    USING btree
    (((virkning).aktoerref));

CREATE INDEX indsats_tils_fremdrift_idx_virkning_aktoertypekode
    ON indsats_tils_fremdrift
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX indsats_tils_fremdrift_idx_virkning_notetekst
    ON indsats_tils_fremdrift
    USING btree
    (((virkning).notetekst));

CREATE INDEX indsats_tils_fremdrift_pat_virkning_notetekst
    ON indsats_tils_fremdrift
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE indsats_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE indsats_relation_id_seq
    OWNER TO mox;


CREATE TABLE indsats_relation (
    id bigint NOT NULL DEFAULT nextval('indsats_relation_id_seq'::regclass),
    indsats_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type IndsatsRelationKode not null,
    objekt_type text null,

    
    rel_index int null,
    

    CONSTRAINT indsats_relation_forkey_indsatsregistrering FOREIGN KEY (indsats_registrering_id) REFERENCES indsats_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT indsats_relation_pkey PRIMARY KEY (id),
    CONSTRAINT indsats_relation_no_virkning_overlap EXCLUDE USING gist (indsats_registrering_id WITH =, _as_convert_indsats_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('indsatskvalitet'::IndsatsRelationKode ) AND rel_type<>('indsatsaktoer'::IndsatsRelationKode ) AND rel_type<>('samtykke'::IndsatsRelationKode ) AND rel_type<>('indsatssag'::IndsatsRelationKode ) AND rel_type<>('indsatsdokument'::IndsatsRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT indsats_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE indsats_relation
  OWNER TO mox;



CREATE UNIQUE INDEX indsats_relation_unique_index_within_type
    ON indsats_relation (indsats_registrering_id,rel_type,rel_index)
    WHERE ( rel_type IN ('indsatskvalitet'::IndsatsRelationKode,'indsatsaktoer'::IndsatsRelationKode,'samtykke'::IndsatsRelationKode,'indsatssag'::IndsatsRelationKode,'indsatsdokument'::IndsatsRelationKode));




CREATE INDEX indsats_relation_idx_rel_maal_obj_uuid
    ON indsats_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX indsats_relation_idx_rel_maal_obj_urn
    ON indsats_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX indsats_relation_idx_rel_maal_uuid
    ON indsats_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX indsats_relation_idx_rel_maal_uuid_isolated
    ON indsats_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX indsats_relation_idx_rel_maal_urn_isolated
    ON indsats_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX indsats_relation_idx_rel_maal_urn
    ON indsats_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX indsats_relation_idx_virkning_aktoerref
    ON indsats_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX indsats_relation_idx_virkning_aktoertypekode
    ON indsats_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX indsats_relation_idx_virkning_notetekst
    ON indsats_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX indsats_relation_pat_virkning_notetekst
    ON indsats_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr IndsatsPubliceretTilsType[])
  RETURNS IndsatsPubliceretTilsType[] AS
  $$
  DECLARE result IndsatsPubliceretTilsType[];
  DECLARE element IndsatsPubliceretTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.publiceret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr IndsatsFremdriftTilsType[])
  RETURNS IndsatsFremdriftTilsType[] AS
  $$
  DECLARE result IndsatsFremdriftTilsType[];
  DECLARE element IndsatsFremdriftTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.fremdrift IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr IndsatsEgenskaberAttrType[])
  RETURNS IndsatsEgenskaberAttrType[] AS
  $$
  DECLARE result IndsatsEgenskaberAttrType[]; 
   DECLARE element IndsatsEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.beskrivelse IS NULL AND element.starttidspunkt IS NULL AND element.sluttidspunkt IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr IndsatsRelationType[])
RETURNS IndsatsRelationType[] AS
$$
 DECLARE result IndsatsRelationType[];
 DECLARE element IndsatsRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.indeks IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....)

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_indsats_registrering(
    indsats_registrering
) RETURNS indsats_registrering AS $BODY$
  SELECT * FROM indsats_registrering as a WHERE
    indsats_id = $1.indsats_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_indsats_registrering(
    indsats_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS indsats_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    indsats_registrering_id bigint;
    indsats_registrering    indsats_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE indsats_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE indsats_id = indsats_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating indsats with uuid [%], Invalid [livscyklus] transition to [%]',indsats_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new indsats registrering

    indsats_registrering_id := nextval('indsats_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    indsats_registrering := ROW(
        indsats_registrering_id,
        indsats_uuid,
        registreringObj
    )::indsats_registrering;

    INSERT INTO indsats_registrering SELECT indsats_registrering.*;

    RETURN indsats_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of IndsatsAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_indsats(
    indsats_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber IndsatsEgenskaberAttrType[],
    

    
    tilsPubliceret IndsatsPubliceretTilsType[],
    
    tilsFremdrift IndsatsFremdriftTilsType[],
    

    relationer IndsatsRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      IndsatsRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_indsats          IndsatsType;
    read_prev_indsats         IndsatsType;
    read_new_indsats_reg      IndsatsRegistreringType;
    read_prev_indsats_reg     IndsatsRegistreringType;
    new_indsats_registrering  indsats_registrering;
    prev_indsats_registrering indsats_registrering;
    indsats_relation_navn     IndsatsRelationKode;

    
    attrEgenskaberObj IndsatsEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
    rel_type_max_index_prev_rev int;
    rel_type_max_index_arr _indsatsRelationMaxIndex[];
    indsats_rel_type_cardinality_unlimited indsatsRelationKode[]:=ARRAY['indsatskvalitet'::IndsatsRelationKode,'indsatsaktoer'::IndsatsRelationKode,'samtykke'::IndsatsRelationKode,'indsatssag'::IndsatsRelationKode,'indsatsdokument'::IndsatsRelationKode];
    indsats_uuid_underscores text;
    indsats_rel_seq_name text;
    indsats_rel_type_cardinality_unlimited_present_in_argument IndsatsRelationKode[];
    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from indsats a join indsats_registrering b ON b.indsats_id=a.id WHERE a.id=indsats_uuid) THEN
        RAISE EXCEPTION 'Unable to update indsats with uuid [%], being unable to find any previous registrations.',indsats_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM indsats a WHERE a.id=indsats_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_indsats(array[indsats_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[indsats_uuid]) THEN
      RAISE EXCEPTION 'Unable to update indsats with uuid [%]. Object does not met stipulated criteria:%', indsats_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_indsats_registrering := _as_create_indsats_registrering(indsats_uuid, livscykluskode, brugerref, note);
    prev_indsats_registrering := _as_get_prev_indsats_registrering(new_indsats_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_indsats_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update indsats with uuid [%], as the indsats seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', indsats_uuid, lostUpdatePreventionTZ, LOWER((prev_indsats_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    
    -- Build array with the max index values of the different types of
    -- relations of the previous registration
    
    SELECT array_agg(rel_type_max_index)::_indsatsRelationMaxIndex[] into rel_type_max_index_arr
    
    FROM
    (
        SELECT
        
        (ROW(rel_type,coalesce(max(rel_index),0))::_indsatsRelationMaxIndex) rel_type_max_index
        
            FROM indsats_relation a
           WHERE a.indsats_registrering_id=prev_indsats_registrering.id
             AND a.rel_type = ANY (indsats_rel_type_cardinality_unlimited)
        GROUP BY rel_type
    ) AS a;

 
    ---Create temporary sequences
    
    indsats_uuid_underscores:=replace(indsats_uuid::text, '-', '_');
    

    SELECT array_agg(DISTINCT a.RelType) INTO indsats_rel_type_cardinality_unlimited_present_in_argument FROM unnest(relationer) a WHERE a.RelType = ANY (indsats_rel_type_cardinality_unlimited);
    

    IF coalesce(array_length(indsats_rel_type_cardinality_unlimited_present_in_argument, 1), 0) > 0 THEN
        FOREACH indsats_relation_navn IN ARRAY (indsats_rel_type_cardinality_unlimited_present_in_argument) LOOP
            indsats_rel_seq_name := 'indsats_' || indsats_relation_navn::text || indsats_uuid_underscores;

            rel_type_max_index_prev_rev := null;

            SELECT a.indeks into rel_type_max_index_prev_rev
              FROM unnest(rel_type_max_index_arr) a(relType,indeks)
             WHERE a.relType=indsats_relation_navn;

            IF rel_type_max_index_prev_rev IS NULL THEN
              rel_type_max_index_prev_rev := 0;
            END IF;

            EXECUTE 'CREATE TEMPORARY SEQUENCE ' || indsats_rel_seq_name || '
            INCREMENT 1
            MINVALUE 1
            MAXVALUE 9223372036854775807
            START ' ||  (rel_type_max_index_prev_rev+1)::text ||'
            CACHE 1;';

        END LOOP;
    END IF;
    

    INSERT INTO indsats_relation (indsats_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type , rel_index )
    SELECT
        new_indsats_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType ,
            CASE WHEN a.relType = ANY (indsats_rel_type_cardinality_unlimited) THEN
                CASE WHEN a.indeks IS NULL
                    OR b.id IS NULL THEN
                    -- For new relations and relations with index given that
                    -- is not found in prev registrering, we'll assign new
                    -- index values.
                    nextval('indsats_' || a.relType::text || indsats_uuid_underscores)
                ELSE
                    a.indeks
                END
            ELSE
                NULL
            END 
        FROM
            unnest(relationer) AS a 
        LEFT JOIN indsats_relation b ON a.relType = ANY (indsats_rel_type_cardinality_unlimited) AND b.indsats_registrering_id = prev_indsats_registrering.id AND a.relType = b.rel_type AND a.indeks = b.rel_index ;

    
    -- Drop temporary sequences
    IF coalesce(array_length(indsats_rel_type_cardinality_unlimited_present_in_argument, 1), 0) > 0 THEN
        
        FOREACH indsats_relation_navn IN ARRAY (indsats_rel_type_cardinality_unlimited_present_in_argument)
        
        LOOP
          indsats_rel_seq_name := 'indsats_' || indsats_relation_navn::text || indsats_uuid_underscores;
          EXECUTE 'DROP SEQUENCE ' || indsats_rel_seq_name || ';';
        END LOOP;
    END IF;
    


    -- Ad 2)
    -- 0..1 relations

    
    -- Please notice, that for 0..1 relations for aktivitet, we're ignoring index
    -- here, and handling it the same way, that is done for other object types (like
    -- Facet, Klasse etc). That is, you only make changes for the
    -- virkningsperiod that you explicitly specify (unless you delete all relations)
    
    
    FOREACH indsats_relation_navn IN ARRAY ARRAY['indsatstype'::IndsatsRelationKode, 'indsatsmodtager'::IndsatsRelationKode]::IndsatsRelationKode[]
     LOOP
        INSERT INTO indsats_relation (indsats_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type , rel_index )
        SELECT
            new_indsats_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type ,
                NULL -- a.rel_index, rel_index is not to be used for 0..1 relations
                
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM indsats_relation b
                 WHERE b.indsats_registrering_id = new_indsats_registrering.id AND b.rel_type = indsats_relation_navn) d
            JOIN indsats_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.indsats_registrering_id = prev_indsats_registrering.id AND a.rel_type = indsats_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
                    INSERT INTO indsats_relation (indsats_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type , rel_index )
                    SELECT
                        new_indsats_registrering.id,  a.virkning, a.rel_maal_uuid, a.rel_maal_urn, a.rel_type, a.objekt_type, a.rel_index
                    FROM indsats_relation a
                    LEFT JOIN indsats_relation b ON b.indsats_registrering_id = new_indsats_registrering.id AND b.rel_type = a.rel_type AND b.rel_index = a.rel_index
                WHERE
                    a.indsats_registrering_id = prev_indsats_registrering.id AND a.rel_type = ANY (indsats_rel_type_cardinality_unlimited) AND b.id IS NULL
                    -- Don't transfer relations of prev. registrering,
                    -- if the index was specified in data given to the/this
                    -- update-function
                    ;

    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsPubliceret IS NOT NULL AND coalesce(array_length(tilsPubliceret, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Publiceret] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- indsats_tils_publiceret

        -- Ad 1)
        INSERT INTO indsats_tils_publiceret(virkning, publiceret, indsats_registrering_id)
             SELECT a.virkning, a.publiceret, new_indsats_registrering.id
               FROM unnest(tilsPubliceret) AS a;

        -- Ad 2
        INSERT INTO indsats_tils_publiceret(virkning, publiceret, indsats_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.publiceret,
            new_indsats_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- indsats_tils_publiceret of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- indsats_tils_publiceret of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM indsats_tils_publiceret b
             WHERE b.indsats_registrering_id = new_indsats_registrering.id) d
              JOIN indsats_tils_publiceret a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.indsats_registrering_id = prev_indsats_registrering.id;
    END IF;
    
    IF tilsFremdrift IS NOT NULL AND coalesce(array_length(tilsFremdrift, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Fremdrift] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- indsats_tils_fremdrift

        -- Ad 1)
        INSERT INTO indsats_tils_fremdrift(virkning, fremdrift, indsats_registrering_id)
             SELECT a.virkning, a.fremdrift, new_indsats_registrering.id
               FROM unnest(tilsFremdrift) AS a;

        -- Ad 2
        INSERT INTO indsats_tils_fremdrift(virkning, fremdrift, indsats_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.fremdrift,
            new_indsats_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- indsats_tils_fremdrift of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- indsats_tils_fremdrift of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM indsats_tils_fremdrift b
             WHERE b.indsats_registrering_id = new_indsats_registrering.id) d
              JOIN indsats_tils_fremdrift a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.indsats_registrering_id = prev_indsats_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- indsats_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrIndsatsObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.beskrivelse,a.starttidspunkt,a.sluttidspunkt,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update indsats with uuid [%], as the indsats have overlapping virknings in the given egenskaber array :%', indsats_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).beskrivelse IS NULL  OR  (attrEgenskaberObj).starttidspunkt IS NULL  OR  (attrEgenskaberObj).sluttidspunkt IS NULL  THEN
            
            INSERT INTO indsats_attr_egenskaber ( brugervendtnoegle,beskrivelse,starttidspunkt,sluttidspunkt, virkning, indsats_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.beskrivelse, a.beskrivelse),
                    
                        
                        
                            CASE WHEN ((attrEgenskaberObj.starttidspunkt).cleared) THEN
                                NULL
                            ELSE
                                coalesce((attrEgenskaberObj.starttidspunkt).value, a.starttidspunkt)
                            END,
                        
                    
                        
                        
                            CASE WHEN ((attrEgenskaberObj.sluttidspunkt).cleared) THEN
                                NULL
                            ELSE
                                coalesce((attrEgenskaberObj.sluttidspunkt).value, a.sluttidspunkt)
                            END,
                        
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_indsats_registrering.id
                        FROM indsats_attr_egenskaber a
                    WHERE
                        a.indsats_registrering_id = prev_indsats_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO indsats_attr_egenskaber ( brugervendtnoegle,beskrivelse,starttidspunkt,sluttidspunkt, virkning, indsats_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.beskrivelse,
                    
                     attrEgenskaberObj.starttidspunkt,
                    
                     attrEgenskaberObj.sluttidspunkt,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_indsats_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the indsats_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM indsats_attr_egenskaber b
                    WHERE b.indsats_registrering_id = new_indsats_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO indsats_attr_egenskaber ( brugervendtnoegle,beskrivelse,starttidspunkt,sluttidspunkt, virkning, indsats_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.beskrivelse,  attrEgenskaberObj.starttidspunkt,  attrEgenskaberObj.sluttidspunkt, attrEgenskaberObj.virkning, new_indsats_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO indsats_attr_egenskaber ( brugervendtnoegle,beskrivelse,starttidspunkt,sluttidspunkt, virkning, indsats_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.beskrivelse,
        
            a.starttidspunkt,
        
            a.sluttidspunkt,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_indsats_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- indsats_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- indsats_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                indsats_attr_egenskaber b
            WHERE
                b.indsats_registrering_id = new_indsats_registrering.id) d
            JOIN indsats_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.indsats_registrering_id = prev_indsats_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_indsats := as_read_indsats(indsats_uuid, (new_indsats_registrering.registrering).timeperiod, null);
    read_prev_indsats := as_read_indsats(indsats_uuid, (prev_indsats_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_indsats.registrering[1].registrering).TimePeriod) = lower((new_indsats_registrering.registrering).TimePeriod) and lower((read_prev_indsats.registrering[1].registrering).TimePeriod)=lower((prev_indsats_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating indsats with id [%]: The ordering of as_list_indsats should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', indsats_uuid, to_json(new_indsats_registrering), to_json(read_new_indsats.registrering[1].registrering), to_json(prev_indsats_registrering), to_json(prev_new_indsats.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_indsats_reg := ROW(
        ROW (null, (read_new_indsats.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_indsats.registrering[1]).tilsPubliceret ,
        (read_new_indsats.registrering[1]).tilsFremdrift ,
        
        (read_new_indsats.registrering[1]).attrEgenskaber ,
        (read_new_indsats.registrering[1]).relationer
    )::indsatsRegistreringType;

    read_prev_indsats_reg := ROW(
        ROW(null, (read_prev_indsats.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_indsats.registrering[1]).tilsPubliceret ,
        (read_prev_indsats.registrering[1]).tilsFremdrift ,
        
        (read_prev_indsats.registrering[1]).attrEgenskaber ,
        (read_prev_indsats.registrering[1]).relationer
    )::indsatsRegistreringType;


    IF read_prev_indsats_reg = read_new_indsats_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_indsats_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_indsats_reg);
      RAISE EXCEPTION 'Aborted updating indsats with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', indsats_uuid, to_json(read_new_indsats_reg), to_json(read_prev_indsats_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_indsats_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_indsats (
    indsats_registrering IndsatsRegistreringType,
    indsats_uuid uuid DEFAULT NULL, auth_criteria_arr
    IndsatsRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE indsats_registrering_id bigint;

    
    indsats_attr_egenskaber_obj indsatsEgenskaberAttrType;
    

    
    indsats_tils_publiceret_obj indsatsPubliceretTilsType;
    
    indsats_tils_fremdrift_obj indsatsFremdriftTilsType;
    

    indsats_relationer IndsatsRelationType;

    

    auth_filtered_uuids uuid[];

    
    indsats_relation_kode indsatsRelationKode;
    indsats_uuid_underscores text;
    indsats_rel_seq_name text;
    indsats_rel_type_cardinality_unlimited indsatsRelationKode[]:=ARRAY['indsatskvalitet'::IndsatsRelationKode,'indsatsaktoer'::IndsatsRelationKode,'samtykke'::IndsatsRelationKode,'indsatssag'::IndsatsRelationKode,'indsatsdokument'::IndsatsRelationKode]::indsatsRelationKode[];
    indsats_rel_type_cardinality_unlimited_present_in_argument indsatsRelationKode[];
    

    does_exist boolean;
    new_indsats_registrering indsats_registrering;
BEGIN
    IF indsats_uuid IS NULL THEN LOOP
        indsats_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from indsats WHERE id=indsats_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from indsats WHERE id=indsats_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (indsats_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (indsats_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (indsats_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_indsats.',(indsats_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO indsats (ID) SELECT
        indsats_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        indsats_registrering_id:=nextval('indsats_registrering_id_seq');

        INSERT INTO indsats_registrering (id, indsats_id,
            registrering) SELECT indsats_registrering_id,
        indsats_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (indsats_registrering.registrering).livscykluskode,
        (indsats_registrering.registrering).brugerref,
        (indsats_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_indsats_registrering :=
            _as_create_indsats_registrering(indsats_uuid,
                (indsats_registrering.registrering).livscykluskode,
                (indsats_registrering.registrering).brugerref,
                (indsats_registrering.registrering).note);

            indsats_registrering_id := new_indsats_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(indsats_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [indsats]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF indsats_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(indsats_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH indsats_attr_egenskaber_obj IN ARRAY indsats_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO indsats_attr_egenskaber (
      
      brugervendtnoegle,
      beskrivelse,
      starttidspunkt,
      sluttidspunkt,
      virkning,
      indsats_registrering_id
    )
    SELECT
     
     indsats_attr_egenskaber_obj.brugervendtnoegle,
      indsats_attr_egenskaber_obj.beskrivelse,
      indsats_attr_egenskaber_obj.starttidspunkt,
      indsats_attr_egenskaber_obj.sluttidspunkt,
      indsats_attr_egenskaber_obj.virkning,
      indsats_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(indsats_registrering.tilsPubliceret, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [publiceret] for indsats. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF indsats_registrering.tilsPubliceret IS NOT NULL AND coalesce(array_length(indsats_registrering.tilsPubliceret,1),0)>0 THEN
  FOREACH indsats_tils_publiceret_obj IN ARRAY indsats_registrering.tilsPubliceret
  LOOP

    INSERT INTO indsats_tils_publiceret (
      virkning,
      publiceret,
      indsats_registrering_id
    )
    SELECT
      indsats_tils_publiceret_obj.virkning,
      indsats_tils_publiceret_obj.publiceret,
      indsats_registrering_id;

  END LOOP;
END IF;

--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(indsats_registrering.tilsFremdrift, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [fremdrift] for indsats. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF indsats_registrering.tilsFremdrift IS NOT NULL AND coalesce(array_length(indsats_registrering.tilsFremdrift,1),0)>0 THEN
  FOREACH indsats_tils_fremdrift_obj IN ARRAY indsats_registrering.tilsFremdrift
  LOOP

    INSERT INTO indsats_tils_fremdrift (
      virkning,
      fremdrift,
      indsats_registrering_id
    )
    SELECT
      indsats_tils_fremdrift_obj.virkning,
      indsats_tils_fremdrift_obj.fremdrift,
      indsats_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations


IF coalesce(array_length(indsats_registrering.relationer,1),0)>0 THEN

--Create temporary sequences
indsats_uuid_underscores:=replace(indsats_uuid::text, '-', '_');

SELECT array_agg(DISTINCT a.RelType) into indsats_rel_type_cardinality_unlimited_present_in_argument FROM unnest(indsats_registrering.relationer) a WHERE a.RelType = any (indsats_rel_type_cardinality_unlimited) ;
IF coalesce(array_length(indsats_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN

FOREACH indsats_relation_kode IN ARRAY (indsats_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  indsats_rel_seq_name := 'indsats_' || indsats_relation_kode::text || indsats_uuid_underscores;

  EXECUTE 'CREATE TEMPORARY SEQUENCE ' || indsats_rel_seq_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START 1
  CACHE 1;';

END LOOP;
END IF;


    INSERT INTO indsats_relation (
      indsats_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type,
      rel_index
    )
    SELECT
      indsats_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType,
      CASE WHEN a.relType = any (indsats_rel_type_cardinality_unlimited) THEN --rel_index
      nextval('indsats_' || a.relType::text || indsats_uuid_underscores)
      ELSE 
      NULL
      END
    FROM unnest(indsats_registrering.relationer) a
  ;



--Drop temporary sequences
IF coalesce(array_length(indsats_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH indsats_relation_kode IN ARRAY (indsats_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  indsats_rel_seq_name := 'indsats_' || indsats_relation_kode::text || indsats_uuid_underscores;
  EXECUTE 'DROP SEQUENCE ' || indsats_rel_seq_name || ';';
END LOOP;
END IF;


END IF;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_indsats(array[indsats_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[indsats_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import indsats with uuid [%]. Object does not met stipulated criteria:%',indsats_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN indsats_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_indsats(indsats_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr IndsatsRegistreringType[]=null
  )
  RETURNS IndsatsType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result IndsatsType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_indsats(indsats_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(indsats_uuids,1),0) AND auth_filtered_uuids @>indsats_uuids) THEN
  RAISE EXCEPTION 'Unable to list indsats with uuids [%]. All objects do not fullfill the stipulated criteria:%',indsats_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.indsatsObj) into result
FROM
(
SELECT
ROW(
	a.indsats_id,
	array_agg(
		ROW (
			a.registrering,
			a.IndsatsTilsPubliceretArr,
			a.IndsatsTilsFremdriftArr,
			a.IndsatsAttrEgenskaberArr,
			a.IndsatsRelationArr
		)::IndsatsRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: IndsatsType  indsatsObj
FROM
(
	SELECT
	a.indsats_id,
	a.indsats_registrering_id,
	a.registrering,
	a.IndsatsAttrEgenskaberArr,
	a.IndsatsTilsPubliceretArr,
	a.IndsatsTilsFremdriftArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type,
                b.rel_index
			):: IndsatsRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.rel_index,b.virkning
        
	)) IndsatsRelationArr
	FROM
	(
			SELECT
			a.indsats_id,
			a.indsats_registrering_id,
			a.registrering,
			a.IndsatsAttrEgenskaberArr,
			a.IndsatsTilsFremdriftArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.publiceret
						) ::IndsatsPubliceretTilsType
					ELSE NULL
					END
					order by b.publiceret,b.virkning
				)) IndsatsTilsPubliceretArr		
			FROM
			(
			SELECT
			a.indsats_id,
			a.indsats_registrering_id,
			a.registrering,
			a.IndsatsAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.fremdrift
						) ::IndsatsFremdriftTilsType
					ELSE NULL
					END
					order by b.fremdrift,b.virkning
				)) IndsatsTilsFremdriftArr		
			FROM
			(
					SELECT
					a.indsats_id,
					a.indsats_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.beskrivelse,
					 		b.starttidspunkt,
					 		b.sluttidspunkt,
					   		b.virkning
                            
							)::IndsatsEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.beskrivelse,b.starttidspunkt,b.sluttidspunkt,b.virkning
                        
					)) IndsatsAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id indsats_id,
					b.id indsats_registrering_id,
					b.registrering			
					FROM		indsats a
					JOIN 		indsats_registrering b 	ON b.indsats_id=a.id
					WHERE a.id = ANY (indsats_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN indsats_attr_egenskaber as b ON b.indsats_registrering_id=a.indsats_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.indsats_id,
					a.indsats_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN indsats_tils_fremdrift as b ON b.indsats_registrering_id=a.indsats_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.indsats_id,
			a.indsats_registrering_id,
			a.registrering,
			a.IndsatsAttrEgenskaberArr	
			) as a
			LEFT JOIN indsats_tils_publiceret as b ON b.indsats_registrering_id=a.indsats_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.indsats_id,
			a.indsats_registrering_id,
			a.registrering,
			a.IndsatsAttrEgenskaberArr,
			a.IndsatsTilsFremdriftArr
	) as a
	LEFT JOIN indsats_relation b ON b.indsats_registrering_id=a.indsats_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.indsats_id,
	a.indsats_registrering_id,
	a.registrering,
	a.IndsatsAttrEgenskaberArr,
	a.IndsatsTilsFremdriftArr,
	a.IndsatsTilsPubliceretArr
) as a

WHERE a.indsats_id IS NOT NULL
GROUP BY 
a.indsats_id
order by a.indsats_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_indsats(
    indsats_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      IndsatsRegistreringType[]=null
) RETURNS IndsatsType AS $$
DECLARE
	resArr IndsatsType[];
BEGIN
    resArr := as_list_indsats(ARRAY[indsats_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_indsats(
    firstResult int,--TOOD ??
    indsats_uuid uuid,
    registreringObj   IndsatsRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr IndsatsRegistreringType[]=null

    ,
    search_operator_greater_than_or_equal_attr_egenskaber IndsatsEgenskaberAttrType[]=null,
    search_operator_less_than_or_equal_attr_egenskaber    IndsatsEgenskaberAttrType[]=null
    

) RETURNS uuid[] AS $$
DECLARE
    indsats_candidates uuid[];
    indsats_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj IndsatsEgenskaberAttrType;

    
    tilsPubliceretTypeObj IndsatsPubliceretTilsType;
    tilsFremdriftTypeObj IndsatsFremdriftTilsType;

    relationTypeObj IndsatsRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

indsats_candidates_is_initialized := false;

IF indsats_uuid is not NULL THEN
    indsats_candidates:= ARRAY[indsats_uuid];
    indsats_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        indsats_candidates:=array(
                SELECT DISTINCT
                b.indsats_id
                FROM
                indsats a
                JOIN indsats_registrering b on b.indsats_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'indsats_candidates_is_initialized step 1:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 1:%',indsats_candidates;
--/****************************//


--RAISE NOTICE 'indsats_candidates_is_initialized step 2:%',indsats_candidates_is_initialized;
--RAISE NOTICE 'indsats_candidates step 2:%',indsats_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_indsats: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(indsats_candidates,1),0)>0 OR NOT indsats_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            indsats_candidates:=array(
            SELECT DISTINCT
            b.indsats_id
            FROM  indsats_attr_egenskaber a
            JOIN indsats_registrering b on a.indsats_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.beskrivelse IS NULL
                    OR
                    a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.starttidspunkt IS NULL
                    OR
                    a.starttidspunkt = attrEgenskaberTypeObj.starttidspunkt
                )
                AND
                (
                    attrEgenskaberTypeObj.sluttidspunkt IS NULL
                    OR
                    a.sluttidspunkt = attrEgenskaberTypeObj.sluttidspunkt
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

            );


            indsats_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'indsats_candidates_is_initialized step 3:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 3:%',indsats_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        indsats_candidates:=array(

            SELECT DISTINCT
            b.indsats_id
            
            FROM  indsats_attr_egenskaber a
            JOIN indsats_registrering b on a.indsats_registrering_id=b.id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.beskrivelse ILIKE anyAttrValue OR
                                    a.starttidspunkt::text ilike anyAttrValue OR
                                    a.sluttidspunkt::text ilike anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )


        );

    indsats_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
    --RAISE DEBUG 'as_search_indsats: skipping filtration on tilsPubliceret';
ELSE
    IF (coalesce(array_length(indsats_candidates,1),0)>0 OR indsats_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
        LOOP
            indsats_candidates:=array(
            SELECT DISTINCT
            b.indsats_id
            FROM  indsats_tils_publiceret a
            JOIN indsats_registrering b on a.indsats_registrering_id=b.id
            WHERE
                (
                    tilsPubliceretTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsPubliceretTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).AktoerRef IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsPubliceretTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsPubliceretTypeObj.virkning) IS NULL OR (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsPubliceretTypeObj.publiceret IS NULL
                    OR
                    tilsPubliceretTypeObj.publiceret = a.publiceret
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

    );


            indsats_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;
--/**********************************************************//
--Filtration on state: Fremdrift
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsFremdrift IS NULL THEN
    --RAISE DEBUG 'as_search_indsats: skipping filtration on tilsFremdrift';
ELSE
    IF (coalesce(array_length(indsats_candidates,1),0)>0 OR indsats_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsFremdriftTypeObj IN ARRAY registreringObj.tilsFremdrift
        LOOP
            indsats_candidates:=array(
            SELECT DISTINCT
            b.indsats_id
            FROM  indsats_tils_fremdrift a
            JOIN indsats_registrering b on a.indsats_registrering_id=b.id
            WHERE
                (
                    tilsFremdriftTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsFremdriftTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsFremdriftTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsFremdriftTypeObj.virkning).AktoerRef IS NULL OR (tilsFremdriftTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsFremdriftTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsFremdriftTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsFremdriftTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsFremdriftTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsFremdriftTypeObj.virkning) IS NULL OR (tilsFremdriftTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsFremdriftTypeObj.fremdrift IS NULL
                    OR
                    tilsFremdriftTypeObj.fremdrift = a.fremdrift
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

    );


            indsats_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer IndsatsRelationType[]
*/


--RAISE DEBUG 'indsats_candidates_is_initialized step 4:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 4:%',indsats_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_indsats: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(indsats_candidates,1),0)>0 OR NOT indsats_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            indsats_candidates:=array(
            SELECT DISTINCT
            b.indsats_id
            FROM  indsats_relation a
            JOIN indsats_registrering b on a.indsats_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                AND
                (
                        relationTypeObj.indeks IS NULL
                        OR
                        relationTypeObj.indeks = a.rel_index
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

    );

            indsats_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        indsats_candidates:=array(
            SELECT DISTINCT
            b.indsats_id
            
            FROM  indsats_relation a
            JOIN indsats_registrering b on a.indsats_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )


            );

    indsats_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        indsats_candidates:=array(
            SELECT DISTINCT
            b.indsats_id
            
            FROM  indsats_relation a
            JOIN indsats_registrering b on a.indsats_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )


            );

    indsats_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 


 --/**********************************************************//
---Filtration using operator 'greather than or equal': Egenskaber
---/**********************************************************//
IF coalesce(array_length(search_operator_greater_than_or_equal_attr_egenskaber,1),0)>0 THEN
       IF (coalesce(array_length(indsats_candidates,1),0)>0 OR NOT indsats_candidates_is_initialized) THEN
               FOREACH attrEgenskaberTypeObj IN ARRAY search_operator_greater_than_or_equal_attr_egenskaber
               LOOP
                       indsats_candidates:=array(
                       SELECT DISTINCT
                       b.indsats_id 
                       FROM  indsats_attr_egenskaber a
                       JOIN indsats_registrering b on a.indsats_registrering_id=b.id
                       WHERE
                               (
                                       (
                                               attrEgenskaberTypeObj.virkning IS NULL 
                                               OR
                                               (
                                                       (
                                                               (
                                                                       (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                                               )
                                                               OR
                                                               (
                                                                       (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                                               )
                                                       )
                                                       AND
                                                       (
                                                                       (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                                                       )
                                                       AND
                                                       (
                                                                       (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                                                       )
                                                       AND
                                                       (
                                                                       (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst
                                                       )
                                               )
                                       )
                               )
                               AND
                               (
                                       (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                                       OR
                                       (
                                               virkningSoeg IS NULL
                                               OR
                                               virkningSoeg && (a.virkning).TimePeriod
                                       )
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                                       OR 
                                       a.brugervendtnoegle >= attrEgenskaberTypeObj.brugervendtnoegle 
                               )
                               
                               AND
                               (
                                       attrEgenskaberTypeObj.beskrivelse IS NULL
                                       OR 
                                       a.beskrivelse >= attrEgenskaberTypeObj.beskrivelse 
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.starttidspunkt IS NULL
                                       OR 
                                       a.starttidspunkt >= attrEgenskaberTypeObj.starttidspunkt 
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.sluttidspunkt IS NULL
                                       OR 
                                       a.sluttidspunkt >= attrEgenskaberTypeObj.sluttidspunkt 
                               )
                               
                               AND
                                               (
                               (registreringObj.registrering) IS NULL 
                               OR
                               (
                                       (
                                               (registreringObj.registrering).timeperiod IS NULL 
                                               OR
                                               (registreringObj.registrering).timeperiod && (b.registrering).timeperiod
                                       )
                                       AND
                                       (
                                               (registreringObj.registrering).livscykluskode IS NULL 
                                               OR
                                               (registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode                 
                                       ) 
                                       AND
                                       (
                                               (registreringObj.registrering).brugerref IS NULL
                                               OR
                                               (registreringObj.registrering).brugerref = (b.registrering).brugerref
                                       )
                                       AND
                                       (
                                               (registreringObj.registrering).note IS NULL
                                               OR
                                               (b.registrering).note ILIKE (registreringObj.registrering).note
                                       )
                       )
               )
               AND
               (
                       (
                               ((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
                               AND
                                       (
                                               (registreringObj.registrering) IS NULL 
                                               OR
                                               (registreringObj.registrering).livscykluskode IS NULL 
                                       )
                       )
                       OR
                       (
                               (NOT ((registreringObj.registrering) IS NULL))
                               AND
                               (registreringObj.registrering).livscykluskode IS NOT NULL 
                       )
               )
               AND
               (
                       (
                         (
                               (registreringObj.registrering) IS NULL
                               OR
                               (registreringObj.registrering).timeperiod IS NULL
                         )
                         AND
                         upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
                       )       
               OR
                       (
                               (NOT ((registreringObj.registrering) IS NULL))
                               AND
                               ((registreringObj.registrering).timeperiod IS NOT NULL)
                       )
               )
               AND
               ((NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

                       );
                       

                       indsats_candidates_is_initialized:=true;
                       
                       
                       END LOOP;
               END IF; 
       END IF;

--RAISE DEBUG 'indsats_candidates_is_initialized step 3:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 3:%',indsats_candidates;

 --/**********************************************************//
--Filtration using operator 'less than or equal': Egenskaber
--/**********************************************************//
IF coalesce(array_length(search_operator_less_than_or_equal_attr_egenskaber,1),0)>0 THEN
       IF (coalesce(array_length(indsats_candidates,1),0)>0 OR NOT indsats_candidates_is_initialized) THEN
               FOREACH attrEgenskaberTypeObj IN ARRAY search_operator_less_than_or_equal_attr_egenskaber
               LOOP
                       indsats_candidates:=array(
                       SELECT DISTINCT
                       b.indsats_id 
                       FROM  indsats_attr_egenskaber a
                       JOIN indsats_registrering b on a.indsats_registrering_id=b.id
                       WHERE
                               (
                                       (
                                               attrEgenskaberTypeObj.virkning IS NULL 
                                               OR
                                               (
                                                       (
                                                               (
                                                                       (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                                               )
                                                               OR
                                                               (
                                                                       (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                                               )
                                                       )
                                                       AND
                                                       (
                                                                       (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                                                       )
                                                       AND
                                                       (
                                                                       (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                                                       )
                                                       AND
                                                       (
                                                                       (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                                                       )
                                               )
                                       )
                               )
                               AND
                               (
                                       (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                                       OR
                                       (
                                               virkningSoeg IS NULL
                                               OR
                                               virkningSoeg && (a.virkning).TimePeriod
                                       )
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                                       OR 
                                       a.brugervendtnoegle <= attrEgenskaberTypeObj.brugervendtnoegle 
                               )
                               
                               AND
                               (
                                       attrEgenskaberTypeObj.beskrivelse IS NULL
                                       OR 
                                       a.beskrivelse <= attrEgenskaberTypeObj.beskrivelse 
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.starttidspunkt IS NULL
                                       OR 
                                       a.starttidspunkt <= attrEgenskaberTypeObj.starttidspunkt 
                               )
                               AND
                               (
                                       attrEgenskaberTypeObj.sluttidspunkt IS NULL
                                       OR 
                                       a.sluttidspunkt <= attrEgenskaberTypeObj.sluttidspunkt 
                               )
                               
                               AND
                                               (
                               (registreringObj.registrering) IS NULL 
                               OR
                               (
                                       (
                                               (registreringObj.registrering).timeperiod IS NULL 
                                               OR
                                               (registreringObj.registrering).timeperiod && (b.registrering).timeperiod
                                       )
                                       AND
                                       (
                                               (registreringObj.registrering).livscykluskode IS NULL 
                                               OR
                                               (registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode                 
                                       ) 
                                       AND
                                       (
                                               (registreringObj.registrering).brugerref IS NULL
                                               OR
                                               (registreringObj.registrering).brugerref = (b.registrering).brugerref
                                       )
                                       AND
                                       (
                                               (registreringObj.registrering).note IS NULL
                                               OR
                                               (b.registrering).note ILIKE (registreringObj.registrering).note
                                       )
                       )
               )
               AND
               (
                       (
                               ((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
                               AND
                                       (
                                               (registreringObj.registrering) IS NULL 
                                               OR
                                               (registreringObj.registrering).livscykluskode IS NULL 
                                       )
                       )
                       OR
                       (
                               (NOT ((registreringObj.registrering) IS NULL))
                               AND
                               (registreringObj.registrering).livscykluskode IS NOT NULL 
                       )
               )
               AND
               (
                       (
                         (
                               (registreringObj.registrering) IS NULL
                               OR
                               (registreringObj.registrering).timeperiod IS NULL
                         )
                         AND
                         upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
                       )       
               OR
                       (
                               (NOT ((registreringObj.registrering) IS NULL))
                               AND
                               ((registreringObj.registrering).timeperiod IS NOT NULL)
                       )
               )
               AND
               ((NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

                       );
                       

                       indsats_candidates_is_initialized:=true;
                       
                       
                       END LOOP;
               END IF; 
       END IF;

--RAISE DEBUG 'indsats_candidates_is_initialized step 3:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 3:%',indsats_candidates;

--/**********************//



--RAISE DEBUG 'indsats_candidates_is_initialized step 5:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 5:%',indsats_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT indsats_candidates_is_initialized THEN
        indsats_candidates:=array(
        SELECT DISTINCT
            indsats_id
        FROM
            indsats_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT indsats_candidates_is_initialized) OR b.indsats_id = ANY (indsats_candidates) )

        )
        ;

        indsats_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT indsats_candidates_is_initialized THEN
    --No filters applied!
    indsats_candidates:=array(
        SELECT DISTINCT id FROM indsats a
    );
ELSE
    indsats_candidates:=array(
        SELECT DISTINCT id FROM unnest(indsats_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'indsats_candidates_is_initialized step 6:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 6:%',indsats_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_indsats(indsats_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_indsats(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_IndsatsRegistreringType_to_json(IndsatsRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END indsatsegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsPubliceret,1),0)>0 THEN to_json($1.tilsPubliceret) 
        ELSE 
        NULL
        END indsatspubliceret
        ,
        
        CASE 
        WHEN coalesce(array_length($1.tilsFremdrift,1),0)>0 THEN to_json($1.tilsFremdrift) 
        ELSE 
        NULL
        END indsatsfremdrift
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType,e.indeks)::IndsatsRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType,indeks)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (IndsatsRegistreringType as json);
create cast (IndsatsRegistreringType as json) with function actual_state._cast_IndsatsRegistreringType_to_json(IndsatsRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_indsatsType_to_json(IndsatsType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg IndsatsRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (IndsatsType as json);
create cast (IndsatsType as json) with function actual_state._cast_indsatsType_to_json(IndsatsType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_indsats(
    indsats_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    IndsatsRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    indsats_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    indsats_sorted_uuid:=array(
          SELECT b.indsats_id
            FROM indsats_registrering b
            JOIN indsats_attr_egenskaber a ON a.indsats_registrering_id=b.id
           WHERE b.indsats_id = ANY (indsats_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.indsats_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.indsats_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN indsats_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_indsats(
	indsats_uuids uuid[],
	registreringObjArr IndsatsRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	indsats_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	indsats_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj IndsatsEgenskaberAttrType;
	
  	tilsPubliceretTypeObj IndsatsPubliceretTilsType;
  	tilsFremdriftTypeObj IndsatsFremdriftTilsType;
	relationTypeObj IndsatsRelationType;
	registreringObj IndsatsRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN indsats_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF indsats_uuids IS NULL OR coalesce(array_length(indsats_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

indsats_candidates:= indsats_uuids;



--RAISE DEBUG 'indsats_candidates_is_initialized step 1:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 1:%',indsats_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_indsats: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(indsats_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_attr_egenskaber a 
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.starttidspunkt IS NULL
					OR 
					a.starttidspunkt = attrEgenskaberTypeObj.starttidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.sluttidspunkt IS NULL
					OR 
					a.sluttidspunkt = attrEgenskaberTypeObj.sluttidspunkt 
				)
				AND b.indsats_id = ANY (indsats_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'indsats_candidates_is_initialized step 3:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 3:%',indsats_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_indsats: skipping filtration on tilsPubliceret';
ELSE
	IF coalesce(array_length(indsats_candidates,1),0)>0 THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_tils_publiceret a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND b.indsats_id = ANY (indsats_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;
--/**********************************************************//
--Filtration on state: Fremdrift
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsFremdrift IS NULL THEN
	--RAISE DEBUG 'as_search_indsats: skipping filtration on tilsFremdrift';
ELSE
	IF coalesce(array_length(indsats_candidates,1),0)>0 THEN 

		FOREACH tilsFremdriftTypeObj IN ARRAY registreringObj.tilsFremdrift
		LOOP
			indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_tils_fremdrift a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsFremdriftTypeObj.fremdrift IS NULL
					OR
					tilsFremdriftTypeObj.fremdrift = a.fremdrift
				)
				AND b.indsats_id = ANY (indsats_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer IndsatsRelationType[]
*/


--RAISE DEBUG 'indsats_candidates_is_initialized step 4:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 4:%',indsats_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_indsats: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(indsats_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			indsats_candidates:=array(
			SELECT DISTINCT
			b.indsats_id 
			FROM  indsats_relation a
			JOIN indsats_registrering b on a.indsats_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.indsats_id = ANY (indsats_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'indsats_candidates_is_initialized step 5:%',indsats_candidates_is_initialized;
--RAISE DEBUG 'indsats_candidates step 5:%',indsats_candidates;

indsats_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (indsats_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (indsats_candidates) b(id)
);

--optimization 
IF coalesce(array_length(indsats_passed_auth_filter,1),0)=coalesce(array_length(indsats_uuids,1),0) AND indsats_passed_auth_filter @>indsats_uuids THEN
	RETURN indsats_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN indsats_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE InteressefaellesskabGyldighedTils AS ENUM ('Aktiv','Inaktiv',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE InteressefaellesskabGyldighedTilsType AS (
    virkning Virkning,
    gyldighed InteressefaellesskabGyldighedTils
)
;



CREATE TYPE InteressefaellesskabEgenskaberAttrType AS (
brugervendtnoegle text,
interessefaellesskabsnavn text,
interessefaellesskabstype text,
integrationsdata text,

 virkning Virkning
);




CREATE TYPE InteressefaellesskabRelationKode AS ENUM  ('branche','interessefaellesskabstype','overordnet','tilhoerer','adresser','opgaver','tilknyttedebrugere','tilknyttedeenheder','tilknyttedefunktioner','tilknyttedeinteressefaellesskaber','tilknyttedeorganisationer','tilknyttedepersoner','tilknyttedeitsystemer');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_interessefaellesskab_relation_kode_to_txt is invoked.



CREATE TYPE InteressefaellesskabRelationType AS (
  relType InteressefaellesskabRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text
)
;



CREATE TYPE InteressefaellesskabRegistreringType AS
(
registrering RegistreringBase,
tilsGyldighed InteressefaellesskabGyldighedTilsType[],
attrEgenskaber InteressefaellesskabEgenskaberAttrType[],
relationer InteressefaellesskabRelationType[]
);

CREATE TYPE InteressefaellesskabType AS
(
  id uuid,
  registrering InteressefaellesskabRegistreringType[]
);  





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_interessefaellesskab_relation_kode_to_txt(
    InteressefaellesskabRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE interessefaellesskab (
    id uuid NOT NULL,
    CONSTRAINT interessefaellesskab_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE interessefaellesskab
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE interessefaellesskab_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE interessefaellesskab_registrering_id_seq
    OWNER TO mox;


CREATE TABLE interessefaellesskab_registrering (
   id bigint NOT NULL DEFAULT nextval('interessefaellesskab_registrering_id_seq'::regclass),
   interessefaellesskab_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT interessefaellesskab_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT interessefaellesskab_registrering_interessefaellesskab_fkey FOREIGN KEY (interessefaellesskab_id)
       REFERENCES interessefaellesskab (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT interessefaellesskab_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(interessefaellesskab_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE interessefaellesskab_registrering
  OWNER TO mox;


CREATE INDEX interessefaellesskab_registrering_idx_livscykluskode
    ON interessefaellesskab_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX interessefaellesskab_registrering_idx_brugerref
    ON interessefaellesskab_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX interessefaellesskab_registrering_idx_note
    ON interessefaellesskab_registrering
    USING btree
    (((registrering).note));


CREATE INDEX interessefaellesskab_registrering_pat_note
    ON interessefaellesskab_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX interessefaellesskab_id_idx
    ON interessefaellesskab_registrering (interessefaellesskab_id);


CREATE TRIGGER notify_interessefaellesskab
    AFTER INSERT OR UPDATE OR DELETE ON interessefaellesskab_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE interessefaellesskab_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE interessefaellesskab_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE interessefaellesskab_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('interessefaellesskab_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        interessefaellesskabsnavn text  NULL,
        interessefaellesskabstype text  NULL,
        integrationsdata text  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    interessefaellesskab_registrering_id bigint NOT NULL,
    CONSTRAINT interessefaellesskab_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT interessefaellesskab_attr_egenskaber_forkey_interessefaellesskabregistrering FOREIGN KEY (interessefaellesskab_registrering_id) REFERENCES interessefaellesskab_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT interessefaellesskab_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (interessefaellesskab_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE interessefaellesskab_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX interessefaellesskab_attr_egenskaber_pat_brugervendtnoegle
            ON interessefaellesskab_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX interessefaellesskab_attr_egenskaber_idx_brugervendtnoegle
            ON interessefaellesskab_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX interessefaellesskab_attr_egenskaber_pat_interessefaellesskabsnavn
            ON interessefaellesskab_attr_egenskaber
            USING gin
            (interessefaellesskabsnavn gin_trgm_ops);

        CREATE INDEX interessefaellesskab_attr_egenskaber_idx_interessefaellesskabsnavn
            ON interessefaellesskab_attr_egenskaber
            USING btree
            (interessefaellesskabsnavn); 
 
     
        CREATE INDEX interessefaellesskab_attr_egenskaber_pat_interessefaellesskabstype
            ON interessefaellesskab_attr_egenskaber
            USING gin
            (interessefaellesskabstype gin_trgm_ops);

        CREATE INDEX interessefaellesskab_attr_egenskaber_idx_interessefaellesskabstype
            ON interessefaellesskab_attr_egenskaber
            USING btree
            (interessefaellesskabstype); 
 
     
        CREATE INDEX interessefaellesskab_attr_egenskaber_pat_integrationsdata
            ON interessefaellesskab_attr_egenskaber
            USING gin
            (integrationsdata gin_trgm_ops);

        CREATE INDEX interessefaellesskab_attr_egenskaber_idx_integrationsdata
            ON interessefaellesskab_attr_egenskaber
            USING btree
            (integrationsdata); 



CREATE INDEX interessefaellesskab_attr_egenskaber_idx_virkning_aktoerref
    ON interessefaellesskab_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX interessefaellesskab_attr_egenskaber_idx_virkning_aktoertypekode
    ON interessefaellesskab_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX interessefaellesskab_attr_egenskaber_idx_virkning_notetekst
    ON interessefaellesskab_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX interessefaellesskab_attr_egenskaber_pat_virkning_notetekst
    ON interessefaellesskab_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE interessefaellesskab_tils_gyldighed_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE interessefaellesskab_tils_gyldighed_id_seq
    OWNER TO mox;


CREATE TABLE interessefaellesskab_tils_gyldighed (
    id bigint NOT NULL DEFAULT nextval('interessefaellesskab_tils_gyldighed_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    gyldighed InteressefaellesskabGyldighedTils NOT NULL, 
    interessefaellesskab_registrering_id bigint not null,
    CONSTRAINT interessefaellesskab_tils_gyldighed_pkey PRIMARY KEY (id),
    CONSTRAINT interessefaellesskab_tils_gyldighed_forkey_interessefaellesskabregistrering FOREIGN KEY (interessefaellesskab_registrering_id) REFERENCES interessefaellesskab_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT interessefaellesskab_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (interessefaellesskab_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE interessefaellesskab_tils_gyldighed
    OWNER TO mox;


CREATE INDEX interessefaellesskab_tils_gyldighed_idx_gyldighed
    ON interessefaellesskab_tils_gyldighed
    USING btree
    (gyldighed);
  
CREATE INDEX interessefaellesskab_tils_gyldighed_idx_virkning_aktoerref
    ON interessefaellesskab_tils_gyldighed
    USING btree
    (((virkning).aktoerref));

CREATE INDEX interessefaellesskab_tils_gyldighed_idx_virkning_aktoertypekode
    ON interessefaellesskab_tils_gyldighed
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX interessefaellesskab_tils_gyldighed_idx_virkning_notetekst
    ON interessefaellesskab_tils_gyldighed
    USING btree
    (((virkning).notetekst));

CREATE INDEX interessefaellesskab_tils_gyldighed_pat_virkning_notetekst
    ON interessefaellesskab_tils_gyldighed
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE interessefaellesskab_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE interessefaellesskab_relation_id_seq
    OWNER TO mox;


CREATE TABLE interessefaellesskab_relation (
    id bigint NOT NULL DEFAULT nextval('interessefaellesskab_relation_id_seq'::regclass),
    interessefaellesskab_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type InteressefaellesskabRelationKode not null,
    objekt_type text null,

    

    CONSTRAINT interessefaellesskab_relation_forkey_interessefaellesskabregistrering FOREIGN KEY (interessefaellesskab_registrering_id) REFERENCES interessefaellesskab_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT interessefaellesskab_relation_pkey PRIMARY KEY (id),
    CONSTRAINT interessefaellesskab_relation_no_virkning_overlap EXCLUDE USING gist (interessefaellesskab_registrering_id WITH =, _as_convert_interessefaellesskab_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('adresser'::InteressefaellesskabRelationKode ) AND rel_type<>('opgaver'::InteressefaellesskabRelationKode ) AND rel_type<>('tilknyttedebrugere'::InteressefaellesskabRelationKode ) AND rel_type<>('tilknyttedeenheder'::InteressefaellesskabRelationKode ) AND rel_type<>('tilknyttedefunktioner'::InteressefaellesskabRelationKode ) AND rel_type<>('tilknyttedeinteressefaellesskaber'::InteressefaellesskabRelationKode ) AND rel_type<>('tilknyttedeorganisationer'::InteressefaellesskabRelationKode ) AND rel_type<>('tilknyttedepersoner'::InteressefaellesskabRelationKode ) AND rel_type<>('tilknyttedeitsystemer'::InteressefaellesskabRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT interessefaellesskab_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE interessefaellesskab_relation
  OWNER TO mox;





CREATE INDEX interessefaellesskab_relation_idx_rel_maal_obj_uuid
    ON interessefaellesskab_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX interessefaellesskab_relation_idx_rel_maal_obj_urn
    ON interessefaellesskab_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX interessefaellesskab_relation_idx_rel_maal_uuid
    ON interessefaellesskab_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX interessefaellesskab_relation_idx_rel_maal_uuid_isolated
    ON interessefaellesskab_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX interessefaellesskab_relation_idx_rel_maal_urn_isolated
    ON interessefaellesskab_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX interessefaellesskab_relation_idx_rel_maal_urn
    ON interessefaellesskab_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX interessefaellesskab_relation_idx_virkning_aktoerref
    ON interessefaellesskab_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX interessefaellesskab_relation_idx_virkning_aktoertypekode
    ON interessefaellesskab_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX interessefaellesskab_relation_idx_virkning_notetekst
    ON interessefaellesskab_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX interessefaellesskab_relation_pat_virkning_notetekst
    ON interessefaellesskab_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr InteressefaellesskabGyldighedTilsType[])
  RETURNS InteressefaellesskabGyldighedTilsType[] AS
  $$
  DECLARE result InteressefaellesskabGyldighedTilsType[];
  DECLARE element InteressefaellesskabGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr InteressefaellesskabEgenskaberAttrType[])
  RETURNS InteressefaellesskabEgenskaberAttrType[] AS
  $$
  DECLARE result InteressefaellesskabEgenskaberAttrType[]; 
   DECLARE element InteressefaellesskabEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.interessefaellesskabsnavn IS NULL AND element.interessefaellesskabstype IS NULL AND element.integrationsdata IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr InteressefaellesskabRelationType[])
RETURNS InteressefaellesskabRelationType[] AS
$$
 DECLARE result InteressefaellesskabRelationType[];
 DECLARE element InteressefaellesskabRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_interessefaellesskab_registrering(
    interessefaellesskab_registrering
) RETURNS interessefaellesskab_registrering AS $BODY$
  SELECT * FROM interessefaellesskab_registrering as a WHERE
    interessefaellesskab_id = $1.interessefaellesskab_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_interessefaellesskab_registrering(
    interessefaellesskab_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS interessefaellesskab_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    interessefaellesskab_registrering_id bigint;
    interessefaellesskab_registrering    interessefaellesskab_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE interessefaellesskab_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE interessefaellesskab_id = interessefaellesskab_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating interessefaellesskab with uuid [%], Invalid [livscyklus] transition to [%]',interessefaellesskab_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new interessefaellesskab registrering

    interessefaellesskab_registrering_id := nextval('interessefaellesskab_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    interessefaellesskab_registrering := ROW(
        interessefaellesskab_registrering_id,
        interessefaellesskab_uuid,
        registreringObj
    )::interessefaellesskab_registrering;

    INSERT INTO interessefaellesskab_registrering SELECT interessefaellesskab_registrering.*;

    RETURN interessefaellesskab_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of InteressefaellesskabAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_interessefaellesskab(
    interessefaellesskab_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber InteressefaellesskabEgenskaberAttrType[],
    

    
    tilsGyldighed InteressefaellesskabGyldighedTilsType[],
    

    relationer InteressefaellesskabRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      InteressefaellesskabRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_interessefaellesskab          InteressefaellesskabType;
    read_prev_interessefaellesskab         InteressefaellesskabType;
    read_new_interessefaellesskab_reg      InteressefaellesskabRegistreringType;
    read_prev_interessefaellesskab_reg     InteressefaellesskabRegistreringType;
    new_interessefaellesskab_registrering  interessefaellesskab_registrering;
    prev_interessefaellesskab_registrering interessefaellesskab_registrering;
    interessefaellesskab_relation_navn     InteressefaellesskabRelationKode;

    
    attrEgenskaberObj InteressefaellesskabEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from interessefaellesskab a join interessefaellesskab_registrering b ON b.interessefaellesskab_id=a.id WHERE a.id=interessefaellesskab_uuid) THEN
        RAISE EXCEPTION 'Unable to update interessefaellesskab with uuid [%], being unable to find any previous registrations.',interessefaellesskab_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM interessefaellesskab a WHERE a.id=interessefaellesskab_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_interessefaellesskab(array[interessefaellesskab_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[interessefaellesskab_uuid]) THEN
      RAISE EXCEPTION 'Unable to update interessefaellesskab with uuid [%]. Object does not met stipulated criteria:%', interessefaellesskab_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_interessefaellesskab_registrering := _as_create_interessefaellesskab_registrering(interessefaellesskab_uuid, livscykluskode, brugerref, note);
    prev_interessefaellesskab_registrering := _as_get_prev_interessefaellesskab_registrering(new_interessefaellesskab_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_interessefaellesskab_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update interessefaellesskab with uuid [%], as the interessefaellesskab seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', interessefaellesskab_uuid, lostUpdatePreventionTZ, LOWER((prev_interessefaellesskab_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    

    INSERT INTO interessefaellesskab_relation (interessefaellesskab_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
    SELECT
        new_interessefaellesskab_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType 
        FROM
            unnest(relationer) AS a ;

    


    -- Ad 2)
    -- 0..1 relations

    
    
    FOREACH interessefaellesskab_relation_navn IN ARRAY ARRAY['branche'::InteressefaellesskabRelationKode ,  'interessefaellesskabstype'::InteressefaellesskabRelationKode ,  'overordnet'::InteressefaellesskabRelationKode ,  'tilhoerer'::InteressefaellesskabRelationKode  ]::InteressefaellesskabRelationKode[]  LOOP
        INSERT INTO interessefaellesskab_relation (interessefaellesskab_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
        SELECT
            new_interessefaellesskab_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM interessefaellesskab_relation b
                 WHERE b.interessefaellesskab_registrering_id = new_interessefaellesskab_registrering.id AND b.rel_type = interessefaellesskab_relation_navn) d
            JOIN interessefaellesskab_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.interessefaellesskab_registrering_id = prev_interessefaellesskab_registrering.id AND a.rel_type = interessefaellesskab_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
    FOREACH interessefaellesskab_relation_navn IN ARRAY ARRAY['adresser'::InteressefaellesskabRelationKode, 'opgaver'::InteressefaellesskabRelationKode, 'tilknyttedebrugere'::InteressefaellesskabRelationKode, 'tilknyttedeenheder'::InteressefaellesskabRelationKode, 'tilknyttedefunktioner'::InteressefaellesskabRelationKode, 'tilknyttedeinteressefaellesskaber'::InteressefaellesskabRelationKode, 'tilknyttedeorganisationer'::InteressefaellesskabRelationKode, 'tilknyttedepersoner'::InteressefaellesskabRelationKode, 'tilknyttedeitsystemer'::InteressefaellesskabRelationKode]::InteressefaellesskabRelationKode[] LOOP
        IF NOT EXISTS (
                    SELECT 1
                      FROM interessefaellesskab_relation
                     WHERE interessefaellesskab_registrering_id = new_interessefaellesskab_registrering.id AND rel_type = interessefaellesskab_relation_navn) THEN
                    
                    INSERT INTO interessefaellesskab_relation (interessefaellesskab_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
                    SELECT
                        new_interessefaellesskab_registrering.id,  virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type
        FROM interessefaellesskab_relation
        WHERE
            interessefaellesskab_registrering_id = prev_interessefaellesskab_registrering.id AND rel_type = interessefaellesskab_relation_navn ;

    
        END IF;
    END LOOP;
    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- interessefaellesskab_tils_gyldighed

        -- Ad 1)
        INSERT INTO interessefaellesskab_tils_gyldighed(virkning, gyldighed, interessefaellesskab_registrering_id)
             SELECT a.virkning, a.gyldighed, new_interessefaellesskab_registrering.id
               FROM unnest(tilsGyldighed) AS a;

        -- Ad 2
        INSERT INTO interessefaellesskab_tils_gyldighed(virkning, gyldighed, interessefaellesskab_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.gyldighed,
            new_interessefaellesskab_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- interessefaellesskab_tils_gyldighed of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- interessefaellesskab_tils_gyldighed of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM interessefaellesskab_tils_gyldighed b
             WHERE b.interessefaellesskab_registrering_id = new_interessefaellesskab_registrering.id) d
              JOIN interessefaellesskab_tils_gyldighed a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.interessefaellesskab_registrering_id = prev_interessefaellesskab_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- interessefaellesskab_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrInteressefaellesskabObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.interessefaellesskabsnavn,a.interessefaellesskabstype,a.integrationsdata,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update interessefaellesskab with uuid [%], as the interessefaellesskab have overlapping virknings in the given egenskaber array :%', interessefaellesskab_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).interessefaellesskabsnavn IS NULL  OR  (attrEgenskaberObj).interessefaellesskabstype IS NULL  OR  (attrEgenskaberObj).integrationsdata IS NULL  THEN
            
            INSERT INTO interessefaellesskab_attr_egenskaber ( brugervendtnoegle,interessefaellesskabsnavn,interessefaellesskabstype,integrationsdata, virkning, interessefaellesskab_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.interessefaellesskabsnavn, a.interessefaellesskabsnavn),
                    
                        
                        
                            coalesce(attrEgenskaberObj.interessefaellesskabstype, a.interessefaellesskabstype),
                    
                        
                        
                            coalesce(attrEgenskaberObj.integrationsdata, a.integrationsdata),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_interessefaellesskab_registrering.id
                        FROM interessefaellesskab_attr_egenskaber a
                    WHERE
                        a.interessefaellesskab_registrering_id = prev_interessefaellesskab_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO interessefaellesskab_attr_egenskaber ( brugervendtnoegle,interessefaellesskabsnavn,interessefaellesskabstype,integrationsdata, virkning, interessefaellesskab_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.interessefaellesskabsnavn,
                    
                     attrEgenskaberObj.interessefaellesskabstype,
                    
                     attrEgenskaberObj.integrationsdata,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_interessefaellesskab_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the interessefaellesskab_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM interessefaellesskab_attr_egenskaber b
                    WHERE b.interessefaellesskab_registrering_id = new_interessefaellesskab_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO interessefaellesskab_attr_egenskaber ( brugervendtnoegle,interessefaellesskabsnavn,interessefaellesskabstype,integrationsdata, virkning, interessefaellesskab_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.interessefaellesskabsnavn,  attrEgenskaberObj.interessefaellesskabstype,  attrEgenskaberObj.integrationsdata, attrEgenskaberObj.virkning, new_interessefaellesskab_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO interessefaellesskab_attr_egenskaber ( brugervendtnoegle,interessefaellesskabsnavn,interessefaellesskabstype,integrationsdata, virkning, interessefaellesskab_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.interessefaellesskabsnavn,
        
            a.interessefaellesskabstype,
        
            a.integrationsdata,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_interessefaellesskab_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- interessefaellesskab_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- interessefaellesskab_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                interessefaellesskab_attr_egenskaber b
            WHERE
                b.interessefaellesskab_registrering_id = new_interessefaellesskab_registrering.id) d
            JOIN interessefaellesskab_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.interessefaellesskab_registrering_id = prev_interessefaellesskab_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_interessefaellesskab := as_read_interessefaellesskab(interessefaellesskab_uuid, (new_interessefaellesskab_registrering.registrering).timeperiod, null);
    read_prev_interessefaellesskab := as_read_interessefaellesskab(interessefaellesskab_uuid, (prev_interessefaellesskab_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_interessefaellesskab.registrering[1].registrering).TimePeriod) = lower((new_interessefaellesskab_registrering.registrering).TimePeriod) and lower((read_prev_interessefaellesskab.registrering[1].registrering).TimePeriod)=lower((prev_interessefaellesskab_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating interessefaellesskab with id [%]: The ordering of as_list_interessefaellesskab should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', interessefaellesskab_uuid, to_json(new_interessefaellesskab_registrering), to_json(read_new_interessefaellesskab.registrering[1].registrering), to_json(prev_interessefaellesskab_registrering), to_json(prev_new_interessefaellesskab.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_interessefaellesskab_reg := ROW(
        ROW (null, (read_new_interessefaellesskab.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_interessefaellesskab.registrering[1]).tilsGyldighed ,
        
        (read_new_interessefaellesskab.registrering[1]).attrEgenskaber ,
        (read_new_interessefaellesskab.registrering[1]).relationer
    )::interessefaellesskabRegistreringType;

    read_prev_interessefaellesskab_reg := ROW(
        ROW(null, (read_prev_interessefaellesskab.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_interessefaellesskab.registrering[1]).tilsGyldighed ,
        
        (read_prev_interessefaellesskab.registrering[1]).attrEgenskaber ,
        (read_prev_interessefaellesskab.registrering[1]).relationer
    )::interessefaellesskabRegistreringType;


    IF read_prev_interessefaellesskab_reg = read_new_interessefaellesskab_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_interessefaellesskab_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_interessefaellesskab_reg);
      RAISE EXCEPTION 'Aborted updating interessefaellesskab with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', interessefaellesskab_uuid, to_json(read_new_interessefaellesskab_reg), to_json(read_prev_interessefaellesskab_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_interessefaellesskab_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_interessefaellesskab (
    interessefaellesskab_registrering InteressefaellesskabRegistreringType,
    interessefaellesskab_uuid uuid DEFAULT NULL, auth_criteria_arr
    InteressefaellesskabRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE interessefaellesskab_registrering_id bigint;

    
    interessefaellesskab_attr_egenskaber_obj interessefaellesskabEgenskaberAttrType;
    

    
    interessefaellesskab_tils_gyldighed_obj interessefaellesskabGyldighedTilsType;
    

    interessefaellesskab_relationer InteressefaellesskabRelationType;

    

    auth_filtered_uuids uuid[];

    

    does_exist boolean;
    new_interessefaellesskab_registrering interessefaellesskab_registrering;
BEGIN
    IF interessefaellesskab_uuid IS NULL THEN LOOP
        interessefaellesskab_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from interessefaellesskab WHERE id=interessefaellesskab_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from interessefaellesskab WHERE id=interessefaellesskab_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (interessefaellesskab_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (interessefaellesskab_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (interessefaellesskab_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_interessefaellesskab.',(interessefaellesskab_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO interessefaellesskab (ID) SELECT
        interessefaellesskab_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        interessefaellesskab_registrering_id:=nextval('interessefaellesskab_registrering_id_seq');

        INSERT INTO interessefaellesskab_registrering (id, interessefaellesskab_id,
            registrering) SELECT interessefaellesskab_registrering_id,
        interessefaellesskab_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (interessefaellesskab_registrering.registrering).livscykluskode,
        (interessefaellesskab_registrering.registrering).brugerref,
        (interessefaellesskab_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_interessefaellesskab_registrering :=
            _as_create_interessefaellesskab_registrering(interessefaellesskab_uuid,
                (interessefaellesskab_registrering.registrering).livscykluskode,
                (interessefaellesskab_registrering.registrering).brugerref,
                (interessefaellesskab_registrering.registrering).note);

            interessefaellesskab_registrering_id := new_interessefaellesskab_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(interessefaellesskab_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [interessefaellesskab]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF interessefaellesskab_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(interessefaellesskab_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH interessefaellesskab_attr_egenskaber_obj IN ARRAY interessefaellesskab_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO interessefaellesskab_attr_egenskaber (
      
      brugervendtnoegle,
      interessefaellesskabsnavn,
      interessefaellesskabstype,
      integrationsdata,
      virkning,
      interessefaellesskab_registrering_id
    )
    SELECT
     
     interessefaellesskab_attr_egenskaber_obj.brugervendtnoegle,
      interessefaellesskab_attr_egenskaber_obj.interessefaellesskabsnavn,
      interessefaellesskab_attr_egenskaber_obj.interessefaellesskabstype,
      interessefaellesskab_attr_egenskaber_obj.integrationsdata,
      interessefaellesskab_attr_egenskaber_obj.virkning,
      interessefaellesskab_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(interessefaellesskab_registrering.tilsGyldighed, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [gyldighed] for interessefaellesskab. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF interessefaellesskab_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(interessefaellesskab_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH interessefaellesskab_tils_gyldighed_obj IN ARRAY interessefaellesskab_registrering.tilsGyldighed
  LOOP

    INSERT INTO interessefaellesskab_tils_gyldighed (
      virkning,
      gyldighed,
      interessefaellesskab_registrering_id
    )
    SELECT
      interessefaellesskab_tils_gyldighed_obj.virkning,
      interessefaellesskab_tils_gyldighed_obj.gyldighed,
      interessefaellesskab_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations



    INSERT INTO interessefaellesskab_relation (
      interessefaellesskab_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      interessefaellesskab_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(interessefaellesskab_registrering.relationer) a
  ;




/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_interessefaellesskab(array[interessefaellesskab_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[interessefaellesskab_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import interessefaellesskab with uuid [%]. Object does not met stipulated criteria:%',interessefaellesskab_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN interessefaellesskab_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_interessefaellesskab(interessefaellesskab_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr InteressefaellesskabRegistreringType[]=null
  )
  RETURNS InteressefaellesskabType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result InteressefaellesskabType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_interessefaellesskab(interessefaellesskab_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(interessefaellesskab_uuids,1),0) AND auth_filtered_uuids @>interessefaellesskab_uuids) THEN
  RAISE EXCEPTION 'Unable to list interessefaellesskab with uuids [%]. All objects do not fullfill the stipulated criteria:%',interessefaellesskab_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.interessefaellesskabObj) into result
FROM
(
SELECT
ROW(
	a.interessefaellesskab_id,
	array_agg(
		ROW (
			a.registrering,
			a.InteressefaellesskabTilsGyldighedArr,
			a.InteressefaellesskabAttrEgenskaberArr,
			a.InteressefaellesskabRelationArr
		)::InteressefaellesskabRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: InteressefaellesskabType  interessefaellesskabObj
FROM
(
	SELECT
	a.interessefaellesskab_id,
	a.interessefaellesskab_registrering_id,
	a.registrering,
	a.InteressefaellesskabAttrEgenskaberArr,
	a.InteressefaellesskabTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type
			):: InteressefaellesskabRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
        
	)) InteressefaellesskabRelationArr
	FROM
	(
			SELECT
			a.interessefaellesskab_id,
			a.interessefaellesskab_registrering_id,
			a.registrering,
			a.InteressefaellesskabAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::InteressefaellesskabGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) InteressefaellesskabTilsGyldighedArr		
			FROM
			(
					SELECT
					a.interessefaellesskab_id,
					a.interessefaellesskab_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.interessefaellesskabsnavn,
					 		b.interessefaellesskabstype,
					 		b.integrationsdata,
					   		b.virkning
                            
							)::InteressefaellesskabEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.interessefaellesskabsnavn,b.interessefaellesskabstype,b.integrationsdata,b.virkning
                        
					)) InteressefaellesskabAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id interessefaellesskab_id,
					b.id interessefaellesskab_registrering_id,
					b.registrering			
					FROM		interessefaellesskab a
					JOIN 		interessefaellesskab_registrering b 	ON b.interessefaellesskab_id=a.id
					WHERE a.id = ANY (interessefaellesskab_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN interessefaellesskab_attr_egenskaber as b ON b.interessefaellesskab_registrering_id=a.interessefaellesskab_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.interessefaellesskab_id,
					a.interessefaellesskab_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN interessefaellesskab_tils_gyldighed as b ON b.interessefaellesskab_registrering_id=a.interessefaellesskab_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.interessefaellesskab_id,
			a.interessefaellesskab_registrering_id,
			a.registrering,
			a.InteressefaellesskabAttrEgenskaberArr
	) as a
	LEFT JOIN interessefaellesskab_relation b ON b.interessefaellesskab_registrering_id=a.interessefaellesskab_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.interessefaellesskab_id,
	a.interessefaellesskab_registrering_id,
	a.registrering,
	a.InteressefaellesskabAttrEgenskaberArr,
	a.InteressefaellesskabTilsGyldighedArr
) as a

WHERE a.interessefaellesskab_id IS NOT NULL
GROUP BY 
a.interessefaellesskab_id
order by a.interessefaellesskab_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_interessefaellesskab(
    interessefaellesskab_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      InteressefaellesskabRegistreringType[]=null
) RETURNS InteressefaellesskabType AS $$
DECLARE
	resArr InteressefaellesskabType[];
BEGIN
    resArr := as_list_interessefaellesskab(ARRAY[interessefaellesskab_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_interessefaellesskab(
    firstResult int,--TOOD ??
    interessefaellesskab_uuid uuid,
    registreringObj   InteressefaellesskabRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr InteressefaellesskabRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    interessefaellesskab_candidates uuid[];
    interessefaellesskab_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj InteressefaellesskabEgenskaberAttrType;

    
    tilsGyldighedTypeObj InteressefaellesskabGyldighedTilsType;

    relationTypeObj InteressefaellesskabRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

interessefaellesskab_candidates_is_initialized := false;

IF interessefaellesskab_uuid is not NULL THEN
    interessefaellesskab_candidates:= ARRAY[interessefaellesskab_uuid];
    interessefaellesskab_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        interessefaellesskab_candidates:=array(
                SELECT DISTINCT
                b.interessefaellesskab_id
                FROM
                interessefaellesskab a
                JOIN interessefaellesskab_registrering b on b.interessefaellesskab_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 1:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 1:%',interessefaellesskab_candidates;
--/****************************//


--RAISE NOTICE 'interessefaellesskab_candidates_is_initialized step 2:%',interessefaellesskab_candidates_is_initialized;
--RAISE NOTICE 'interessefaellesskab_candidates step 2:%',interessefaellesskab_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_interessefaellesskab: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(interessefaellesskab_candidates,1),0)>0 OR NOT interessefaellesskab_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            interessefaellesskab_candidates:=array(
            SELECT DISTINCT
            b.interessefaellesskab_id
            FROM  interessefaellesskab_attr_egenskaber a
            JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.interessefaellesskabsnavn IS NULL
                    OR
                    a.interessefaellesskabsnavn ILIKE attrEgenskaberTypeObj.interessefaellesskabsnavn --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.interessefaellesskabstype IS NULL
                    OR
                    a.interessefaellesskabstype ILIKE attrEgenskaberTypeObj.interessefaellesskabstype --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.integrationsdata IS NULL
                    OR
                    a.integrationsdata ILIKE attrEgenskaberTypeObj.integrationsdata --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )

            );


            interessefaellesskab_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 3:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 3:%',interessefaellesskab_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        interessefaellesskab_candidates:=array(

            SELECT DISTINCT
            b.interessefaellesskab_id
            
            FROM  interessefaellesskab_attr_egenskaber a
            JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.interessefaellesskabsnavn ILIKE anyAttrValue OR
                        a.interessefaellesskabstype ILIKE anyAttrValue OR
                        a.integrationsdata ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )


        );

    interessefaellesskab_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
    --RAISE DEBUG 'as_search_interessefaellesskab: skipping filtration on tilsGyldighed';
ELSE
    IF (coalesce(array_length(interessefaellesskab_candidates,1),0)>0 OR interessefaellesskab_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
        LOOP
            interessefaellesskab_candidates:=array(
            SELECT DISTINCT
            b.interessefaellesskab_id
            FROM  interessefaellesskab_tils_gyldighed a
            JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id
            WHERE
                (
                    tilsGyldighedTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsGyldighedTypeObj.gyldighed IS NULL
                    OR
                    tilsGyldighedTypeObj.gyldighed = a.gyldighed
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )

    );


            interessefaellesskab_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer InteressefaellesskabRelationType[]
*/


--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 4:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 4:%',interessefaellesskab_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_interessefaellesskab: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(interessefaellesskab_candidates,1),0)>0 OR NOT interessefaellesskab_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            interessefaellesskab_candidates:=array(
            SELECT DISTINCT
            b.interessefaellesskab_id
            FROM  interessefaellesskab_relation a
            JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )

    );

            interessefaellesskab_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        interessefaellesskab_candidates:=array(
            SELECT DISTINCT
            b.interessefaellesskab_id
            
            FROM  interessefaellesskab_relation a
            JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )


            );

    interessefaellesskab_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        interessefaellesskab_candidates:=array(
            SELECT DISTINCT
            b.interessefaellesskab_id
            
            FROM  interessefaellesskab_relation a
            JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )


            );

    interessefaellesskab_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 




--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 5:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 5:%',interessefaellesskab_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT interessefaellesskab_candidates_is_initialized THEN
        interessefaellesskab_candidates:=array(
        SELECT DISTINCT
            interessefaellesskab_id
        FROM
            interessefaellesskab_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT interessefaellesskab_candidates_is_initialized) OR b.interessefaellesskab_id = ANY (interessefaellesskab_candidates) )

        )
        ;

        interessefaellesskab_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT interessefaellesskab_candidates_is_initialized THEN
    --No filters applied!
    interessefaellesskab_candidates:=array(
        SELECT DISTINCT id FROM interessefaellesskab a
    );
ELSE
    interessefaellesskab_candidates:=array(
        SELECT DISTINCT id FROM unnest(interessefaellesskab_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 6:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 6:%',interessefaellesskab_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_interessefaellesskab(interessefaellesskab_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_interessefaellesskab(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_InteressefaellesskabRegistreringType_to_json(InteressefaellesskabRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END interessefaellesskabegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END interessefaellesskabgyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::InteressefaellesskabRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (InteressefaellesskabRegistreringType as json);
create cast (InteressefaellesskabRegistreringType as json) with function actual_state._cast_InteressefaellesskabRegistreringType_to_json(InteressefaellesskabRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_interessefaellesskabType_to_json(InteressefaellesskabType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg InteressefaellesskabRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (InteressefaellesskabType as json);
create cast (InteressefaellesskabType as json) with function actual_state._cast_interessefaellesskabType_to_json(InteressefaellesskabType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_interessefaellesskab(
    interessefaellesskab_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    InteressefaellesskabRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    interessefaellesskab_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    interessefaellesskab_sorted_uuid:=array(
          SELECT b.interessefaellesskab_id
            FROM interessefaellesskab_registrering b
            JOIN interessefaellesskab_attr_egenskaber a ON a.interessefaellesskab_registrering_id=b.id
           WHERE b.interessefaellesskab_id = ANY (interessefaellesskab_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.interessefaellesskab_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.interessefaellesskab_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN interessefaellesskab_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_interessefaellesskab(
	interessefaellesskab_uuids uuid[],
	registreringObjArr InteressefaellesskabRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	interessefaellesskab_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	interessefaellesskab_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj InteressefaellesskabEgenskaberAttrType;
	
  	tilsGyldighedTypeObj InteressefaellesskabGyldighedTilsType;
	relationTypeObj InteressefaellesskabRelationType;
	registreringObj InteressefaellesskabRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN interessefaellesskab_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF interessefaellesskab_uuids IS NULL OR coalesce(array_length(interessefaellesskab_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

interessefaellesskab_candidates:= interessefaellesskab_uuids;



--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 1:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 1:%',interessefaellesskab_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_interessefaellesskab: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(interessefaellesskab_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			interessefaellesskab_candidates:=array(
			SELECT DISTINCT
			b.interessefaellesskab_id 
			FROM  interessefaellesskab_attr_egenskaber a 
			JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.interessefaellesskabsnavn IS NULL
					OR 
					a.interessefaellesskabsnavn = attrEgenskaberTypeObj.interessefaellesskabsnavn 
				)
				AND
				(
					attrEgenskaberTypeObj.interessefaellesskabstype IS NULL
					OR 
					a.interessefaellesskabstype = attrEgenskaberTypeObj.interessefaellesskabstype 
				)
				AND
				(
					attrEgenskaberTypeObj.integrationsdata IS NULL
					OR 
					a.integrationsdata = attrEgenskaberTypeObj.integrationsdata 
				)
				AND b.interessefaellesskab_id = ANY (interessefaellesskab_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 3:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 3:%',interessefaellesskab_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_interessefaellesskab: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(interessefaellesskab_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			interessefaellesskab_candidates:=array(
			SELECT DISTINCT
			b.interessefaellesskab_id 
			FROM  interessefaellesskab_tils_gyldighed a
			JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.interessefaellesskab_id = ANY (interessefaellesskab_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer InteressefaellesskabRelationType[]
*/


--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 4:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 4:%',interessefaellesskab_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_interessefaellesskab: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(interessefaellesskab_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			interessefaellesskab_candidates:=array(
			SELECT DISTINCT
			b.interessefaellesskab_id 
			FROM  interessefaellesskab_relation a
			JOIN interessefaellesskab_registrering b on a.interessefaellesskab_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.interessefaellesskab_id = ANY (interessefaellesskab_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'interessefaellesskab_candidates_is_initialized step 5:%',interessefaellesskab_candidates_is_initialized;
--RAISE DEBUG 'interessefaellesskab_candidates step 5:%',interessefaellesskab_candidates;

interessefaellesskab_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (interessefaellesskab_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (interessefaellesskab_candidates) b(id)
);

--optimization 
IF coalesce(array_length(interessefaellesskab_passed_auth_filter,1),0)=coalesce(array_length(interessefaellesskab_uuids,1),0) AND interessefaellesskab_passed_auth_filter @>interessefaellesskab_uuids THEN
	RETURN interessefaellesskab_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN interessefaellesskab_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE ItsystemGyldighedTils AS ENUM ('Aktiv','Inaktiv',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE ItsystemGyldighedTilsType AS (
    virkning Virkning,
    gyldighed ItsystemGyldighedTils
)
;



CREATE TYPE ItsystemEgenskaberAttrType AS (
brugervendtnoegle text,
itsystemnavn text,
itsystemtype text,
konfigurationreference text[],
integrationsdata text,

 virkning Virkning
);




CREATE TYPE ItsystemRelationKode AS ENUM  ('tilhoerer','tilknyttedeorganisationer','tilknyttedeenheder','tilknyttedefunktioner','tilknyttedebrugere','tilknyttedeinteressefaellesskaber','tilknyttedeitsystemer','tilknyttedepersoner','systemtyper','opgaver','adresser');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_itsystem_relation_kode_to_txt is invoked.



CREATE TYPE ItsystemRelationType AS (
  relType ItsystemRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text
)
;



CREATE TYPE ItsystemRegistreringType AS
(
registrering RegistreringBase,
tilsGyldighed ItsystemGyldighedTilsType[],
attrEgenskaber ItsystemEgenskaberAttrType[],
relationer ItsystemRelationType[]
);

CREATE TYPE ItsystemType AS
(
  id uuid,
  registrering ItsystemRegistreringType[]
);  





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_itsystem_relation_kode_to_txt(
    ItsystemRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE itsystem (
    id uuid NOT NULL,
    CONSTRAINT itsystem_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE itsystem
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE itsystem_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE itsystem_registrering_id_seq
    OWNER TO mox;


CREATE TABLE itsystem_registrering (
   id bigint NOT NULL DEFAULT nextval('itsystem_registrering_id_seq'::regclass),
   itsystem_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT itsystem_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT itsystem_registrering_itsystem_fkey FOREIGN KEY (itsystem_id)
       REFERENCES itsystem (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT itsystem_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(itsystem_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE itsystem_registrering
  OWNER TO mox;


CREATE INDEX itsystem_registrering_idx_livscykluskode
    ON itsystem_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX itsystem_registrering_idx_brugerref
    ON itsystem_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX itsystem_registrering_idx_note
    ON itsystem_registrering
    USING btree
    (((registrering).note));


CREATE INDEX itsystem_registrering_pat_note
    ON itsystem_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX itsystem_id_idx
    ON itsystem_registrering (itsystem_id);


CREATE TRIGGER notify_itsystem
    AFTER INSERT OR UPDATE OR DELETE ON itsystem_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE itsystem_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE itsystem_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE itsystem_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('itsystem_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        itsystemnavn text  NULL,
        itsystemtype text  NULL,
        konfigurationreference text[]  NULL,
        integrationsdata text  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    itsystem_registrering_id bigint NOT NULL,
    CONSTRAINT itsystem_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT itsystem_attr_egenskaber_forkey_itsystemregistrering FOREIGN KEY (itsystem_registrering_id) REFERENCES itsystem_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT itsystem_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (itsystem_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE itsystem_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX itsystem_attr_egenskaber_pat_brugervendtnoegle
            ON itsystem_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX itsystem_attr_egenskaber_idx_brugervendtnoegle
            ON itsystem_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX itsystem_attr_egenskaber_pat_itsystemnavn
            ON itsystem_attr_egenskaber
            USING gin
            (itsystemnavn gin_trgm_ops);

        CREATE INDEX itsystem_attr_egenskaber_idx_itsystemnavn
            ON itsystem_attr_egenskaber
            USING btree
            (itsystemnavn); 
 
     
        CREATE INDEX itsystem_attr_egenskaber_pat_itsystemtype
            ON itsystem_attr_egenskaber
            USING gin
            (itsystemtype gin_trgm_ops);

        CREATE INDEX itsystem_attr_egenskaber_idx_itsystemtype
            ON itsystem_attr_egenskaber
            USING btree
            (itsystemtype); 
 
    
        
            CREATE INDEX itsystem_attr_egenskaber_pat_konfigurationreference
            ON itsystem_attr_egenskaber
            USING gin
            (konfigurationreference _text_ops);
         
     
 
     
        CREATE INDEX itsystem_attr_egenskaber_pat_integrationsdata
            ON itsystem_attr_egenskaber
            USING gin
            (integrationsdata gin_trgm_ops);

        CREATE INDEX itsystem_attr_egenskaber_idx_integrationsdata
            ON itsystem_attr_egenskaber
            USING btree
            (integrationsdata); 



CREATE INDEX itsystem_attr_egenskaber_idx_virkning_aktoerref
    ON itsystem_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX itsystem_attr_egenskaber_idx_virkning_aktoertypekode
    ON itsystem_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX itsystem_attr_egenskaber_idx_virkning_notetekst
    ON itsystem_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX itsystem_attr_egenskaber_pat_virkning_notetekst
    ON itsystem_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE itsystem_tils_gyldighed_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE itsystem_tils_gyldighed_id_seq
    OWNER TO mox;


CREATE TABLE itsystem_tils_gyldighed (
    id bigint NOT NULL DEFAULT nextval('itsystem_tils_gyldighed_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    gyldighed ItsystemGyldighedTils NOT NULL, 
    itsystem_registrering_id bigint not null,
    CONSTRAINT itsystem_tils_gyldighed_pkey PRIMARY KEY (id),
    CONSTRAINT itsystem_tils_gyldighed_forkey_itsystemregistrering FOREIGN KEY (itsystem_registrering_id) REFERENCES itsystem_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT itsystem_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (itsystem_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE itsystem_tils_gyldighed
    OWNER TO mox;


CREATE INDEX itsystem_tils_gyldighed_idx_gyldighed
    ON itsystem_tils_gyldighed
    USING btree
    (gyldighed);
  
CREATE INDEX itsystem_tils_gyldighed_idx_virkning_aktoerref
    ON itsystem_tils_gyldighed
    USING btree
    (((virkning).aktoerref));

CREATE INDEX itsystem_tils_gyldighed_idx_virkning_aktoertypekode
    ON itsystem_tils_gyldighed
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX itsystem_tils_gyldighed_idx_virkning_notetekst
    ON itsystem_tils_gyldighed
    USING btree
    (((virkning).notetekst));

CREATE INDEX itsystem_tils_gyldighed_pat_virkning_notetekst
    ON itsystem_tils_gyldighed
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE itsystem_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE itsystem_relation_id_seq
    OWNER TO mox;


CREATE TABLE itsystem_relation (
    id bigint NOT NULL DEFAULT nextval('itsystem_relation_id_seq'::regclass),
    itsystem_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type ItsystemRelationKode not null,
    objekt_type text null,

    

    CONSTRAINT itsystem_relation_forkey_itsystemregistrering FOREIGN KEY (itsystem_registrering_id) REFERENCES itsystem_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT itsystem_relation_pkey PRIMARY KEY (id),
    CONSTRAINT itsystem_relation_no_virkning_overlap EXCLUDE USING gist (itsystem_registrering_id WITH =, _as_convert_itsystem_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('tilknyttedeorganisationer'::ItsystemRelationKode ) AND rel_type<>('tilknyttedeenheder'::ItsystemRelationKode ) AND rel_type<>('tilknyttedefunktioner'::ItsystemRelationKode ) AND rel_type<>('tilknyttedebrugere'::ItsystemRelationKode ) AND rel_type<>('tilknyttedeinteressefaellesskaber'::ItsystemRelationKode ) AND rel_type<>('tilknyttedeitsystemer'::ItsystemRelationKode ) AND rel_type<>('tilknyttedepersoner'::ItsystemRelationKode ) AND rel_type<>('systemtyper'::ItsystemRelationKode ) AND rel_type<>('opgaver'::ItsystemRelationKode ) AND rel_type<>('adresser'::ItsystemRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT itsystem_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE itsystem_relation
  OWNER TO mox;





CREATE INDEX itsystem_relation_idx_rel_maal_obj_uuid
    ON itsystem_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX itsystem_relation_idx_rel_maal_obj_urn
    ON itsystem_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX itsystem_relation_idx_rel_maal_uuid
    ON itsystem_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX itsystem_relation_idx_rel_maal_uuid_isolated
    ON itsystem_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX itsystem_relation_idx_rel_maal_urn_isolated
    ON itsystem_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX itsystem_relation_idx_rel_maal_urn
    ON itsystem_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX itsystem_relation_idx_virkning_aktoerref
    ON itsystem_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX itsystem_relation_idx_virkning_aktoertypekode
    ON itsystem_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX itsystem_relation_idx_virkning_notetekst
    ON itsystem_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX itsystem_relation_pat_virkning_notetekst
    ON itsystem_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr ItsystemGyldighedTilsType[])
  RETURNS ItsystemGyldighedTilsType[] AS
  $$
  DECLARE result ItsystemGyldighedTilsType[];
  DECLARE element ItsystemGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr ItsystemEgenskaberAttrType[])
  RETURNS ItsystemEgenskaberAttrType[] AS
  $$
  DECLARE result ItsystemEgenskaberAttrType[]; 
   DECLARE element ItsystemEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.itsystemnavn IS NULL AND element.itsystemtype IS NULL AND element.konfigurationreference IS NULL AND element.integrationsdata IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr ItsystemRelationType[])
RETURNS ItsystemRelationType[] AS
$$
 DECLARE result ItsystemRelationType[];
 DECLARE element ItsystemRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_itsystem_registrering(
    itsystem_registrering
) RETURNS itsystem_registrering AS $BODY$
  SELECT * FROM itsystem_registrering as a WHERE
    itsystem_id = $1.itsystem_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_itsystem_registrering(
    itsystem_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS itsystem_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    itsystem_registrering_id bigint;
    itsystem_registrering    itsystem_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE itsystem_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE itsystem_id = itsystem_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating itsystem with uuid [%], Invalid [livscyklus] transition to [%]',itsystem_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new itsystem registrering

    itsystem_registrering_id := nextval('itsystem_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    itsystem_registrering := ROW(
        itsystem_registrering_id,
        itsystem_uuid,
        registreringObj
    )::itsystem_registrering;

    INSERT INTO itsystem_registrering SELECT itsystem_registrering.*;

    RETURN itsystem_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of ItsystemAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_itsystem(
    itsystem_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber ItsystemEgenskaberAttrType[],
    

    
    tilsGyldighed ItsystemGyldighedTilsType[],
    

    relationer ItsystemRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      ItsystemRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_itsystem          ItsystemType;
    read_prev_itsystem         ItsystemType;
    read_new_itsystem_reg      ItsystemRegistreringType;
    read_prev_itsystem_reg     ItsystemRegistreringType;
    new_itsystem_registrering  itsystem_registrering;
    prev_itsystem_registrering itsystem_registrering;
    itsystem_relation_navn     ItsystemRelationKode;

    
    attrEgenskaberObj ItsystemEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from itsystem a join itsystem_registrering b ON b.itsystem_id=a.id WHERE a.id=itsystem_uuid) THEN
        RAISE EXCEPTION 'Unable to update itsystem with uuid [%], being unable to find any previous registrations.',itsystem_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM itsystem a WHERE a.id=itsystem_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_itsystem(array[itsystem_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[itsystem_uuid]) THEN
      RAISE EXCEPTION 'Unable to update itsystem with uuid [%]. Object does not met stipulated criteria:%', itsystem_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_itsystem_registrering := _as_create_itsystem_registrering(itsystem_uuid, livscykluskode, brugerref, note);
    prev_itsystem_registrering := _as_get_prev_itsystem_registrering(new_itsystem_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_itsystem_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update itsystem with uuid [%], as the itsystem seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', itsystem_uuid, lostUpdatePreventionTZ, LOWER((prev_itsystem_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    

    INSERT INTO itsystem_relation (itsystem_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
    SELECT
        new_itsystem_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType 
        FROM
            unnest(relationer) AS a ;

    


    -- Ad 2)
    -- 0..1 relations

    
    
    FOREACH itsystem_relation_navn IN ARRAY ARRAY['tilhoerer'::ItsystemRelationKode  ]::ItsystemRelationKode[]  LOOP
        INSERT INTO itsystem_relation (itsystem_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
        SELECT
            new_itsystem_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM itsystem_relation b
                 WHERE b.itsystem_registrering_id = new_itsystem_registrering.id AND b.rel_type = itsystem_relation_navn) d
            JOIN itsystem_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.itsystem_registrering_id = prev_itsystem_registrering.id AND a.rel_type = itsystem_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
    FOREACH itsystem_relation_navn IN ARRAY ARRAY['tilknyttedeorganisationer'::ItsystemRelationKode, 'tilknyttedeenheder'::ItsystemRelationKode, 'tilknyttedefunktioner'::ItsystemRelationKode, 'tilknyttedebrugere'::ItsystemRelationKode, 'tilknyttedeinteressefaellesskaber'::ItsystemRelationKode, 'tilknyttedeitsystemer'::ItsystemRelationKode, 'tilknyttedepersoner'::ItsystemRelationKode, 'systemtyper'::ItsystemRelationKode, 'opgaver'::ItsystemRelationKode, 'adresser'::ItsystemRelationKode]::ItsystemRelationKode[] LOOP
        IF NOT EXISTS (
                    SELECT 1
                      FROM itsystem_relation
                     WHERE itsystem_registrering_id = new_itsystem_registrering.id AND rel_type = itsystem_relation_navn) THEN
                    
                    INSERT INTO itsystem_relation (itsystem_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
                    SELECT
                        new_itsystem_registrering.id,  virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type
        FROM itsystem_relation
        WHERE
            itsystem_registrering_id = prev_itsystem_registrering.id AND rel_type = itsystem_relation_navn ;

    
        END IF;
    END LOOP;
    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- itsystem_tils_gyldighed

        -- Ad 1)
        INSERT INTO itsystem_tils_gyldighed(virkning, gyldighed, itsystem_registrering_id)
             SELECT a.virkning, a.gyldighed, new_itsystem_registrering.id
               FROM unnest(tilsGyldighed) AS a;

        -- Ad 2
        INSERT INTO itsystem_tils_gyldighed(virkning, gyldighed, itsystem_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.gyldighed,
            new_itsystem_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- itsystem_tils_gyldighed of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- itsystem_tils_gyldighed of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM itsystem_tils_gyldighed b
             WHERE b.itsystem_registrering_id = new_itsystem_registrering.id) d
              JOIN itsystem_tils_gyldighed a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.itsystem_registrering_id = prev_itsystem_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- itsystem_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrItsystemObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.itsystemnavn,a.itsystemtype,a.konfigurationreference,a.integrationsdata,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update itsystem with uuid [%], as the itsystem have overlapping virknings in the given egenskaber array :%', itsystem_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).itsystemnavn IS NULL  OR  (attrEgenskaberObj).itsystemtype IS NULL  OR  (attrEgenskaberObj).konfigurationreference IS NULL  OR  (attrEgenskaberObj).integrationsdata IS NULL  THEN
            
            INSERT INTO itsystem_attr_egenskaber ( brugervendtnoegle,itsystemnavn,itsystemtype,konfigurationreference,integrationsdata, virkning, itsystem_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.itsystemnavn, a.itsystemnavn),
                    
                        
                        
                            coalesce(attrEgenskaberObj.itsystemtype, a.itsystemtype),
                    
                        
                        
                            coalesce(attrEgenskaberObj.konfigurationreference, a.konfigurationreference),
                    
                        
                        
                            coalesce(attrEgenskaberObj.integrationsdata, a.integrationsdata),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_itsystem_registrering.id
                        FROM itsystem_attr_egenskaber a
                    WHERE
                        a.itsystem_registrering_id = prev_itsystem_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO itsystem_attr_egenskaber ( brugervendtnoegle,itsystemnavn,itsystemtype,konfigurationreference,integrationsdata, virkning, itsystem_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.itsystemnavn,
                    
                     attrEgenskaberObj.itsystemtype,
                    
                     attrEgenskaberObj.konfigurationreference,
                    
                     attrEgenskaberObj.integrationsdata,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_itsystem_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the itsystem_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM itsystem_attr_egenskaber b
                    WHERE b.itsystem_registrering_id = new_itsystem_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO itsystem_attr_egenskaber ( brugervendtnoegle,itsystemnavn,itsystemtype,konfigurationreference,integrationsdata, virkning, itsystem_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.itsystemnavn,  attrEgenskaberObj.itsystemtype,  attrEgenskaberObj.konfigurationreference,  attrEgenskaberObj.integrationsdata, attrEgenskaberObj.virkning, new_itsystem_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO itsystem_attr_egenskaber ( brugervendtnoegle,itsystemnavn,itsystemtype,konfigurationreference,integrationsdata, virkning, itsystem_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.itsystemnavn,
        
            a.itsystemtype,
        
            a.konfigurationreference,
        
            a.integrationsdata,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_itsystem_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- itsystem_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- itsystem_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                itsystem_attr_egenskaber b
            WHERE
                b.itsystem_registrering_id = new_itsystem_registrering.id) d
            JOIN itsystem_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.itsystem_registrering_id = prev_itsystem_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_itsystem := as_read_itsystem(itsystem_uuid, (new_itsystem_registrering.registrering).timeperiod, null);
    read_prev_itsystem := as_read_itsystem(itsystem_uuid, (prev_itsystem_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_itsystem.registrering[1].registrering).TimePeriod) = lower((new_itsystem_registrering.registrering).TimePeriod) and lower((read_prev_itsystem.registrering[1].registrering).TimePeriod)=lower((prev_itsystem_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating itsystem with id [%]: The ordering of as_list_itsystem should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', itsystem_uuid, to_json(new_itsystem_registrering), to_json(read_new_itsystem.registrering[1].registrering), to_json(prev_itsystem_registrering), to_json(prev_new_itsystem.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_itsystem_reg := ROW(
        ROW (null, (read_new_itsystem.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_itsystem.registrering[1]).tilsGyldighed ,
        
        (read_new_itsystem.registrering[1]).attrEgenskaber ,
        (read_new_itsystem.registrering[1]).relationer
    )::itsystemRegistreringType;

    read_prev_itsystem_reg := ROW(
        ROW(null, (read_prev_itsystem.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_itsystem.registrering[1]).tilsGyldighed ,
        
        (read_prev_itsystem.registrering[1]).attrEgenskaber ,
        (read_prev_itsystem.registrering[1]).relationer
    )::itsystemRegistreringType;


    IF read_prev_itsystem_reg = read_new_itsystem_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_itsystem_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_itsystem_reg);
      RAISE EXCEPTION 'Aborted updating itsystem with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', itsystem_uuid, to_json(read_new_itsystem_reg), to_json(read_prev_itsystem_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_itsystem_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_itsystem (
    itsystem_registrering ItsystemRegistreringType,
    itsystem_uuid uuid DEFAULT NULL, auth_criteria_arr
    ItsystemRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE itsystem_registrering_id bigint;

    
    itsystem_attr_egenskaber_obj itsystemEgenskaberAttrType;
    

    
    itsystem_tils_gyldighed_obj itsystemGyldighedTilsType;
    

    itsystem_relationer ItsystemRelationType;

    

    auth_filtered_uuids uuid[];

    

    does_exist boolean;
    new_itsystem_registrering itsystem_registrering;
BEGIN
    IF itsystem_uuid IS NULL THEN LOOP
        itsystem_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from itsystem WHERE id=itsystem_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from itsystem WHERE id=itsystem_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (itsystem_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (itsystem_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (itsystem_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_itsystem.',(itsystem_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO itsystem (ID) SELECT
        itsystem_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        itsystem_registrering_id:=nextval('itsystem_registrering_id_seq');

        INSERT INTO itsystem_registrering (id, itsystem_id,
            registrering) SELECT itsystem_registrering_id,
        itsystem_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (itsystem_registrering.registrering).livscykluskode,
        (itsystem_registrering.registrering).brugerref,
        (itsystem_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_itsystem_registrering :=
            _as_create_itsystem_registrering(itsystem_uuid,
                (itsystem_registrering.registrering).livscykluskode,
                (itsystem_registrering.registrering).brugerref,
                (itsystem_registrering.registrering).note);

            itsystem_registrering_id := new_itsystem_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(itsystem_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [itsystem]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF itsystem_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(itsystem_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH itsystem_attr_egenskaber_obj IN ARRAY itsystem_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO itsystem_attr_egenskaber (
      
      brugervendtnoegle,
      itsystemnavn,
      itsystemtype,
      konfigurationreference,
      integrationsdata,
      virkning,
      itsystem_registrering_id
    )
    SELECT
     
     itsystem_attr_egenskaber_obj.brugervendtnoegle,
      itsystem_attr_egenskaber_obj.itsystemnavn,
      itsystem_attr_egenskaber_obj.itsystemtype,
      itsystem_attr_egenskaber_obj.konfigurationreference,
      itsystem_attr_egenskaber_obj.integrationsdata,
      itsystem_attr_egenskaber_obj.virkning,
      itsystem_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(itsystem_registrering.tilsGyldighed, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [gyldighed] for itsystem. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF itsystem_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(itsystem_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH itsystem_tils_gyldighed_obj IN ARRAY itsystem_registrering.tilsGyldighed
  LOOP

    INSERT INTO itsystem_tils_gyldighed (
      virkning,
      gyldighed,
      itsystem_registrering_id
    )
    SELECT
      itsystem_tils_gyldighed_obj.virkning,
      itsystem_tils_gyldighed_obj.gyldighed,
      itsystem_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations



    INSERT INTO itsystem_relation (
      itsystem_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      itsystem_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(itsystem_registrering.relationer) a
  ;




/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_itsystem(array[itsystem_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[itsystem_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import itsystem with uuid [%]. Object does not met stipulated criteria:%',itsystem_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN itsystem_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_itsystem(itsystem_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr ItsystemRegistreringType[]=null
  )
  RETURNS ItsystemType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result ItsystemType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_itsystem(itsystem_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(itsystem_uuids,1),0) AND auth_filtered_uuids @>itsystem_uuids) THEN
  RAISE EXCEPTION 'Unable to list itsystem with uuids [%]. All objects do not fullfill the stipulated criteria:%',itsystem_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.itsystemObj) into result
FROM
(
SELECT
ROW(
	a.itsystem_id,
	array_agg(
		ROW (
			a.registrering,
			a.ItsystemTilsGyldighedArr,
			a.ItsystemAttrEgenskaberArr,
			a.ItsystemRelationArr
		)::ItsystemRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: ItsystemType  itsystemObj
FROM
(
	SELECT
	a.itsystem_id,
	a.itsystem_registrering_id,
	a.registrering,
	a.ItsystemAttrEgenskaberArr,
	a.ItsystemTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type
			):: ItsystemRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
        
	)) ItsystemRelationArr
	FROM
	(
			SELECT
			a.itsystem_id,
			a.itsystem_registrering_id,
			a.registrering,
			a.ItsystemAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::ItsystemGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) ItsystemTilsGyldighedArr		
			FROM
			(
					SELECT
					a.itsystem_id,
					a.itsystem_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.itsystemnavn,
					 		b.itsystemtype,
					 		b.konfigurationreference,
					 		b.integrationsdata,
					   		b.virkning
                            
							)::ItsystemEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.itsystemnavn,b.itsystemtype,b.konfigurationreference,b.integrationsdata,b.virkning
                        
					)) ItsystemAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id itsystem_id,
					b.id itsystem_registrering_id,
					b.registrering			
					FROM		itsystem a
					JOIN 		itsystem_registrering b 	ON b.itsystem_id=a.id
					WHERE a.id = ANY (itsystem_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN itsystem_attr_egenskaber as b ON b.itsystem_registrering_id=a.itsystem_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.itsystem_id,
					a.itsystem_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN itsystem_tils_gyldighed as b ON b.itsystem_registrering_id=a.itsystem_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.itsystem_id,
			a.itsystem_registrering_id,
			a.registrering,
			a.ItsystemAttrEgenskaberArr
	) as a
	LEFT JOIN itsystem_relation b ON b.itsystem_registrering_id=a.itsystem_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.itsystem_id,
	a.itsystem_registrering_id,
	a.registrering,
	a.ItsystemAttrEgenskaberArr,
	a.ItsystemTilsGyldighedArr
) as a

WHERE a.itsystem_id IS NOT NULL
GROUP BY 
a.itsystem_id
order by a.itsystem_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_itsystem(
    itsystem_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      ItsystemRegistreringType[]=null
) RETURNS ItsystemType AS $$
DECLARE
	resArr ItsystemType[];
BEGIN
    resArr := as_list_itsystem(ARRAY[itsystem_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_itsystem(
    firstResult int,--TOOD ??
    itsystem_uuid uuid,
    registreringObj   ItsystemRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr ItsystemRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    itsystem_candidates uuid[];
    itsystem_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj ItsystemEgenskaberAttrType;

    
    tilsGyldighedTypeObj ItsystemGyldighedTilsType;

    relationTypeObj ItsystemRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

itsystem_candidates_is_initialized := false;

IF itsystem_uuid is not NULL THEN
    itsystem_candidates:= ARRAY[itsystem_uuid];
    itsystem_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        itsystem_candidates:=array(
                SELECT DISTINCT
                b.itsystem_id
                FROM
                itsystem a
                JOIN itsystem_registrering b on b.itsystem_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'itsystem_candidates_is_initialized step 1:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 1:%',itsystem_candidates;
--/****************************//


--RAISE NOTICE 'itsystem_candidates_is_initialized step 2:%',itsystem_candidates_is_initialized;
--RAISE NOTICE 'itsystem_candidates step 2:%',itsystem_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_itsystem: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(itsystem_candidates,1),0)>0 OR NOT itsystem_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            itsystem_candidates:=array(
            SELECT DISTINCT
            b.itsystem_id
            FROM  itsystem_attr_egenskaber a
            JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.itsystemnavn IS NULL
                    OR
                    a.itsystemnavn ILIKE attrEgenskaberTypeObj.itsystemnavn --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.itsystemtype IS NULL
                    OR
                    a.itsystemtype ILIKE attrEgenskaberTypeObj.itsystemtype --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.konfigurationreference IS NULL
                    OR
                    _as_search_match_array(attrEgenskaberTypeObj.konfigurationreference,a.konfigurationreference)
                )
                AND
                (
                    attrEgenskaberTypeObj.integrationsdata IS NULL
                    OR
                    a.integrationsdata ILIKE attrEgenskaberTypeObj.integrationsdata --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )

            );


            itsystem_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'itsystem_candidates_is_initialized step 3:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 3:%',itsystem_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        itsystem_candidates:=array(

            SELECT DISTINCT
            b.itsystem_id
            
            FROM  itsystem_attr_egenskaber a
            JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.itsystemnavn ILIKE anyAttrValue OR
                        a.itsystemtype ILIKE anyAttrValue OR
                              _as_search_ilike_array(anyAttrValue,a.konfigurationreference) OR
                        a.integrationsdata ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )


        );

    itsystem_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
    --RAISE DEBUG 'as_search_itsystem: skipping filtration on tilsGyldighed';
ELSE
    IF (coalesce(array_length(itsystem_candidates,1),0)>0 OR itsystem_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
        LOOP
            itsystem_candidates:=array(
            SELECT DISTINCT
            b.itsystem_id
            FROM  itsystem_tils_gyldighed a
            JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id
            WHERE
                (
                    tilsGyldighedTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsGyldighedTypeObj.gyldighed IS NULL
                    OR
                    tilsGyldighedTypeObj.gyldighed = a.gyldighed
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )

    );


            itsystem_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer ItsystemRelationType[]
*/


--RAISE DEBUG 'itsystem_candidates_is_initialized step 4:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 4:%',itsystem_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_itsystem: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(itsystem_candidates,1),0)>0 OR NOT itsystem_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            itsystem_candidates:=array(
            SELECT DISTINCT
            b.itsystem_id
            FROM  itsystem_relation a
            JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )

    );

            itsystem_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        itsystem_candidates:=array(
            SELECT DISTINCT
            b.itsystem_id
            
            FROM  itsystem_relation a
            JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )


            );

    itsystem_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        itsystem_candidates:=array(
            SELECT DISTINCT
            b.itsystem_id
            
            FROM  itsystem_relation a
            JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )


            );

    itsystem_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 




--RAISE DEBUG 'itsystem_candidates_is_initialized step 5:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 5:%',itsystem_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT itsystem_candidates_is_initialized THEN
        itsystem_candidates:=array(
        SELECT DISTINCT
            itsystem_id
        FROM
            itsystem_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT itsystem_candidates_is_initialized) OR b.itsystem_id = ANY (itsystem_candidates) )

        )
        ;

        itsystem_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT itsystem_candidates_is_initialized THEN
    --No filters applied!
    itsystem_candidates:=array(
        SELECT DISTINCT id FROM itsystem a
    );
ELSE
    itsystem_candidates:=array(
        SELECT DISTINCT id FROM unnest(itsystem_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'itsystem_candidates_is_initialized step 6:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 6:%',itsystem_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_itsystem(itsystem_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_itsystem(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_ItsystemRegistreringType_to_json(ItsystemRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END itsystemegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END itsystemgyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::ItsystemRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (ItsystemRegistreringType as json);
create cast (ItsystemRegistreringType as json) with function actual_state._cast_ItsystemRegistreringType_to_json(ItsystemRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_itsystemType_to_json(ItsystemType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg ItsystemRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (ItsystemType as json);
create cast (ItsystemType as json) with function actual_state._cast_itsystemType_to_json(ItsystemType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_itsystem(
    itsystem_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    ItsystemRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    itsystem_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    itsystem_sorted_uuid:=array(
          SELECT b.itsystem_id
            FROM itsystem_registrering b
            JOIN itsystem_attr_egenskaber a ON a.itsystem_registrering_id=b.id
           WHERE b.itsystem_id = ANY (itsystem_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.itsystem_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.itsystem_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN itsystem_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_itsystem(
	itsystem_uuids uuid[],
	registreringObjArr ItsystemRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	itsystem_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	itsystem_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj ItsystemEgenskaberAttrType;
	
  	tilsGyldighedTypeObj ItsystemGyldighedTilsType;
	relationTypeObj ItsystemRelationType;
	registreringObj ItsystemRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN itsystem_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF itsystem_uuids IS NULL OR coalesce(array_length(itsystem_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

itsystem_candidates:= itsystem_uuids;



--RAISE DEBUG 'itsystem_candidates_is_initialized step 1:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 1:%',itsystem_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_itsystem: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(itsystem_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			itsystem_candidates:=array(
			SELECT DISTINCT
			b.itsystem_id 
			FROM  itsystem_attr_egenskaber a 
			JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.itsystemnavn IS NULL
					OR 
					a.itsystemnavn = attrEgenskaberTypeObj.itsystemnavn 
				)
				AND
				(
					attrEgenskaberTypeObj.itsystemtype IS NULL
					OR 
					a.itsystemtype = attrEgenskaberTypeObj.itsystemtype 
				)
				AND
				(
					attrEgenskaberTypeObj.konfigurationreference IS NULL
					OR
						((coalesce(array_length(attrEgenskaberTypeObj.konfigurationreference,1),0)=0 AND coalesce(array_length(a.konfigurationreference,1),0)=0 ) OR (attrEgenskaberTypeObj.konfigurationreference @> a.konfigurationreference AND a.konfigurationreference @>attrEgenskaberTypeObj.konfigurationreference  )) 
				)
				AND
				(
					attrEgenskaberTypeObj.integrationsdata IS NULL
					OR 
					a.integrationsdata = attrEgenskaberTypeObj.integrationsdata 
				)
				AND b.itsystem_id = ANY (itsystem_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'itsystem_candidates_is_initialized step 3:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 3:%',itsystem_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_itsystem: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(itsystem_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			itsystem_candidates:=array(
			SELECT DISTINCT
			b.itsystem_id 
			FROM  itsystem_tils_gyldighed a
			JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.itsystem_id = ANY (itsystem_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer ItsystemRelationType[]
*/


--RAISE DEBUG 'itsystem_candidates_is_initialized step 4:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 4:%',itsystem_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_itsystem: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(itsystem_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			itsystem_candidates:=array(
			SELECT DISTINCT
			b.itsystem_id 
			FROM  itsystem_relation a
			JOIN itsystem_registrering b on a.itsystem_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.itsystem_id = ANY (itsystem_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'itsystem_candidates_is_initialized step 5:%',itsystem_candidates_is_initialized;
--RAISE DEBUG 'itsystem_candidates step 5:%',itsystem_candidates;

itsystem_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (itsystem_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (itsystem_candidates) b(id)
);

--optimization 
IF coalesce(array_length(itsystem_passed_auth_filter,1),0)=coalesce(array_length(itsystem_uuids,1),0) AND itsystem_passed_auth_filter @>itsystem_uuids THEN
	RETURN itsystem_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN itsystem_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE KlassePubliceretTils AS ENUM ('Publiceret','IkkePubliceret',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE KlassePubliceretTilsType AS (
    virkning Virkning,
    publiceret KlassePubliceretTils
)
;



CREATE TYPE KlasseSoegeordType AS (
soegeordidentifikator text,
beskrivelse text,
soegeordskategori text
)
;

CREATE TYPE KlasseEgenskaberAttrType AS (
brugervendtnoegle text,
beskrivelse text,
eksempel text,
omfang text,
titel text,
retskilde text,
aendringsnotat text,
integrationsdata text,

soegeord KlasseSoegeordType[],

 virkning Virkning
);




CREATE TYPE KlasseRelationKode AS ENUM  ('ejer','ansvarlig','overordnetklasse','facet','redaktoerer','sideordnede','mapninger','tilfoejelser','erstatter','lovligekombinationer');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_klasse_relation_kode_to_txt is invoked.



CREATE TYPE KlasseRelationType AS (
  relType KlasseRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text
)
;



CREATE TYPE KlasseRegistreringType AS
(
registrering RegistreringBase,
tilsPubliceret KlassePubliceretTilsType[],
attrEgenskaber KlasseEgenskaberAttrType[],
relationer KlasseRelationType[]
);

CREATE TYPE KlasseType AS
(
  id uuid,
  registrering KlasseRegistreringType[]
);  





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_klasse_relation_kode_to_txt(
    KlasseRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE klasse (
    id uuid NOT NULL,
    CONSTRAINT klasse_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE klasse
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE klasse_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE klasse_registrering_id_seq
    OWNER TO mox;


CREATE TABLE klasse_registrering (
   id bigint NOT NULL DEFAULT nextval('klasse_registrering_id_seq'::regclass),
   klasse_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT klasse_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT klasse_registrering_klasse_fkey FOREIGN KEY (klasse_id)
       REFERENCES klasse (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT klasse_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(klasse_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE klasse_registrering
  OWNER TO mox;


CREATE INDEX klasse_registrering_idx_livscykluskode
    ON klasse_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX klasse_registrering_idx_brugerref
    ON klasse_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX klasse_registrering_idx_note
    ON klasse_registrering
    USING btree
    (((registrering).note));


CREATE INDEX klasse_registrering_pat_note
    ON klasse_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX klasse_id_idx
    ON klasse_registrering (klasse_id);


CREATE TRIGGER notify_klasse
    AFTER INSERT OR UPDATE OR DELETE ON klasse_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE klasse_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE klasse_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE klasse_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('klasse_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        beskrivelse text  NULL,
        eksempel text  NULL,
        omfang text  NULL,
        titel text NOT NULL,
        retskilde text  NULL,
        aendringsnotat text  NULL,
        integrationsdata text  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    klasse_registrering_id bigint NOT NULL,
    CONSTRAINT klasse_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT klasse_attr_egenskaber_forkey_klasseregistrering FOREIGN KEY (klasse_registrering_id) REFERENCES klasse_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT klasse_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (klasse_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE klasse_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX klasse_attr_egenskaber_pat_brugervendtnoegle
            ON klasse_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX klasse_attr_egenskaber_idx_brugervendtnoegle
            ON klasse_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX klasse_attr_egenskaber_pat_beskrivelse
            ON klasse_attr_egenskaber
            USING gin
            (beskrivelse gin_trgm_ops);

        CREATE INDEX klasse_attr_egenskaber_idx_beskrivelse
            ON klasse_attr_egenskaber
            USING btree
            (beskrivelse); 
 
     
        CREATE INDEX klasse_attr_egenskaber_pat_eksempel
            ON klasse_attr_egenskaber
            USING gin
            (eksempel gin_trgm_ops);

        CREATE INDEX klasse_attr_egenskaber_idx_eksempel
            ON klasse_attr_egenskaber
            USING btree
            (eksempel); 
 
     
        CREATE INDEX klasse_attr_egenskaber_pat_omfang
            ON klasse_attr_egenskaber
            USING gin
            (omfang gin_trgm_ops);

        CREATE INDEX klasse_attr_egenskaber_idx_omfang
            ON klasse_attr_egenskaber
            USING btree
            (omfang); 
 
     
        CREATE INDEX klasse_attr_egenskaber_pat_titel
            ON klasse_attr_egenskaber
            USING gin
            (titel gin_trgm_ops);

        CREATE INDEX klasse_attr_egenskaber_idx_titel
            ON klasse_attr_egenskaber
            USING btree
            (titel); 
 
     
        CREATE INDEX klasse_attr_egenskaber_pat_retskilde
            ON klasse_attr_egenskaber
            USING gin
            (retskilde gin_trgm_ops);

        CREATE INDEX klasse_attr_egenskaber_idx_retskilde
            ON klasse_attr_egenskaber
            USING btree
            (retskilde); 
 
     
        CREATE INDEX klasse_attr_egenskaber_pat_aendringsnotat
            ON klasse_attr_egenskaber
            USING gin
            (aendringsnotat gin_trgm_ops);

        CREATE INDEX klasse_attr_egenskaber_idx_aendringsnotat
            ON klasse_attr_egenskaber
            USING btree
            (aendringsnotat); 
 
     
        CREATE INDEX klasse_attr_egenskaber_pat_integrationsdata
            ON klasse_attr_egenskaber
            USING gin
            (integrationsdata gin_trgm_ops);

        CREATE INDEX klasse_attr_egenskaber_idx_integrationsdata
            ON klasse_attr_egenskaber
            USING btree
            (integrationsdata); 



CREATE INDEX klasse_attr_egenskaber_idx_virkning_aktoerref
    ON klasse_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX klasse_attr_egenskaber_idx_virkning_aktoertypekode
    ON klasse_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX klasse_attr_egenskaber_idx_virkning_notetekst
    ON klasse_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX klasse_attr_egenskaber_pat_virkning_notetekst
    ON klasse_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);





CREATE SEQUENCE klasse_attr_egenskaber_soegeord_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE klasse_attr_egenskaber_soegeord_id_seq
    OWNER TO mox;

CREATE TABLE klasse_attr_egenskaber_soegeord (
    id bigint NOT NULL DEFAULT nextval('klasse_attr_egenskaber_soegeord_id_seq'::regclass),
    soegeordidentifikator text null,
    beskrivelse text null,
    soegeordskategori text null,
    klasse_attr_egenskaber_id bigint not null,
    CONSTRAINT klasse_attr_egenskaber_soegeord_pkey PRIMARY KEY (id),
    CONSTRAINT klasse_attr_egenskaber_soegeord_forkey_klasse_attr_egenskaber FOREIGN KEY (klasse_attr_egenskaber_id) REFERENCES klasse_attr_egenskaber (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT klasse_attr_egenskaber_soegeord_chk_not_all_null CHECK (NOT (soegeordidentifikator IS NULL AND beskrivelse IS NULL AND soegeordskategori IS NULL))
)
WITH (
    OIDS=FALSE
);

ALTER TABLE klasse_attr_egenskaber_soegeord
    OWNER TO mox;


CREATE INDEX klasse_attr_egenskaber_soegeord_idx_soegeordidentifikator
    ON klasse_attr_egenskaber_soegeord
    USING btree
    (soegeordidentifikator);

CREATE INDEX klasse_attr_egenskaber_soegeord_pat_soegeordidentifikator
    ON klasse_attr_egenskaber_soegeord
    USING gin
    (soegeordidentifikator gin_trgm_ops);

CREATE INDEX klasse_attr_egenskaber_soegeord_idx_beskrivelse
    ON klasse_attr_egenskaber_soegeord
    USING btree
    (beskrivelse);

CREATE INDEX klasse_attr_egenskaber_soegeord_pat_beskrivelse
    ON klasse_attr_egenskaber_soegeord
    USING gin
    (beskrivelse gin_trgm_ops);

CREATE INDEX klasse_attr_egenskaber_soegeord_idx_soegeordskategori
    ON klasse_attr_egenskaber_soegeord
    USING btree
    (soegeordskategori);

CREATE INDEX klasse_attr_egenskaber_soegeord_pat_soegeordskategori
    ON klasse_attr_egenskaber_soegeord
    USING gin
    (soegeordskategori gin_trgm_ops);



/****************************************************************************/



CREATE SEQUENCE klasse_tils_publiceret_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE klasse_tils_publiceret_id_seq
    OWNER TO mox;


CREATE TABLE klasse_tils_publiceret (
    id bigint NOT NULL DEFAULT nextval('klasse_tils_publiceret_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    publiceret KlassePubliceretTils NOT NULL, 
    klasse_registrering_id bigint not null,
    CONSTRAINT klasse_tils_publiceret_pkey PRIMARY KEY (id),
    CONSTRAINT klasse_tils_publiceret_forkey_klasseregistrering FOREIGN KEY (klasse_registrering_id) REFERENCES klasse_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT klasse_tils_publiceret_exclude_virkning_overlap EXCLUDE USING gist (klasse_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE klasse_tils_publiceret
    OWNER TO mox;


CREATE INDEX klasse_tils_publiceret_idx_publiceret
    ON klasse_tils_publiceret
    USING btree
    (publiceret);
  
CREATE INDEX klasse_tils_publiceret_idx_virkning_aktoerref
    ON klasse_tils_publiceret
    USING btree
    (((virkning).aktoerref));

CREATE INDEX klasse_tils_publiceret_idx_virkning_aktoertypekode
    ON klasse_tils_publiceret
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX klasse_tils_publiceret_idx_virkning_notetekst
    ON klasse_tils_publiceret
    USING btree
    (((virkning).notetekst));

CREATE INDEX klasse_tils_publiceret_pat_virkning_notetekst
    ON klasse_tils_publiceret
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE klasse_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE klasse_relation_id_seq
    OWNER TO mox;


CREATE TABLE klasse_relation (
    id bigint NOT NULL DEFAULT nextval('klasse_relation_id_seq'::regclass),
    klasse_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type KlasseRelationKode not null,
    objekt_type text null,

    

    CONSTRAINT klasse_relation_forkey_klasseregistrering FOREIGN KEY (klasse_registrering_id) REFERENCES klasse_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT klasse_relation_pkey PRIMARY KEY (id),
    CONSTRAINT klasse_relation_no_virkning_overlap EXCLUDE USING gist (klasse_registrering_id WITH =, _as_convert_klasse_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('redaktoerer'::KlasseRelationKode ) AND rel_type<>('sideordnede'::KlasseRelationKode ) AND rel_type<>('mapninger'::KlasseRelationKode ) AND rel_type<>('tilfoejelser'::KlasseRelationKode ) AND rel_type<>('erstatter'::KlasseRelationKode ) AND rel_type<>('lovligekombinationer'::KlasseRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT klasse_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE klasse_relation
  OWNER TO mox;





CREATE INDEX klasse_relation_idx_rel_maal_obj_uuid
    ON klasse_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX klasse_relation_idx_rel_maal_obj_urn
    ON klasse_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX klasse_relation_idx_rel_maal_uuid
    ON klasse_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX klasse_relation_idx_rel_maal_uuid_isolated
    ON klasse_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX klasse_relation_idx_rel_maal_urn_isolated
    ON klasse_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX klasse_relation_idx_rel_maal_urn
    ON klasse_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX klasse_relation_idx_virkning_aktoerref
    ON klasse_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX klasse_relation_idx_virkning_aktoertypekode
    ON klasse_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX klasse_relation_idx_virkning_notetekst
    ON klasse_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX klasse_relation_pat_virkning_notetekst
    ON klasse_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr KlassePubliceretTilsType[])
  RETURNS KlassePubliceretTilsType[] AS
  $$
  DECLARE result KlassePubliceretTilsType[];
  DECLARE element KlassePubliceretTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.publiceret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr KlasseEgenskaberAttrType[])
  RETURNS KlasseEgenskaberAttrType[] AS
  $$
  DECLARE result KlasseEgenskaberAttrType[]; 
   DECLARE element KlasseEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.beskrivelse IS NULL AND element.eksempel IS NULL AND element.omfang IS NULL AND element.titel IS NULL AND element.retskilde IS NULL AND element.aendringsnotat IS NULL ) AND element.virkning IS NULL AND (element.soegeord IS NULL OR coalesce(array_length(element.soegeord,1),0)=0 )) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....)

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr KlasseRelationType[])
RETURNS KlasseRelationType[] AS
$$
 DECLARE result KlasseRelationType[];
 DECLARE element KlasseRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;



CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr KlasseSoegeordType[])
  RETURNS KlasseSoegeordType[] AS
  $$
  DECLARE result KlasseSoegeordType[];
  DECLARE element KlasseSoegeordType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (element.soegeordidentifikator IS NULL AND element.beskrivelse IS NULL AND element.soegeordskategori IS NULL ) THEN
     -- RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  IF array_length(result,1)=0 THEN
    RETURN NULL;
  ELSE
    RETURN result;
  END IF;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;



-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_klasse_registrering(
    klasse_registrering
) RETURNS klasse_registrering AS $BODY$
  SELECT * FROM klasse_registrering as a WHERE
    klasse_id = $1.klasse_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_klasse_registrering(
    klasse_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS klasse_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    klasse_registrering_id bigint;
    klasse_registrering    klasse_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE klasse_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE klasse_id = klasse_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating klasse with uuid [%], Invalid [livscyklus] transition to [%]',klasse_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new klasse registrering

    klasse_registrering_id := nextval('klasse_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    klasse_registrering := ROW(
        klasse_registrering_id,
        klasse_uuid,
        registreringObj
    )::klasse_registrering;

    INSERT INTO klasse_registrering SELECT klasse_registrering.*;

    RETURN klasse_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of KlasseAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_klasse(
    klasse_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber KlasseEgenskaberAttrType[],
    

    
    tilsPubliceret KlassePubliceretTilsType[],
    

    relationer KlasseRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      KlasseRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_klasse          KlasseType;
    read_prev_klasse         KlasseType;
    read_new_klasse_reg      KlasseRegistreringType;
    read_prev_klasse_reg     KlasseRegistreringType;
    new_klasse_registrering  klasse_registrering;
    prev_klasse_registrering klasse_registrering;
    klasse_relation_navn     KlasseRelationKode;

    
    attrEgenskaberObj KlasseEgenskaberAttrType;
    

    
    new_id_klasse_attr_egenskaber bigint;
    klasseSoegeordObj KlasseSoegeordType;
    

    auth_filtered_uuids uuid[];

    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from klasse a join klasse_registrering b ON b.klasse_id=a.id WHERE a.id=klasse_uuid) THEN
        RAISE EXCEPTION 'Unable to update klasse with uuid [%], being unable to find any previous registrations.',klasse_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM klasse a WHERE a.id=klasse_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_klasse(array[klasse_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[klasse_uuid]) THEN
      RAISE EXCEPTION 'Unable to update klasse with uuid [%]. Object does not met stipulated criteria:%', klasse_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_klasse_registrering := _as_create_klasse_registrering(klasse_uuid, livscykluskode, brugerref, note);
    prev_klasse_registrering := _as_get_prev_klasse_registrering(new_klasse_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_klasse_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update klasse with uuid [%], as the klasse seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', klasse_uuid, lostUpdatePreventionTZ, LOWER((prev_klasse_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    

    INSERT INTO klasse_relation (klasse_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
    SELECT
        new_klasse_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType 
        FROM
            unnest(relationer) AS a ;

    


    -- Ad 2)
    -- 0..1 relations

    
    
    FOREACH klasse_relation_navn IN ARRAY ARRAY['ejer'::KlasseRelationKode ,  'ansvarlig'::KlasseRelationKode ,  'overordnetklasse'::KlasseRelationKode ,  'facet'::KlasseRelationKode  ]::KlasseRelationKode[]  LOOP
        INSERT INTO klasse_relation (klasse_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
        SELECT
            new_klasse_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM klasse_relation b
                 WHERE b.klasse_registrering_id = new_klasse_registrering.id AND b.rel_type = klasse_relation_navn) d
            JOIN klasse_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.klasse_registrering_id = prev_klasse_registrering.id AND a.rel_type = klasse_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
    FOREACH klasse_relation_navn IN ARRAY ARRAY['redaktoerer'::KlasseRelationKode, 'sideordnede'::KlasseRelationKode, 'mapninger'::KlasseRelationKode, 'tilfoejelser'::KlasseRelationKode, 'erstatter'::KlasseRelationKode, 'lovligekombinationer'::KlasseRelationKode]::KlasseRelationKode[] LOOP
        IF NOT EXISTS (
                    SELECT 1
                      FROM klasse_relation
                     WHERE klasse_registrering_id = new_klasse_registrering.id AND rel_type = klasse_relation_navn) THEN
                    
                    INSERT INTO klasse_relation (klasse_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
                    SELECT
                        new_klasse_registrering.id,  virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type
        FROM klasse_relation
        WHERE
            klasse_registrering_id = prev_klasse_registrering.id AND rel_type = klasse_relation_navn ;

    
        END IF;
    END LOOP;
    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsPubliceret IS NOT NULL AND coalesce(array_length(tilsPubliceret, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Publiceret] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- klasse_tils_publiceret

        -- Ad 1)
        INSERT INTO klasse_tils_publiceret(virkning, publiceret, klasse_registrering_id)
             SELECT a.virkning, a.publiceret, new_klasse_registrering.id
               FROM unnest(tilsPubliceret) AS a;

        -- Ad 2
        INSERT INTO klasse_tils_publiceret(virkning, publiceret, klasse_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.publiceret,
            new_klasse_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- klasse_tils_publiceret of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- klasse_tils_publiceret of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM klasse_tils_publiceret b
             WHERE b.klasse_registrering_id = new_klasse_registrering.id) d
              JOIN klasse_tils_publiceret a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.klasse_registrering_id = prev_klasse_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- klasse_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrKlasseObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.beskrivelse,a.eksempel,a.omfang,a.titel,a.retskilde,a.aendringsnotat,a.integrationsdata,
                    a.virkning
                    ,
                        a.soegeord
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update klasse with uuid [%], as the klasse have overlapping virknings in the given egenskaber array :%', klasse_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).beskrivelse IS NULL  OR  (attrEgenskaberObj).eksempel IS NULL  OR  (attrEgenskaberObj).omfang IS NULL  OR  (attrEgenskaberObj).titel IS NULL  OR  (attrEgenskaberObj).retskilde IS NULL  OR  (attrEgenskaberObj).aendringsnotat IS NULL  OR  (attrEgenskaberObj).integrationsdata IS NULL  THEN
             WITH inserted_merged_attr_egenskaber AS (
            INSERT INTO klasse_attr_egenskaber ( id,  brugervendtnoegle,beskrivelse,eksempel,omfang,titel,retskilde,aendringsnotat,integrationsdata, virkning, klasse_registrering_id)
                SELECT
                    
                         nextval('klasse_attr_egenskaber_id_seq'), 
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.beskrivelse, a.beskrivelse),
                    
                        
                        
                            coalesce(attrEgenskaberObj.eksempel, a.eksempel),
                    
                        
                        
                            coalesce(attrEgenskaberObj.omfang, a.omfang),
                    
                        
                        
                            coalesce(attrEgenskaberObj.titel, a.titel),
                    
                        
                        
                            coalesce(attrEgenskaberObj.retskilde, a.retskilde),
                    
                        
                        
                            coalesce(attrEgenskaberObj.aendringsnotat, a.aendringsnotat),
                    
                        
                        
                            coalesce(attrEgenskaberObj.integrationsdata, a.integrationsdata),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_klasse_registrering.id
                        FROM klasse_attr_egenskaber a
                    WHERE
                        a.klasse_registrering_id = prev_klasse_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        
                        RETURNING
                            id new_id,
                            (virkning).TimePeriod merged_timeperiod
                        ) INSERT INTO klasse_attr_egenskaber_soegeord (soegeordidentifikator, beskrivelse, soegeordskategori, klasse_attr_egenskaber_id)
                        SELECT
                            coalesce(b.soegeordidentifikator, c.soegeordidentifikator), --please notice that this is not a merge - one of the joins on b or c will fail.
                            coalesce(b.beskrivelse, c.beskrivelse), --please notice that this is not a merge - one of the joins on b or c will fail.
                            coalesce(b.soegeordskategori, c.soegeordskategori), --please notice that this is not a merge - one of the joins on b or c will fail.
                            a.new_id
                        FROM
                            inserted_merged_attr_egenskaber a
                            LEFT JOIN unnest(attrEgenskaberObj.soegeord) AS b (soegeordidentifikator,
                                beskrivelse,
                                soegeordskategori) ON attrEgenskaberObj.soegeord IS NOT NULL
                            LEFT JOIN klasse_attr_egenskaber AS b2 ON attrEgenskaberObj.soegeord IS NULL AND b2.klasse_registrering_id = prev_klasse_registrering.id AND (b2.virkning).TimePeriod @> a.merged_timeperiod --Please notice, that this will max hit exactly one row - the row that the new id was merged with
                            LEFT JOIN klasse_attr_egenskaber_soegeord AS c ON attrEgenskaberObj.soegeord IS NULL AND c.klasse_attr_egenskaber_id = b2.id
                        WHERE ((attrEgenskaberObj.soegeord IS NULL AND c.id IS NOT NULL) --there is sogeord of merged egenskab
                            OR coalesce(array_length(attrEgenskaberObj.soegeord, 1), 0) > 0 --soegeord is defined in array
                        ) AND (NOT (attrEgenskaberObj.soegeord IS NOT NULL AND array_length(attrEgenskaberObj.soegeord, 1) = 0)) --if the array is empty, no sogeord should be inserted
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
        WITH inserted_attr_egenskaber AS (
        
            INSERT INTO klasse_attr_egenskaber ( id,  brugervendtnoegle,beskrivelse,eksempel,omfang,titel,retskilde,aendringsnotat,integrationsdata, virkning, klasse_registrering_id)
                SELECT
                    
                     nextval('klasse_attr_egenskaber_id_seq'), attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.beskrivelse,
                    
                     attrEgenskaberObj.eksempel,
                    
                     attrEgenskaberObj.omfang,
                    
                     attrEgenskaberObj.titel,
                    
                     attrEgenskaberObj.retskilde,
                    
                     attrEgenskaberObj.aendringsnotat,
                    
                     attrEgenskaberObj.integrationsdata,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_klasse_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the klasse_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM klasse_attr_egenskaber b
                    WHERE b.klasse_registrering_id = new_klasse_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE 
                    RETURNING id
        ) INSERT INTO klasse_attr_egenskaber_soegeord(soegeordidentifikator, beskrivelse, soegeordskategori, klasse_attr_egenskaber_id)
        SELECT
            a.soegeordidentifikator,
            a.beskrivelse,
            a.soegeordskategori,
            b.id
        FROM
            unnest(attrEgenskaberObj.soegeord) AS a (soegeordidentifikator,
                beskrivelse,
                soegeordskategori)
            JOIN inserted_attr_egenskaber b ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            
            new_id_klasse_attr_egenskaber := nextval('klasse_attr_egenskaber_id_seq');
            

            INSERT INTO klasse_attr_egenskaber ( id,  brugervendtnoegle,beskrivelse,eksempel,omfang,titel,retskilde,aendringsnotat,integrationsdata, virkning, klasse_registrering_id)
                VALUES ( new_id_klasse_attr_egenskaber,   attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.beskrivelse,  attrEgenskaberObj.eksempel,  attrEgenskaberObj.omfang,  attrEgenskaberObj.titel,  attrEgenskaberObj.retskilde,  attrEgenskaberObj.aendringsnotat,  attrEgenskaberObj.integrationsdata, attrEgenskaberObj.virkning, new_klasse_registrering.id );
        IF attrEgenskaberObj.soegeord IS NOT NULL THEN
            INSERT INTO klasse_attr_egenskaber_soegeord (soegeordidentifikator, beskrivelse, soegeordskategori, klasse_attr_egenskaber_id)
            SELECT
                a.soegeordidentifikator,
                a.beskrivelse,
                a.soegeordskategori,
                new_id_klasse_attr_egenskaber
            FROM
                unnest(attrEgenskaberObj.soegeord) AS a (soegeordidentifikator, beskrivelse, soegeordskategori);
        END IF;

        
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

WITH copied_attr_egenskaber AS (

    INSERT INTO klasse_attr_egenskaber ( id,  brugervendtnoegle,beskrivelse,eksempel,omfang,titel,retskilde,aendringsnotat,integrationsdata, virkning, klasse_registrering_id)
    SELECT
         nextval('klasse_attr_egenskaber_id_seq'), 
        
            a.brugervendtnoegle,
        
            a.beskrivelse,
        
            a.eksempel,
        
            a.omfang,
        
            a.titel,
        
            a.retskilde,
        
            a.aendringsnotat,
        
            a.integrationsdata,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_klasse_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- klasse_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- klasse_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                klasse_attr_egenskaber b
            WHERE
                b.klasse_registrering_id = new_klasse_registrering.id) d
            JOIN klasse_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.klasse_registrering_id = prev_klasse_registrering.id 
            RETURNING id new_id, (virkning).TimePeriod
    ) INSERT INTO klasse_attr_egenskaber_soegeord (soegeordidentifikator, beskrivelse, soegeordskategori, klasse_attr_egenskaber_id)
    SELECT
        b.soegeordidentifikator, b.beskrivelse, b.soegeordskategori, a.new_id
    FROM
        copied_attr_egenskaber a
        JOIN klasse_attr_egenskaber a2 ON a2.klasse_registrering_id = prev_klasse_registrering.id AND (a2.virkning).TimePeriod @> a.TimePeriod
        -- This will hit exactly one row - that is, the row that we copied.
        JOIN klasse_attr_egenskaber_soegeord b ON a2.id = b.klasse_attr_egenskaber_id
        ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_klasse := as_read_klasse(klasse_uuid, (new_klasse_registrering.registrering).timeperiod, null);
    read_prev_klasse := as_read_klasse(klasse_uuid, (prev_klasse_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_klasse.registrering[1].registrering).TimePeriod) = lower((new_klasse_registrering.registrering).TimePeriod) and lower((read_prev_klasse.registrering[1].registrering).TimePeriod)=lower((prev_klasse_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating klasse with id [%]: The ordering of as_list_klasse should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', klasse_uuid, to_json(new_klasse_registrering), to_json(read_new_klasse.registrering[1].registrering), to_json(prev_klasse_registrering), to_json(prev_new_klasse.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_klasse_reg := ROW(
        ROW (null, (read_new_klasse.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_klasse.registrering[1]).tilsPubliceret ,
        
        (read_new_klasse.registrering[1]).attrEgenskaber ,
        (read_new_klasse.registrering[1]).relationer
    )::klasseRegistreringType;

    read_prev_klasse_reg := ROW(
        ROW(null, (read_prev_klasse.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_klasse.registrering[1]).tilsPubliceret ,
        
        (read_prev_klasse.registrering[1]).attrEgenskaber ,
        (read_prev_klasse.registrering[1]).relationer
    )::klasseRegistreringType;


    IF read_prev_klasse_reg = read_new_klasse_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_klasse_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_klasse_reg);
      RAISE EXCEPTION 'Aborted updating klasse with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', klasse_uuid, to_json(read_new_klasse_reg), to_json(read_prev_klasse_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_klasse_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_klasse (
    klasse_registrering KlasseRegistreringType,
    klasse_uuid uuid DEFAULT NULL, auth_criteria_arr
    KlasseRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE klasse_registrering_id bigint;

    
    klasse_attr_egenskaber_obj klasseEgenskaberAttrType;
    

    
    klasse_tils_publiceret_obj klassePubliceretTilsType;
    

    klasse_relationer KlasseRelationType;

    
    klasse_attr_egenskaber_id bigint;
    klasse_attr_egenskaber_soegeord_obj KlasseSoegeordType;
    

    auth_filtered_uuids uuid[];

    

    does_exist boolean;
    new_klasse_registrering klasse_registrering;
BEGIN
    IF klasse_uuid IS NULL THEN LOOP
        klasse_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from klasse WHERE id=klasse_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from klasse WHERE id=klasse_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (klasse_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (klasse_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (klasse_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_klasse.',(klasse_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO klasse (ID) SELECT
        klasse_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        klasse_registrering_id:=nextval('klasse_registrering_id_seq');

        INSERT INTO klasse_registrering (id, klasse_id,
            registrering) SELECT klasse_registrering_id,
        klasse_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (klasse_registrering.registrering).livscykluskode,
        (klasse_registrering.registrering).brugerref,
        (klasse_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_klasse_registrering :=
            _as_create_klasse_registrering(klasse_uuid,
                (klasse_registrering.registrering).livscykluskode,
                (klasse_registrering.registrering).brugerref,
                (klasse_registrering.registrering).note);

            klasse_registrering_id := new_klasse_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(klasse_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [klasse]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF klasse_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(klasse_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH klasse_attr_egenskaber_obj IN ARRAY klasse_registrering.attrEgenskaber
  LOOP

  
  klasse_attr_egenskaber_id:=nextval('klasse_attr_egenskaber_id_seq');
  
    INSERT INTO klasse_attr_egenskaber (
      id,
      brugervendtnoegle,
      beskrivelse,
      eksempel,
      omfang,
      titel,
      retskilde,
      aendringsnotat,
      integrationsdata,
      virkning,
      klasse_registrering_id
    )
    SELECT
     klasse_attr_egenskaber_id,
     klasse_attr_egenskaber_obj.brugervendtnoegle,
      klasse_attr_egenskaber_obj.beskrivelse,
      klasse_attr_egenskaber_obj.eksempel,
      klasse_attr_egenskaber_obj.omfang,
      klasse_attr_egenskaber_obj.titel,
      klasse_attr_egenskaber_obj.retskilde,
      klasse_attr_egenskaber_obj.aendringsnotat,
      klasse_attr_egenskaber_obj.integrationsdata,
      klasse_attr_egenskaber_obj.virkning,
      klasse_registrering_id
    ;
  
    
 /************/
 --Insert Soegeord
  IF klasse_attr_egenskaber_obj.soegeord IS NOT NULL AND coalesce(array_length(klasse_attr_egenskaber_obj.soegeord,1),0)>1 THEN
    FOREACH klasse_attr_egenskaber_soegeord_obj IN ARRAY klasse_attr_egenskaber_obj.soegeord
      LOOP

      IF (klasse_attr_egenskaber_soegeord_obj.soegeordidentifikator IS NOT NULL AND klasse_attr_egenskaber_soegeord_obj.soegeordidentifikator<>'') 
      OR (klasse_attr_egenskaber_soegeord_obj.beskrivelse IS NOT NULL AND klasse_attr_egenskaber_soegeord_obj.beskrivelse<>'' )
      OR (klasse_attr_egenskaber_soegeord_obj.soegeordskategori IS NOT NULL AND klasse_attr_egenskaber_soegeord_obj.soegeordskategori<>'') THEN

      INSERT INTO klasse_attr_egenskaber_soegeord (
        soegeordidentifikator,
        beskrivelse,
        soegeordskategori,
        klasse_attr_egenskaber_id
      )
      SELECT
        klasse_attr_egenskaber_soegeord_obj.soegeordidentifikator,
        klasse_attr_egenskaber_soegeord_obj.beskrivelse,
        klasse_attr_egenskaber_soegeord_obj.soegeordskategori,
        klasse_attr_egenskaber_id
      ;
      END IF;
 
     END LOOP;
    END IF;
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(klasse_registrering.tilsPubliceret, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [publiceret] for klasse. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF klasse_registrering.tilsPubliceret IS NOT NULL AND coalesce(array_length(klasse_registrering.tilsPubliceret,1),0)>0 THEN
  FOREACH klasse_tils_publiceret_obj IN ARRAY klasse_registrering.tilsPubliceret
  LOOP

    INSERT INTO klasse_tils_publiceret (
      virkning,
      publiceret,
      klasse_registrering_id
    )
    SELECT
      klasse_tils_publiceret_obj.virkning,
      klasse_tils_publiceret_obj.publiceret,
      klasse_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations



    INSERT INTO klasse_relation (
      klasse_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      klasse_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(klasse_registrering.relationer) a
  ;




/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_klasse(array[klasse_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[klasse_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import klasse with uuid [%]. Object does not met stipulated criteria:%',klasse_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN klasse_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_klasse(klasse_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr KlasseRegistreringType[]=null
  )
  RETURNS KlasseType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result KlasseType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_klasse(klasse_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(klasse_uuids,1),0) AND auth_filtered_uuids @>klasse_uuids) THEN
  RAISE EXCEPTION 'Unable to list klasse with uuids [%]. All objects do not fullfill the stipulated criteria:%',klasse_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.klasseObj) into result
FROM
(
SELECT
ROW(
	a.klasse_id,
	array_agg(
		ROW (
			a.registrering,
			a.KlasseTilsPubliceretArr,
			a.KlasseAttrEgenskaberArr,
			a.KlasseRelationArr
		)::KlasseRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: KlasseType  klasseObj
FROM
(
	SELECT
	a.klasse_id,
	a.klasse_registrering_id,
	a.registrering,
	a.KlasseAttrEgenskaberArr,
	a.KlasseTilsPubliceretArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type
			):: KlasseRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
        
	)) KlasseRelationArr
	FROM
	(
			SELECT
			a.klasse_id,
			a.klasse_registrering_id,
			a.registrering,
			a.KlasseAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.publiceret
						) ::KlassePubliceretTilsType
					ELSE NULL
					END
					order by b.publiceret,b.virkning
				)) KlasseTilsPubliceretArr		
			FROM
			(
					SELECT
					a.klasse_id,
					a.klasse_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN a.attr_id is not null THEN
                        
						ROW(
                            
                                                       a.brugervendtnoegle,
                                                       a.beskrivelse,
                                                       a.eksempel,
                                                       a.omfang,
                                                       a.titel,
                                                       a.retskilde,
                                                       a.aendringsnotat,
                                                       a.integrationsdata,
                                                       a.KlasseAttrEgenskaberSoegeordTypeArr,
                                                       a.virkning 
                            
							)::KlasseEgenskaberAttrType
						ELSE
						NULL
						END
                        
                        order by a.brugervendtnoegle,a.beskrivelse,a.eksempel,a.omfang,a.titel,a.retskilde,a.aendringsnotat,a.virkning,a.KlasseAttrEgenskaberSoegeordTypeArr
                        
					)) KlasseAttrEgenskaberArr
                    
                               FROM            
                               (
                                               SELECT
                                               a.klasse_id,
                                               a.klasse_registrering_id,
                                               a.registrering,
                                               b.id attr_id,
                                               b.brugervendtnoegle,
                                               b.beskrivelse,
                                               b.eksempel,
                                               b.omfang,
                                               b.titel,
                                               b.retskilde,
                                               b.aendringsnotat,
                                               b.integrationsdata,
                                               b.virkning,     
                                               _remove_nulls_in_array(array_agg(
                                                       CASE 
                                                       WHEN c.id is not null THEN
                                                       ROW(
                                                               c.soegeordidentifikator,
                                                               c.beskrivelse,
                                                               c.soegeordskategori 
                                                       )::KlasseSoegeordType
                                               ELSE
                                               NULL
                                               END
                                               order by c.soegeordidentifikator,c.beskrivelse,c.soegeordskategori
                                       )) KlasseAttrEgenskaberSoegeordTypeArr
                    
					FROM
					(
					SELECT
					a.id klasse_id,
					b.id klasse_registrering_id,
					b.registrering			
					FROM		klasse a
					JOIN 		klasse_registrering b 	ON b.klasse_id=a.id
					WHERE a.id = ANY (klasse_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN klasse_attr_egenskaber as b ON b.klasse_registrering_id=a.klasse_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
                                               LEFT JOIN klasse_attr_egenskaber_soegeord as c ON c.klasse_attr_egenskaber_id=b.id
                                               GROUP BY 
                                               a.klasse_id,
                                               a.klasse_registrering_id,
                                               a.registrering,
                                               b.id,
                                               b.brugervendtnoegle,
                                               b.beskrivelse,
                                               b.eksempel,
                                               b.omfang,
                                               b.titel,
                                               b.retskilde,
                                               b.aendringsnotat,
                                               b.integrationsdata,
                                               b.virkning
                               ) as a
                    
					GROUP BY 
					a.klasse_id,
					a.klasse_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN klasse_tils_publiceret as b ON b.klasse_registrering_id=a.klasse_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.klasse_id,
			a.klasse_registrering_id,
			a.registrering,
			a.KlasseAttrEgenskaberArr
	) as a
	LEFT JOIN klasse_relation b ON b.klasse_registrering_id=a.klasse_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.klasse_id,
	a.klasse_registrering_id,
	a.registrering,
	a.KlasseAttrEgenskaberArr,
	a.KlasseTilsPubliceretArr
) as a

WHERE a.klasse_id IS NOT NULL
GROUP BY 
a.klasse_id
order by a.klasse_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_klasse(
    klasse_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      KlasseRegistreringType[]=null
) RETURNS KlasseType AS $$
DECLARE
	resArr KlasseType[];
BEGIN
    resArr := as_list_klasse(ARRAY[klasse_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_klasse(
    firstResult int,--TOOD ??
    klasse_uuid uuid,
    registreringObj   KlasseRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr KlasseRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    klasse_candidates uuid[];
    klasse_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj KlasseEgenskaberAttrType;

    
    tilsPubliceretTypeObj KlassePubliceretTilsType;

    relationTypeObj KlasseRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
    manipulatedAttrEgenskaberArr KlasseEgenskaberAttrType[]:='{}';
    soegeordObj KlasseSoegeordType;
    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

klasse_candidates_is_initialized := false;

IF klasse_uuid is not NULL THEN
    klasse_candidates:= ARRAY[klasse_uuid];
    klasse_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        klasse_candidates:=array(
                SELECT DISTINCT
                b.klasse_id
                FROM
                klasse a
                JOIN klasse_registrering b on b.klasse_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'klasse_candidates_is_initialized step 1:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 1:%',klasse_candidates;
--/****************************//


--RAISE NOTICE 'klasse_candidates_is_initialized step 2:%',klasse_candidates_is_initialized;
--RAISE NOTICE 'klasse_candidates step 2:%',klasse_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_klasse: skipping filtration on attrEgenskaber';
ELSE


--To help facilitate the comparrison efforts (while diverging at a minimum form the templated db-kode,
--we'll manipulate the attrEgenskaber array so to make sure that every object only has 1 sogeord element - duplicating the parent elements in attrEgenskaber as needed  )

FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
LOOP
       IF  (attrEgenskaberTypeObj).soegeord IS NULL OR coalesce(array_length((attrEgenskaberTypeObj).soegeord,1),0)<2 THEN
       manipulatedAttrEgenskaberArr:=array_append(manipulatedAttrEgenskaberArr,attrEgenskaberTypeObj); --The element only has 0 or 1 soegeord element, så no manipulations is needed.
       ELSE
               FOREACH soegeordObj IN ARRAY (attrEgenskaberTypeObj).soegeord
               LOOP
                       manipulatedAttrEgenskaberArr:=array_append(manipulatedAttrEgenskaberArr,
                               ROW (
                                       attrEgenskaberTypeObj.brugervendtnoegle,
                                       attrEgenskaberTypeObj.beskrivelse,
                                       attrEgenskaberTypeObj.eksempel,
                                       attrEgenskaberTypeObj.omfang,
                                       attrEgenskaberTypeObj.titel,
                                       attrEgenskaberTypeObj.retskilde,
                                       attrEgenskaberTypeObj.aendringsnotat,
                                       ARRAY[soegeordObj]::KlasseSoegeordType[], --NOTICE: Only 1 element in array
                                       attrEgenskaberTypeObj.virkning
                                       )::KlasseEgenskaberAttrType
                               );
               END LOOP;
       END IF;
END LOOP;

    IF (coalesce(array_length(klasse_candidates,1),0)>0 OR NOT klasse_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY manipulatedAttrEgenskaberArr
        
        LOOP
            klasse_candidates:=array(
            SELECT DISTINCT
            b.klasse_id
            FROM  klasse_attr_egenskaber a
            JOIN klasse_registrering b on a.klasse_registrering_id=b.id
            
            LEFT JOIN klasse_attr_egenskaber_soegeord c on a.id=c.klasse_attr_egenskaber_id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.beskrivelse IS NULL
                    OR
                    a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.eksempel IS NULL
                    OR
                    a.eksempel ILIKE attrEgenskaberTypeObj.eksempel --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.omfang IS NULL
                    OR
                    a.omfang ILIKE attrEgenskaberTypeObj.omfang --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.titel IS NULL
                    OR
                    a.titel ILIKE attrEgenskaberTypeObj.titel --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.retskilde IS NULL
                    OR
                    a.retskilde ILIKE attrEgenskaberTypeObj.retskilde --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.aendringsnotat IS NULL
                    OR
                    a.aendringsnotat ILIKE attrEgenskaberTypeObj.aendringsnotat --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.integrationsdata IS NULL
                    OR
                    a.integrationsdata ILIKE attrEgenskaberTypeObj.integrationsdata --case insensitive
                )
                AND
                
                (
                        (attrEgenskaberTypeObj.soegeord IS NULL OR array_length(attrEgenskaberTypeObj.soegeord,1)=0)
                        OR
                        (
                                (
                                        (attrEgenskaberTypeObj.soegeord[1]).soegeordidentifikator IS NULL
                                        OR
                                        c.soegeordidentifikator ILIKE (attrEgenskaberTypeObj.soegeord[1]).soegeordidentifikator  
                                )
                                AND
                                (
                                        (attrEgenskaberTypeObj.soegeord[1]).beskrivelse IS NULL
                                        OR
                                        c.beskrivelse ILIKE (attrEgenskaberTypeObj.soegeord[1]).beskrivelse  
                                )               
                                AND
                                (
                                        (attrEgenskaberTypeObj.soegeord[1]).soegeordskategori IS NULL
                                        OR
                                        c.soegeordskategori ILIKE (attrEgenskaberTypeObj.soegeord[1]).soegeordskategori  
                                )
                        )
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )

            );


            klasse_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'klasse_candidates_is_initialized step 3:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 3:%',klasse_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        klasse_candidates:=array(

            SELECT DISTINCT
            b.klasse_id
            
            FROM  klasse_attr_egenskaber a
            JOIN klasse_registrering b on a.klasse_registrering_id=b.id
            
            LEFT JOIN klasse_attr_egenskaber_soegeord c on a.id=c.klasse_attr_egenskaber_id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.beskrivelse ILIKE anyAttrValue OR
                        a.eksempel ILIKE anyAttrValue OR
                        a.omfang ILIKE anyAttrValue OR
                        a.titel ILIKE anyAttrValue OR
                        a.retskilde ILIKE anyAttrValue OR
                        a.aendringsnotat ILIKE anyAttrValue OR
                        a.integrationsdata ILIKE anyAttrValue
                
                OR
                c.soegeordidentifikator ILIKE anyAttrValue
                OR
                c.beskrivelse ILIKE anyAttrValue
                OR
                c.soegeordskategori ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )


        );

    klasse_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
    --RAISE DEBUG 'as_search_klasse: skipping filtration on tilsPubliceret';
ELSE
    IF (coalesce(array_length(klasse_candidates,1),0)>0 OR klasse_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
        LOOP
            klasse_candidates:=array(
            SELECT DISTINCT
            b.klasse_id
            FROM  klasse_tils_publiceret a
            JOIN klasse_registrering b on a.klasse_registrering_id=b.id
            WHERE
                (
                    tilsPubliceretTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsPubliceretTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).AktoerRef IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsPubliceretTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsPubliceretTypeObj.virkning) IS NULL OR (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsPubliceretTypeObj.publiceret IS NULL
                    OR
                    tilsPubliceretTypeObj.publiceret = a.publiceret
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )

    );


            klasse_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer KlasseRelationType[]
*/


--RAISE DEBUG 'klasse_candidates_is_initialized step 4:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 4:%',klasse_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_klasse: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(klasse_candidates,1),0)>0 OR NOT klasse_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            klasse_candidates:=array(
            SELECT DISTINCT
            b.klasse_id
            FROM  klasse_relation a
            JOIN klasse_registrering b on a.klasse_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )

    );

            klasse_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        klasse_candidates:=array(
            SELECT DISTINCT
            b.klasse_id
            
            FROM  klasse_relation a
            JOIN klasse_registrering b on a.klasse_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )


            );

    klasse_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        klasse_candidates:=array(
            SELECT DISTINCT
            b.klasse_id
            
            FROM  klasse_relation a
            JOIN klasse_registrering b on a.klasse_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )


            );

    klasse_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 




--RAISE DEBUG 'klasse_candidates_is_initialized step 5:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 5:%',klasse_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT klasse_candidates_is_initialized THEN
        klasse_candidates:=array(
        SELECT DISTINCT
            klasse_id
        FROM
            klasse_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klasse_candidates_is_initialized) OR b.klasse_id = ANY (klasse_candidates) )

        )
        ;

        klasse_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT klasse_candidates_is_initialized THEN
    --No filters applied!
    klasse_candidates:=array(
        SELECT DISTINCT id FROM klasse a
    );
ELSE
    klasse_candidates:=array(
        SELECT DISTINCT id FROM unnest(klasse_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'klasse_candidates_is_initialized step 6:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 6:%',klasse_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_klasse(klasse_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_klasse(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_KlasseRegistreringType_to_json(KlasseRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END klasseegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsPubliceret,1),0)>0 THEN to_json($1.tilsPubliceret) 
        ELSE 
        NULL
        END klassepubliceret
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::KlasseRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (KlasseRegistreringType as json);
create cast (KlasseRegistreringType as json) with function actual_state._cast_KlasseRegistreringType_to_json(KlasseRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_klasseType_to_json(KlasseType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg KlasseRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (KlasseType as json);
create cast (KlasseType as json) with function actual_state._cast_klasseType_to_json(KlasseType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_klasse(
    klasse_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    KlasseRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    klasse_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    klasse_sorted_uuid:=array(
          SELECT b.klasse_id
            FROM klasse_registrering b
            JOIN klasse_attr_egenskaber a ON a.klasse_registrering_id=b.id
           WHERE b.klasse_id = ANY (klasse_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.klasse_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.klasse_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN klasse_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_klasse(
	klasse_uuids uuid[],
	registreringObjArr KlasseRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	klasse_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	klasse_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj KlasseEgenskaberAttrType;
	
  	tilsPubliceretTypeObj KlassePubliceretTilsType;
	relationTypeObj KlasseRelationType;
	registreringObj KlasseRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN klasse_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF klasse_uuids IS NULL OR coalesce(array_length(klasse_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

klasse_candidates:= klasse_uuids;



--RAISE DEBUG 'klasse_candidates_is_initialized step 1:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 1:%',klasse_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_klasse: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(klasse_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			klasse_candidates:=array(
			SELECT DISTINCT
			b.klasse_id 
			FROM  klasse_attr_egenskaber a 
			JOIN klasse_registrering b on a.klasse_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.eksempel IS NULL
					OR 
					a.eksempel = attrEgenskaberTypeObj.eksempel 
				)
				AND
				(
					attrEgenskaberTypeObj.omfang IS NULL
					OR 
					a.omfang = attrEgenskaberTypeObj.omfang 
				)
				AND
				(
					attrEgenskaberTypeObj.titel IS NULL
					OR 
					a.titel = attrEgenskaberTypeObj.titel 
				)
				AND
				(
					attrEgenskaberTypeObj.retskilde IS NULL
					OR 
					a.retskilde = attrEgenskaberTypeObj.retskilde 
				)
				AND
				(
					attrEgenskaberTypeObj.aendringsnotat IS NULL
					OR 
					a.aendringsnotat = attrEgenskaberTypeObj.aendringsnotat 
				)
				AND
				(
					attrEgenskaberTypeObj.integrationsdata IS NULL
					OR 
					a.integrationsdata = attrEgenskaberTypeObj.integrationsdata 
				)
				AND b.klasse_id = ANY (klasse_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'klasse_candidates_is_initialized step 3:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 3:%',klasse_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_klasse: skipping filtration on tilsPubliceret';
ELSE
	IF coalesce(array_length(klasse_candidates,1),0)>0 THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			klasse_candidates:=array(
			SELECT DISTINCT
			b.klasse_id 
			FROM  klasse_tils_publiceret a
			JOIN klasse_registrering b on a.klasse_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND b.klasse_id = ANY (klasse_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer KlasseRelationType[]
*/


--RAISE DEBUG 'klasse_candidates_is_initialized step 4:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 4:%',klasse_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_klasse: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(klasse_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			klasse_candidates:=array(
			SELECT DISTINCT
			b.klasse_id 
			FROM  klasse_relation a
			JOIN klasse_registrering b on a.klasse_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.klasse_id = ANY (klasse_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'klasse_candidates_is_initialized step 5:%',klasse_candidates_is_initialized;
--RAISE DEBUG 'klasse_candidates step 5:%',klasse_candidates;

klasse_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (klasse_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (klasse_candidates) b(id)
);

--optimization 
IF coalesce(array_length(klasse_passed_auth_filter,1),0)=coalesce(array_length(klasse_uuids,1),0) AND klasse_passed_auth_filter @>klasse_uuids THEN
	RETURN klasse_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN klasse_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE KlassifikationPubliceretTils AS ENUM ('Publiceret','IkkePubliceret',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE KlassifikationPubliceretTilsType AS (
    virkning Virkning,
    publiceret KlassifikationPubliceretTils
)
;



CREATE TYPE KlassifikationEgenskaberAttrType AS (
brugervendtnoegle text,
beskrivelse text,
kaldenavn text,
ophavsret text,
integrationsdata text,

 virkning Virkning
);




CREATE TYPE KlassifikationRelationKode AS ENUM  ('ansvarlig','ejer');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_klassifikation_relation_kode_to_txt is invoked.



CREATE TYPE KlassifikationRelationType AS (
  relType KlassifikationRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text
)
;



CREATE TYPE KlassifikationRegistreringType AS
(
registrering RegistreringBase,
tilsPubliceret KlassifikationPubliceretTilsType[],
attrEgenskaber KlassifikationEgenskaberAttrType[],
relationer KlassifikationRelationType[]
);

CREATE TYPE KlassifikationType AS
(
  id uuid,
  registrering KlassifikationRegistreringType[]
);  





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_klassifikation_relation_kode_to_txt(
    KlassifikationRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE klassifikation (
    id uuid NOT NULL,
    CONSTRAINT klassifikation_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE klassifikation
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE klassifikation_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE klassifikation_registrering_id_seq
    OWNER TO mox;


CREATE TABLE klassifikation_registrering (
   id bigint NOT NULL DEFAULT nextval('klassifikation_registrering_id_seq'::regclass),
   klassifikation_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT klassifikation_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT klassifikation_registrering_klassifikation_fkey FOREIGN KEY (klassifikation_id)
       REFERENCES klassifikation (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT klassifikation_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(klassifikation_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE klassifikation_registrering
  OWNER TO mox;


CREATE INDEX klassifikation_registrering_idx_livscykluskode
    ON klassifikation_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX klassifikation_registrering_idx_brugerref
    ON klassifikation_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX klassifikation_registrering_idx_note
    ON klassifikation_registrering
    USING btree
    (((registrering).note));


CREATE INDEX klassifikation_registrering_pat_note
    ON klassifikation_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX klassifikation_id_idx
    ON klassifikation_registrering (klassifikation_id);


CREATE TRIGGER notify_klassifikation
    AFTER INSERT OR UPDATE OR DELETE ON klassifikation_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE klassifikation_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE klassifikation_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE klassifikation_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('klassifikation_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        beskrivelse text  NULL,
        kaldenavn text  NULL,
        ophavsret text  NULL,
        integrationsdata text  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    klassifikation_registrering_id bigint NOT NULL,
    CONSTRAINT klassifikation_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT klassifikation_attr_egenskaber_forkey_klassifikationregistrering FOREIGN KEY (klassifikation_registrering_id) REFERENCES klassifikation_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT klassifikation_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (klassifikation_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE klassifikation_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX klassifikation_attr_egenskaber_pat_brugervendtnoegle
            ON klassifikation_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX klassifikation_attr_egenskaber_idx_brugervendtnoegle
            ON klassifikation_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX klassifikation_attr_egenskaber_pat_beskrivelse
            ON klassifikation_attr_egenskaber
            USING gin
            (beskrivelse gin_trgm_ops);

        CREATE INDEX klassifikation_attr_egenskaber_idx_beskrivelse
            ON klassifikation_attr_egenskaber
            USING btree
            (beskrivelse); 
 
     
        CREATE INDEX klassifikation_attr_egenskaber_pat_kaldenavn
            ON klassifikation_attr_egenskaber
            USING gin
            (kaldenavn gin_trgm_ops);

        CREATE INDEX klassifikation_attr_egenskaber_idx_kaldenavn
            ON klassifikation_attr_egenskaber
            USING btree
            (kaldenavn); 
 
     
        CREATE INDEX klassifikation_attr_egenskaber_pat_ophavsret
            ON klassifikation_attr_egenskaber
            USING gin
            (ophavsret gin_trgm_ops);

        CREATE INDEX klassifikation_attr_egenskaber_idx_ophavsret
            ON klassifikation_attr_egenskaber
            USING btree
            (ophavsret); 
 
     
        CREATE INDEX klassifikation_attr_egenskaber_pat_integrationsdata
            ON klassifikation_attr_egenskaber
            USING gin
            (integrationsdata gin_trgm_ops);

        CREATE INDEX klassifikation_attr_egenskaber_idx_integrationsdata
            ON klassifikation_attr_egenskaber
            USING btree
            (integrationsdata); 



CREATE INDEX klassifikation_attr_egenskaber_idx_virkning_aktoerref
    ON klassifikation_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX klassifikation_attr_egenskaber_idx_virkning_aktoertypekode
    ON klassifikation_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX klassifikation_attr_egenskaber_idx_virkning_notetekst
    ON klassifikation_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX klassifikation_attr_egenskaber_pat_virkning_notetekst
    ON klassifikation_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE klassifikation_tils_publiceret_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE klassifikation_tils_publiceret_id_seq
    OWNER TO mox;


CREATE TABLE klassifikation_tils_publiceret (
    id bigint NOT NULL DEFAULT nextval('klassifikation_tils_publiceret_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    publiceret KlassifikationPubliceretTils NOT NULL, 
    klassifikation_registrering_id bigint not null,
    CONSTRAINT klassifikation_tils_publiceret_pkey PRIMARY KEY (id),
    CONSTRAINT klassifikation_tils_publiceret_forkey_klassifikationregistrering FOREIGN KEY (klassifikation_registrering_id) REFERENCES klassifikation_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT klassifikation_tils_publiceret_exclude_virkning_overlap EXCLUDE USING gist (klassifikation_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE klassifikation_tils_publiceret
    OWNER TO mox;


CREATE INDEX klassifikation_tils_publiceret_idx_publiceret
    ON klassifikation_tils_publiceret
    USING btree
    (publiceret);
  
CREATE INDEX klassifikation_tils_publiceret_idx_virkning_aktoerref
    ON klassifikation_tils_publiceret
    USING btree
    (((virkning).aktoerref));

CREATE INDEX klassifikation_tils_publiceret_idx_virkning_aktoertypekode
    ON klassifikation_tils_publiceret
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX klassifikation_tils_publiceret_idx_virkning_notetekst
    ON klassifikation_tils_publiceret
    USING btree
    (((virkning).notetekst));

CREATE INDEX klassifikation_tils_publiceret_pat_virkning_notetekst
    ON klassifikation_tils_publiceret
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE klassifikation_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE klassifikation_relation_id_seq
    OWNER TO mox;


CREATE TABLE klassifikation_relation (
    id bigint NOT NULL DEFAULT nextval('klassifikation_relation_id_seq'::regclass),
    klassifikation_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type KlassifikationRelationKode not null,
    objekt_type text null,

    

    CONSTRAINT klassifikation_relation_forkey_klassifikationregistrering FOREIGN KEY (klassifikation_registrering_id) REFERENCES klassifikation_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT klassifikation_relation_pkey PRIMARY KEY (id),
    CONSTRAINT klassifikation_relation_no_virkning_overlap EXCLUDE USING gist (klassifikation_registrering_id WITH =, _as_convert_klassifikation_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT klassifikation_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE klassifikation_relation
  OWNER TO mox;





CREATE INDEX klassifikation_relation_idx_rel_maal_obj_uuid
    ON klassifikation_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX klassifikation_relation_idx_rel_maal_obj_urn
    ON klassifikation_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX klassifikation_relation_idx_rel_maal_uuid
    ON klassifikation_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX klassifikation_relation_idx_rel_maal_uuid_isolated
    ON klassifikation_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX klassifikation_relation_idx_rel_maal_urn_isolated
    ON klassifikation_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX klassifikation_relation_idx_rel_maal_urn
    ON klassifikation_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX klassifikation_relation_idx_virkning_aktoerref
    ON klassifikation_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX klassifikation_relation_idx_virkning_aktoertypekode
    ON klassifikation_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX klassifikation_relation_idx_virkning_notetekst
    ON klassifikation_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX klassifikation_relation_pat_virkning_notetekst
    ON klassifikation_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr KlassifikationPubliceretTilsType[])
  RETURNS KlassifikationPubliceretTilsType[] AS
  $$
  DECLARE result KlassifikationPubliceretTilsType[];
  DECLARE element KlassifikationPubliceretTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.publiceret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr KlassifikationEgenskaberAttrType[])
  RETURNS KlassifikationEgenskaberAttrType[] AS
  $$
  DECLARE result KlassifikationEgenskaberAttrType[]; 
   DECLARE element KlassifikationEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.beskrivelse IS NULL AND element.kaldenavn IS NULL AND element.ophavsret IS NULL AND element.integrationsdata IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr KlassifikationRelationType[])
RETURNS KlassifikationRelationType[] AS
$$
 DECLARE result KlassifikationRelationType[];
 DECLARE element KlassifikationRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_klassifikation_registrering(
    klassifikation_registrering
) RETURNS klassifikation_registrering AS $BODY$
  SELECT * FROM klassifikation_registrering as a WHERE
    klassifikation_id = $1.klassifikation_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_klassifikation_registrering(
    klassifikation_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS klassifikation_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    klassifikation_registrering_id bigint;
    klassifikation_registrering    klassifikation_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE klassifikation_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE klassifikation_id = klassifikation_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating klassifikation with uuid [%], Invalid [livscyklus] transition to [%]',klassifikation_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new klassifikation registrering

    klassifikation_registrering_id := nextval('klassifikation_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    klassifikation_registrering := ROW(
        klassifikation_registrering_id,
        klassifikation_uuid,
        registreringObj
    )::klassifikation_registrering;

    INSERT INTO klassifikation_registrering SELECT klassifikation_registrering.*;

    RETURN klassifikation_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of KlassifikationAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_klassifikation(
    klassifikation_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber KlassifikationEgenskaberAttrType[],
    

    
    tilsPubliceret KlassifikationPubliceretTilsType[],
    

    relationer KlassifikationRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      KlassifikationRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_klassifikation          KlassifikationType;
    read_prev_klassifikation         KlassifikationType;
    read_new_klassifikation_reg      KlassifikationRegistreringType;
    read_prev_klassifikation_reg     KlassifikationRegistreringType;
    new_klassifikation_registrering  klassifikation_registrering;
    prev_klassifikation_registrering klassifikation_registrering;
    klassifikation_relation_navn     KlassifikationRelationKode;

    
    attrEgenskaberObj KlassifikationEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from klassifikation a join klassifikation_registrering b ON b.klassifikation_id=a.id WHERE a.id=klassifikation_uuid) THEN
        RAISE EXCEPTION 'Unable to update klassifikation with uuid [%], being unable to find any previous registrations.',klassifikation_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM klassifikation a WHERE a.id=klassifikation_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_klassifikation(array[klassifikation_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[klassifikation_uuid]) THEN
      RAISE EXCEPTION 'Unable to update klassifikation with uuid [%]. Object does not met stipulated criteria:%', klassifikation_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_klassifikation_registrering := _as_create_klassifikation_registrering(klassifikation_uuid, livscykluskode, brugerref, note);
    prev_klassifikation_registrering := _as_get_prev_klassifikation_registrering(new_klassifikation_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_klassifikation_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update klassifikation with uuid [%], as the klassifikation seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', klassifikation_uuid, lostUpdatePreventionTZ, LOWER((prev_klassifikation_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    

    INSERT INTO klassifikation_relation (klassifikation_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
    SELECT
        new_klassifikation_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType 
        FROM
            unnest(relationer) AS a ;

    


    -- Ad 2)
    -- 0..1 relations

    
    
    FOREACH klassifikation_relation_navn IN ARRAY ARRAY['ansvarlig'::KlassifikationRelationKode ,  'ejer'::KlassifikationRelationKode  ]::KlassifikationRelationKode[]  LOOP
        INSERT INTO klassifikation_relation (klassifikation_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
        SELECT
            new_klassifikation_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM klassifikation_relation b
                 WHERE b.klassifikation_registrering_id = new_klassifikation_registrering.id AND b.rel_type = klassifikation_relation_navn) d
            JOIN klassifikation_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.klassifikation_registrering_id = prev_klassifikation_registrering.id AND a.rel_type = klassifikation_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
    FOREACH klassifikation_relation_navn IN ARRAY ARRAY[]::KlassifikationRelationKode[] LOOP
        IF NOT EXISTS (
                    SELECT 1
                      FROM klassifikation_relation
                     WHERE klassifikation_registrering_id = new_klassifikation_registrering.id AND rel_type = klassifikation_relation_navn) THEN
                    
                    INSERT INTO klassifikation_relation (klassifikation_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
                    SELECT
                        new_klassifikation_registrering.id,  virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type
        FROM klassifikation_relation
        WHERE
            klassifikation_registrering_id = prev_klassifikation_registrering.id AND rel_type = klassifikation_relation_navn ;

    
        END IF;
    END LOOP;
    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsPubliceret IS NOT NULL AND coalesce(array_length(tilsPubliceret, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Publiceret] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- klassifikation_tils_publiceret

        -- Ad 1)
        INSERT INTO klassifikation_tils_publiceret(virkning, publiceret, klassifikation_registrering_id)
             SELECT a.virkning, a.publiceret, new_klassifikation_registrering.id
               FROM unnest(tilsPubliceret) AS a;

        -- Ad 2
        INSERT INTO klassifikation_tils_publiceret(virkning, publiceret, klassifikation_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.publiceret,
            new_klassifikation_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- klassifikation_tils_publiceret of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- klassifikation_tils_publiceret of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM klassifikation_tils_publiceret b
             WHERE b.klassifikation_registrering_id = new_klassifikation_registrering.id) d
              JOIN klassifikation_tils_publiceret a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.klassifikation_registrering_id = prev_klassifikation_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- klassifikation_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrKlassifikationObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.beskrivelse,a.kaldenavn,a.ophavsret,a.integrationsdata,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update klassifikation with uuid [%], as the klassifikation have overlapping virknings in the given egenskaber array :%', klassifikation_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).beskrivelse IS NULL  OR  (attrEgenskaberObj).kaldenavn IS NULL  OR  (attrEgenskaberObj).ophavsret IS NULL  OR  (attrEgenskaberObj).integrationsdata IS NULL  THEN
            
            INSERT INTO klassifikation_attr_egenskaber ( brugervendtnoegle,beskrivelse,kaldenavn,ophavsret,integrationsdata, virkning, klassifikation_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.beskrivelse, a.beskrivelse),
                    
                        
                        
                            coalesce(attrEgenskaberObj.kaldenavn, a.kaldenavn),
                    
                        
                        
                            coalesce(attrEgenskaberObj.ophavsret, a.ophavsret),
                    
                        
                        
                            coalesce(attrEgenskaberObj.integrationsdata, a.integrationsdata),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_klassifikation_registrering.id
                        FROM klassifikation_attr_egenskaber a
                    WHERE
                        a.klassifikation_registrering_id = prev_klassifikation_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO klassifikation_attr_egenskaber ( brugervendtnoegle,beskrivelse,kaldenavn,ophavsret,integrationsdata, virkning, klassifikation_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.beskrivelse,
                    
                     attrEgenskaberObj.kaldenavn,
                    
                     attrEgenskaberObj.ophavsret,
                    
                     attrEgenskaberObj.integrationsdata,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_klassifikation_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the klassifikation_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM klassifikation_attr_egenskaber b
                    WHERE b.klassifikation_registrering_id = new_klassifikation_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO klassifikation_attr_egenskaber ( brugervendtnoegle,beskrivelse,kaldenavn,ophavsret,integrationsdata, virkning, klassifikation_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.beskrivelse,  attrEgenskaberObj.kaldenavn,  attrEgenskaberObj.ophavsret,  attrEgenskaberObj.integrationsdata, attrEgenskaberObj.virkning, new_klassifikation_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO klassifikation_attr_egenskaber ( brugervendtnoegle,beskrivelse,kaldenavn,ophavsret,integrationsdata, virkning, klassifikation_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.beskrivelse,
        
            a.kaldenavn,
        
            a.ophavsret,
        
            a.integrationsdata,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_klassifikation_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- klassifikation_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- klassifikation_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                klassifikation_attr_egenskaber b
            WHERE
                b.klassifikation_registrering_id = new_klassifikation_registrering.id) d
            JOIN klassifikation_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.klassifikation_registrering_id = prev_klassifikation_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_klassifikation := as_read_klassifikation(klassifikation_uuid, (new_klassifikation_registrering.registrering).timeperiod, null);
    read_prev_klassifikation := as_read_klassifikation(klassifikation_uuid, (prev_klassifikation_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_klassifikation.registrering[1].registrering).TimePeriod) = lower((new_klassifikation_registrering.registrering).TimePeriod) and lower((read_prev_klassifikation.registrering[1].registrering).TimePeriod)=lower((prev_klassifikation_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating klassifikation with id [%]: The ordering of as_list_klassifikation should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', klassifikation_uuid, to_json(new_klassifikation_registrering), to_json(read_new_klassifikation.registrering[1].registrering), to_json(prev_klassifikation_registrering), to_json(prev_new_klassifikation.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_klassifikation_reg := ROW(
        ROW (null, (read_new_klassifikation.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_klassifikation.registrering[1]).tilsPubliceret ,
        
        (read_new_klassifikation.registrering[1]).attrEgenskaber ,
        (read_new_klassifikation.registrering[1]).relationer
    )::klassifikationRegistreringType;

    read_prev_klassifikation_reg := ROW(
        ROW(null, (read_prev_klassifikation.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_klassifikation.registrering[1]).tilsPubliceret ,
        
        (read_prev_klassifikation.registrering[1]).attrEgenskaber ,
        (read_prev_klassifikation.registrering[1]).relationer
    )::klassifikationRegistreringType;


    IF read_prev_klassifikation_reg = read_new_klassifikation_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_klassifikation_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_klassifikation_reg);
      RAISE EXCEPTION 'Aborted updating klassifikation with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', klassifikation_uuid, to_json(read_new_klassifikation_reg), to_json(read_prev_klassifikation_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_klassifikation_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_klassifikation (
    klassifikation_registrering KlassifikationRegistreringType,
    klassifikation_uuid uuid DEFAULT NULL, auth_criteria_arr
    KlassifikationRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE klassifikation_registrering_id bigint;

    
    klassifikation_attr_egenskaber_obj klassifikationEgenskaberAttrType;
    

    
    klassifikation_tils_publiceret_obj klassifikationPubliceretTilsType;
    

    klassifikation_relationer KlassifikationRelationType;

    

    auth_filtered_uuids uuid[];

    

    does_exist boolean;
    new_klassifikation_registrering klassifikation_registrering;
BEGIN
    IF klassifikation_uuid IS NULL THEN LOOP
        klassifikation_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from klassifikation WHERE id=klassifikation_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from klassifikation WHERE id=klassifikation_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (klassifikation_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (klassifikation_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (klassifikation_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_klassifikation.',(klassifikation_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO klassifikation (ID) SELECT
        klassifikation_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        klassifikation_registrering_id:=nextval('klassifikation_registrering_id_seq');

        INSERT INTO klassifikation_registrering (id, klassifikation_id,
            registrering) SELECT klassifikation_registrering_id,
        klassifikation_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (klassifikation_registrering.registrering).livscykluskode,
        (klassifikation_registrering.registrering).brugerref,
        (klassifikation_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_klassifikation_registrering :=
            _as_create_klassifikation_registrering(klassifikation_uuid,
                (klassifikation_registrering.registrering).livscykluskode,
                (klassifikation_registrering.registrering).brugerref,
                (klassifikation_registrering.registrering).note);

            klassifikation_registrering_id := new_klassifikation_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(klassifikation_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [klassifikation]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF klassifikation_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(klassifikation_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH klassifikation_attr_egenskaber_obj IN ARRAY klassifikation_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO klassifikation_attr_egenskaber (
      
      brugervendtnoegle,
      beskrivelse,
      kaldenavn,
      ophavsret,
      integrationsdata,
      virkning,
      klassifikation_registrering_id
    )
    SELECT
     
     klassifikation_attr_egenskaber_obj.brugervendtnoegle,
      klassifikation_attr_egenskaber_obj.beskrivelse,
      klassifikation_attr_egenskaber_obj.kaldenavn,
      klassifikation_attr_egenskaber_obj.ophavsret,
      klassifikation_attr_egenskaber_obj.integrationsdata,
      klassifikation_attr_egenskaber_obj.virkning,
      klassifikation_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(klassifikation_registrering.tilsPubliceret, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [publiceret] for klassifikation. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF klassifikation_registrering.tilsPubliceret IS NOT NULL AND coalesce(array_length(klassifikation_registrering.tilsPubliceret,1),0)>0 THEN
  FOREACH klassifikation_tils_publiceret_obj IN ARRAY klassifikation_registrering.tilsPubliceret
  LOOP

    INSERT INTO klassifikation_tils_publiceret (
      virkning,
      publiceret,
      klassifikation_registrering_id
    )
    SELECT
      klassifikation_tils_publiceret_obj.virkning,
      klassifikation_tils_publiceret_obj.publiceret,
      klassifikation_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations



    INSERT INTO klassifikation_relation (
      klassifikation_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      klassifikation_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(klassifikation_registrering.relationer) a
  ;




/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_klassifikation(array[klassifikation_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[klassifikation_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import klassifikation with uuid [%]. Object does not met stipulated criteria:%',klassifikation_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN klassifikation_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_klassifikation(klassifikation_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr KlassifikationRegistreringType[]=null
  )
  RETURNS KlassifikationType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result KlassifikationType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_klassifikation(klassifikation_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(klassifikation_uuids,1),0) AND auth_filtered_uuids @>klassifikation_uuids) THEN
  RAISE EXCEPTION 'Unable to list klassifikation with uuids [%]. All objects do not fullfill the stipulated criteria:%',klassifikation_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.klassifikationObj) into result
FROM
(
SELECT
ROW(
	a.klassifikation_id,
	array_agg(
		ROW (
			a.registrering,
			a.KlassifikationTilsPubliceretArr,
			a.KlassifikationAttrEgenskaberArr,
			a.KlassifikationRelationArr
		)::KlassifikationRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: KlassifikationType  klassifikationObj
FROM
(
	SELECT
	a.klassifikation_id,
	a.klassifikation_registrering_id,
	a.registrering,
	a.KlassifikationAttrEgenskaberArr,
	a.KlassifikationTilsPubliceretArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type
			):: KlassifikationRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
        
	)) KlassifikationRelationArr
	FROM
	(
			SELECT
			a.klassifikation_id,
			a.klassifikation_registrering_id,
			a.registrering,
			a.KlassifikationAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.publiceret
						) ::KlassifikationPubliceretTilsType
					ELSE NULL
					END
					order by b.publiceret,b.virkning
				)) KlassifikationTilsPubliceretArr		
			FROM
			(
					SELECT
					a.klassifikation_id,
					a.klassifikation_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.beskrivelse,
					 		b.kaldenavn,
					 		b.ophavsret,
					 		b.integrationsdata,
					   		b.virkning
                            
							)::KlassifikationEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.beskrivelse,b.kaldenavn,b.ophavsret,b.integrationsdata,b.virkning
                        
					)) KlassifikationAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id klassifikation_id,
					b.id klassifikation_registrering_id,
					b.registrering			
					FROM		klassifikation a
					JOIN 		klassifikation_registrering b 	ON b.klassifikation_id=a.id
					WHERE a.id = ANY (klassifikation_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN klassifikation_attr_egenskaber as b ON b.klassifikation_registrering_id=a.klassifikation_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.klassifikation_id,
					a.klassifikation_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN klassifikation_tils_publiceret as b ON b.klassifikation_registrering_id=a.klassifikation_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.klassifikation_id,
			a.klassifikation_registrering_id,
			a.registrering,
			a.KlassifikationAttrEgenskaberArr
	) as a
	LEFT JOIN klassifikation_relation b ON b.klassifikation_registrering_id=a.klassifikation_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.klassifikation_id,
	a.klassifikation_registrering_id,
	a.registrering,
	a.KlassifikationAttrEgenskaberArr,
	a.KlassifikationTilsPubliceretArr
) as a

WHERE a.klassifikation_id IS NOT NULL
GROUP BY 
a.klassifikation_id
order by a.klassifikation_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_klassifikation(
    klassifikation_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      KlassifikationRegistreringType[]=null
) RETURNS KlassifikationType AS $$
DECLARE
	resArr KlassifikationType[];
BEGIN
    resArr := as_list_klassifikation(ARRAY[klassifikation_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_klassifikation(
    firstResult int,--TOOD ??
    klassifikation_uuid uuid,
    registreringObj   KlassifikationRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr KlassifikationRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    klassifikation_candidates uuid[];
    klassifikation_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj KlassifikationEgenskaberAttrType;

    
    tilsPubliceretTypeObj KlassifikationPubliceretTilsType;

    relationTypeObj KlassifikationRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

klassifikation_candidates_is_initialized := false;

IF klassifikation_uuid is not NULL THEN
    klassifikation_candidates:= ARRAY[klassifikation_uuid];
    klassifikation_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        klassifikation_candidates:=array(
                SELECT DISTINCT
                b.klassifikation_id
                FROM
                klassifikation a
                JOIN klassifikation_registrering b on b.klassifikation_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'klassifikation_candidates_is_initialized step 1:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 1:%',klassifikation_candidates;
--/****************************//


--RAISE NOTICE 'klassifikation_candidates_is_initialized step 2:%',klassifikation_candidates_is_initialized;
--RAISE NOTICE 'klassifikation_candidates step 2:%',klassifikation_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_klassifikation: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(klassifikation_candidates,1),0)>0 OR NOT klassifikation_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            klassifikation_candidates:=array(
            SELECT DISTINCT
            b.klassifikation_id
            FROM  klassifikation_attr_egenskaber a
            JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.beskrivelse IS NULL
                    OR
                    a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.kaldenavn IS NULL
                    OR
                    a.kaldenavn ILIKE attrEgenskaberTypeObj.kaldenavn --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.ophavsret IS NULL
                    OR
                    a.ophavsret ILIKE attrEgenskaberTypeObj.ophavsret --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.integrationsdata IS NULL
                    OR
                    a.integrationsdata ILIKE attrEgenskaberTypeObj.integrationsdata --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )

            );


            klassifikation_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'klassifikation_candidates_is_initialized step 3:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 3:%',klassifikation_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        klassifikation_candidates:=array(

            SELECT DISTINCT
            b.klassifikation_id
            
            FROM  klassifikation_attr_egenskaber a
            JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.beskrivelse ILIKE anyAttrValue OR
                        a.kaldenavn ILIKE anyAttrValue OR
                        a.ophavsret ILIKE anyAttrValue OR
                        a.integrationsdata ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )


        );

    klassifikation_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
    --RAISE DEBUG 'as_search_klassifikation: skipping filtration on tilsPubliceret';
ELSE
    IF (coalesce(array_length(klassifikation_candidates,1),0)>0 OR klassifikation_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
        LOOP
            klassifikation_candidates:=array(
            SELECT DISTINCT
            b.klassifikation_id
            FROM  klassifikation_tils_publiceret a
            JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id
            WHERE
                (
                    tilsPubliceretTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsPubliceretTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).AktoerRef IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsPubliceretTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsPubliceretTypeObj.virkning) IS NULL OR (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsPubliceretTypeObj.publiceret IS NULL
                    OR
                    tilsPubliceretTypeObj.publiceret = a.publiceret
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )

    );


            klassifikation_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer KlassifikationRelationType[]
*/


--RAISE DEBUG 'klassifikation_candidates_is_initialized step 4:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 4:%',klassifikation_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_klassifikation: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(klassifikation_candidates,1),0)>0 OR NOT klassifikation_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            klassifikation_candidates:=array(
            SELECT DISTINCT
            b.klassifikation_id
            FROM  klassifikation_relation a
            JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )

    );

            klassifikation_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        klassifikation_candidates:=array(
            SELECT DISTINCT
            b.klassifikation_id
            
            FROM  klassifikation_relation a
            JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )


            );

    klassifikation_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        klassifikation_candidates:=array(
            SELECT DISTINCT
            b.klassifikation_id
            
            FROM  klassifikation_relation a
            JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )


            );

    klassifikation_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 




--RAISE DEBUG 'klassifikation_candidates_is_initialized step 5:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 5:%',klassifikation_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT klassifikation_candidates_is_initialized THEN
        klassifikation_candidates:=array(
        SELECT DISTINCT
            klassifikation_id
        FROM
            klassifikation_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT klassifikation_candidates_is_initialized) OR b.klassifikation_id = ANY (klassifikation_candidates) )

        )
        ;

        klassifikation_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT klassifikation_candidates_is_initialized THEN
    --No filters applied!
    klassifikation_candidates:=array(
        SELECT DISTINCT id FROM klassifikation a
    );
ELSE
    klassifikation_candidates:=array(
        SELECT DISTINCT id FROM unnest(klassifikation_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'klassifikation_candidates_is_initialized step 6:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 6:%',klassifikation_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_klassifikation(klassifikation_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_klassifikation(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_KlassifikationRegistreringType_to_json(KlassifikationRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END klassifikationegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsPubliceret,1),0)>0 THEN to_json($1.tilsPubliceret) 
        ELSE 
        NULL
        END klassifikationpubliceret
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::KlassifikationRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (KlassifikationRegistreringType as json);
create cast (KlassifikationRegistreringType as json) with function actual_state._cast_KlassifikationRegistreringType_to_json(KlassifikationRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_klassifikationType_to_json(KlassifikationType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg KlassifikationRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (KlassifikationType as json);
create cast (KlassifikationType as json) with function actual_state._cast_klassifikationType_to_json(KlassifikationType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_klassifikation(
    klassifikation_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    KlassifikationRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    klassifikation_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    klassifikation_sorted_uuid:=array(
          SELECT b.klassifikation_id
            FROM klassifikation_registrering b
            JOIN klassifikation_attr_egenskaber a ON a.klassifikation_registrering_id=b.id
           WHERE b.klassifikation_id = ANY (klassifikation_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.klassifikation_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.klassifikation_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN klassifikation_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_klassifikation(
	klassifikation_uuids uuid[],
	registreringObjArr KlassifikationRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	klassifikation_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	klassifikation_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj KlassifikationEgenskaberAttrType;
	
  	tilsPubliceretTypeObj KlassifikationPubliceretTilsType;
	relationTypeObj KlassifikationRelationType;
	registreringObj KlassifikationRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN klassifikation_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF klassifikation_uuids IS NULL OR coalesce(array_length(klassifikation_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

klassifikation_candidates:= klassifikation_uuids;



--RAISE DEBUG 'klassifikation_candidates_is_initialized step 1:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 1:%',klassifikation_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_klassifikation: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(klassifikation_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			klassifikation_candidates:=array(
			SELECT DISTINCT
			b.klassifikation_id 
			FROM  klassifikation_attr_egenskaber a 
			JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.kaldenavn IS NULL
					OR 
					a.kaldenavn = attrEgenskaberTypeObj.kaldenavn 
				)
				AND
				(
					attrEgenskaberTypeObj.ophavsret IS NULL
					OR 
					a.ophavsret = attrEgenskaberTypeObj.ophavsret 
				)
				AND
				(
					attrEgenskaberTypeObj.integrationsdata IS NULL
					OR 
					a.integrationsdata = attrEgenskaberTypeObj.integrationsdata 
				)
				AND b.klassifikation_id = ANY (klassifikation_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'klassifikation_candidates_is_initialized step 3:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 3:%',klassifikation_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_klassifikation: skipping filtration on tilsPubliceret';
ELSE
	IF coalesce(array_length(klassifikation_candidates,1),0)>0 THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			klassifikation_candidates:=array(
			SELECT DISTINCT
			b.klassifikation_id 
			FROM  klassifikation_tils_publiceret a
			JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND b.klassifikation_id = ANY (klassifikation_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer KlassifikationRelationType[]
*/


--RAISE DEBUG 'klassifikation_candidates_is_initialized step 4:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 4:%',klassifikation_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_klassifikation: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(klassifikation_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			klassifikation_candidates:=array(
			SELECT DISTINCT
			b.klassifikation_id 
			FROM  klassifikation_relation a
			JOIN klassifikation_registrering b on a.klassifikation_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.klassifikation_id = ANY (klassifikation_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'klassifikation_candidates_is_initialized step 5:%',klassifikation_candidates_is_initialized;
--RAISE DEBUG 'klassifikation_candidates step 5:%',klassifikation_candidates;

klassifikation_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (klassifikation_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (klassifikation_candidates) b(id)
);

--optimization 
IF coalesce(array_length(klassifikation_passed_auth_filter,1),0)=coalesce(array_length(klassifikation_uuids,1),0) AND klassifikation_passed_auth_filter @>klassifikation_uuids THEN
	RETURN klassifikation_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN klassifikation_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE LoghaendelseGyldighedTils AS ENUM ('Rettet','Ikke rettet',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE LoghaendelseGyldighedTilsType AS (
    virkning Virkning,
    gyldighed LoghaendelseGyldighedTils
)
;



CREATE TYPE LoghaendelseEgenskaberAttrType AS (
service text,
klasse text,
tidspunkt text,
operation text,
objekttype text,
returkode text,
returtekst text,
note text,

 virkning Virkning
);




CREATE TYPE LoghaendelseRelationKode AS ENUM  ('objekt','bruger','brugerrolle');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_loghaendelse_relation_kode_to_txt is invoked.



CREATE TYPE LoghaendelseRelationType AS (
  relType LoghaendelseRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text
)
;



CREATE TYPE LoghaendelseRegistreringType AS
(
registrering RegistreringBase,
tilsGyldighed LoghaendelseGyldighedTilsType[],
attrEgenskaber LoghaendelseEgenskaberAttrType[],
relationer LoghaendelseRelationType[]
);

CREATE TYPE LoghaendelseType AS
(
  id uuid,
  registrering LoghaendelseRegistreringType[]
);  





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_loghaendelse_relation_kode_to_txt(
    LoghaendelseRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE loghaendelse (
    id uuid NOT NULL,
    CONSTRAINT loghaendelse_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE loghaendelse
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE loghaendelse_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE loghaendelse_registrering_id_seq
    OWNER TO mox;


CREATE TABLE loghaendelse_registrering (
   id bigint NOT NULL DEFAULT nextval('loghaendelse_registrering_id_seq'::regclass),
   loghaendelse_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT loghaendelse_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT loghaendelse_registrering_loghaendelse_fkey FOREIGN KEY (loghaendelse_id)
       REFERENCES loghaendelse (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT loghaendelse_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(loghaendelse_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE loghaendelse_registrering
  OWNER TO mox;


CREATE INDEX loghaendelse_registrering_idx_livscykluskode
    ON loghaendelse_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX loghaendelse_registrering_idx_brugerref
    ON loghaendelse_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX loghaendelse_registrering_idx_note
    ON loghaendelse_registrering
    USING btree
    (((registrering).note));


CREATE INDEX loghaendelse_registrering_pat_note
    ON loghaendelse_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX loghaendelse_id_idx
    ON loghaendelse_registrering (loghaendelse_id);


CREATE TRIGGER notify_loghaendelse
    AFTER INSERT OR UPDATE OR DELETE ON loghaendelse_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE loghaendelse_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE loghaendelse_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE loghaendelse_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('loghaendelse_attr_egenskaber_id_seq'::regclass),
        service text  NULL,
        klasse text  NULL,
        tidspunkt text  NULL,
        operation text  NULL,
        objekttype text  NULL,
        returkode text  NULL,
        returtekst text  NULL,
        note text  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    loghaendelse_registrering_id bigint NOT NULL,
    CONSTRAINT loghaendelse_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT loghaendelse_attr_egenskaber_forkey_loghaendelseregistrering FOREIGN KEY (loghaendelse_registrering_id) REFERENCES loghaendelse_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT loghaendelse_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (loghaendelse_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE loghaendelse_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX loghaendelse_attr_egenskaber_pat_service
            ON loghaendelse_attr_egenskaber
            USING gin
            (service gin_trgm_ops);

        CREATE INDEX loghaendelse_attr_egenskaber_idx_service
            ON loghaendelse_attr_egenskaber
            USING btree
            (service); 
 
     
        CREATE INDEX loghaendelse_attr_egenskaber_pat_klasse
            ON loghaendelse_attr_egenskaber
            USING gin
            (klasse gin_trgm_ops);

        CREATE INDEX loghaendelse_attr_egenskaber_idx_klasse
            ON loghaendelse_attr_egenskaber
            USING btree
            (klasse); 
 
     
        CREATE INDEX loghaendelse_attr_egenskaber_pat_tidspunkt
            ON loghaendelse_attr_egenskaber
            USING gin
            (tidspunkt gin_trgm_ops);

        CREATE INDEX loghaendelse_attr_egenskaber_idx_tidspunkt
            ON loghaendelse_attr_egenskaber
            USING btree
            (tidspunkt); 
 
     
        CREATE INDEX loghaendelse_attr_egenskaber_pat_operation
            ON loghaendelse_attr_egenskaber
            USING gin
            (operation gin_trgm_ops);

        CREATE INDEX loghaendelse_attr_egenskaber_idx_operation
            ON loghaendelse_attr_egenskaber
            USING btree
            (operation); 
 
     
        CREATE INDEX loghaendelse_attr_egenskaber_pat_objekttype
            ON loghaendelse_attr_egenskaber
            USING gin
            (objekttype gin_trgm_ops);

        CREATE INDEX loghaendelse_attr_egenskaber_idx_objekttype
            ON loghaendelse_attr_egenskaber
            USING btree
            (objekttype); 
 
     
        CREATE INDEX loghaendelse_attr_egenskaber_pat_returkode
            ON loghaendelse_attr_egenskaber
            USING gin
            (returkode gin_trgm_ops);

        CREATE INDEX loghaendelse_attr_egenskaber_idx_returkode
            ON loghaendelse_attr_egenskaber
            USING btree
            (returkode); 
 
     
        CREATE INDEX loghaendelse_attr_egenskaber_pat_returtekst
            ON loghaendelse_attr_egenskaber
            USING gin
            (returtekst gin_trgm_ops);

        CREATE INDEX loghaendelse_attr_egenskaber_idx_returtekst
            ON loghaendelse_attr_egenskaber
            USING btree
            (returtekst); 
 
     
        CREATE INDEX loghaendelse_attr_egenskaber_pat_note
            ON loghaendelse_attr_egenskaber
            USING gin
            (note gin_trgm_ops);

        CREATE INDEX loghaendelse_attr_egenskaber_idx_note
            ON loghaendelse_attr_egenskaber
            USING btree
            (note); 



CREATE INDEX loghaendelse_attr_egenskaber_idx_virkning_aktoerref
    ON loghaendelse_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX loghaendelse_attr_egenskaber_idx_virkning_aktoertypekode
    ON loghaendelse_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX loghaendelse_attr_egenskaber_idx_virkning_notetekst
    ON loghaendelse_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX loghaendelse_attr_egenskaber_pat_virkning_notetekst
    ON loghaendelse_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE loghaendelse_tils_gyldighed_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE loghaendelse_tils_gyldighed_id_seq
    OWNER TO mox;


CREATE TABLE loghaendelse_tils_gyldighed (
    id bigint NOT NULL DEFAULT nextval('loghaendelse_tils_gyldighed_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    gyldighed LoghaendelseGyldighedTils NOT NULL, 
    loghaendelse_registrering_id bigint not null,
    CONSTRAINT loghaendelse_tils_gyldighed_pkey PRIMARY KEY (id),
    CONSTRAINT loghaendelse_tils_gyldighed_forkey_loghaendelseregistrering FOREIGN KEY (loghaendelse_registrering_id) REFERENCES loghaendelse_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT loghaendelse_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (loghaendelse_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE loghaendelse_tils_gyldighed
    OWNER TO mox;


CREATE INDEX loghaendelse_tils_gyldighed_idx_gyldighed
    ON loghaendelse_tils_gyldighed
    USING btree
    (gyldighed);
  
CREATE INDEX loghaendelse_tils_gyldighed_idx_virkning_aktoerref
    ON loghaendelse_tils_gyldighed
    USING btree
    (((virkning).aktoerref));

CREATE INDEX loghaendelse_tils_gyldighed_idx_virkning_aktoertypekode
    ON loghaendelse_tils_gyldighed
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX loghaendelse_tils_gyldighed_idx_virkning_notetekst
    ON loghaendelse_tils_gyldighed
    USING btree
    (((virkning).notetekst));

CREATE INDEX loghaendelse_tils_gyldighed_pat_virkning_notetekst
    ON loghaendelse_tils_gyldighed
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE loghaendelse_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE loghaendelse_relation_id_seq
    OWNER TO mox;


CREATE TABLE loghaendelse_relation (
    id bigint NOT NULL DEFAULT nextval('loghaendelse_relation_id_seq'::regclass),
    loghaendelse_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type LoghaendelseRelationKode not null,
    objekt_type text null,

    

    CONSTRAINT loghaendelse_relation_forkey_loghaendelseregistrering FOREIGN KEY (loghaendelse_registrering_id) REFERENCES loghaendelse_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT loghaendelse_relation_pkey PRIMARY KEY (id),
    CONSTRAINT loghaendelse_relation_no_virkning_overlap EXCLUDE USING gist (loghaendelse_registrering_id WITH =, _as_convert_loghaendelse_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT loghaendelse_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE loghaendelse_relation
  OWNER TO mox;





CREATE INDEX loghaendelse_relation_idx_rel_maal_obj_uuid
    ON loghaendelse_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX loghaendelse_relation_idx_rel_maal_obj_urn
    ON loghaendelse_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX loghaendelse_relation_idx_rel_maal_uuid
    ON loghaendelse_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX loghaendelse_relation_idx_rel_maal_uuid_isolated
    ON loghaendelse_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX loghaendelse_relation_idx_rel_maal_urn_isolated
    ON loghaendelse_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX loghaendelse_relation_idx_rel_maal_urn
    ON loghaendelse_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX loghaendelse_relation_idx_virkning_aktoerref
    ON loghaendelse_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX loghaendelse_relation_idx_virkning_aktoertypekode
    ON loghaendelse_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX loghaendelse_relation_idx_virkning_notetekst
    ON loghaendelse_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX loghaendelse_relation_pat_virkning_notetekst
    ON loghaendelse_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr LoghaendelseGyldighedTilsType[])
  RETURNS LoghaendelseGyldighedTilsType[] AS
  $$
  DECLARE result LoghaendelseGyldighedTilsType[];
  DECLARE element LoghaendelseGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr LoghaendelseEgenskaberAttrType[])
  RETURNS LoghaendelseEgenskaberAttrType[] AS
  $$
  DECLARE result LoghaendelseEgenskaberAttrType[]; 
   DECLARE element LoghaendelseEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.service IS NULL AND element.klasse IS NULL AND element.tidspunkt IS NULL AND element.operation IS NULL AND element.objekttype IS NULL AND element.returkode IS NULL AND element.returtekst IS NULL AND element.note IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr LoghaendelseRelationType[])
RETURNS LoghaendelseRelationType[] AS
$$
 DECLARE result LoghaendelseRelationType[];
 DECLARE element LoghaendelseRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_loghaendelse_registrering(
    loghaendelse_registrering
) RETURNS loghaendelse_registrering AS $BODY$
  SELECT * FROM loghaendelse_registrering as a WHERE
    loghaendelse_id = $1.loghaendelse_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_loghaendelse_registrering(
    loghaendelse_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS loghaendelse_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    loghaendelse_registrering_id bigint;
    loghaendelse_registrering    loghaendelse_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE loghaendelse_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE loghaendelse_id = loghaendelse_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating loghaendelse with uuid [%], Invalid [livscyklus] transition to [%]',loghaendelse_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new loghaendelse registrering

    loghaendelse_registrering_id := nextval('loghaendelse_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    loghaendelse_registrering := ROW(
        loghaendelse_registrering_id,
        loghaendelse_uuid,
        registreringObj
    )::loghaendelse_registrering;

    INSERT INTO loghaendelse_registrering SELECT loghaendelse_registrering.*;

    RETURN loghaendelse_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of LoghaendelseAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_loghaendelse(
    loghaendelse_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber LoghaendelseEgenskaberAttrType[],
    

    
    tilsGyldighed LoghaendelseGyldighedTilsType[],
    

    relationer LoghaendelseRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      LoghaendelseRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_loghaendelse          LoghaendelseType;
    read_prev_loghaendelse         LoghaendelseType;
    read_new_loghaendelse_reg      LoghaendelseRegistreringType;
    read_prev_loghaendelse_reg     LoghaendelseRegistreringType;
    new_loghaendelse_registrering  loghaendelse_registrering;
    prev_loghaendelse_registrering loghaendelse_registrering;
    loghaendelse_relation_navn     LoghaendelseRelationKode;

    
    attrEgenskaberObj LoghaendelseEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from loghaendelse a join loghaendelse_registrering b ON b.loghaendelse_id=a.id WHERE a.id=loghaendelse_uuid) THEN
        RAISE EXCEPTION 'Unable to update loghaendelse with uuid [%], being unable to find any previous registrations.',loghaendelse_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM loghaendelse a WHERE a.id=loghaendelse_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_loghaendelse(array[loghaendelse_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[loghaendelse_uuid]) THEN
      RAISE EXCEPTION 'Unable to update loghaendelse with uuid [%]. Object does not met stipulated criteria:%', loghaendelse_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_loghaendelse_registrering := _as_create_loghaendelse_registrering(loghaendelse_uuid, livscykluskode, brugerref, note);
    prev_loghaendelse_registrering := _as_get_prev_loghaendelse_registrering(new_loghaendelse_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_loghaendelse_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update loghaendelse with uuid [%], as the loghaendelse seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', loghaendelse_uuid, lostUpdatePreventionTZ, LOWER((prev_loghaendelse_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    

    INSERT INTO loghaendelse_relation (loghaendelse_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
    SELECT
        new_loghaendelse_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType 
        FROM
            unnest(relationer) AS a ;

    


    -- Ad 2)
    -- 0..1 relations

    
    
    FOREACH loghaendelse_relation_navn IN ARRAY ARRAY['objekt'::LoghaendelseRelationKode ,  'bruger'::LoghaendelseRelationKode ,  'brugerrolle'::LoghaendelseRelationKode  ]::LoghaendelseRelationKode[]  LOOP
        INSERT INTO loghaendelse_relation (loghaendelse_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
        SELECT
            new_loghaendelse_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM loghaendelse_relation b
                 WHERE b.loghaendelse_registrering_id = new_loghaendelse_registrering.id AND b.rel_type = loghaendelse_relation_navn) d
            JOIN loghaendelse_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.loghaendelse_registrering_id = prev_loghaendelse_registrering.id AND a.rel_type = loghaendelse_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
    FOREACH loghaendelse_relation_navn IN ARRAY ARRAY[]::LoghaendelseRelationKode[] LOOP
        IF NOT EXISTS (
                    SELECT 1
                      FROM loghaendelse_relation
                     WHERE loghaendelse_registrering_id = new_loghaendelse_registrering.id AND rel_type = loghaendelse_relation_navn) THEN
                    
                    INSERT INTO loghaendelse_relation (loghaendelse_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
                    SELECT
                        new_loghaendelse_registrering.id,  virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type
        FROM loghaendelse_relation
        WHERE
            loghaendelse_registrering_id = prev_loghaendelse_registrering.id AND rel_type = loghaendelse_relation_navn ;

    
        END IF;
    END LOOP;
    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- loghaendelse_tils_gyldighed

        -- Ad 1)
        INSERT INTO loghaendelse_tils_gyldighed(virkning, gyldighed, loghaendelse_registrering_id)
             SELECT a.virkning, a.gyldighed, new_loghaendelse_registrering.id
               FROM unnest(tilsGyldighed) AS a;

        -- Ad 2
        INSERT INTO loghaendelse_tils_gyldighed(virkning, gyldighed, loghaendelse_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.gyldighed,
            new_loghaendelse_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- loghaendelse_tils_gyldighed of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- loghaendelse_tils_gyldighed of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM loghaendelse_tils_gyldighed b
             WHERE b.loghaendelse_registrering_id = new_loghaendelse_registrering.id) d
              JOIN loghaendelse_tils_gyldighed a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.loghaendelse_registrering_id = prev_loghaendelse_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- loghaendelse_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrLoghaendelseObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.service,a.klasse,a.tidspunkt,a.operation,a.objekttype,a.returkode,a.returtekst,a.note,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update loghaendelse with uuid [%], as the loghaendelse have overlapping virknings in the given egenskaber array :%', loghaendelse_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).service IS NULL  OR  (attrEgenskaberObj).klasse IS NULL  OR  (attrEgenskaberObj).tidspunkt IS NULL  OR  (attrEgenskaberObj).operation IS NULL  OR  (attrEgenskaberObj).objekttype IS NULL  OR  (attrEgenskaberObj).returkode IS NULL  OR  (attrEgenskaberObj).returtekst IS NULL  OR  (attrEgenskaberObj).note IS NULL  THEN
            
            INSERT INTO loghaendelse_attr_egenskaber ( service,klasse,tidspunkt,operation,objekttype,returkode,returtekst,note, virkning, loghaendelse_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.service, a.service),
                    
                        
                        
                            coalesce(attrEgenskaberObj.klasse, a.klasse),
                    
                        
                        
                            coalesce(attrEgenskaberObj.tidspunkt, a.tidspunkt),
                    
                        
                        
                            coalesce(attrEgenskaberObj.operation, a.operation),
                    
                        
                        
                            coalesce(attrEgenskaberObj.objekttype, a.objekttype),
                    
                        
                        
                            coalesce(attrEgenskaberObj.returkode, a.returkode),
                    
                        
                        
                            coalesce(attrEgenskaberObj.returtekst, a.returtekst),
                    
                        
                        
                            coalesce(attrEgenskaberObj.note, a.note),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_loghaendelse_registrering.id
                        FROM loghaendelse_attr_egenskaber a
                    WHERE
                        a.loghaendelse_registrering_id = prev_loghaendelse_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO loghaendelse_attr_egenskaber ( service,klasse,tidspunkt,operation,objekttype,returkode,returtekst,note, virkning, loghaendelse_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.service,
                    
                     attrEgenskaberObj.klasse,
                    
                     attrEgenskaberObj.tidspunkt,
                    
                     attrEgenskaberObj.operation,
                    
                     attrEgenskaberObj.objekttype,
                    
                     attrEgenskaberObj.returkode,
                    
                     attrEgenskaberObj.returtekst,
                    
                     attrEgenskaberObj.note,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_loghaendelse_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the loghaendelse_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM loghaendelse_attr_egenskaber b
                    WHERE b.loghaendelse_registrering_id = new_loghaendelse_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO loghaendelse_attr_egenskaber ( service,klasse,tidspunkt,operation,objekttype,returkode,returtekst,note, virkning, loghaendelse_registrering_id)
                VALUES (  attrEgenskaberObj.service,  attrEgenskaberObj.klasse,  attrEgenskaberObj.tidspunkt,  attrEgenskaberObj.operation,  attrEgenskaberObj.objekttype,  attrEgenskaberObj.returkode,  attrEgenskaberObj.returtekst,  attrEgenskaberObj.note, attrEgenskaberObj.virkning, new_loghaendelse_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO loghaendelse_attr_egenskaber ( service,klasse,tidspunkt,operation,objekttype,returkode,returtekst,note, virkning, loghaendelse_registrering_id)
    SELECT
        
        
            a.service,
        
            a.klasse,
        
            a.tidspunkt,
        
            a.operation,
        
            a.objekttype,
        
            a.returkode,
        
            a.returtekst,
        
            a.note,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_loghaendelse_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- loghaendelse_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- loghaendelse_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                loghaendelse_attr_egenskaber b
            WHERE
                b.loghaendelse_registrering_id = new_loghaendelse_registrering.id) d
            JOIN loghaendelse_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.loghaendelse_registrering_id = prev_loghaendelse_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_loghaendelse := as_read_loghaendelse(loghaendelse_uuid, (new_loghaendelse_registrering.registrering).timeperiod, null);
    read_prev_loghaendelse := as_read_loghaendelse(loghaendelse_uuid, (prev_loghaendelse_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_loghaendelse.registrering[1].registrering).TimePeriod) = lower((new_loghaendelse_registrering.registrering).TimePeriod) and lower((read_prev_loghaendelse.registrering[1].registrering).TimePeriod)=lower((prev_loghaendelse_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating loghaendelse with id [%]: The ordering of as_list_loghaendelse should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', loghaendelse_uuid, to_json(new_loghaendelse_registrering), to_json(read_new_loghaendelse.registrering[1].registrering), to_json(prev_loghaendelse_registrering), to_json(prev_new_loghaendelse.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_loghaendelse_reg := ROW(
        ROW (null, (read_new_loghaendelse.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_loghaendelse.registrering[1]).tilsGyldighed ,
        
        (read_new_loghaendelse.registrering[1]).attrEgenskaber ,
        (read_new_loghaendelse.registrering[1]).relationer
    )::loghaendelseRegistreringType;

    read_prev_loghaendelse_reg := ROW(
        ROW(null, (read_prev_loghaendelse.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_loghaendelse.registrering[1]).tilsGyldighed ,
        
        (read_prev_loghaendelse.registrering[1]).attrEgenskaber ,
        (read_prev_loghaendelse.registrering[1]).relationer
    )::loghaendelseRegistreringType;


    IF read_prev_loghaendelse_reg = read_new_loghaendelse_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_loghaendelse_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_loghaendelse_reg);
      RAISE EXCEPTION 'Aborted updating loghaendelse with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', loghaendelse_uuid, to_json(read_new_loghaendelse_reg), to_json(read_prev_loghaendelse_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_loghaendelse_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_loghaendelse (
    loghaendelse_registrering LoghaendelseRegistreringType,
    loghaendelse_uuid uuid DEFAULT NULL, auth_criteria_arr
    LoghaendelseRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE loghaendelse_registrering_id bigint;

    
    loghaendelse_attr_egenskaber_obj loghaendelseEgenskaberAttrType;
    

    
    loghaendelse_tils_gyldighed_obj loghaendelseGyldighedTilsType;
    

    loghaendelse_relationer LoghaendelseRelationType;

    

    auth_filtered_uuids uuid[];

    

    does_exist boolean;
    new_loghaendelse_registrering loghaendelse_registrering;
BEGIN
    IF loghaendelse_uuid IS NULL THEN LOOP
        loghaendelse_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from loghaendelse WHERE id=loghaendelse_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from loghaendelse WHERE id=loghaendelse_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (loghaendelse_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (loghaendelse_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (loghaendelse_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_loghaendelse.',(loghaendelse_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO loghaendelse (ID) SELECT
        loghaendelse_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        loghaendelse_registrering_id:=nextval('loghaendelse_registrering_id_seq');

        INSERT INTO loghaendelse_registrering (id, loghaendelse_id,
            registrering) SELECT loghaendelse_registrering_id,
        loghaendelse_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (loghaendelse_registrering.registrering).livscykluskode,
        (loghaendelse_registrering.registrering).brugerref,
        (loghaendelse_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_loghaendelse_registrering :=
            _as_create_loghaendelse_registrering(loghaendelse_uuid,
                (loghaendelse_registrering.registrering).livscykluskode,
                (loghaendelse_registrering.registrering).brugerref,
                (loghaendelse_registrering.registrering).note);

            loghaendelse_registrering_id := new_loghaendelse_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(loghaendelse_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [loghaendelse]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF loghaendelse_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(loghaendelse_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH loghaendelse_attr_egenskaber_obj IN ARRAY loghaendelse_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO loghaendelse_attr_egenskaber (
      
      service,
      klasse,
      tidspunkt,
      operation,
      objekttype,
      returkode,
      returtekst,
      note,
      virkning,
      loghaendelse_registrering_id
    )
    SELECT
     
     loghaendelse_attr_egenskaber_obj.service,
      loghaendelse_attr_egenskaber_obj.klasse,
      loghaendelse_attr_egenskaber_obj.tidspunkt,
      loghaendelse_attr_egenskaber_obj.operation,
      loghaendelse_attr_egenskaber_obj.objekttype,
      loghaendelse_attr_egenskaber_obj.returkode,
      loghaendelse_attr_egenskaber_obj.returtekst,
      loghaendelse_attr_egenskaber_obj.note,
      loghaendelse_attr_egenskaber_obj.virkning,
      loghaendelse_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(loghaendelse_registrering.tilsGyldighed, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [gyldighed] for loghaendelse. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF loghaendelse_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(loghaendelse_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH loghaendelse_tils_gyldighed_obj IN ARRAY loghaendelse_registrering.tilsGyldighed
  LOOP

    INSERT INTO loghaendelse_tils_gyldighed (
      virkning,
      gyldighed,
      loghaendelse_registrering_id
    )
    SELECT
      loghaendelse_tils_gyldighed_obj.virkning,
      loghaendelse_tils_gyldighed_obj.gyldighed,
      loghaendelse_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations



    INSERT INTO loghaendelse_relation (
      loghaendelse_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      loghaendelse_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(loghaendelse_registrering.relationer) a
  ;




/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_loghaendelse(array[loghaendelse_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[loghaendelse_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import loghaendelse with uuid [%]. Object does not met stipulated criteria:%',loghaendelse_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN loghaendelse_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_loghaendelse(loghaendelse_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr LoghaendelseRegistreringType[]=null
  )
  RETURNS LoghaendelseType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result LoghaendelseType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_loghaendelse(loghaendelse_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(loghaendelse_uuids,1),0) AND auth_filtered_uuids @>loghaendelse_uuids) THEN
  RAISE EXCEPTION 'Unable to list loghaendelse with uuids [%]. All objects do not fullfill the stipulated criteria:%',loghaendelse_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.loghaendelseObj) into result
FROM
(
SELECT
ROW(
	a.loghaendelse_id,
	array_agg(
		ROW (
			a.registrering,
			a.LoghaendelseTilsGyldighedArr,
			a.LoghaendelseAttrEgenskaberArr,
			a.LoghaendelseRelationArr
		)::LoghaendelseRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: LoghaendelseType  loghaendelseObj
FROM
(
	SELECT
	a.loghaendelse_id,
	a.loghaendelse_registrering_id,
	a.registrering,
	a.LoghaendelseAttrEgenskaberArr,
	a.LoghaendelseTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type
			):: LoghaendelseRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
        
	)) LoghaendelseRelationArr
	FROM
	(
			SELECT
			a.loghaendelse_id,
			a.loghaendelse_registrering_id,
			a.registrering,
			a.LoghaendelseAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::LoghaendelseGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) LoghaendelseTilsGyldighedArr		
			FROM
			(
					SELECT
					a.loghaendelse_id,
					a.loghaendelse_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.service,
					 		b.klasse,
					 		b.tidspunkt,
					 		b.operation,
					 		b.objekttype,
					 		b.returkode,
					 		b.returtekst,
					 		b.note,
					   		b.virkning
                            
							)::LoghaendelseEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.service,b.klasse,b.tidspunkt,b.operation,b.objekttype,b.returkode,b.returtekst,b.note,b.virkning
                        
					)) LoghaendelseAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id loghaendelse_id,
					b.id loghaendelse_registrering_id,
					b.registrering			
					FROM		loghaendelse a
					JOIN 		loghaendelse_registrering b 	ON b.loghaendelse_id=a.id
					WHERE a.id = ANY (loghaendelse_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN loghaendelse_attr_egenskaber as b ON b.loghaendelse_registrering_id=a.loghaendelse_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.loghaendelse_id,
					a.loghaendelse_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN loghaendelse_tils_gyldighed as b ON b.loghaendelse_registrering_id=a.loghaendelse_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.loghaendelse_id,
			a.loghaendelse_registrering_id,
			a.registrering,
			a.LoghaendelseAttrEgenskaberArr
	) as a
	LEFT JOIN loghaendelse_relation b ON b.loghaendelse_registrering_id=a.loghaendelse_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.loghaendelse_id,
	a.loghaendelse_registrering_id,
	a.registrering,
	a.LoghaendelseAttrEgenskaberArr,
	a.LoghaendelseTilsGyldighedArr
) as a

WHERE a.loghaendelse_id IS NOT NULL
GROUP BY 
a.loghaendelse_id
order by a.loghaendelse_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_loghaendelse(
    loghaendelse_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      LoghaendelseRegistreringType[]=null
) RETURNS LoghaendelseType AS $$
DECLARE
	resArr LoghaendelseType[];
BEGIN
    resArr := as_list_loghaendelse(ARRAY[loghaendelse_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_loghaendelse(
    firstResult int,--TOOD ??
    loghaendelse_uuid uuid,
    registreringObj   LoghaendelseRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr LoghaendelseRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    loghaendelse_candidates uuid[];
    loghaendelse_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj LoghaendelseEgenskaberAttrType;

    
    tilsGyldighedTypeObj LoghaendelseGyldighedTilsType;

    relationTypeObj LoghaendelseRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

loghaendelse_candidates_is_initialized := false;

IF loghaendelse_uuid is not NULL THEN
    loghaendelse_candidates:= ARRAY[loghaendelse_uuid];
    loghaendelse_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        loghaendelse_candidates:=array(
                SELECT DISTINCT
                b.loghaendelse_id
                FROM
                loghaendelse a
                JOIN loghaendelse_registrering b on b.loghaendelse_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 1:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 1:%',loghaendelse_candidates;
--/****************************//


--RAISE NOTICE 'loghaendelse_candidates_is_initialized step 2:%',loghaendelse_candidates_is_initialized;
--RAISE NOTICE 'loghaendelse_candidates step 2:%',loghaendelse_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_loghaendelse: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(loghaendelse_candidates,1),0)>0 OR NOT loghaendelse_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            loghaendelse_candidates:=array(
            SELECT DISTINCT
            b.loghaendelse_id
            FROM  loghaendelse_attr_egenskaber a
            JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.service IS NULL
                    OR
                    a.service ILIKE attrEgenskaberTypeObj.service --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.klasse IS NULL
                    OR
                    a.klasse ILIKE attrEgenskaberTypeObj.klasse --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.tidspunkt IS NULL
                    OR
                    a.tidspunkt ILIKE attrEgenskaberTypeObj.tidspunkt --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.operation IS NULL
                    OR
                    a.operation ILIKE attrEgenskaberTypeObj.operation --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.objekttype IS NULL
                    OR
                    a.objekttype ILIKE attrEgenskaberTypeObj.objekttype --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.returkode IS NULL
                    OR
                    a.returkode ILIKE attrEgenskaberTypeObj.returkode --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.returtekst IS NULL
                    OR
                    a.returtekst ILIKE attrEgenskaberTypeObj.returtekst --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.note IS NULL
                    OR
                    a.note ILIKE attrEgenskaberTypeObj.note --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )

            );


            loghaendelse_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 3:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 3:%',loghaendelse_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        loghaendelse_candidates:=array(

            SELECT DISTINCT
            b.loghaendelse_id
            
            FROM  loghaendelse_attr_egenskaber a
            JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id
            
            WHERE
            (
                        a.service ILIKE anyAttrValue OR
                        a.klasse ILIKE anyAttrValue OR
                        a.tidspunkt ILIKE anyAttrValue OR
                        a.operation ILIKE anyAttrValue OR
                        a.objekttype ILIKE anyAttrValue OR
                        a.returkode ILIKE anyAttrValue OR
                        a.returtekst ILIKE anyAttrValue OR
                        a.note ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )


        );

    loghaendelse_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
    --RAISE DEBUG 'as_search_loghaendelse: skipping filtration on tilsGyldighed';
ELSE
    IF (coalesce(array_length(loghaendelse_candidates,1),0)>0 OR loghaendelse_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
        LOOP
            loghaendelse_candidates:=array(
            SELECT DISTINCT
            b.loghaendelse_id
            FROM  loghaendelse_tils_gyldighed a
            JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id
            WHERE
                (
                    tilsGyldighedTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsGyldighedTypeObj.gyldighed IS NULL
                    OR
                    tilsGyldighedTypeObj.gyldighed = a.gyldighed
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )

    );


            loghaendelse_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer LoghaendelseRelationType[]
*/


--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 4:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 4:%',loghaendelse_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_loghaendelse: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(loghaendelse_candidates,1),0)>0 OR NOT loghaendelse_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            loghaendelse_candidates:=array(
            SELECT DISTINCT
            b.loghaendelse_id
            FROM  loghaendelse_relation a
            JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )

    );

            loghaendelse_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        loghaendelse_candidates:=array(
            SELECT DISTINCT
            b.loghaendelse_id
            
            FROM  loghaendelse_relation a
            JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )


            );

    loghaendelse_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        loghaendelse_candidates:=array(
            SELECT DISTINCT
            b.loghaendelse_id
            
            FROM  loghaendelse_relation a
            JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )


            );

    loghaendelse_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 




--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 5:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 5:%',loghaendelse_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT loghaendelse_candidates_is_initialized THEN
        loghaendelse_candidates:=array(
        SELECT DISTINCT
            loghaendelse_id
        FROM
            loghaendelse_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT loghaendelse_candidates_is_initialized) OR b.loghaendelse_id = ANY (loghaendelse_candidates) )

        )
        ;

        loghaendelse_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT loghaendelse_candidates_is_initialized THEN
    --No filters applied!
    loghaendelse_candidates:=array(
        SELECT DISTINCT id FROM loghaendelse a
    );
ELSE
    loghaendelse_candidates:=array(
        SELECT DISTINCT id FROM unnest(loghaendelse_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 6:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 6:%',loghaendelse_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_loghaendelse(loghaendelse_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_loghaendelse(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_LoghaendelseRegistreringType_to_json(LoghaendelseRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END loghaendelseegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END loghaendelsegyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::LoghaendelseRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (LoghaendelseRegistreringType as json);
create cast (LoghaendelseRegistreringType as json) with function actual_state._cast_LoghaendelseRegistreringType_to_json(LoghaendelseRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_loghaendelseType_to_json(LoghaendelseType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg LoghaendelseRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (LoghaendelseType as json);
create cast (LoghaendelseType as json) with function actual_state._cast_loghaendelseType_to_json(LoghaendelseType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_loghaendelse(
    loghaendelse_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    LoghaendelseRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    loghaendelse_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    loghaendelse_sorted_uuid:=array(
          SELECT b.loghaendelse_id
            FROM loghaendelse_registrering b
            JOIN loghaendelse_attr_egenskaber a ON a.loghaendelse_registrering_id=b.id
           WHERE b.loghaendelse_id = ANY (loghaendelse_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.loghaendelse_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.loghaendelse_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN loghaendelse_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_loghaendelse(
	loghaendelse_uuids uuid[],
	registreringObjArr LoghaendelseRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	loghaendelse_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	loghaendelse_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj LoghaendelseEgenskaberAttrType;
	
  	tilsGyldighedTypeObj LoghaendelseGyldighedTilsType;
	relationTypeObj LoghaendelseRelationType;
	registreringObj LoghaendelseRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN loghaendelse_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF loghaendelse_uuids IS NULL OR coalesce(array_length(loghaendelse_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

loghaendelse_candidates:= loghaendelse_uuids;



--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 1:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 1:%',loghaendelse_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_loghaendelse: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(loghaendelse_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			loghaendelse_candidates:=array(
			SELECT DISTINCT
			b.loghaendelse_id 
			FROM  loghaendelse_attr_egenskaber a 
			JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.service IS NULL
					OR 
					a.service = attrEgenskaberTypeObj.service 
				)
				AND
				(
					attrEgenskaberTypeObj.klasse IS NULL
					OR 
					a.klasse = attrEgenskaberTypeObj.klasse 
				)
				AND
				(
					attrEgenskaberTypeObj.tidspunkt IS NULL
					OR 
					a.tidspunkt = attrEgenskaberTypeObj.tidspunkt 
				)
				AND
				(
					attrEgenskaberTypeObj.operation IS NULL
					OR 
					a.operation = attrEgenskaberTypeObj.operation 
				)
				AND
				(
					attrEgenskaberTypeObj.objekttype IS NULL
					OR 
					a.objekttype = attrEgenskaberTypeObj.objekttype 
				)
				AND
				(
					attrEgenskaberTypeObj.returkode IS NULL
					OR 
					a.returkode = attrEgenskaberTypeObj.returkode 
				)
				AND
				(
					attrEgenskaberTypeObj.returtekst IS NULL
					OR 
					a.returtekst = attrEgenskaberTypeObj.returtekst 
				)
				AND
				(
					attrEgenskaberTypeObj.note IS NULL
					OR 
					a.note = attrEgenskaberTypeObj.note 
				)
				AND b.loghaendelse_id = ANY (loghaendelse_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 3:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 3:%',loghaendelse_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_loghaendelse: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(loghaendelse_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			loghaendelse_candidates:=array(
			SELECT DISTINCT
			b.loghaendelse_id 
			FROM  loghaendelse_tils_gyldighed a
			JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.loghaendelse_id = ANY (loghaendelse_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer LoghaendelseRelationType[]
*/


--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 4:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 4:%',loghaendelse_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_loghaendelse: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(loghaendelse_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			loghaendelse_candidates:=array(
			SELECT DISTINCT
			b.loghaendelse_id 
			FROM  loghaendelse_relation a
			JOIN loghaendelse_registrering b on a.loghaendelse_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.loghaendelse_id = ANY (loghaendelse_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'loghaendelse_candidates_is_initialized step 5:%',loghaendelse_candidates_is_initialized;
--RAISE DEBUG 'loghaendelse_candidates step 5:%',loghaendelse_candidates;

loghaendelse_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (loghaendelse_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (loghaendelse_candidates) b(id)
);

--optimization 
IF coalesce(array_length(loghaendelse_passed_auth_filter,1),0)=coalesce(array_length(loghaendelse_uuids,1),0) AND loghaendelse_passed_auth_filter @>loghaendelse_uuids THEN
	RETURN loghaendelse_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN loghaendelse_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE OrganisationGyldighedTils AS ENUM ('Aktiv','Inaktiv',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE OrganisationGyldighedTilsType AS (
    virkning Virkning,
    gyldighed OrganisationGyldighedTils
)
;



CREATE TYPE OrganisationEgenskaberAttrType AS (
brugervendtnoegle text,
organisationsnavn text,
integrationsdata text,

 virkning Virkning
);




CREATE TYPE OrganisationRelationKode AS ENUM  ('branche','myndighed','myndighedstype','overordnet','produktionsenhed','skatteenhed','tilhoerer','virksomhed','virksomhedstype','adresser','ansatte','opgaver','tilknyttedebrugere','tilknyttedeenheder','tilknyttedefunktioner','tilknyttedeinteressefaellesskaber','tilknyttedeorganisationer','tilknyttedepersoner','tilknyttedeitsystemer');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_organisation_relation_kode_to_txt is invoked.



CREATE TYPE OrganisationRelationType AS (
  relType OrganisationRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text
)
;



CREATE TYPE OrganisationRegistreringType AS
(
registrering RegistreringBase,
tilsGyldighed OrganisationGyldighedTilsType[],
attrEgenskaber OrganisationEgenskaberAttrType[],
relationer OrganisationRelationType[]
);

CREATE TYPE OrganisationType AS
(
  id uuid,
  registrering OrganisationRegistreringType[]
);  





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_organisation_relation_kode_to_txt(
    OrganisationRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE organisation (
    id uuid NOT NULL,
    CONSTRAINT organisation_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE organisation
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE organisation_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE organisation_registrering_id_seq
    OWNER TO mox;


CREATE TABLE organisation_registrering (
   id bigint NOT NULL DEFAULT nextval('organisation_registrering_id_seq'::regclass),
   organisation_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT organisation_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT organisation_registrering_organisation_fkey FOREIGN KEY (organisation_id)
       REFERENCES organisation (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT organisation_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(organisation_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE organisation_registrering
  OWNER TO mox;


CREATE INDEX organisation_registrering_idx_livscykluskode
    ON organisation_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX organisation_registrering_idx_brugerref
    ON organisation_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX organisation_registrering_idx_note
    ON organisation_registrering
    USING btree
    (((registrering).note));


CREATE INDEX organisation_registrering_pat_note
    ON organisation_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX organisation_id_idx
    ON organisation_registrering (organisation_id);


CREATE TRIGGER notify_organisation
    AFTER INSERT OR UPDATE OR DELETE ON organisation_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE organisation_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE organisation_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE organisation_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('organisation_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        organisationsnavn text  NULL,
        integrationsdata text  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    organisation_registrering_id bigint NOT NULL,
    CONSTRAINT organisation_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT organisation_attr_egenskaber_forkey_organisationregistrering FOREIGN KEY (organisation_registrering_id) REFERENCES organisation_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT organisation_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (organisation_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE organisation_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX organisation_attr_egenskaber_pat_brugervendtnoegle
            ON organisation_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX organisation_attr_egenskaber_idx_brugervendtnoegle
            ON organisation_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX organisation_attr_egenskaber_pat_organisationsnavn
            ON organisation_attr_egenskaber
            USING gin
            (organisationsnavn gin_trgm_ops);

        CREATE INDEX organisation_attr_egenskaber_idx_organisationsnavn
            ON organisation_attr_egenskaber
            USING btree
            (organisationsnavn); 
 
     
        CREATE INDEX organisation_attr_egenskaber_pat_integrationsdata
            ON organisation_attr_egenskaber
            USING gin
            (integrationsdata gin_trgm_ops);

        CREATE INDEX organisation_attr_egenskaber_idx_integrationsdata
            ON organisation_attr_egenskaber
            USING btree
            (integrationsdata); 



CREATE INDEX organisation_attr_egenskaber_idx_virkning_aktoerref
    ON organisation_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX organisation_attr_egenskaber_idx_virkning_aktoertypekode
    ON organisation_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX organisation_attr_egenskaber_idx_virkning_notetekst
    ON organisation_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX organisation_attr_egenskaber_pat_virkning_notetekst
    ON organisation_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE organisation_tils_gyldighed_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE organisation_tils_gyldighed_id_seq
    OWNER TO mox;


CREATE TABLE organisation_tils_gyldighed (
    id bigint NOT NULL DEFAULT nextval('organisation_tils_gyldighed_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    gyldighed OrganisationGyldighedTils NOT NULL, 
    organisation_registrering_id bigint not null,
    CONSTRAINT organisation_tils_gyldighed_pkey PRIMARY KEY (id),
    CONSTRAINT organisation_tils_gyldighed_forkey_organisationregistrering FOREIGN KEY (organisation_registrering_id) REFERENCES organisation_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT organisation_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (organisation_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE organisation_tils_gyldighed
    OWNER TO mox;


CREATE INDEX organisation_tils_gyldighed_idx_gyldighed
    ON organisation_tils_gyldighed
    USING btree
    (gyldighed);
  
CREATE INDEX organisation_tils_gyldighed_idx_virkning_aktoerref
    ON organisation_tils_gyldighed
    USING btree
    (((virkning).aktoerref));

CREATE INDEX organisation_tils_gyldighed_idx_virkning_aktoertypekode
    ON organisation_tils_gyldighed
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX organisation_tils_gyldighed_idx_virkning_notetekst
    ON organisation_tils_gyldighed
    USING btree
    (((virkning).notetekst));

CREATE INDEX organisation_tils_gyldighed_pat_virkning_notetekst
    ON organisation_tils_gyldighed
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE organisation_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE organisation_relation_id_seq
    OWNER TO mox;


CREATE TABLE organisation_relation (
    id bigint NOT NULL DEFAULT nextval('organisation_relation_id_seq'::regclass),
    organisation_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type OrganisationRelationKode not null,
    objekt_type text null,

    

    CONSTRAINT organisation_relation_forkey_organisationregistrering FOREIGN KEY (organisation_registrering_id) REFERENCES organisation_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT organisation_relation_pkey PRIMARY KEY (id),
    CONSTRAINT organisation_relation_no_virkning_overlap EXCLUDE USING gist (organisation_registrering_id WITH =, _as_convert_organisation_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('adresser'::OrganisationRelationKode ) AND rel_type<>('ansatte'::OrganisationRelationKode ) AND rel_type<>('opgaver'::OrganisationRelationKode ) AND rel_type<>('tilknyttedebrugere'::OrganisationRelationKode ) AND rel_type<>('tilknyttedeenheder'::OrganisationRelationKode ) AND rel_type<>('tilknyttedefunktioner'::OrganisationRelationKode ) AND rel_type<>('tilknyttedeinteressefaellesskaber'::OrganisationRelationKode ) AND rel_type<>('tilknyttedeorganisationer'::OrganisationRelationKode ) AND rel_type<>('tilknyttedepersoner'::OrganisationRelationKode ) AND rel_type<>('tilknyttedeitsystemer'::OrganisationRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT organisation_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE organisation_relation
  OWNER TO mox;





CREATE INDEX organisation_relation_idx_rel_maal_obj_uuid
    ON organisation_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX organisation_relation_idx_rel_maal_obj_urn
    ON organisation_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX organisation_relation_idx_rel_maal_uuid
    ON organisation_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX organisation_relation_idx_rel_maal_uuid_isolated
    ON organisation_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX organisation_relation_idx_rel_maal_urn_isolated
    ON organisation_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX organisation_relation_idx_rel_maal_urn
    ON organisation_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX organisation_relation_idx_virkning_aktoerref
    ON organisation_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX organisation_relation_idx_virkning_aktoertypekode
    ON organisation_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX organisation_relation_idx_virkning_notetekst
    ON organisation_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX organisation_relation_pat_virkning_notetekst
    ON organisation_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr OrganisationGyldighedTilsType[])
  RETURNS OrganisationGyldighedTilsType[] AS
  $$
  DECLARE result OrganisationGyldighedTilsType[];
  DECLARE element OrganisationGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr OrganisationEgenskaberAttrType[])
  RETURNS OrganisationEgenskaberAttrType[] AS
  $$
  DECLARE result OrganisationEgenskaberAttrType[]; 
   DECLARE element OrganisationEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.organisationsnavn IS NULL AND element.integrationsdata IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr OrganisationRelationType[])
RETURNS OrganisationRelationType[] AS
$$
 DECLARE result OrganisationRelationType[];
 DECLARE element OrganisationRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_organisation_registrering(
    organisation_registrering
) RETURNS organisation_registrering AS $BODY$
  SELECT * FROM organisation_registrering as a WHERE
    organisation_id = $1.organisation_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_organisation_registrering(
    organisation_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS organisation_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    organisation_registrering_id bigint;
    organisation_registrering    organisation_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE organisation_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE organisation_id = organisation_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating organisation with uuid [%], Invalid [livscyklus] transition to [%]',organisation_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new organisation registrering

    organisation_registrering_id := nextval('organisation_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    organisation_registrering := ROW(
        organisation_registrering_id,
        organisation_uuid,
        registreringObj
    )::organisation_registrering;

    INSERT INTO organisation_registrering SELECT organisation_registrering.*;

    RETURN organisation_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of OrganisationAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_organisation(
    organisation_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber OrganisationEgenskaberAttrType[],
    

    
    tilsGyldighed OrganisationGyldighedTilsType[],
    

    relationer OrganisationRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      OrganisationRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_organisation          OrganisationType;
    read_prev_organisation         OrganisationType;
    read_new_organisation_reg      OrganisationRegistreringType;
    read_prev_organisation_reg     OrganisationRegistreringType;
    new_organisation_registrering  organisation_registrering;
    prev_organisation_registrering organisation_registrering;
    organisation_relation_navn     OrganisationRelationKode;

    
    attrEgenskaberObj OrganisationEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from organisation a join organisation_registrering b ON b.organisation_id=a.id WHERE a.id=organisation_uuid) THEN
        RAISE EXCEPTION 'Unable to update organisation with uuid [%], being unable to find any previous registrations.',organisation_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM organisation a WHERE a.id=organisation_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_organisation(array[organisation_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[organisation_uuid]) THEN
      RAISE EXCEPTION 'Unable to update organisation with uuid [%]. Object does not met stipulated criteria:%', organisation_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_organisation_registrering := _as_create_organisation_registrering(organisation_uuid, livscykluskode, brugerref, note);
    prev_organisation_registrering := _as_get_prev_organisation_registrering(new_organisation_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_organisation_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update organisation with uuid [%], as the organisation seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', organisation_uuid, lostUpdatePreventionTZ, LOWER((prev_organisation_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    

    INSERT INTO organisation_relation (organisation_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
    SELECT
        new_organisation_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType 
        FROM
            unnest(relationer) AS a ;

    


    -- Ad 2)
    -- 0..1 relations

    
    
    FOREACH organisation_relation_navn IN ARRAY ARRAY['branche'::OrganisationRelationKode ,  'myndighed'::OrganisationRelationKode ,  'myndighedstype'::OrganisationRelationKode ,  'overordnet'::OrganisationRelationKode ,  'produktionsenhed'::OrganisationRelationKode ,  'skatteenhed'::OrganisationRelationKode ,  'tilhoerer'::OrganisationRelationKode ,  'virksomhed'::OrganisationRelationKode ,  'virksomhedstype'::OrganisationRelationKode  ]::OrganisationRelationKode[]  LOOP
        INSERT INTO organisation_relation (organisation_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
        SELECT
            new_organisation_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM organisation_relation b
                 WHERE b.organisation_registrering_id = new_organisation_registrering.id AND b.rel_type = organisation_relation_navn) d
            JOIN organisation_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.organisation_registrering_id = prev_organisation_registrering.id AND a.rel_type = organisation_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
    FOREACH organisation_relation_navn IN ARRAY ARRAY['adresser'::OrganisationRelationKode, 'ansatte'::OrganisationRelationKode, 'opgaver'::OrganisationRelationKode, 'tilknyttedebrugere'::OrganisationRelationKode, 'tilknyttedeenheder'::OrganisationRelationKode, 'tilknyttedefunktioner'::OrganisationRelationKode, 'tilknyttedeinteressefaellesskaber'::OrganisationRelationKode, 'tilknyttedeorganisationer'::OrganisationRelationKode, 'tilknyttedepersoner'::OrganisationRelationKode, 'tilknyttedeitsystemer'::OrganisationRelationKode]::OrganisationRelationKode[] LOOP
        IF NOT EXISTS (
                    SELECT 1
                      FROM organisation_relation
                     WHERE organisation_registrering_id = new_organisation_registrering.id AND rel_type = organisation_relation_navn) THEN
                    
                    INSERT INTO organisation_relation (organisation_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
                    SELECT
                        new_organisation_registrering.id,  virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type
        FROM organisation_relation
        WHERE
            organisation_registrering_id = prev_organisation_registrering.id AND rel_type = organisation_relation_navn ;

    
        END IF;
    END LOOP;
    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- organisation_tils_gyldighed

        -- Ad 1)
        INSERT INTO organisation_tils_gyldighed(virkning, gyldighed, organisation_registrering_id)
             SELECT a.virkning, a.gyldighed, new_organisation_registrering.id
               FROM unnest(tilsGyldighed) AS a;

        -- Ad 2
        INSERT INTO organisation_tils_gyldighed(virkning, gyldighed, organisation_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.gyldighed,
            new_organisation_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- organisation_tils_gyldighed of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- organisation_tils_gyldighed of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM organisation_tils_gyldighed b
             WHERE b.organisation_registrering_id = new_organisation_registrering.id) d
              JOIN organisation_tils_gyldighed a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.organisation_registrering_id = prev_organisation_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- organisation_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrOrganisationObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.organisationsnavn,a.integrationsdata,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update organisation with uuid [%], as the organisation have overlapping virknings in the given egenskaber array :%', organisation_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).organisationsnavn IS NULL  OR  (attrEgenskaberObj).integrationsdata IS NULL  THEN
            
            INSERT INTO organisation_attr_egenskaber ( brugervendtnoegle,organisationsnavn,integrationsdata, virkning, organisation_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.organisationsnavn, a.organisationsnavn),
                    
                        
                        
                            coalesce(attrEgenskaberObj.integrationsdata, a.integrationsdata),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_organisation_registrering.id
                        FROM organisation_attr_egenskaber a
                    WHERE
                        a.organisation_registrering_id = prev_organisation_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO organisation_attr_egenskaber ( brugervendtnoegle,organisationsnavn,integrationsdata, virkning, organisation_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.organisationsnavn,
                    
                     attrEgenskaberObj.integrationsdata,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_organisation_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the organisation_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM organisation_attr_egenskaber b
                    WHERE b.organisation_registrering_id = new_organisation_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO organisation_attr_egenskaber ( brugervendtnoegle,organisationsnavn,integrationsdata, virkning, organisation_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.organisationsnavn,  attrEgenskaberObj.integrationsdata, attrEgenskaberObj.virkning, new_organisation_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO organisation_attr_egenskaber ( brugervendtnoegle,organisationsnavn,integrationsdata, virkning, organisation_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.organisationsnavn,
        
            a.integrationsdata,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_organisation_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- organisation_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- organisation_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                organisation_attr_egenskaber b
            WHERE
                b.organisation_registrering_id = new_organisation_registrering.id) d
            JOIN organisation_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.organisation_registrering_id = prev_organisation_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_organisation := as_read_organisation(organisation_uuid, (new_organisation_registrering.registrering).timeperiod, null);
    read_prev_organisation := as_read_organisation(organisation_uuid, (prev_organisation_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_organisation.registrering[1].registrering).TimePeriod) = lower((new_organisation_registrering.registrering).TimePeriod) and lower((read_prev_organisation.registrering[1].registrering).TimePeriod)=lower((prev_organisation_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating organisation with id [%]: The ordering of as_list_organisation should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', organisation_uuid, to_json(new_organisation_registrering), to_json(read_new_organisation.registrering[1].registrering), to_json(prev_organisation_registrering), to_json(prev_new_organisation.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_organisation_reg := ROW(
        ROW (null, (read_new_organisation.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_organisation.registrering[1]).tilsGyldighed ,
        
        (read_new_organisation.registrering[1]).attrEgenskaber ,
        (read_new_organisation.registrering[1]).relationer
    )::organisationRegistreringType;

    read_prev_organisation_reg := ROW(
        ROW(null, (read_prev_organisation.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_organisation.registrering[1]).tilsGyldighed ,
        
        (read_prev_organisation.registrering[1]).attrEgenskaber ,
        (read_prev_organisation.registrering[1]).relationer
    )::organisationRegistreringType;


    IF read_prev_organisation_reg = read_new_organisation_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_organisation_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_organisation_reg);
      RAISE EXCEPTION 'Aborted updating organisation with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', organisation_uuid, to_json(read_new_organisation_reg), to_json(read_prev_organisation_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_organisation_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_organisation (
    organisation_registrering OrganisationRegistreringType,
    organisation_uuid uuid DEFAULT NULL, auth_criteria_arr
    OrganisationRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE organisation_registrering_id bigint;

    
    organisation_attr_egenskaber_obj organisationEgenskaberAttrType;
    

    
    organisation_tils_gyldighed_obj organisationGyldighedTilsType;
    

    organisation_relationer OrganisationRelationType;

    

    auth_filtered_uuids uuid[];

    

    does_exist boolean;
    new_organisation_registrering organisation_registrering;
BEGIN
    IF organisation_uuid IS NULL THEN LOOP
        organisation_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from organisation WHERE id=organisation_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from organisation WHERE id=organisation_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (organisation_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (organisation_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (organisation_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_organisation.',(organisation_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO organisation (ID) SELECT
        organisation_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        organisation_registrering_id:=nextval('organisation_registrering_id_seq');

        INSERT INTO organisation_registrering (id, organisation_id,
            registrering) SELECT organisation_registrering_id,
        organisation_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (organisation_registrering.registrering).livscykluskode,
        (organisation_registrering.registrering).brugerref,
        (organisation_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_organisation_registrering :=
            _as_create_organisation_registrering(organisation_uuid,
                (organisation_registrering.registrering).livscykluskode,
                (organisation_registrering.registrering).brugerref,
                (organisation_registrering.registrering).note);

            organisation_registrering_id := new_organisation_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(organisation_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [organisation]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF organisation_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(organisation_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH organisation_attr_egenskaber_obj IN ARRAY organisation_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO organisation_attr_egenskaber (
      
      brugervendtnoegle,
      organisationsnavn,
      integrationsdata,
      virkning,
      organisation_registrering_id
    )
    SELECT
     
     organisation_attr_egenskaber_obj.brugervendtnoegle,
      organisation_attr_egenskaber_obj.organisationsnavn,
      organisation_attr_egenskaber_obj.integrationsdata,
      organisation_attr_egenskaber_obj.virkning,
      organisation_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(organisation_registrering.tilsGyldighed, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [gyldighed] for organisation. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF organisation_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(organisation_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH organisation_tils_gyldighed_obj IN ARRAY organisation_registrering.tilsGyldighed
  LOOP

    INSERT INTO organisation_tils_gyldighed (
      virkning,
      gyldighed,
      organisation_registrering_id
    )
    SELECT
      organisation_tils_gyldighed_obj.virkning,
      organisation_tils_gyldighed_obj.gyldighed,
      organisation_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations



    INSERT INTO organisation_relation (
      organisation_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      organisation_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(organisation_registrering.relationer) a
  ;




/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_organisation(array[organisation_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[organisation_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import organisation with uuid [%]. Object does not met stipulated criteria:%',organisation_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN organisation_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_organisation(organisation_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr OrganisationRegistreringType[]=null
  )
  RETURNS OrganisationType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result OrganisationType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisation(organisation_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(organisation_uuids,1),0) AND auth_filtered_uuids @>organisation_uuids) THEN
  RAISE EXCEPTION 'Unable to list organisation with uuids [%]. All objects do not fullfill the stipulated criteria:%',organisation_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.organisationObj) into result
FROM
(
SELECT
ROW(
	a.organisation_id,
	array_agg(
		ROW (
			a.registrering,
			a.OrganisationTilsGyldighedArr,
			a.OrganisationAttrEgenskaberArr,
			a.OrganisationRelationArr
		)::OrganisationRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: OrganisationType  organisationObj
FROM
(
	SELECT
	a.organisation_id,
	a.organisation_registrering_id,
	a.registrering,
	a.OrganisationAttrEgenskaberArr,
	a.OrganisationTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type
			):: OrganisationRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
        
	)) OrganisationRelationArr
	FROM
	(
			SELECT
			a.organisation_id,
			a.organisation_registrering_id,
			a.registrering,
			a.OrganisationAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::OrganisationGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) OrganisationTilsGyldighedArr		
			FROM
			(
					SELECT
					a.organisation_id,
					a.organisation_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.organisationsnavn,
					 		b.integrationsdata,
					   		b.virkning
                            
							)::OrganisationEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.organisationsnavn,b.integrationsdata,b.virkning
                        
					)) OrganisationAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id organisation_id,
					b.id organisation_registrering_id,
					b.registrering			
					FROM		organisation a
					JOIN 		organisation_registrering b 	ON b.organisation_id=a.id
					WHERE a.id = ANY (organisation_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN organisation_attr_egenskaber as b ON b.organisation_registrering_id=a.organisation_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.organisation_id,
					a.organisation_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN organisation_tils_gyldighed as b ON b.organisation_registrering_id=a.organisation_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.organisation_id,
			a.organisation_registrering_id,
			a.registrering,
			a.OrganisationAttrEgenskaberArr
	) as a
	LEFT JOIN organisation_relation b ON b.organisation_registrering_id=a.organisation_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.organisation_id,
	a.organisation_registrering_id,
	a.registrering,
	a.OrganisationAttrEgenskaberArr,
	a.OrganisationTilsGyldighedArr
) as a

WHERE a.organisation_id IS NOT NULL
GROUP BY 
a.organisation_id
order by a.organisation_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_organisation(
    organisation_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      OrganisationRegistreringType[]=null
) RETURNS OrganisationType AS $$
DECLARE
	resArr OrganisationType[];
BEGIN
    resArr := as_list_organisation(ARRAY[organisation_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_organisation(
    firstResult int,--TOOD ??
    organisation_uuid uuid,
    registreringObj   OrganisationRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr OrganisationRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    organisation_candidates uuid[];
    organisation_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj OrganisationEgenskaberAttrType;

    
    tilsGyldighedTypeObj OrganisationGyldighedTilsType;

    relationTypeObj OrganisationRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

organisation_candidates_is_initialized := false;

IF organisation_uuid is not NULL THEN
    organisation_candidates:= ARRAY[organisation_uuid];
    organisation_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        organisation_candidates:=array(
                SELECT DISTINCT
                b.organisation_id
                FROM
                organisation a
                JOIN organisation_registrering b on b.organisation_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'organisation_candidates_is_initialized step 1:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 1:%',organisation_candidates;
--/****************************//


--RAISE NOTICE 'organisation_candidates_is_initialized step 2:%',organisation_candidates_is_initialized;
--RAISE NOTICE 'organisation_candidates step 2:%',organisation_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_organisation: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(organisation_candidates,1),0)>0 OR NOT organisation_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            organisation_candidates:=array(
            SELECT DISTINCT
            b.organisation_id
            FROM  organisation_attr_egenskaber a
            JOIN organisation_registrering b on a.organisation_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.organisationsnavn IS NULL
                    OR
                    a.organisationsnavn ILIKE attrEgenskaberTypeObj.organisationsnavn --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.integrationsdata IS NULL
                    OR
                    a.integrationsdata ILIKE attrEgenskaberTypeObj.integrationsdata --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )

            );


            organisation_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'organisation_candidates_is_initialized step 3:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 3:%',organisation_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        organisation_candidates:=array(

            SELECT DISTINCT
            b.organisation_id
            
            FROM  organisation_attr_egenskaber a
            JOIN organisation_registrering b on a.organisation_registrering_id=b.id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.organisationsnavn ILIKE anyAttrValue OR
                        a.integrationsdata ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )


        );

    organisation_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
    --RAISE DEBUG 'as_search_organisation: skipping filtration on tilsGyldighed';
ELSE
    IF (coalesce(array_length(organisation_candidates,1),0)>0 OR organisation_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
        LOOP
            organisation_candidates:=array(
            SELECT DISTINCT
            b.organisation_id
            FROM  organisation_tils_gyldighed a
            JOIN organisation_registrering b on a.organisation_registrering_id=b.id
            WHERE
                (
                    tilsGyldighedTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsGyldighedTypeObj.gyldighed IS NULL
                    OR
                    tilsGyldighedTypeObj.gyldighed = a.gyldighed
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )

    );


            organisation_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer OrganisationRelationType[]
*/


--RAISE DEBUG 'organisation_candidates_is_initialized step 4:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 4:%',organisation_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_organisation: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(organisation_candidates,1),0)>0 OR NOT organisation_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            organisation_candidates:=array(
            SELECT DISTINCT
            b.organisation_id
            FROM  organisation_relation a
            JOIN organisation_registrering b on a.organisation_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )

    );

            organisation_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        organisation_candidates:=array(
            SELECT DISTINCT
            b.organisation_id
            
            FROM  organisation_relation a
            JOIN organisation_registrering b on a.organisation_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )


            );

    organisation_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        organisation_candidates:=array(
            SELECT DISTINCT
            b.organisation_id
            
            FROM  organisation_relation a
            JOIN organisation_registrering b on a.organisation_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )


            );

    organisation_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 




--RAISE DEBUG 'organisation_candidates_is_initialized step 5:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 5:%',organisation_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT organisation_candidates_is_initialized THEN
        organisation_candidates:=array(
        SELECT DISTINCT
            organisation_id
        FROM
            organisation_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisation_candidates_is_initialized) OR b.organisation_id = ANY (organisation_candidates) )

        )
        ;

        organisation_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT organisation_candidates_is_initialized THEN
    --No filters applied!
    organisation_candidates:=array(
        SELECT DISTINCT id FROM organisation a
    );
ELSE
    organisation_candidates:=array(
        SELECT DISTINCT id FROM unnest(organisation_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'organisation_candidates_is_initialized step 6:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 6:%',organisation_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisation(organisation_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_organisation(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_OrganisationRegistreringType_to_json(OrganisationRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END organisationegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END organisationgyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::OrganisationRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (OrganisationRegistreringType as json);
create cast (OrganisationRegistreringType as json) with function actual_state._cast_OrganisationRegistreringType_to_json(OrganisationRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_organisationType_to_json(OrganisationType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg OrganisationRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (OrganisationType as json);
create cast (OrganisationType as json) with function actual_state._cast_organisationType_to_json(OrganisationType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_organisation(
    organisation_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    OrganisationRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    organisation_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    organisation_sorted_uuid:=array(
          SELECT b.organisation_id
            FROM organisation_registrering b
            JOIN organisation_attr_egenskaber a ON a.organisation_registrering_id=b.id
           WHERE b.organisation_id = ANY (organisation_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.organisation_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.organisation_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN organisation_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_organisation(
	organisation_uuids uuid[],
	registreringObjArr OrganisationRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	organisation_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	organisation_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj OrganisationEgenskaberAttrType;
	
  	tilsGyldighedTypeObj OrganisationGyldighedTilsType;
	relationTypeObj OrganisationRelationType;
	registreringObj OrganisationRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN organisation_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF organisation_uuids IS NULL OR coalesce(array_length(organisation_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

organisation_candidates:= organisation_uuids;



--RAISE DEBUG 'organisation_candidates_is_initialized step 1:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 1:%',organisation_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_organisation: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(organisation_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			organisation_candidates:=array(
			SELECT DISTINCT
			b.organisation_id 
			FROM  organisation_attr_egenskaber a 
			JOIN organisation_registrering b on a.organisation_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.organisationsnavn IS NULL
					OR 
					a.organisationsnavn = attrEgenskaberTypeObj.organisationsnavn 
				)
				AND
				(
					attrEgenskaberTypeObj.integrationsdata IS NULL
					OR 
					a.integrationsdata = attrEgenskaberTypeObj.integrationsdata 
				)
				AND b.organisation_id = ANY (organisation_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'organisation_candidates_is_initialized step 3:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 3:%',organisation_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_organisation: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(organisation_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			organisation_candidates:=array(
			SELECT DISTINCT
			b.organisation_id 
			FROM  organisation_tils_gyldighed a
			JOIN organisation_registrering b on a.organisation_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.organisation_id = ANY (organisation_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer OrganisationRelationType[]
*/


--RAISE DEBUG 'organisation_candidates_is_initialized step 4:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 4:%',organisation_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_organisation: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(organisation_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			organisation_candidates:=array(
			SELECT DISTINCT
			b.organisation_id 
			FROM  organisation_relation a
			JOIN organisation_registrering b on a.organisation_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.organisation_id = ANY (organisation_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'organisation_candidates_is_initialized step 5:%',organisation_candidates_is_initialized;
--RAISE DEBUG 'organisation_candidates step 5:%',organisation_candidates;

organisation_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (organisation_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (organisation_candidates) b(id)
);

--optimization 
IF coalesce(array_length(organisation_passed_auth_filter,1),0)=coalesce(array_length(organisation_uuids,1),0) AND organisation_passed_auth_filter @>organisation_uuids THEN
	RETURN organisation_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN organisation_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE OrganisationenhedGyldighedTils AS ENUM ('Aktiv','Inaktiv',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE OrganisationenhedGyldighedTilsType AS (
    virkning Virkning,
    gyldighed OrganisationenhedGyldighedTils
)
;



CREATE TYPE OrganisationenhedEgenskaberAttrType AS (
brugervendtnoegle text,
enhedsnavn text,

 virkning Virkning
);




CREATE TYPE OrganisationenhedRelationKode AS ENUM  ('branche','enhedstype','overordnet','produktionsenhed','skatteenhed','tilhoerer','adresser','ansatte','opgaver','tilknyttedebrugere','tilknyttedeenheder','tilknyttedefunktioner','tilknyttedeinteressefaellesskaber','tilknyttedeorganisationer','tilknyttedepersoner','tilknyttedeitsystemer');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_organisationenhed_relation_kode_to_txt is invoked.



CREATE TYPE OrganisationenhedRelationType AS (
  relType OrganisationenhedRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text
)
;



CREATE TYPE OrganisationenhedRegistreringType AS
(
registrering RegistreringBase,
tilsGyldighed OrganisationenhedGyldighedTilsType[],
attrEgenskaber OrganisationenhedEgenskaberAttrType[],
relationer OrganisationenhedRelationType[]
);

CREATE TYPE OrganisationenhedType AS
(
  id uuid,
  registrering OrganisationenhedRegistreringType[]
);  





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_organisationenhed_relation_kode_to_txt(
    OrganisationenhedRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE organisationenhed (
    id uuid NOT NULL,
    CONSTRAINT organisationenhed_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE organisationenhed
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE organisationenhed_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE organisationenhed_registrering_id_seq
    OWNER TO mox;


CREATE TABLE organisationenhed_registrering (
   id bigint NOT NULL DEFAULT nextval('organisationenhed_registrering_id_seq'::regclass),
   organisationenhed_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT organisationenhed_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT organisationenhed_registrering_organisationenhed_fkey FOREIGN KEY (organisationenhed_id)
       REFERENCES organisationenhed (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT organisationenhed_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(organisationenhed_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE organisationenhed_registrering
  OWNER TO mox;


CREATE INDEX organisationenhed_registrering_idx_livscykluskode
    ON organisationenhed_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX organisationenhed_registrering_idx_brugerref
    ON organisationenhed_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX organisationenhed_registrering_idx_note
    ON organisationenhed_registrering
    USING btree
    (((registrering).note));


CREATE INDEX organisationenhed_registrering_pat_note
    ON organisationenhed_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX organisationenhed_id_idx
    ON organisationenhed_registrering (organisationenhed_id);


CREATE TRIGGER notify_organisationenhed
    AFTER INSERT OR UPDATE OR DELETE ON organisationenhed_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE organisationenhed_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE organisationenhed_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE organisationenhed_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('organisationenhed_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        enhedsnavn text  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    organisationenhed_registrering_id bigint NOT NULL,
    CONSTRAINT organisationenhed_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT organisationenhed_attr_egenskaber_forkey_organisationenhedregistrering FOREIGN KEY (organisationenhed_registrering_id) REFERENCES organisationenhed_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT organisationenhed_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (organisationenhed_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE organisationenhed_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX organisationenhed_attr_egenskaber_pat_brugervendtnoegle
            ON organisationenhed_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX organisationenhed_attr_egenskaber_idx_brugervendtnoegle
            ON organisationenhed_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX organisationenhed_attr_egenskaber_pat_enhedsnavn
            ON organisationenhed_attr_egenskaber
            USING gin
            (enhedsnavn gin_trgm_ops);

        CREATE INDEX organisationenhed_attr_egenskaber_idx_enhedsnavn
            ON organisationenhed_attr_egenskaber
            USING btree
            (enhedsnavn); 



CREATE INDEX organisationenhed_attr_egenskaber_idx_virkning_aktoerref
    ON organisationenhed_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX organisationenhed_attr_egenskaber_idx_virkning_aktoertypekode
    ON organisationenhed_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX organisationenhed_attr_egenskaber_idx_virkning_notetekst
    ON organisationenhed_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX organisationenhed_attr_egenskaber_pat_virkning_notetekst
    ON organisationenhed_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE organisationenhed_tils_gyldighed_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE organisationenhed_tils_gyldighed_id_seq
    OWNER TO mox;


CREATE TABLE organisationenhed_tils_gyldighed (
    id bigint NOT NULL DEFAULT nextval('organisationenhed_tils_gyldighed_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    gyldighed OrganisationenhedGyldighedTils NOT NULL, 
    organisationenhed_registrering_id bigint not null,
    CONSTRAINT organisationenhed_tils_gyldighed_pkey PRIMARY KEY (id),
    CONSTRAINT organisationenhed_tils_gyldighed_forkey_organisationenhedregistrering FOREIGN KEY (organisationenhed_registrering_id) REFERENCES organisationenhed_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT organisationenhed_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (organisationenhed_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE organisationenhed_tils_gyldighed
    OWNER TO mox;


CREATE INDEX organisationenhed_tils_gyldighed_idx_gyldighed
    ON organisationenhed_tils_gyldighed
    USING btree
    (gyldighed);
  
CREATE INDEX organisationenhed_tils_gyldighed_idx_virkning_aktoerref
    ON organisationenhed_tils_gyldighed
    USING btree
    (((virkning).aktoerref));

CREATE INDEX organisationenhed_tils_gyldighed_idx_virkning_aktoertypekode
    ON organisationenhed_tils_gyldighed
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX organisationenhed_tils_gyldighed_idx_virkning_notetekst
    ON organisationenhed_tils_gyldighed
    USING btree
    (((virkning).notetekst));

CREATE INDEX organisationenhed_tils_gyldighed_pat_virkning_notetekst
    ON organisationenhed_tils_gyldighed
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE organisationenhed_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE organisationenhed_relation_id_seq
    OWNER TO mox;


CREATE TABLE organisationenhed_relation (
    id bigint NOT NULL DEFAULT nextval('organisationenhed_relation_id_seq'::regclass),
    organisationenhed_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type OrganisationenhedRelationKode not null,
    objekt_type text null,

    

    CONSTRAINT organisationenhed_relation_forkey_organisationenhedregistrering FOREIGN KEY (organisationenhed_registrering_id) REFERENCES organisationenhed_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT organisationenhed_relation_pkey PRIMARY KEY (id),
    CONSTRAINT organisationenhed_relation_no_virkning_overlap EXCLUDE USING gist (organisationenhed_registrering_id WITH =, _as_convert_organisationenhed_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('adresser'::OrganisationenhedRelationKode ) AND rel_type<>('ansatte'::OrganisationenhedRelationKode ) AND rel_type<>('opgaver'::OrganisationenhedRelationKode ) AND rel_type<>('tilknyttedebrugere'::OrganisationenhedRelationKode ) AND rel_type<>('tilknyttedeenheder'::OrganisationenhedRelationKode ) AND rel_type<>('tilknyttedefunktioner'::OrganisationenhedRelationKode ) AND rel_type<>('tilknyttedeinteressefaellesskaber'::OrganisationenhedRelationKode ) AND rel_type<>('tilknyttedeorganisationer'::OrganisationenhedRelationKode ) AND rel_type<>('tilknyttedepersoner'::OrganisationenhedRelationKode ) AND rel_type<>('tilknyttedeitsystemer'::OrganisationenhedRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT organisationenhed_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE organisationenhed_relation
  OWNER TO mox;





CREATE INDEX organisationenhed_relation_idx_rel_maal_obj_uuid
    ON organisationenhed_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX organisationenhed_relation_idx_rel_maal_obj_urn
    ON organisationenhed_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX organisationenhed_relation_idx_rel_maal_uuid
    ON organisationenhed_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX organisationenhed_relation_idx_rel_maal_uuid_isolated
    ON organisationenhed_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX organisationenhed_relation_idx_rel_maal_urn_isolated
    ON organisationenhed_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX organisationenhed_relation_idx_rel_maal_urn
    ON organisationenhed_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX organisationenhed_relation_idx_virkning_aktoerref
    ON organisationenhed_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX organisationenhed_relation_idx_virkning_aktoertypekode
    ON organisationenhed_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX organisationenhed_relation_idx_virkning_notetekst
    ON organisationenhed_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX organisationenhed_relation_pat_virkning_notetekst
    ON organisationenhed_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr OrganisationenhedGyldighedTilsType[])
  RETURNS OrganisationenhedGyldighedTilsType[] AS
  $$
  DECLARE result OrganisationenhedGyldighedTilsType[];
  DECLARE element OrganisationenhedGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr OrganisationenhedEgenskaberAttrType[])
  RETURNS OrganisationenhedEgenskaberAttrType[] AS
  $$
  DECLARE result OrganisationenhedEgenskaberAttrType[]; 
   DECLARE element OrganisationenhedEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.enhedsnavn IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr OrganisationenhedRelationType[])
RETURNS OrganisationenhedRelationType[] AS
$$
 DECLARE result OrganisationenhedRelationType[];
 DECLARE element OrganisationenhedRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_organisationenhed_registrering(
    organisationenhed_registrering
) RETURNS organisationenhed_registrering AS $BODY$
  SELECT * FROM organisationenhed_registrering as a WHERE
    organisationenhed_id = $1.organisationenhed_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_organisationenhed_registrering(
    organisationenhed_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS organisationenhed_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    organisationenhed_registrering_id bigint;
    organisationenhed_registrering    organisationenhed_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE organisationenhed_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE organisationenhed_id = organisationenhed_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating organisationenhed with uuid [%], Invalid [livscyklus] transition to [%]',organisationenhed_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new organisationenhed registrering

    organisationenhed_registrering_id := nextval('organisationenhed_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    organisationenhed_registrering := ROW(
        organisationenhed_registrering_id,
        organisationenhed_uuid,
        registreringObj
    )::organisationenhed_registrering;

    INSERT INTO organisationenhed_registrering SELECT organisationenhed_registrering.*;

    RETURN organisationenhed_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of OrganisationenhedAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_organisationenhed(
    organisationenhed_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber OrganisationenhedEgenskaberAttrType[],
    

    
    tilsGyldighed OrganisationenhedGyldighedTilsType[],
    

    relationer OrganisationenhedRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      OrganisationenhedRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_organisationenhed          OrganisationenhedType;
    read_prev_organisationenhed         OrganisationenhedType;
    read_new_organisationenhed_reg      OrganisationenhedRegistreringType;
    read_prev_organisationenhed_reg     OrganisationenhedRegistreringType;
    new_organisationenhed_registrering  organisationenhed_registrering;
    prev_organisationenhed_registrering organisationenhed_registrering;
    organisationenhed_relation_navn     OrganisationenhedRelationKode;

    
    attrEgenskaberObj OrganisationenhedEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from organisationenhed a join organisationenhed_registrering b ON b.organisationenhed_id=a.id WHERE a.id=organisationenhed_uuid) THEN
        RAISE EXCEPTION 'Unable to update organisationenhed with uuid [%], being unable to find any previous registrations.',organisationenhed_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM organisationenhed a WHERE a.id=organisationenhed_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_organisationenhed(array[organisationenhed_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[organisationenhed_uuid]) THEN
      RAISE EXCEPTION 'Unable to update organisationenhed with uuid [%]. Object does not met stipulated criteria:%', organisationenhed_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_organisationenhed_registrering := _as_create_organisationenhed_registrering(organisationenhed_uuid, livscykluskode, brugerref, note);
    prev_organisationenhed_registrering := _as_get_prev_organisationenhed_registrering(new_organisationenhed_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_organisationenhed_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update organisationenhed with uuid [%], as the organisationenhed seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', organisationenhed_uuid, lostUpdatePreventionTZ, LOWER((prev_organisationenhed_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    

    INSERT INTO organisationenhed_relation (organisationenhed_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
    SELECT
        new_organisationenhed_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType 
        FROM
            unnest(relationer) AS a ;

    


    -- Ad 2)
    -- 0..1 relations

    
    
    FOREACH organisationenhed_relation_navn IN ARRAY ARRAY['branche'::OrganisationenhedRelationKode ,  'enhedstype'::OrganisationenhedRelationKode ,  'overordnet'::OrganisationenhedRelationKode ,  'produktionsenhed'::OrganisationenhedRelationKode ,  'skatteenhed'::OrganisationenhedRelationKode ,  'tilhoerer'::OrganisationenhedRelationKode  ]::OrganisationenhedRelationKode[]  LOOP
        INSERT INTO organisationenhed_relation (organisationenhed_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
        SELECT
            new_organisationenhed_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM organisationenhed_relation b
                 WHERE b.organisationenhed_registrering_id = new_organisationenhed_registrering.id AND b.rel_type = organisationenhed_relation_navn) d
            JOIN organisationenhed_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.organisationenhed_registrering_id = prev_organisationenhed_registrering.id AND a.rel_type = organisationenhed_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
    FOREACH organisationenhed_relation_navn IN ARRAY ARRAY['adresser'::OrganisationenhedRelationKode, 'ansatte'::OrganisationenhedRelationKode, 'opgaver'::OrganisationenhedRelationKode, 'tilknyttedebrugere'::OrganisationenhedRelationKode, 'tilknyttedeenheder'::OrganisationenhedRelationKode, 'tilknyttedefunktioner'::OrganisationenhedRelationKode, 'tilknyttedeinteressefaellesskaber'::OrganisationenhedRelationKode, 'tilknyttedeorganisationer'::OrganisationenhedRelationKode, 'tilknyttedepersoner'::OrganisationenhedRelationKode, 'tilknyttedeitsystemer'::OrganisationenhedRelationKode]::OrganisationenhedRelationKode[] LOOP
        IF NOT EXISTS (
                    SELECT 1
                      FROM organisationenhed_relation
                     WHERE organisationenhed_registrering_id = new_organisationenhed_registrering.id AND rel_type = organisationenhed_relation_navn) THEN
                    
                    INSERT INTO organisationenhed_relation (organisationenhed_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
                    SELECT
                        new_organisationenhed_registrering.id,  virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type
        FROM organisationenhed_relation
        WHERE
            organisationenhed_registrering_id = prev_organisationenhed_registrering.id AND rel_type = organisationenhed_relation_navn ;

    
        END IF;
    END LOOP;
    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- organisationenhed_tils_gyldighed

        -- Ad 1)
        INSERT INTO organisationenhed_tils_gyldighed(virkning, gyldighed, organisationenhed_registrering_id)
             SELECT a.virkning, a.gyldighed, new_organisationenhed_registrering.id
               FROM unnest(tilsGyldighed) AS a;

        -- Ad 2
        INSERT INTO organisationenhed_tils_gyldighed(virkning, gyldighed, organisationenhed_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.gyldighed,
            new_organisationenhed_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- organisationenhed_tils_gyldighed of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- organisationenhed_tils_gyldighed of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM organisationenhed_tils_gyldighed b
             WHERE b.organisationenhed_registrering_id = new_organisationenhed_registrering.id) d
              JOIN organisationenhed_tils_gyldighed a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.organisationenhed_registrering_id = prev_organisationenhed_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- organisationenhed_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrOrganisationenhedObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.enhedsnavn,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update organisationenhed with uuid [%], as the organisationenhed have overlapping virknings in the given egenskaber array :%', organisationenhed_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).enhedsnavn IS NULL  THEN
            
            INSERT INTO organisationenhed_attr_egenskaber ( brugervendtnoegle,enhedsnavn, virkning, organisationenhed_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.enhedsnavn, a.enhedsnavn),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_organisationenhed_registrering.id
                        FROM organisationenhed_attr_egenskaber a
                    WHERE
                        a.organisationenhed_registrering_id = prev_organisationenhed_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO organisationenhed_attr_egenskaber ( brugervendtnoegle,enhedsnavn, virkning, organisationenhed_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.enhedsnavn,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_organisationenhed_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the organisationenhed_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM organisationenhed_attr_egenskaber b
                    WHERE b.organisationenhed_registrering_id = new_organisationenhed_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO organisationenhed_attr_egenskaber ( brugervendtnoegle,enhedsnavn, virkning, organisationenhed_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.enhedsnavn, attrEgenskaberObj.virkning, new_organisationenhed_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO organisationenhed_attr_egenskaber ( brugervendtnoegle,enhedsnavn, virkning, organisationenhed_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.enhedsnavn,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_organisationenhed_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- organisationenhed_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- organisationenhed_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                organisationenhed_attr_egenskaber b
            WHERE
                b.organisationenhed_registrering_id = new_organisationenhed_registrering.id) d
            JOIN organisationenhed_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.organisationenhed_registrering_id = prev_organisationenhed_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_organisationenhed := as_read_organisationenhed(organisationenhed_uuid, (new_organisationenhed_registrering.registrering).timeperiod, null);
    read_prev_organisationenhed := as_read_organisationenhed(organisationenhed_uuid, (prev_organisationenhed_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_organisationenhed.registrering[1].registrering).TimePeriod) = lower((new_organisationenhed_registrering.registrering).TimePeriod) and lower((read_prev_organisationenhed.registrering[1].registrering).TimePeriod)=lower((prev_organisationenhed_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating organisationenhed with id [%]: The ordering of as_list_organisationenhed should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', organisationenhed_uuid, to_json(new_organisationenhed_registrering), to_json(read_new_organisationenhed.registrering[1].registrering), to_json(prev_organisationenhed_registrering), to_json(prev_new_organisationenhed.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_organisationenhed_reg := ROW(
        ROW (null, (read_new_organisationenhed.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_organisationenhed.registrering[1]).tilsGyldighed ,
        
        (read_new_organisationenhed.registrering[1]).attrEgenskaber ,
        (read_new_organisationenhed.registrering[1]).relationer
    )::organisationenhedRegistreringType;

    read_prev_organisationenhed_reg := ROW(
        ROW(null, (read_prev_organisationenhed.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_organisationenhed.registrering[1]).tilsGyldighed ,
        
        (read_prev_organisationenhed.registrering[1]).attrEgenskaber ,
        (read_prev_organisationenhed.registrering[1]).relationer
    )::organisationenhedRegistreringType;


    IF read_prev_organisationenhed_reg = read_new_organisationenhed_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_organisationenhed_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_organisationenhed_reg);
      RAISE EXCEPTION 'Aborted updating organisationenhed with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', organisationenhed_uuid, to_json(read_new_organisationenhed_reg), to_json(read_prev_organisationenhed_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_organisationenhed_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_organisationenhed (
    organisationenhed_registrering OrganisationenhedRegistreringType,
    organisationenhed_uuid uuid DEFAULT NULL, auth_criteria_arr
    OrganisationenhedRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE organisationenhed_registrering_id bigint;

    
    organisationenhed_attr_egenskaber_obj organisationenhedEgenskaberAttrType;
    

    
    organisationenhed_tils_gyldighed_obj organisationenhedGyldighedTilsType;
    

    organisationenhed_relationer OrganisationenhedRelationType;

    

    auth_filtered_uuids uuid[];

    

    does_exist boolean;
    new_organisationenhed_registrering organisationenhed_registrering;
BEGIN
    IF organisationenhed_uuid IS NULL THEN LOOP
        organisationenhed_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from organisationenhed WHERE id=organisationenhed_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from organisationenhed WHERE id=organisationenhed_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (organisationenhed_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (organisationenhed_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (organisationenhed_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_organisationenhed.',(organisationenhed_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO organisationenhed (ID) SELECT
        organisationenhed_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        organisationenhed_registrering_id:=nextval('organisationenhed_registrering_id_seq');

        INSERT INTO organisationenhed_registrering (id, organisationenhed_id,
            registrering) SELECT organisationenhed_registrering_id,
        organisationenhed_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (organisationenhed_registrering.registrering).livscykluskode,
        (organisationenhed_registrering.registrering).brugerref,
        (organisationenhed_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_organisationenhed_registrering :=
            _as_create_organisationenhed_registrering(organisationenhed_uuid,
                (organisationenhed_registrering.registrering).livscykluskode,
                (organisationenhed_registrering.registrering).brugerref,
                (organisationenhed_registrering.registrering).note);

            organisationenhed_registrering_id := new_organisationenhed_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(organisationenhed_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [organisationenhed]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF organisationenhed_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(organisationenhed_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH organisationenhed_attr_egenskaber_obj IN ARRAY organisationenhed_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO organisationenhed_attr_egenskaber (
      
      brugervendtnoegle,
      enhedsnavn,
      virkning,
      organisationenhed_registrering_id
    )
    SELECT
     
     organisationenhed_attr_egenskaber_obj.brugervendtnoegle,
      organisationenhed_attr_egenskaber_obj.enhedsnavn,
      organisationenhed_attr_egenskaber_obj.virkning,
      organisationenhed_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(organisationenhed_registrering.tilsGyldighed, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [gyldighed] for organisationenhed. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF organisationenhed_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(organisationenhed_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH organisationenhed_tils_gyldighed_obj IN ARRAY organisationenhed_registrering.tilsGyldighed
  LOOP

    INSERT INTO organisationenhed_tils_gyldighed (
      virkning,
      gyldighed,
      organisationenhed_registrering_id
    )
    SELECT
      organisationenhed_tils_gyldighed_obj.virkning,
      organisationenhed_tils_gyldighed_obj.gyldighed,
      organisationenhed_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations



    INSERT INTO organisationenhed_relation (
      organisationenhed_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      organisationenhed_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(organisationenhed_registrering.relationer) a
  ;




/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationenhed(array[organisationenhed_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[organisationenhed_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import organisationenhed with uuid [%]. Object does not met stipulated criteria:%',organisationenhed_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN organisationenhed_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_organisationenhed(organisationenhed_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr OrganisationenhedRegistreringType[]=null
  )
  RETURNS OrganisationenhedType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result OrganisationenhedType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationenhed(organisationenhed_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(organisationenhed_uuids,1),0) AND auth_filtered_uuids @>organisationenhed_uuids) THEN
  RAISE EXCEPTION 'Unable to list organisationenhed with uuids [%]. All objects do not fullfill the stipulated criteria:%',organisationenhed_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.organisationenhedObj) into result
FROM
(
SELECT
ROW(
	a.organisationenhed_id,
	array_agg(
		ROW (
			a.registrering,
			a.OrganisationenhedTilsGyldighedArr,
			a.OrganisationenhedAttrEgenskaberArr,
			a.OrganisationenhedRelationArr
		)::OrganisationenhedRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: OrganisationenhedType  organisationenhedObj
FROM
(
	SELECT
	a.organisationenhed_id,
	a.organisationenhed_registrering_id,
	a.registrering,
	a.OrganisationenhedAttrEgenskaberArr,
	a.OrganisationenhedTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type
			):: OrganisationenhedRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
        
	)) OrganisationenhedRelationArr
	FROM
	(
			SELECT
			a.organisationenhed_id,
			a.organisationenhed_registrering_id,
			a.registrering,
			a.OrganisationenhedAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::OrganisationenhedGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) OrganisationenhedTilsGyldighedArr		
			FROM
			(
					SELECT
					a.organisationenhed_id,
					a.organisationenhed_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.enhedsnavn,
					   		b.virkning
                            
							)::OrganisationenhedEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.enhedsnavn,b.virkning
                        
					)) OrganisationenhedAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id organisationenhed_id,
					b.id organisationenhed_registrering_id,
					b.registrering			
					FROM		organisationenhed a
					JOIN 		organisationenhed_registrering b 	ON b.organisationenhed_id=a.id
					WHERE a.id = ANY (organisationenhed_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN organisationenhed_attr_egenskaber as b ON b.organisationenhed_registrering_id=a.organisationenhed_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.organisationenhed_id,
					a.organisationenhed_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN organisationenhed_tils_gyldighed as b ON b.organisationenhed_registrering_id=a.organisationenhed_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.organisationenhed_id,
			a.organisationenhed_registrering_id,
			a.registrering,
			a.OrganisationenhedAttrEgenskaberArr
	) as a
	LEFT JOIN organisationenhed_relation b ON b.organisationenhed_registrering_id=a.organisationenhed_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.organisationenhed_id,
	a.organisationenhed_registrering_id,
	a.registrering,
	a.OrganisationenhedAttrEgenskaberArr,
	a.OrganisationenhedTilsGyldighedArr
) as a

WHERE a.organisationenhed_id IS NOT NULL
GROUP BY 
a.organisationenhed_id
order by a.organisationenhed_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_organisationenhed(
    organisationenhed_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      OrganisationenhedRegistreringType[]=null
) RETURNS OrganisationenhedType AS $$
DECLARE
	resArr OrganisationenhedType[];
BEGIN
    resArr := as_list_organisationenhed(ARRAY[organisationenhed_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_organisationenhed(
    firstResult int,--TOOD ??
    organisationenhed_uuid uuid,
    registreringObj   OrganisationenhedRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr OrganisationenhedRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    organisationenhed_candidates uuid[];
    organisationenhed_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj OrganisationenhedEgenskaberAttrType;

    
    tilsGyldighedTypeObj OrganisationenhedGyldighedTilsType;

    relationTypeObj OrganisationenhedRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

organisationenhed_candidates_is_initialized := false;

IF organisationenhed_uuid is not NULL THEN
    organisationenhed_candidates:= ARRAY[organisationenhed_uuid];
    organisationenhed_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        organisationenhed_candidates:=array(
                SELECT DISTINCT
                b.organisationenhed_id
                FROM
                organisationenhed a
                JOIN organisationenhed_registrering b on b.organisationenhed_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 1:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 1:%',organisationenhed_candidates;
--/****************************//


--RAISE NOTICE 'organisationenhed_candidates_is_initialized step 2:%',organisationenhed_candidates_is_initialized;
--RAISE NOTICE 'organisationenhed_candidates step 2:%',organisationenhed_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_organisationenhed: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(organisationenhed_candidates,1),0)>0 OR NOT organisationenhed_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            organisationenhed_candidates:=array(
            SELECT DISTINCT
            b.organisationenhed_id
            FROM  organisationenhed_attr_egenskaber a
            JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.enhedsnavn IS NULL
                    OR
                    a.enhedsnavn ILIKE attrEgenskaberTypeObj.enhedsnavn --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )

            );


            organisationenhed_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 3:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 3:%',organisationenhed_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        organisationenhed_candidates:=array(

            SELECT DISTINCT
            b.organisationenhed_id
            
            FROM  organisationenhed_attr_egenskaber a
            JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.enhedsnavn ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )


        );

    organisationenhed_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
    --RAISE DEBUG 'as_search_organisationenhed: skipping filtration on tilsGyldighed';
ELSE
    IF (coalesce(array_length(organisationenhed_candidates,1),0)>0 OR organisationenhed_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
        LOOP
            organisationenhed_candidates:=array(
            SELECT DISTINCT
            b.organisationenhed_id
            FROM  organisationenhed_tils_gyldighed a
            JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id
            WHERE
                (
                    tilsGyldighedTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsGyldighedTypeObj.gyldighed IS NULL
                    OR
                    tilsGyldighedTypeObj.gyldighed = a.gyldighed
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )

    );


            organisationenhed_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer OrganisationenhedRelationType[]
*/


--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 4:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 4:%',organisationenhed_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_organisationenhed: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(organisationenhed_candidates,1),0)>0 OR NOT organisationenhed_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            organisationenhed_candidates:=array(
            SELECT DISTINCT
            b.organisationenhed_id
            FROM  organisationenhed_relation a
            JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )

    );

            organisationenhed_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        organisationenhed_candidates:=array(
            SELECT DISTINCT
            b.organisationenhed_id
            
            FROM  organisationenhed_relation a
            JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )


            );

    organisationenhed_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        organisationenhed_candidates:=array(
            SELECT DISTINCT
            b.organisationenhed_id
            
            FROM  organisationenhed_relation a
            JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )


            );

    organisationenhed_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 




--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 5:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 5:%',organisationenhed_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT organisationenhed_candidates_is_initialized THEN
        organisationenhed_candidates:=array(
        SELECT DISTINCT
            organisationenhed_id
        FROM
            organisationenhed_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationenhed_candidates_is_initialized) OR b.organisationenhed_id = ANY (organisationenhed_candidates) )

        )
        ;

        organisationenhed_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT organisationenhed_candidates_is_initialized THEN
    --No filters applied!
    organisationenhed_candidates:=array(
        SELECT DISTINCT id FROM organisationenhed a
    );
ELSE
    organisationenhed_candidates:=array(
        SELECT DISTINCT id FROM unnest(organisationenhed_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 6:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 6:%',organisationenhed_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationenhed(organisationenhed_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_organisationenhed(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_OrganisationenhedRegistreringType_to_json(OrganisationenhedRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END organisationenhedegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END organisationenhedgyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::OrganisationenhedRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (OrganisationenhedRegistreringType as json);
create cast (OrganisationenhedRegistreringType as json) with function actual_state._cast_OrganisationenhedRegistreringType_to_json(OrganisationenhedRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_organisationenhedType_to_json(OrganisationenhedType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg OrganisationenhedRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (OrganisationenhedType as json);
create cast (OrganisationenhedType as json) with function actual_state._cast_organisationenhedType_to_json(OrganisationenhedType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_organisationenhed(
    organisationenhed_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    OrganisationenhedRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    organisationenhed_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    organisationenhed_sorted_uuid:=array(
          SELECT b.organisationenhed_id
            FROM organisationenhed_registrering b
            JOIN organisationenhed_attr_egenskaber a ON a.organisationenhed_registrering_id=b.id
           WHERE b.organisationenhed_id = ANY (organisationenhed_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.organisationenhed_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.organisationenhed_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN organisationenhed_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_organisationenhed(
	organisationenhed_uuids uuid[],
	registreringObjArr OrganisationenhedRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	organisationenhed_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	organisationenhed_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj OrganisationenhedEgenskaberAttrType;
	
  	tilsGyldighedTypeObj OrganisationenhedGyldighedTilsType;
	relationTypeObj OrganisationenhedRelationType;
	registreringObj OrganisationenhedRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN organisationenhed_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF organisationenhed_uuids IS NULL OR coalesce(array_length(organisationenhed_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

organisationenhed_candidates:= organisationenhed_uuids;



--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 1:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 1:%',organisationenhed_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_organisationenhed: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(organisationenhed_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			organisationenhed_candidates:=array(
			SELECT DISTINCT
			b.organisationenhed_id 
			FROM  organisationenhed_attr_egenskaber a 
			JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.enhedsnavn IS NULL
					OR 
					a.enhedsnavn = attrEgenskaberTypeObj.enhedsnavn 
				)
				AND b.organisationenhed_id = ANY (organisationenhed_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 3:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 3:%',organisationenhed_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_organisationenhed: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(organisationenhed_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			organisationenhed_candidates:=array(
			SELECT DISTINCT
			b.organisationenhed_id 
			FROM  organisationenhed_tils_gyldighed a
			JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.organisationenhed_id = ANY (organisationenhed_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer OrganisationenhedRelationType[]
*/


--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 4:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 4:%',organisationenhed_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_organisationenhed: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(organisationenhed_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			organisationenhed_candidates:=array(
			SELECT DISTINCT
			b.organisationenhed_id 
			FROM  organisationenhed_relation a
			JOIN organisationenhed_registrering b on a.organisationenhed_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.organisationenhed_id = ANY (organisationenhed_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'organisationenhed_candidates_is_initialized step 5:%',organisationenhed_candidates_is_initialized;
--RAISE DEBUG 'organisationenhed_candidates step 5:%',organisationenhed_candidates;

organisationenhed_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (organisationenhed_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (organisationenhed_candidates) b(id)
);

--optimization 
IF coalesce(array_length(organisationenhed_passed_auth_filter,1),0)=coalesce(array_length(organisationenhed_uuids,1),0) AND organisationenhed_passed_auth_filter @>organisationenhed_uuids THEN
	RETURN organisationenhed_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN organisationenhed_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE OrganisationfunktionGyldighedTils AS ENUM ('Aktiv','Inaktiv',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE OrganisationfunktionGyldighedTilsType AS (
    virkning Virkning,
    gyldighed OrganisationfunktionGyldighedTils
)
;



CREATE TYPE OrganisationfunktionEgenskaberAttrType AS (
brugervendtnoegle text,
funktionsnavn text,

 virkning Virkning
);




CREATE TYPE OrganisationfunktionRelationKode AS ENUM  ('organisatoriskfunktionstype','adresser','opgaver','tilknyttedebrugere','tilknyttedeenheder','tilknyttedeorganisationer','tilknyttedeitsystemer','tilknyttedeinteressefaellesskaber','tilknyttedepersoner');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_organisationfunktion_relation_kode_to_txt is invoked.



CREATE TYPE OrganisationfunktionRelationType AS (
  relType OrganisationfunktionRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text
)
;



CREATE TYPE OrganisationfunktionRegistreringType AS
(
registrering RegistreringBase,
tilsGyldighed OrganisationfunktionGyldighedTilsType[],
attrEgenskaber OrganisationfunktionEgenskaberAttrType[],
relationer OrganisationfunktionRelationType[]
);

CREATE TYPE OrganisationfunktionType AS
(
  id uuid,
  registrering OrganisationfunktionRegistreringType[]
);  





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_organisationfunktion_relation_kode_to_txt(
    OrganisationfunktionRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE organisationfunktion (
    id uuid NOT NULL,
    CONSTRAINT organisationfunktion_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE organisationfunktion
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE organisationfunktion_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE organisationfunktion_registrering_id_seq
    OWNER TO mox;


CREATE TABLE organisationfunktion_registrering (
   id bigint NOT NULL DEFAULT nextval('organisationfunktion_registrering_id_seq'::regclass),
   organisationfunktion_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT organisationfunktion_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT organisationfunktion_registrering_organisationfunktion_fkey FOREIGN KEY (organisationfunktion_id)
       REFERENCES organisationfunktion (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT organisationfunktion_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(organisationfunktion_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE organisationfunktion_registrering
  OWNER TO mox;


CREATE INDEX organisationfunktion_registrering_idx_livscykluskode
    ON organisationfunktion_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX organisationfunktion_registrering_idx_brugerref
    ON organisationfunktion_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX organisationfunktion_registrering_idx_note
    ON organisationfunktion_registrering
    USING btree
    (((registrering).note));


CREATE INDEX organisationfunktion_registrering_pat_note
    ON organisationfunktion_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX organisationfunktion_id_idx
    ON organisationfunktion_registrering (organisationfunktion_id);


CREATE TRIGGER notify_organisationfunktion
    AFTER INSERT OR UPDATE OR DELETE ON organisationfunktion_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE organisationfunktion_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE organisationfunktion_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE organisationfunktion_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('organisationfunktion_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        funktionsnavn text  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    organisationfunktion_registrering_id bigint NOT NULL,
    CONSTRAINT organisationfunktion_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT organisationfunktion_attr_egenskaber_forkey_organisationfunktionregistrering FOREIGN KEY (organisationfunktion_registrering_id) REFERENCES organisationfunktion_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT organisationfunktion_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (organisationfunktion_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE organisationfunktion_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX organisationfunktion_attr_egenskaber_pat_brugervendtnoegle
            ON organisationfunktion_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX organisationfunktion_attr_egenskaber_idx_brugervendtnoegle
            ON organisationfunktion_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX organisationfunktion_attr_egenskaber_pat_funktionsnavn
            ON organisationfunktion_attr_egenskaber
            USING gin
            (funktionsnavn gin_trgm_ops);

        CREATE INDEX organisationfunktion_attr_egenskaber_idx_funktionsnavn
            ON organisationfunktion_attr_egenskaber
            USING btree
            (funktionsnavn); 



CREATE INDEX organisationfunktion_attr_egenskaber_idx_virkning_aktoerref
    ON organisationfunktion_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX organisationfunktion_attr_egenskaber_idx_virkning_aktoertypekode
    ON organisationfunktion_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX organisationfunktion_attr_egenskaber_idx_virkning_notetekst
    ON organisationfunktion_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX organisationfunktion_attr_egenskaber_pat_virkning_notetekst
    ON organisationfunktion_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE organisationfunktion_tils_gyldighed_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE organisationfunktion_tils_gyldighed_id_seq
    OWNER TO mox;


CREATE TABLE organisationfunktion_tils_gyldighed (
    id bigint NOT NULL DEFAULT nextval('organisationfunktion_tils_gyldighed_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    gyldighed OrganisationfunktionGyldighedTils NOT NULL, 
    organisationfunktion_registrering_id bigint not null,
    CONSTRAINT organisationfunktion_tils_gyldighed_pkey PRIMARY KEY (id),
    CONSTRAINT organisationfunktion_tils_gyldighed_forkey_organisationfunktionregistrering FOREIGN KEY (organisationfunktion_registrering_id) REFERENCES organisationfunktion_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT organisationfunktion_tils_gyldighed_exclude_virkning_overlap EXCLUDE USING gist (organisationfunktion_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE organisationfunktion_tils_gyldighed
    OWNER TO mox;


CREATE INDEX organisationfunktion_tils_gyldighed_idx_gyldighed
    ON organisationfunktion_tils_gyldighed
    USING btree
    (gyldighed);
  
CREATE INDEX organisationfunktion_tils_gyldighed_idx_virkning_aktoerref
    ON organisationfunktion_tils_gyldighed
    USING btree
    (((virkning).aktoerref));

CREATE INDEX organisationfunktion_tils_gyldighed_idx_virkning_aktoertypekode
    ON organisationfunktion_tils_gyldighed
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX organisationfunktion_tils_gyldighed_idx_virkning_notetekst
    ON organisationfunktion_tils_gyldighed
    USING btree
    (((virkning).notetekst));

CREATE INDEX organisationfunktion_tils_gyldighed_pat_virkning_notetekst
    ON organisationfunktion_tils_gyldighed
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE organisationfunktion_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE organisationfunktion_relation_id_seq
    OWNER TO mox;


CREATE TABLE organisationfunktion_relation (
    id bigint NOT NULL DEFAULT nextval('organisationfunktion_relation_id_seq'::regclass),
    organisationfunktion_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type OrganisationfunktionRelationKode not null,
    objekt_type text null,

    

    CONSTRAINT organisationfunktion_relation_forkey_organisationfunktionregistrering FOREIGN KEY (organisationfunktion_registrering_id) REFERENCES organisationfunktion_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT organisationfunktion_relation_pkey PRIMARY KEY (id),
    CONSTRAINT organisationfunktion_relation_no_virkning_overlap EXCLUDE USING gist (organisationfunktion_registrering_id WITH =, _as_convert_organisationfunktion_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('adresser'::OrganisationfunktionRelationKode ) AND rel_type<>('opgaver'::OrganisationfunktionRelationKode ) AND rel_type<>('tilknyttedebrugere'::OrganisationfunktionRelationKode ) AND rel_type<>('tilknyttedeenheder'::OrganisationfunktionRelationKode ) AND rel_type<>('tilknyttedeorganisationer'::OrganisationfunktionRelationKode ) AND rel_type<>('tilknyttedeitsystemer'::OrganisationfunktionRelationKode ) AND rel_type<>('tilknyttedeinteressefaellesskaber'::OrganisationfunktionRelationKode ) AND rel_type<>('tilknyttedepersoner'::OrganisationfunktionRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT organisationfunktion_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>'')))
);
ALTER TABLE organisationfunktion_relation
  OWNER TO mox;





CREATE INDEX organisationfunktion_relation_idx_rel_maal_obj_uuid
    ON organisationfunktion_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX organisationfunktion_relation_idx_rel_maal_obj_urn
    ON organisationfunktion_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX organisationfunktion_relation_idx_rel_maal_uuid
    ON organisationfunktion_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX organisationfunktion_relation_idx_rel_maal_uuid_isolated
    ON organisationfunktion_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX organisationfunktion_relation_idx_rel_maal_urn_isolated
    ON organisationfunktion_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX organisationfunktion_relation_idx_rel_maal_urn
    ON organisationfunktion_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX organisationfunktion_relation_idx_virkning_aktoerref
    ON organisationfunktion_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX organisationfunktion_relation_idx_virkning_aktoertypekode
    ON organisationfunktion_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX organisationfunktion_relation_idx_virkning_notetekst
    ON organisationfunktion_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX organisationfunktion_relation_pat_virkning_notetekst
    ON organisationfunktion_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr OrganisationfunktionGyldighedTilsType[])
  RETURNS OrganisationfunktionGyldighedTilsType[] AS
  $$
  DECLARE result OrganisationfunktionGyldighedTilsType[];
  DECLARE element OrganisationfunktionGyldighedTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.gyldighed IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr OrganisationfunktionEgenskaberAttrType[])
  RETURNS OrganisationfunktionEgenskaberAttrType[] AS
  $$
  DECLARE result OrganisationfunktionEgenskaberAttrType[]; 
   DECLARE element OrganisationfunktionEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.funktionsnavn IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr OrganisationfunktionRelationType[])
RETURNS OrganisationfunktionRelationType[] AS
$$
 DECLARE result OrganisationfunktionRelationType[];
 DECLARE element OrganisationfunktionRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_organisationfunktion_registrering(
    organisationfunktion_registrering
) RETURNS organisationfunktion_registrering AS $BODY$
  SELECT * FROM organisationfunktion_registrering as a WHERE
    organisationfunktion_id = $1.organisationfunktion_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_organisationfunktion_registrering(
    organisationfunktion_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS organisationfunktion_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    organisationfunktion_registrering_id bigint;
    organisationfunktion_registrering    organisationfunktion_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE organisationfunktion_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE organisationfunktion_id = organisationfunktion_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating organisationfunktion with uuid [%], Invalid [livscyklus] transition to [%]',organisationfunktion_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new organisationfunktion registrering

    organisationfunktion_registrering_id := nextval('organisationfunktion_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    organisationfunktion_registrering := ROW(
        organisationfunktion_registrering_id,
        organisationfunktion_uuid,
        registreringObj
    )::organisationfunktion_registrering;

    INSERT INTO organisationfunktion_registrering SELECT organisationfunktion_registrering.*;

    RETURN organisationfunktion_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of OrganisationfunktionAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_organisationfunktion(
    organisationfunktion_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber OrganisationfunktionEgenskaberAttrType[],
    

    
    tilsGyldighed OrganisationfunktionGyldighedTilsType[],
    

    relationer OrganisationfunktionRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      OrganisationfunktionRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_organisationfunktion          OrganisationfunktionType;
    read_prev_organisationfunktion         OrganisationfunktionType;
    read_new_organisationfunktion_reg      OrganisationfunktionRegistreringType;
    read_prev_organisationfunktion_reg     OrganisationfunktionRegistreringType;
    new_organisationfunktion_registrering  organisationfunktion_registrering;
    prev_organisationfunktion_registrering organisationfunktion_registrering;
    organisationfunktion_relation_navn     OrganisationfunktionRelationKode;

    
    attrEgenskaberObj OrganisationfunktionEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from organisationfunktion a join organisationfunktion_registrering b ON b.organisationfunktion_id=a.id WHERE a.id=organisationfunktion_uuid) THEN
        RAISE EXCEPTION 'Unable to update organisationfunktion with uuid [%], being unable to find any previous registrations.',organisationfunktion_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM organisationfunktion a WHERE a.id=organisationfunktion_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_organisationfunktion(array[organisationfunktion_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[organisationfunktion_uuid]) THEN
      RAISE EXCEPTION 'Unable to update organisationfunktion with uuid [%]. Object does not met stipulated criteria:%', organisationfunktion_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_organisationfunktion_registrering := _as_create_organisationfunktion_registrering(organisationfunktion_uuid, livscykluskode, brugerref, note);
    prev_organisationfunktion_registrering := _as_get_prev_organisationfunktion_registrering(new_organisationfunktion_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_organisationfunktion_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update organisationfunktion with uuid [%], as the organisationfunktion seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', organisationfunktion_uuid, lostUpdatePreventionTZ, LOWER((prev_organisationfunktion_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    

    INSERT INTO organisationfunktion_relation (organisationfunktion_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
    SELECT
        new_organisationfunktion_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType 
        FROM
            unnest(relationer) AS a ;

    


    -- Ad 2)
    -- 0..1 relations

    
    
    FOREACH organisationfunktion_relation_navn IN ARRAY ARRAY['organisatoriskfunktionstype'::OrganisationfunktionRelationKode  ]::OrganisationfunktionRelationKode[]  LOOP
        INSERT INTO organisationfunktion_relation (organisationfunktion_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
        SELECT
            new_organisationfunktion_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM organisationfunktion_relation b
                 WHERE b.organisationfunktion_registrering_id = new_organisationfunktion_registrering.id AND b.rel_type = organisationfunktion_relation_navn) d
            JOIN organisationfunktion_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.organisationfunktion_registrering_id = prev_organisationfunktion_registrering.id AND a.rel_type = organisationfunktion_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
    FOREACH organisationfunktion_relation_navn IN ARRAY ARRAY['adresser'::OrganisationfunktionRelationKode, 'opgaver'::OrganisationfunktionRelationKode, 'tilknyttedebrugere'::OrganisationfunktionRelationKode, 'tilknyttedeenheder'::OrganisationfunktionRelationKode, 'tilknyttedeorganisationer'::OrganisationfunktionRelationKode, 'tilknyttedeitsystemer'::OrganisationfunktionRelationKode, 'tilknyttedeinteressefaellesskaber'::OrganisationfunktionRelationKode, 'tilknyttedepersoner'::OrganisationfunktionRelationKode]::OrganisationfunktionRelationKode[] LOOP
        IF NOT EXISTS (
                    SELECT 1
                      FROM organisationfunktion_relation
                     WHERE organisationfunktion_registrering_id = new_organisationfunktion_registrering.id AND rel_type = organisationfunktion_relation_navn) THEN
                    
                    INSERT INTO organisationfunktion_relation (organisationfunktion_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type )
                    SELECT
                        new_organisationfunktion_registrering.id,  virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type
        FROM organisationfunktion_relation
        WHERE
            organisationfunktion_registrering_id = prev_organisationfunktion_registrering.id AND rel_type = organisationfunktion_relation_navn ;

    
        END IF;
    END LOOP;
    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsGyldighed IS NOT NULL AND coalesce(array_length(tilsGyldighed, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Gyldighed] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- organisationfunktion_tils_gyldighed

        -- Ad 1)
        INSERT INTO organisationfunktion_tils_gyldighed(virkning, gyldighed, organisationfunktion_registrering_id)
             SELECT a.virkning, a.gyldighed, new_organisationfunktion_registrering.id
               FROM unnest(tilsGyldighed) AS a;

        -- Ad 2
        INSERT INTO organisationfunktion_tils_gyldighed(virkning, gyldighed, organisationfunktion_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.gyldighed,
            new_organisationfunktion_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- organisationfunktion_tils_gyldighed of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- organisationfunktion_tils_gyldighed of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM organisationfunktion_tils_gyldighed b
             WHERE b.organisationfunktion_registrering_id = new_organisationfunktion_registrering.id) d
              JOIN organisationfunktion_tils_gyldighed a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.organisationfunktion_registrering_id = prev_organisationfunktion_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- organisationfunktion_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrOrganisationfunktionObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.funktionsnavn,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update organisationfunktion with uuid [%], as the organisationfunktion have overlapping virknings in the given egenskaber array :%', organisationfunktion_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).funktionsnavn IS NULL  THEN
            
            INSERT INTO organisationfunktion_attr_egenskaber ( brugervendtnoegle,funktionsnavn, virkning, organisationfunktion_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.funktionsnavn, a.funktionsnavn),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_organisationfunktion_registrering.id
                        FROM organisationfunktion_attr_egenskaber a
                    WHERE
                        a.organisationfunktion_registrering_id = prev_organisationfunktion_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO organisationfunktion_attr_egenskaber ( brugervendtnoegle,funktionsnavn, virkning, organisationfunktion_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.funktionsnavn,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_organisationfunktion_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the organisationfunktion_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM organisationfunktion_attr_egenskaber b
                    WHERE b.organisationfunktion_registrering_id = new_organisationfunktion_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO organisationfunktion_attr_egenskaber ( brugervendtnoegle,funktionsnavn, virkning, organisationfunktion_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.funktionsnavn, attrEgenskaberObj.virkning, new_organisationfunktion_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO organisationfunktion_attr_egenskaber ( brugervendtnoegle,funktionsnavn, virkning, organisationfunktion_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.funktionsnavn,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_organisationfunktion_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- organisationfunktion_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- organisationfunktion_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                organisationfunktion_attr_egenskaber b
            WHERE
                b.organisationfunktion_registrering_id = new_organisationfunktion_registrering.id) d
            JOIN organisationfunktion_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.organisationfunktion_registrering_id = prev_organisationfunktion_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_organisationfunktion := as_read_organisationfunktion(organisationfunktion_uuid, (new_organisationfunktion_registrering.registrering).timeperiod, null);
    read_prev_organisationfunktion := as_read_organisationfunktion(organisationfunktion_uuid, (prev_organisationfunktion_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_organisationfunktion.registrering[1].registrering).TimePeriod) = lower((new_organisationfunktion_registrering.registrering).TimePeriod) and lower((read_prev_organisationfunktion.registrering[1].registrering).TimePeriod)=lower((prev_organisationfunktion_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating organisationfunktion with id [%]: The ordering of as_list_organisationfunktion should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', organisationfunktion_uuid, to_json(new_organisationfunktion_registrering), to_json(read_new_organisationfunktion.registrering[1].registrering), to_json(prev_organisationfunktion_registrering), to_json(prev_new_organisationfunktion.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_organisationfunktion_reg := ROW(
        ROW (null, (read_new_organisationfunktion.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_organisationfunktion.registrering[1]).tilsGyldighed ,
        
        (read_new_organisationfunktion.registrering[1]).attrEgenskaber ,
        (read_new_organisationfunktion.registrering[1]).relationer
    )::organisationfunktionRegistreringType;

    read_prev_organisationfunktion_reg := ROW(
        ROW(null, (read_prev_organisationfunktion.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_organisationfunktion.registrering[1]).tilsGyldighed ,
        
        (read_prev_organisationfunktion.registrering[1]).attrEgenskaber ,
        (read_prev_organisationfunktion.registrering[1]).relationer
    )::organisationfunktionRegistreringType;


    IF read_prev_organisationfunktion_reg = read_new_organisationfunktion_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_organisationfunktion_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_organisationfunktion_reg);
      RAISE EXCEPTION 'Aborted updating organisationfunktion with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', organisationfunktion_uuid, to_json(read_new_organisationfunktion_reg), to_json(read_prev_organisationfunktion_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_organisationfunktion_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_organisationfunktion (
    organisationfunktion_registrering OrganisationfunktionRegistreringType,
    organisationfunktion_uuid uuid DEFAULT NULL, auth_criteria_arr
    OrganisationfunktionRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE organisationfunktion_registrering_id bigint;

    
    organisationfunktion_attr_egenskaber_obj organisationfunktionEgenskaberAttrType;
    

    
    organisationfunktion_tils_gyldighed_obj organisationfunktionGyldighedTilsType;
    

    organisationfunktion_relationer OrganisationfunktionRelationType;

    

    auth_filtered_uuids uuid[];

    

    does_exist boolean;
    new_organisationfunktion_registrering organisationfunktion_registrering;
BEGIN
    IF organisationfunktion_uuid IS NULL THEN LOOP
        organisationfunktion_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from organisationfunktion WHERE id=organisationfunktion_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from organisationfunktion WHERE id=organisationfunktion_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (organisationfunktion_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (organisationfunktion_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (organisationfunktion_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_organisationfunktion.',(organisationfunktion_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO organisationfunktion (ID) SELECT
        organisationfunktion_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        organisationfunktion_registrering_id:=nextval('organisationfunktion_registrering_id_seq');

        INSERT INTO organisationfunktion_registrering (id, organisationfunktion_id,
            registrering) SELECT organisationfunktion_registrering_id,
        organisationfunktion_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (organisationfunktion_registrering.registrering).livscykluskode,
        (organisationfunktion_registrering.registrering).brugerref,
        (organisationfunktion_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_organisationfunktion_registrering :=
            _as_create_organisationfunktion_registrering(organisationfunktion_uuid,
                (organisationfunktion_registrering.registrering).livscykluskode,
                (organisationfunktion_registrering.registrering).brugerref,
                (organisationfunktion_registrering.registrering).note);

            organisationfunktion_registrering_id := new_organisationfunktion_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(organisationfunktion_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [organisationfunktion]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF organisationfunktion_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(organisationfunktion_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH organisationfunktion_attr_egenskaber_obj IN ARRAY organisationfunktion_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO organisationfunktion_attr_egenskaber (
      
      brugervendtnoegle,
      funktionsnavn,
      virkning,
      organisationfunktion_registrering_id
    )
    SELECT
     
     organisationfunktion_attr_egenskaber_obj.brugervendtnoegle,
      organisationfunktion_attr_egenskaber_obj.funktionsnavn,
      organisationfunktion_attr_egenskaber_obj.virkning,
      organisationfunktion_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(organisationfunktion_registrering.tilsGyldighed, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [gyldighed] for organisationfunktion. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF organisationfunktion_registrering.tilsGyldighed IS NOT NULL AND coalesce(array_length(organisationfunktion_registrering.tilsGyldighed,1),0)>0 THEN
  FOREACH organisationfunktion_tils_gyldighed_obj IN ARRAY organisationfunktion_registrering.tilsGyldighed
  LOOP

    INSERT INTO organisationfunktion_tils_gyldighed (
      virkning,
      gyldighed,
      organisationfunktion_registrering_id
    )
    SELECT
      organisationfunktion_tils_gyldighed_obj.virkning,
      organisationfunktion_tils_gyldighed_obj.gyldighed,
      organisationfunktion_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations



    INSERT INTO organisationfunktion_relation (
      organisationfunktion_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type
    )
    SELECT
      organisationfunktion_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType
    FROM unnest(organisationfunktion_registrering.relationer) a
  ;




/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationfunktion(array[organisationfunktion_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[organisationfunktion_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import organisationfunktion with uuid [%]. Object does not met stipulated criteria:%',organisationfunktion_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN organisationfunktion_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_organisationfunktion(organisationfunktion_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr OrganisationfunktionRegistreringType[]=null
  )
  RETURNS OrganisationfunktionType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result OrganisationfunktionType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationfunktion(organisationfunktion_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(organisationfunktion_uuids,1),0) AND auth_filtered_uuids @>organisationfunktion_uuids) THEN
  RAISE EXCEPTION 'Unable to list organisationfunktion with uuids [%]. All objects do not fullfill the stipulated criteria:%',organisationfunktion_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.organisationfunktionObj) into result
FROM
(
SELECT
ROW(
	a.organisationfunktion_id,
	array_agg(
		ROW (
			a.registrering,
			a.OrganisationfunktionTilsGyldighedArr,
			a.OrganisationfunktionAttrEgenskaberArr,
			a.OrganisationfunktionRelationArr
		)::OrganisationfunktionRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: OrganisationfunktionType  organisationfunktionObj
FROM
(
	SELECT
	a.organisationfunktion_id,
	a.organisationfunktion_registrering_id,
	a.registrering,
	a.OrganisationfunktionAttrEgenskaberArr,
	a.OrganisationfunktionTilsGyldighedArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type
			):: OrganisationfunktionRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.virkning
        
	)) OrganisationfunktionRelationArr
	FROM
	(
			SELECT
			a.organisationfunktion_id,
			a.organisationfunktion_registrering_id,
			a.registrering,
			a.OrganisationfunktionAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.gyldighed
						) ::OrganisationfunktionGyldighedTilsType
					ELSE NULL
					END
					order by b.gyldighed,b.virkning
				)) OrganisationfunktionTilsGyldighedArr		
			FROM
			(
					SELECT
					a.organisationfunktion_id,
					a.organisationfunktion_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.funktionsnavn,
					   		b.virkning
                            
							)::OrganisationfunktionEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.funktionsnavn,b.virkning
                        
					)) OrganisationfunktionAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id organisationfunktion_id,
					b.id organisationfunktion_registrering_id,
					b.registrering			
					FROM		organisationfunktion a
					JOIN 		organisationfunktion_registrering b 	ON b.organisationfunktion_id=a.id
					WHERE a.id = ANY (organisationfunktion_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN organisationfunktion_attr_egenskaber as b ON b.organisationfunktion_registrering_id=a.organisationfunktion_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.organisationfunktion_id,
					a.organisationfunktion_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN organisationfunktion_tils_gyldighed as b ON b.organisationfunktion_registrering_id=a.organisationfunktion_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.organisationfunktion_id,
			a.organisationfunktion_registrering_id,
			a.registrering,
			a.OrganisationfunktionAttrEgenskaberArr
	) as a
	LEFT JOIN organisationfunktion_relation b ON b.organisationfunktion_registrering_id=a.organisationfunktion_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.organisationfunktion_id,
	a.organisationfunktion_registrering_id,
	a.registrering,
	a.OrganisationfunktionAttrEgenskaberArr,
	a.OrganisationfunktionTilsGyldighedArr
) as a

WHERE a.organisationfunktion_id IS NOT NULL
GROUP BY 
a.organisationfunktion_id
order by a.organisationfunktion_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_organisationfunktion(
    organisationfunktion_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      OrganisationfunktionRegistreringType[]=null
) RETURNS OrganisationfunktionType AS $$
DECLARE
	resArr OrganisationfunktionType[];
BEGIN
    resArr := as_list_organisationfunktion(ARRAY[organisationfunktion_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_organisationfunktion(
    firstResult int,--TOOD ??
    organisationfunktion_uuid uuid,
    registreringObj   OrganisationfunktionRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr OrganisationfunktionRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    organisationfunktion_candidates uuid[];
    organisationfunktion_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj OrganisationfunktionEgenskaberAttrType;

    
    tilsGyldighedTypeObj OrganisationfunktionGyldighedTilsType;

    relationTypeObj OrganisationfunktionRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

organisationfunktion_candidates_is_initialized := false;

IF organisationfunktion_uuid is not NULL THEN
    organisationfunktion_candidates:= ARRAY[organisationfunktion_uuid];
    organisationfunktion_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        organisationfunktion_candidates:=array(
                SELECT DISTINCT
                b.organisationfunktion_id
                FROM
                organisationfunktion a
                JOIN organisationfunktion_registrering b on b.organisationfunktion_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 1:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 1:%',organisationfunktion_candidates;
--/****************************//


--RAISE NOTICE 'organisationfunktion_candidates_is_initialized step 2:%',organisationfunktion_candidates_is_initialized;
--RAISE NOTICE 'organisationfunktion_candidates step 2:%',organisationfunktion_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_organisationfunktion: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(organisationfunktion_candidates,1),0)>0 OR NOT organisationfunktion_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            organisationfunktion_candidates:=array(
            SELECT DISTINCT
            b.organisationfunktion_id
            FROM  organisationfunktion_attr_egenskaber a
            JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.funktionsnavn IS NULL
                    OR
                    a.funktionsnavn ILIKE attrEgenskaberTypeObj.funktionsnavn --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )

            );


            organisationfunktion_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 3:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 3:%',organisationfunktion_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        organisationfunktion_candidates:=array(

            SELECT DISTINCT
            b.organisationfunktion_id
            
            FROM  organisationfunktion_attr_egenskaber a
            JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.funktionsnavn ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )


        );

    organisationfunktion_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
    --RAISE DEBUG 'as_search_organisationfunktion: skipping filtration on tilsGyldighed';
ELSE
    IF (coalesce(array_length(organisationfunktion_candidates,1),0)>0 OR organisationfunktion_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
        LOOP
            organisationfunktion_candidates:=array(
            SELECT DISTINCT
            b.organisationfunktion_id
            FROM  organisationfunktion_tils_gyldighed a
            JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id
            WHERE
                (
                    tilsGyldighedTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsGyldighedTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerRef IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsGyldighedTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsGyldighedTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsGyldighedTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsGyldighedTypeObj.virkning) IS NULL OR (tilsGyldighedTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsGyldighedTypeObj.gyldighed IS NULL
                    OR
                    tilsGyldighedTypeObj.gyldighed = a.gyldighed
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )

    );


            organisationfunktion_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer OrganisationfunktionRelationType[]
*/


--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 4:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 4:%',organisationfunktion_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_organisationfunktion: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(organisationfunktion_candidates,1),0)>0 OR NOT organisationfunktion_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            organisationfunktion_candidates:=array(
            SELECT DISTINCT
            b.organisationfunktion_id
            FROM  organisationfunktion_relation a
            JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )

    );

            organisationfunktion_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        organisationfunktion_candidates:=array(
            SELECT DISTINCT
            b.organisationfunktion_id
            
            FROM  organisationfunktion_relation a
            JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )


            );

    organisationfunktion_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        organisationfunktion_candidates:=array(
            SELECT DISTINCT
            b.organisationfunktion_id
            
            FROM  organisationfunktion_relation a
            JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )


            );

    organisationfunktion_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 




--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 5:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 5:%',organisationfunktion_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT organisationfunktion_candidates_is_initialized THEN
        organisationfunktion_candidates:=array(
        SELECT DISTINCT
            organisationfunktion_id
        FROM
            organisationfunktion_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT organisationfunktion_candidates_is_initialized) OR b.organisationfunktion_id = ANY (organisationfunktion_candidates) )

        )
        ;

        organisationfunktion_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT organisationfunktion_candidates_is_initialized THEN
    --No filters applied!
    organisationfunktion_candidates:=array(
        SELECT DISTINCT id FROM organisationfunktion a
    );
ELSE
    organisationfunktion_candidates:=array(
        SELECT DISTINCT id FROM unnest(organisationfunktion_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 6:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 6:%',organisationfunktion_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_organisationfunktion(organisationfunktion_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_organisationfunktion(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_OrganisationfunktionRegistreringType_to_json(OrganisationfunktionRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END organisationfunktionegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsGyldighed,1),0)>0 THEN to_json($1.tilsGyldighed) 
        ELSE 
        NULL
        END organisationfunktiongyldighed
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType)::OrganisationfunktionRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (OrganisationfunktionRegistreringType as json);
create cast (OrganisationfunktionRegistreringType as json) with function actual_state._cast_OrganisationfunktionRegistreringType_to_json(OrganisationfunktionRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_organisationfunktionType_to_json(OrganisationfunktionType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg OrganisationfunktionRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (OrganisationfunktionType as json);
create cast (OrganisationfunktionType as json) with function actual_state._cast_organisationfunktionType_to_json(OrganisationfunktionType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_organisationfunktion(
    organisationfunktion_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    OrganisationfunktionRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    organisationfunktion_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    organisationfunktion_sorted_uuid:=array(
          SELECT b.organisationfunktion_id
            FROM organisationfunktion_registrering b
            JOIN organisationfunktion_attr_egenskaber a ON a.organisationfunktion_registrering_id=b.id
           WHERE b.organisationfunktion_id = ANY (organisationfunktion_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.organisationfunktion_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.organisationfunktion_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN organisationfunktion_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_organisationfunktion(
	organisationfunktion_uuids uuid[],
	registreringObjArr OrganisationfunktionRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	organisationfunktion_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	organisationfunktion_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj OrganisationfunktionEgenskaberAttrType;
	
  	tilsGyldighedTypeObj OrganisationfunktionGyldighedTilsType;
	relationTypeObj OrganisationfunktionRelationType;
	registreringObj OrganisationfunktionRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN organisationfunktion_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF organisationfunktion_uuids IS NULL OR coalesce(array_length(organisationfunktion_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

organisationfunktion_candidates:= organisationfunktion_uuids;



--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 1:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 1:%',organisationfunktion_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_organisationfunktion: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(organisationfunktion_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			organisationfunktion_candidates:=array(
			SELECT DISTINCT
			b.organisationfunktion_id 
			FROM  organisationfunktion_attr_egenskaber a 
			JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.funktionsnavn IS NULL
					OR 
					a.funktionsnavn = attrEgenskaberTypeObj.funktionsnavn 
				)
				AND b.organisationfunktion_id = ANY (organisationfunktion_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 3:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 3:%',organisationfunktion_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Gyldighed
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsGyldighed IS NULL THEN
	--RAISE DEBUG 'as_search_organisationfunktion: skipping filtration on tilsGyldighed';
ELSE
	IF coalesce(array_length(organisationfunktion_candidates,1),0)>0 THEN 

		FOREACH tilsGyldighedTypeObj IN ARRAY registreringObj.tilsGyldighed
		LOOP
			organisationfunktion_candidates:=array(
			SELECT DISTINCT
			b.organisationfunktion_id 
			FROM  organisationfunktion_tils_gyldighed a
			JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsGyldighedTypeObj.gyldighed IS NULL
					OR
					tilsGyldighedTypeObj.gyldighed = a.gyldighed
				)
				AND b.organisationfunktion_id = ANY (organisationfunktion_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer OrganisationfunktionRelationType[]
*/


--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 4:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 4:%',organisationfunktion_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_organisationfunktion: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(organisationfunktion_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			organisationfunktion_candidates:=array(
			SELECT DISTINCT
			b.organisationfunktion_id 
			FROM  organisationfunktion_relation a
			JOIN organisationfunktion_registrering b on a.organisationfunktion_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.organisationfunktion_id = ANY (organisationfunktion_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'organisationfunktion_candidates_is_initialized step 5:%',organisationfunktion_candidates_is_initialized;
--RAISE DEBUG 'organisationfunktion_candidates step 5:%',organisationfunktion_candidates;

organisationfunktion_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (organisationfunktion_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (organisationfunktion_candidates) b(id)
);

--optimization 
IF coalesce(array_length(organisationfunktion_passed_auth_filter,1),0)=coalesce(array_length(organisationfunktion_uuids,1),0) AND organisationfunktion_passed_auth_filter @>organisationfunktion_uuids THEN
	RETURN organisationfunktion_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN organisationfunktion_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE SagFremdriftTils AS ENUM ('Opstaaet','Oplyst','Afgjort','Bestilt','Udfoert','Afsluttet',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE SagFremdriftTilsType AS (
    virkning Virkning,
    fremdrift SagFremdriftTils
)
;



CREATE TYPE SagEgenskaberAttrType AS (
brugervendtnoegle text,
afleveret ClearableBoolean,

beskrivelse text,
hjemmel text,
kassationskode text,
offentlighedundtaget offentlighedundtagettype,
principiel ClearableBoolean,

sagsnummer text,
titel text,

 virkning Virkning
);




CREATE TYPE SagRelationKode AS ENUM  ('behandlingarkiv','afleveringsarkiv','primaerklasse','opgaveklasse','handlingsklasse','kontoklasse','sikkerhedsklasse','foelsomhedsklasse','indsatsklasse','ydelsesklasse','ejer','ansvarlig','primaerbehandler','udlaanttil','primaerpart','ydelsesmodtager','oversag','praecedens','afgiftsobjekt','ejendomsskat','andetarkiv','andrebehandlere','sekundaerpart','andresager','byggeri','fredning','journalpost');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_sag_relation_kode_to_txt is invoked.


CREATE TYPE SagRelationJournalPostSpecifikKode AS ENUM ('journalnotat','vedlagtdokument','tilakteretdokument');
 
CREATE TYPE JournalNotatType AS (
titel text,
notat text,
format text
);

CREATE TYPE JournalPostDokumentAttrType AS (
dokumenttitel text,
offentlighedUndtaget OffentlighedundtagetType
);


CREATE TYPE SagRelationType AS (
  relType SagRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text,
  indeks int,
  relTypeSpec SagRelationJournalPostSpecifikKode,
  journalNotat JournalNotatType,
  journalDokumentAttr JournalPostDokumentAttrType
)
;



CREATE TYPE SagRegistreringType AS
(
registrering RegistreringBase,
tilsFremdrift SagFremdriftTilsType[],
attrEgenskaber SagEgenskaberAttrType[],
relationer SagRelationType[]
);

CREATE TYPE SagType AS
(
  id uuid,
  registrering SagRegistreringType[]
);  


CREATE Type _SagRelationMaxIndex AS
(
  relType SagRelationKode,
  indeks int
);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_sag_relation_kode_to_txt(
    SagRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE sag (
    id uuid NOT NULL,
    CONSTRAINT sag_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE sag
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE sag_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE sag_registrering_id_seq
    OWNER TO mox;


CREATE TABLE sag_registrering (
   id bigint NOT NULL DEFAULT nextval('sag_registrering_id_seq'::regclass),
   sag_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT sag_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT sag_registrering_sag_fkey FOREIGN KEY (sag_id)
       REFERENCES sag (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT sag_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(sag_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE sag_registrering
  OWNER TO mox;


CREATE INDEX sag_registrering_idx_livscykluskode
    ON sag_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX sag_registrering_idx_brugerref
    ON sag_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX sag_registrering_idx_note
    ON sag_registrering
    USING btree
    (((registrering).note));


CREATE INDEX sag_registrering_pat_note
    ON sag_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX sag_id_idx
    ON sag_registrering (sag_id);


CREATE TRIGGER notify_sag
    AFTER INSERT OR UPDATE OR DELETE ON sag_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE sag_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE sag_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE sag_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('sag_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        afleveret boolean  NULL,
        beskrivelse text NOT NULL,
        hjemmel text  NULL,
        kassationskode text NOT NULL,
        offentlighedundtaget offentlighedundtagettype  NULL,
        principiel boolean  NULL,
        sagsnummer text NOT NULL,
        titel text NOT NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    sag_registrering_id bigint NOT NULL,
    CONSTRAINT sag_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT sag_attr_egenskaber_forkey_sagregistrering FOREIGN KEY (sag_registrering_id) REFERENCES sag_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT sag_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (sag_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE sag_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX sag_attr_egenskaber_pat_brugervendtnoegle
            ON sag_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX sag_attr_egenskaber_idx_brugervendtnoegle
            ON sag_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
    
         
             
                CREATE INDEX sag_attr_egenskaber_idx_afleveret
                    ON sag_attr_egenskaber
                    USING btree
                    (afleveret);

            
         
     
 
     
        CREATE INDEX sag_attr_egenskaber_pat_beskrivelse
            ON sag_attr_egenskaber
            USING gin
            (beskrivelse gin_trgm_ops);

        CREATE INDEX sag_attr_egenskaber_idx_beskrivelse
            ON sag_attr_egenskaber
            USING btree
            (beskrivelse); 
 
     
        CREATE INDEX sag_attr_egenskaber_pat_hjemmel
            ON sag_attr_egenskaber
            USING gin
            (hjemmel gin_trgm_ops);

        CREATE INDEX sag_attr_egenskaber_idx_hjemmel
            ON sag_attr_egenskaber
            USING btree
            (hjemmel); 
 
     
        CREATE INDEX sag_attr_egenskaber_pat_kassationskode
            ON sag_attr_egenskaber
            USING gin
            (kassationskode gin_trgm_ops);

        CREATE INDEX sag_attr_egenskaber_idx_kassationskode
            ON sag_attr_egenskaber
            USING btree
            (kassationskode); 
 
    
         
             
                CREATE INDEX sag_attr_egenskaber_pat_AlternativTitel_offentlighedundtaget
                    ON sag_attr_egenskaber
                    USING gin
                    ( ((offentlighedundtaget).AlternativTitel) gin_trgm_ops);

                CREATE INDEX sag_attr_egenskaber_idx_AlternativTitel_offentlighedundtaget
                    ON sag_attr_egenskaber
                    USING btree
                    (((offentlighedundtaget).AlternativTitel));

                CREATE INDEX sag_attr_egenskaber_pat_Hjemmel_offentlighedundtaget
                    ON sag_attr_egenskaber
                    USING gin
                    (((offentlighedundtaget).Hjemmel) gin_trgm_ops);

                CREATE INDEX sag_attr_egenskaber_idx_Hjemmel_offentlighedundtaget
                    ON sag_attr_egenskaber
                    USING btree
                    (((offentlighedundtaget).Hjemmel));
            
         
     
 
    
         
             
                CREATE INDEX sag_attr_egenskaber_idx_principiel
                    ON sag_attr_egenskaber
                    USING btree
                    (principiel);

            
         
     
 
     
        CREATE INDEX sag_attr_egenskaber_pat_sagsnummer
            ON sag_attr_egenskaber
            USING gin
            (sagsnummer gin_trgm_ops);

        CREATE INDEX sag_attr_egenskaber_idx_sagsnummer
            ON sag_attr_egenskaber
            USING btree
            (sagsnummer); 
 
     
        CREATE INDEX sag_attr_egenskaber_pat_titel
            ON sag_attr_egenskaber
            USING gin
            (titel gin_trgm_ops);

        CREATE INDEX sag_attr_egenskaber_idx_titel
            ON sag_attr_egenskaber
            USING btree
            (titel); 



CREATE INDEX sag_attr_egenskaber_idx_virkning_aktoerref
    ON sag_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX sag_attr_egenskaber_idx_virkning_aktoertypekode
    ON sag_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX sag_attr_egenskaber_idx_virkning_notetekst
    ON sag_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX sag_attr_egenskaber_pat_virkning_notetekst
    ON sag_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE sag_tils_fremdrift_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE sag_tils_fremdrift_id_seq
    OWNER TO mox;


CREATE TABLE sag_tils_fremdrift (
    id bigint NOT NULL DEFAULT nextval('sag_tils_fremdrift_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    fremdrift SagFremdriftTils NOT NULL, 
    sag_registrering_id bigint not null,
    CONSTRAINT sag_tils_fremdrift_pkey PRIMARY KEY (id),
    CONSTRAINT sag_tils_fremdrift_forkey_sagregistrering FOREIGN KEY (sag_registrering_id) REFERENCES sag_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT sag_tils_fremdrift_exclude_virkning_overlap EXCLUDE USING gist (sag_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE sag_tils_fremdrift
    OWNER TO mox;


CREATE INDEX sag_tils_fremdrift_idx_fremdrift
    ON sag_tils_fremdrift
    USING btree
    (fremdrift);
  
CREATE INDEX sag_tils_fremdrift_idx_virkning_aktoerref
    ON sag_tils_fremdrift
    USING btree
    (((virkning).aktoerref));

CREATE INDEX sag_tils_fremdrift_idx_virkning_aktoertypekode
    ON sag_tils_fremdrift
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX sag_tils_fremdrift_idx_virkning_notetekst
    ON sag_tils_fremdrift
    USING btree
    (((virkning).notetekst));

CREATE INDEX sag_tils_fremdrift_pat_virkning_notetekst
    ON sag_tils_fremdrift
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE sag_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE sag_relation_id_seq
    OWNER TO mox;


CREATE TABLE sag_relation (
    id bigint NOT NULL DEFAULT nextval('sag_relation_id_seq'::regclass),
    sag_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type SagRelationKode not null,
    objekt_type text null,

    
    rel_index int null,
    rel_type_spec SagRelationJournalPostSpecifikKode null,
    journal_notat JournalNotatType null,
    journal_dokument_attr JournalPostDokumentAttrType null,
    

    CONSTRAINT sag_relation_forkey_sagregistrering FOREIGN KEY (sag_registrering_id) REFERENCES sag_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT sag_relation_pkey PRIMARY KEY (id),
    CONSTRAINT sag_relation_no_virkning_overlap EXCLUDE USING gist (sag_registrering_id WITH =, _as_convert_sag_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('andetarkiv'::SagRelationKode ) AND rel_type<>('andrebehandlere'::SagRelationKode ) AND rel_type<>('sekundaerpart'::SagRelationKode ) AND rel_type<>('andresager'::SagRelationKode ) AND rel_type<>('byggeri'::SagRelationKode ) AND rel_type<>('fredning'::SagRelationKode ) AND rel_type<>('journalpost'::SagRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT sag_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>''))),
    CONSTRAINT sag_relation_rel_type_spec_null_other_than_journalpost CHECK (rel_type_spec IS NULL OR rel_type='journalpost'::SagRelationKode ),
    CONSTRAINT sag_relation_journal_dok_attr_only_vedlagtdok_tilakteretdok CHECK (journal_dokument_attr IS NULL OR rel_type_spec IN ('vedlagtdokument'::SagRelationJournalPostSpecifikKode,'tilakteretdokument'::SagRelationJournalPostSpecifikKode)),
    CONSTRAINT sag_journal_notat_only_for_notat_type CHECK (journal_notat IS NULL OR rel_type_spec='journalnotat' )
);
ALTER TABLE sag_relation
  OWNER TO mox;



CREATE UNIQUE INDEX sag_relation_unique_index_within_type
    ON sag_relation (sag_registrering_id,rel_type,rel_index)
    WHERE ( rel_type IN ('andetarkiv'::SagRelationKode,'andrebehandlere'::SagRelationKode,'sekundaerpart'::SagRelationKode,'andresager'::SagRelationKode,'byggeri'::SagRelationKode,'fredning'::SagRelationKode,'journalpost'::SagRelationKode));




CREATE INDEX sag_relation_idx_rel_maal_obj_uuid
    ON sag_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX sag_relation_idx_rel_maal_obj_urn
    ON sag_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX sag_relation_idx_rel_maal_uuid
    ON sag_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX sag_relation_idx_rel_maal_uuid_isolated
    ON sag_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX sag_relation_idx_rel_maal_urn_isolated
    ON sag_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX sag_relation_idx_rel_maal_urn
    ON sag_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX sag_relation_idx_virkning_aktoerref
    ON sag_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX sag_relation_idx_virkning_aktoertypekode
    ON sag_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX sag_relation_idx_virkning_notetekst
    ON sag_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX sag_relation_pat_virkning_notetekst
    ON sag_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr SagFremdriftTilsType[])
  RETURNS SagFremdriftTilsType[] AS
  $$
  DECLARE result SagFremdriftTilsType[];
  DECLARE element SagFremdriftTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.fremdrift IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr SagEgenskaberAttrType[])
  RETURNS SagEgenskaberAttrType[] AS
  $$
  DECLARE result SagEgenskaberAttrType[]; 
   DECLARE element SagEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.afleveret IS NULL AND element.beskrivelse IS NULL AND element.hjemmel IS NULL AND element.kassationskode IS NULL AND element.offentlighedundtaget IS NULL AND element.principiel IS NULL AND element.sagsnummer IS NULL AND element.titel IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr SagRelationType[])
RETURNS SagRelationType[] AS
$$
 DECLARE result SagRelationType[];
 DECLARE element SagRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.indeks IS NULL AND element.relTypeSpec IS NULL AND (element.journalNotat IS NULL OR ( (element.journalNotat).titel IS NULL AND (element.journalNotat).notat IS NULL AND (element.journalNotat).format IS NULL )) AND (element.journalDokumentAttr IS NULL OR ((element.journalDokumentAttr).dokumenttitel IS NULL AND (element.journalDokumentAttr).offentlighedUndtaget IS NULL )) AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....)

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_sag_registrering(
    sag_registrering
) RETURNS sag_registrering AS $BODY$
  SELECT * FROM sag_registrering as a WHERE
    sag_id = $1.sag_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_sag_registrering(
    sag_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS sag_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    sag_registrering_id bigint;
    sag_registrering    sag_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE sag_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE sag_id = sag_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating sag with uuid [%], Invalid [livscyklus] transition to [%]',sag_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new sag registrering

    sag_registrering_id := nextval('sag_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    sag_registrering := ROW(
        sag_registrering_id,
        sag_uuid,
        registreringObj
    )::sag_registrering;

    INSERT INTO sag_registrering SELECT sag_registrering.*;

    RETURN sag_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of SagAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_sag(
    sag_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber SagEgenskaberAttrType[],
    

    
    tilsFremdrift SagFremdriftTilsType[],
    

    relationer SagRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      SagRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_sag          SagType;
    read_prev_sag         SagType;
    read_new_sag_reg      SagRegistreringType;
    read_prev_sag_reg     SagRegistreringType;
    new_sag_registrering  sag_registrering;
    prev_sag_registrering sag_registrering;
    sag_relation_navn     SagRelationKode;

    
    attrEgenskaberObj SagEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
    rel_type_max_index_prev_rev int;
    rel_type_max_index_arr _SagRelationMaxIndex[];
    sag_rel_type_cardinality_unlimited SagRelationKode[]:=ARRAY['andetarkiv'::SagRelationKode,'andrebehandlere'::SagRelationKode,'sekundaerpart'::SagRelationKode,'andresager'::SagRelationKode,'byggeri'::SagRelationKode,'fredning'::SagRelationKode,'journalpost'::SagRelationKode]::SagRelationKode[];
    sag_uuid_underscores text;
    sag_rel_seq_name text;
    sag_rel_type_cardinality_unlimited_present_in_argument sagRelationKode[];
    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from sag a join sag_registrering b ON b.sag_id=a.id WHERE a.id=sag_uuid) THEN
        RAISE EXCEPTION 'Unable to update sag with uuid [%], being unable to find any previous registrations.',sag_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM sag a WHERE a.id=sag_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_sag(array[sag_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[sag_uuid]) THEN
      RAISE EXCEPTION 'Unable to update sag with uuid [%]. Object does not met stipulated criteria:%', sag_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_sag_registrering := _as_create_sag_registrering(sag_uuid, livscykluskode, brugerref, note);
    prev_sag_registrering := _as_get_prev_sag_registrering(new_sag_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_sag_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update sag with uuid [%], as the sag seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', sag_uuid, lostUpdatePreventionTZ, LOWER((prev_sag_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    
    -- Build array with the max index values of the different types of
    -- relations of the previous registration
    
    SELECT array_agg(rel_type_max_index)::_SagRelationMaxIndex[] into rel_type_max_index_arr
    
    FROM
    (
        SELECT
        
        (ROW(rel_type,coalesce(max(rel_index),0))::_SagRelationMaxIndex) rel_type_max_index
        
            FROM sag_relation a
           WHERE a.sag_registrering_id=prev_sag_registrering.id
             AND a.rel_type = ANY (sag_rel_type_cardinality_unlimited)
        GROUP BY rel_type
    ) AS a;

 
    ---Create temporary sequences
    
    sag_uuid_underscores:=replace(sag_uuid::text, '-', '_');
    

    SELECT array_agg(DISTINCT a.RelType) INTO sag_rel_type_cardinality_unlimited_present_in_argument FROM unnest(relationer) a WHERE a.RelType = ANY (sag_rel_type_cardinality_unlimited);
    

    IF coalesce(array_length(sag_rel_type_cardinality_unlimited_present_in_argument, 1), 0) > 0 THEN
        FOREACH sag_relation_navn IN ARRAY (sag_rel_type_cardinality_unlimited_present_in_argument) LOOP
            sag_rel_seq_name := 'sag_' || sag_relation_navn::text || sag_uuid_underscores;

            rel_type_max_index_prev_rev := null;

            SELECT a.indeks into rel_type_max_index_prev_rev
              FROM unnest(rel_type_max_index_arr) a(relType,indeks)
             WHERE a.relType=sag_relation_navn;

            IF rel_type_max_index_prev_rev IS NULL THEN
              rel_type_max_index_prev_rev := 0;
            END IF;

            EXECUTE 'CREATE TEMPORARY SEQUENCE ' || sag_rel_seq_name || '
            INCREMENT 1
            MINVALUE 1
            MAXVALUE 9223372036854775807
            START ' ||  (rel_type_max_index_prev_rev+1)::text ||'
            CACHE 1;';

        END LOOP;
    END IF;
    

    INSERT INTO sag_relation (sag_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type , rel_index, rel_type_spec, journal_notat, journal_dokument_attr )
    SELECT
        new_sag_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType ,
            CASE WHEN a.relType = ANY (sag_rel_type_cardinality_unlimited) THEN
                CASE WHEN a.indeks IS NULL
                    OR b.id IS NULL THEN
                    -- For new relations and relations with index given that
                    -- is not found in prev registrering, we'll assign new
                    -- index values.
                    nextval('sag_' || a.relType::text || sag_uuid_underscores)
                ELSE
                    a.indeks
                END
            ELSE
                NULL
            END,
            CASE WHEN a.relType = 'journalpost' THEN
                a.relTypeSpec
            ELSE
                NULL
            END,
            CASE WHEN (NOT (a.journalNotat IS NULL))
                AND ((a.journalNotat).titel IS NOT NULL
                    OR (a.journalNotat).notat IS NOT NULL
                    OR (a.journalNotat).format IS NOT NULL) THEN
                a.journalNotat
            ELSE
                NULL
            END,
            CASE WHEN ((NOT a.journalDokumentAttr IS NULL)
                    AND ((a.journalDokumentAttr).dokumenttitel IS NOT NULL
                        OR (NOT ((a.journalDokumentAttr).offentlighedUndtaget IS NULL)
                            AND (((a.journalDokumentAttr).offentlighedUndtaget).AlternativTitel IS NOT NULL
                                OR ((a.journalDokumentAttr).offentlighedUndtaget).Hjemmel IS NOT NULL)))) THEN
                a.journalDokumentAttr
            ELSE
                NULL
            END 
        FROM
            unnest(relationer) AS a 
        LEFT JOIN sag_relation b ON a.relType = ANY (sag_rel_type_cardinality_unlimited) AND b.sag_registrering_id = prev_sag_registrering.id AND a.relType = b.rel_type AND a.indeks = b.rel_index ;

    
    -- Drop temporary sequences
    IF coalesce(array_length(sag_rel_type_cardinality_unlimited_present_in_argument, 1), 0) > 0 THEN
        
        FOREACH sag_relation_navn IN ARRAY (sag_rel_type_cardinality_unlimited_present_in_argument)
        
        LOOP
          sag_rel_seq_name := 'sag_' || sag_relation_navn::text || sag_uuid_underscores;
          EXECUTE 'DROP SEQUENCE ' || sag_rel_seq_name || ';';
        END LOOP;
    END IF;
    


    -- Ad 2)
    -- 0..1 relations

    
    -- Please notice, that for 0..1 relations for aktivitet, we're ignoring index
    -- here, and handling it the same way, that is done for other object types (like
    -- Facet, Klasse etc). That is, you only make changes for the
    -- virkningsperiod that you explicitly specify (unless you delete all relations)
    
    
    FOREACH sag_relation_navn IN ARRAY ARRAY['behandlingarkiv'::SagRelationKode ,  'afleveringsarkiv'::SagRelationKode ,  'primaerklasse'::SagRelationKode ,  'opgaveklasse'::SagRelationKode ,  'handlingsklasse'::SagRelationKode ,  'kontoklasse'::SagRelationKode ,  'sikkerhedsklasse'::SagRelationKode ,  'foelsomhedsklasse'::SagRelationKode ,  'indsatsklasse'::SagRelationKode ,  'ydelsesklasse'::SagRelationKode ,  'ejer'::SagRelationKode ,  'ansvarlig'::SagRelationKode ,  'primaerbehandler'::SagRelationKode ,  'udlaanttil'::SagRelationKode ,  'primaerpart'::SagRelationKode ,  'ydelsesmodtager'::SagRelationKode ,  'oversag'::SagRelationKode ,  'praecedens'::SagRelationKode ,  'afgiftsobjekt'::SagRelationKode ,  'ejendomsskat'::SagRelationKode  ]::SagRelationKode[]  LOOP
        INSERT INTO sag_relation (sag_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type , rel_index, rel_type_spec, journal_notat, journal_dokument_attr )
        SELECT
            new_sag_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type ,
                NULL, -- a.rel_index, rel_index is not to be used for 0..1 relations
                a.rel_type_spec,
                a.journal_notat,
                a.journal_dokument_attr 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM sag_relation b
                 WHERE b.sag_registrering_id = new_sag_registrering.id AND b.rel_type = sag_relation_navn) d
            JOIN sag_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.sag_registrering_id = prev_sag_registrering.id AND a.rel_type = sag_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
                    INSERT INTO sag_relation (sag_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type , rel_index, rel_type_spec, journal_notat, journal_dokument_attr )
                    SELECT
                        new_sag_registrering.id,  a.virkning, a.rel_maal_uuid, a.rel_maal_urn, a.rel_type, a.objekt_type, a.rel_index, a.rel_type_spec, a.journal_notat, a.journal_dokument_attr
                FROM sag_relation a
                LEFT JOIN sag_relation b ON b.sag_registrering_id = new_sag_registrering.id AND b.rel_type = a.rel_type AND b.rel_index = a.rel_index
            WHERE
                a.sag_registrering_id = prev_sag_registrering.id AND a.rel_type = ANY (sag_rel_type_cardinality_unlimited) AND b.id IS NULL
                -- Don't transfer relations of prev. registrering, if the
                -- index was specified in data given to the/this
                -- update-function
                ;

    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsFremdrift IS NOT NULL AND coalesce(array_length(tilsFremdrift, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Fremdrift] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- sag_tils_fremdrift

        -- Ad 1)
        INSERT INTO sag_tils_fremdrift(virkning, fremdrift, sag_registrering_id)
             SELECT a.virkning, a.fremdrift, new_sag_registrering.id
               FROM unnest(tilsFremdrift) AS a;

        -- Ad 2
        INSERT INTO sag_tils_fremdrift(virkning, fremdrift, sag_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.fremdrift,
            new_sag_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- sag_tils_fremdrift of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- sag_tils_fremdrift of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM sag_tils_fremdrift b
             WHERE b.sag_registrering_id = new_sag_registrering.id) d
              JOIN sag_tils_fremdrift a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.sag_registrering_id = prev_sag_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- sag_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrSagObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.afleveret,a.beskrivelse,a.hjemmel,a.kassationskode,a.offentlighedundtaget,a.principiel,a.sagsnummer,a.titel,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update sag with uuid [%], as the sag have overlapping virknings in the given egenskaber array :%', sag_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).afleveret IS NULL  OR  (attrEgenskaberObj).beskrivelse IS NULL  OR  (attrEgenskaberObj).hjemmel IS NULL  OR  (attrEgenskaberObj).kassationskode IS NULL  OR  (attrEgenskaberObj).offentlighedundtaget IS NULL  OR  (attrEgenskaberObj).principiel IS NULL  OR  (attrEgenskaberObj).sagsnummer IS NULL  OR  (attrEgenskaberObj).titel IS NULL  THEN
            
            INSERT INTO sag_attr_egenskaber ( brugervendtnoegle,afleveret,beskrivelse,hjemmel,kassationskode,offentlighedundtaget,principiel,sagsnummer,titel, virkning, sag_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            CASE WHEN ((attrEgenskaberObj.afleveret).cleared) THEN
                                NULL
                            ELSE
                                coalesce((attrEgenskaberObj.afleveret).value, a.afleveret)
                            END,
                        
                    
                        
                        
                            coalesce(attrEgenskaberObj.beskrivelse, a.beskrivelse),
                    
                        
                        
                            coalesce(attrEgenskaberObj.hjemmel, a.hjemmel),
                    
                        
                        
                            coalesce(attrEgenskaberObj.kassationskode, a.kassationskode),
                    
                        
                        
                            coalesce(attrEgenskaberObj.offentlighedundtaget, a.offentlighedundtaget),
                    
                        
                        
                            CASE WHEN ((attrEgenskaberObj.principiel).cleared) THEN
                                NULL
                            ELSE
                                coalesce((attrEgenskaberObj.principiel).value, a.principiel)
                            END,
                        
                    
                        
                        
                            coalesce(attrEgenskaberObj.sagsnummer, a.sagsnummer),
                    
                        
                        
                            coalesce(attrEgenskaberObj.titel, a.titel),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_sag_registrering.id
                        FROM sag_attr_egenskaber a
                    WHERE
                        a.sag_registrering_id = prev_sag_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO sag_attr_egenskaber ( brugervendtnoegle,afleveret,beskrivelse,hjemmel,kassationskode,offentlighedundtaget,principiel,sagsnummer,titel, virkning, sag_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.afleveret,
                    
                     attrEgenskaberObj.beskrivelse,
                    
                     attrEgenskaberObj.hjemmel,
                    
                     attrEgenskaberObj.kassationskode,
                    
                     attrEgenskaberObj.offentlighedundtaget,
                    
                     attrEgenskaberObj.principiel,
                    
                     attrEgenskaberObj.sagsnummer,
                    
                     attrEgenskaberObj.titel,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_sag_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the sag_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM sag_attr_egenskaber b
                    WHERE b.sag_registrering_id = new_sag_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO sag_attr_egenskaber ( brugervendtnoegle,afleveret,beskrivelse,hjemmel,kassationskode,offentlighedundtaget,principiel,sagsnummer,titel, virkning, sag_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.afleveret,  attrEgenskaberObj.beskrivelse,  attrEgenskaberObj.hjemmel,  attrEgenskaberObj.kassationskode,  attrEgenskaberObj.offentlighedundtaget,  attrEgenskaberObj.principiel,  attrEgenskaberObj.sagsnummer,  attrEgenskaberObj.titel, attrEgenskaberObj.virkning, new_sag_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO sag_attr_egenskaber ( brugervendtnoegle,afleveret,beskrivelse,hjemmel,kassationskode,offentlighedundtaget,principiel,sagsnummer,titel, virkning, sag_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.afleveret,
        
            a.beskrivelse,
        
            a.hjemmel,
        
            a.kassationskode,
        
            a.offentlighedundtaget,
        
            a.principiel,
        
            a.sagsnummer,
        
            a.titel,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_sag_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- sag_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- sag_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                sag_attr_egenskaber b
            WHERE
                b.sag_registrering_id = new_sag_registrering.id) d
            JOIN sag_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.sag_registrering_id = prev_sag_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_sag := as_read_sag(sag_uuid, (new_sag_registrering.registrering).timeperiod, null);
    read_prev_sag := as_read_sag(sag_uuid, (prev_sag_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_sag.registrering[1].registrering).TimePeriod) = lower((new_sag_registrering.registrering).TimePeriod) and lower((read_prev_sag.registrering[1].registrering).TimePeriod)=lower((prev_sag_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating sag with id [%]: The ordering of as_list_sag should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', sag_uuid, to_json(new_sag_registrering), to_json(read_new_sag.registrering[1].registrering), to_json(prev_sag_registrering), to_json(prev_new_sag.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_sag_reg := ROW(
        ROW (null, (read_new_sag.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_sag.registrering[1]).tilsFremdrift ,
        
        (read_new_sag.registrering[1]).attrEgenskaber ,
        (read_new_sag.registrering[1]).relationer
    )::sagRegistreringType;

    read_prev_sag_reg := ROW(
        ROW(null, (read_prev_sag.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_sag.registrering[1]).tilsFremdrift ,
        
        (read_prev_sag.registrering[1]).attrEgenskaber ,
        (read_prev_sag.registrering[1]).relationer
    )::sagRegistreringType;


    IF read_prev_sag_reg = read_new_sag_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_sag_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_sag_reg);
      RAISE EXCEPTION 'Aborted updating sag with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', sag_uuid, to_json(read_new_sag_reg), to_json(read_prev_sag_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_sag_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_sag (
    sag_registrering SagRegistreringType,
    sag_uuid uuid DEFAULT NULL, auth_criteria_arr
    SagRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE sag_registrering_id bigint;

    
    sag_attr_egenskaber_obj sagEgenskaberAttrType;
    

    
    sag_tils_fremdrift_obj sagFremdriftTilsType;
    

    sag_relationer SagRelationType;

    
    sag_relation_kode SagRelationKode;
    sag_uuid_underscores text;
    sag_rel_seq_name text;
    sag_rel_type_cardinality_unlimited SagRelationKode[]:=ARRAY['andetarkiv'::SagRelationKode,'andrebehandlere'::SagRelationKode,'sekundaerpart'::SagRelationKode,'andresager'::SagRelationKode,'byggeri'::SagRelationKode,'fredning'::SagRelationKode,'journalpost'::SagRelationKode]::SagRelationKode[];
    

    auth_filtered_uuids uuid[];

    
    sag_rel_type_cardinality_unlimited_present_in_argument sagRelationKode[];
    

    does_exist boolean;
    new_sag_registrering sag_registrering;
BEGIN
    IF sag_uuid IS NULL THEN LOOP
        sag_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from sag WHERE id=sag_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from sag WHERE id=sag_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (sag_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (sag_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (sag_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_sag.',(sag_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO sag (ID) SELECT
        sag_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        sag_registrering_id:=nextval('sag_registrering_id_seq');

        INSERT INTO sag_registrering (id, sag_id,
            registrering) SELECT sag_registrering_id,
        sag_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (sag_registrering.registrering).livscykluskode,
        (sag_registrering.registrering).brugerref,
        (sag_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_sag_registrering :=
            _as_create_sag_registrering(sag_uuid,
                (sag_registrering.registrering).livscykluskode,
                (sag_registrering.registrering).brugerref,
                (sag_registrering.registrering).note);

            sag_registrering_id := new_sag_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(sag_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [sag]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF sag_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(sag_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH sag_attr_egenskaber_obj IN ARRAY sag_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO sag_attr_egenskaber (
      
      brugervendtnoegle,
      afleveret,
      beskrivelse,
      hjemmel,
      kassationskode,
      offentlighedundtaget,
      principiel,
      sagsnummer,
      titel,
      virkning,
      sag_registrering_id
    )
    SELECT
     
     sag_attr_egenskaber_obj.brugervendtnoegle,
      sag_attr_egenskaber_obj.afleveret,
      sag_attr_egenskaber_obj.beskrivelse,
      sag_attr_egenskaber_obj.hjemmel,
      sag_attr_egenskaber_obj.kassationskode,
      sag_attr_egenskaber_obj.offentlighedundtaget,
      sag_attr_egenskaber_obj.principiel,
      sag_attr_egenskaber_obj.sagsnummer,
      sag_attr_egenskaber_obj.titel,
      sag_attr_egenskaber_obj.virkning,
      sag_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(sag_registrering.tilsFremdrift, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [fremdrift] for sag. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF sag_registrering.tilsFremdrift IS NOT NULL AND coalesce(array_length(sag_registrering.tilsFremdrift,1),0)>0 THEN
  FOREACH sag_tils_fremdrift_obj IN ARRAY sag_registrering.tilsFremdrift
  LOOP

    INSERT INTO sag_tils_fremdrift (
      virkning,
      fremdrift,
      sag_registrering_id
    )
    SELECT
      sag_tils_fremdrift_obj.virkning,
      sag_tils_fremdrift_obj.fremdrift,
      sag_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations


IF coalesce(array_length(sag_registrering.relationer,1),0)>0 THEN

--Create temporary sequences
sag_uuid_underscores:=replace(sag_uuid::text, '-', '_');

SELECT array_agg(DISTINCT a.RelType) into sag_rel_type_cardinality_unlimited_present_in_argument FROM unnest(sag_registrering.relationer) a WHERE a.RelType = any (sag_rel_type_cardinality_unlimited) ;
IF coalesce(array_length(sag_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN

FOREACH sag_relation_kode IN ARRAY (sag_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  sag_rel_seq_name := 'sag_' || sag_relation_kode::text || sag_uuid_underscores;

  EXECUTE 'CREATE TEMPORARY SEQUENCE ' || sag_rel_seq_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START 1
  CACHE 1;';

END LOOP;
END IF;


    INSERT INTO sag_relation (
      sag_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type,
      rel_index,
      rel_type_spec,
      journal_notat,
      journal_dokument_attr
    )
    SELECT
      sag_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType,
      CASE WHEN a.relType = any (sag_rel_type_cardinality_unlimited) THEN --rel_index
      nextval('sag_' || a.relType::text || sag_uuid_underscores)
      ELSE 
      NULL
      END,
      CASE 
        WHEN a.relType='journalpost' THEN a.relTypeSpec  --rel_type_spec
        ELSE
        NULL
      END,
    CASE 
        WHEN  
          (NOT (a.journalNotat IS NULL)) 
          AND
          (
            (a.journalNotat).titel IS NOT NULL
            OR
            (a.journalNotat).notat IS NOT NULL
            OR
            (a.journalNotat).format IS NOT NULL
          )
         THEN a.journalNotat
         ELSE
         NULL
    END
    ,CASE 
      WHEN (
              (NOT a.journalDokumentAttr IS NULL)
              AND
              (
                (a.journalDokumentAttr).dokumenttitel IS NOT NULL
                OR
                (
                  NOT ((a.journalDokumentAttr).offentlighedUndtaget IS NULL)
                  AND
                  (
                    ((a.journalDokumentAttr).offentlighedUndtaget).AlternativTitel IS NOT NULL
                     OR
                     ((a.journalDokumentAttr).offentlighedUndtaget).Hjemmel IS NOT NULL
                   )
                 )
              )
            ) THEN a.journalDokumentAttr
       ELSE
       NULL
      END
      
    FROM unnest(sag_registrering.relationer) a
  ;



--Drop temporary sequences
IF coalesce(array_length(sag_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH sag_relation_kode IN ARRAY (sag_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  sag_rel_seq_name := 'sag_' || sag_relation_kode::text || sag_uuid_underscores;
  EXECUTE 'DROP SEQUENCE ' || sag_rel_seq_name || ';';
END LOOP;
END IF;


END IF;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_sag(array[sag_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[sag_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import sag with uuid [%]. Object does not met stipulated criteria:%',sag_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN sag_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_sag(sag_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr SagRegistreringType[]=null
  )
  RETURNS SagType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result SagType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_sag(sag_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(sag_uuids,1),0) AND auth_filtered_uuids @>sag_uuids) THEN
  RAISE EXCEPTION 'Unable to list sag with uuids [%]. All objects do not fullfill the stipulated criteria:%',sag_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.sagObj) into result
FROM
(
SELECT
ROW(
	a.sag_id,
	array_agg(
		ROW (
			a.registrering,
			a.SagTilsFremdriftArr,
			a.SagAttrEgenskaberArr,
			a.SagRelationArr
		)::SagRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: SagType  sagObj
FROM
(
	SELECT
	a.sag_id,
	a.sag_registrering_id,
	a.registrering,
	a.SagAttrEgenskaberArr,
	a.SagTilsFremdriftArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type,
                b.rel_index,
                b.rel_type_spec,
                b.journal_notat,
                b.journal_dokument_attr
			):: SagRelationType
		ELSE
		NULL
		END
        
        order by b.rel_type,b.rel_index,b.rel_maal_uuid,b.rel_maal_urn,b.objekt_type,b.rel_type_spec,b.journal_notat,b.journal_dokument_attr,b.virkning
        
	)) SagRelationArr
	FROM
	(
			SELECT
			a.sag_id,
			a.sag_registrering_id,
			a.registrering,
			a.SagAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.fremdrift
						) ::SagFremdriftTilsType
					ELSE NULL
					END
					order by b.fremdrift,b.virkning
				)) SagTilsFremdriftArr		
			FROM
			(
					SELECT
					a.sag_id,
					a.sag_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.afleveret,
					 		b.beskrivelse,
					 		b.hjemmel,
					 		b.kassationskode,
					 		b.offentlighedundtaget,
					 		b.principiel,
					 		b.sagsnummer,
					 		b.titel,
					   		b.virkning
                            
							)::SagEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.afleveret,b.beskrivelse,b.hjemmel,b.kassationskode,b.offentlighedundtaget,b.principiel,b.sagsnummer,b.titel,b.virkning
                        
					)) SagAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id sag_id,
					b.id sag_registrering_id,
					b.registrering			
					FROM		sag a
					JOIN 		sag_registrering b 	ON b.sag_id=a.id
					WHERE a.id = ANY (sag_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN sag_attr_egenskaber as b ON b.sag_registrering_id=a.sag_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.sag_id,
					a.sag_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN sag_tils_fremdrift as b ON b.sag_registrering_id=a.sag_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.sag_id,
			a.sag_registrering_id,
			a.registrering,
			a.SagAttrEgenskaberArr
	) as a
	LEFT JOIN sag_relation b ON b.sag_registrering_id=a.sag_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.sag_id,
	a.sag_registrering_id,
	a.registrering,
	a.SagAttrEgenskaberArr,
	a.SagTilsFremdriftArr
) as a

WHERE a.sag_id IS NOT NULL
GROUP BY 
a.sag_id
order by a.sag_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_sag(
    sag_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      SagRegistreringType[]=null
) RETURNS SagType AS $$
DECLARE
	resArr SagType[];
BEGIN
    resArr := as_list_sag(ARRAY[sag_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_sag(
    firstResult int,--TOOD ??
    sag_uuid uuid,
    registreringObj   SagRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr SagRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    sag_candidates uuid[];
    sag_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj SagEgenskaberAttrType;

    
    tilsFremdriftTypeObj SagFremdriftTilsType;

    relationTypeObj SagRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

sag_candidates_is_initialized := false;

IF sag_uuid is not NULL THEN
    sag_candidates:= ARRAY[sag_uuid];
    sag_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        sag_candidates:=array(
                SELECT DISTINCT
                b.sag_id
                FROM
                sag a
                JOIN sag_registrering b on b.sag_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'sag_candidates_is_initialized step 1:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 1:%',sag_candidates;
--/****************************//


--RAISE NOTICE 'sag_candidates_is_initialized step 2:%',sag_candidates_is_initialized;
--RAISE NOTICE 'sag_candidates step 2:%',sag_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_sag: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(sag_candidates,1),0)>0 OR NOT sag_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            sag_candidates:=array(
            SELECT DISTINCT
            b.sag_id
            FROM  sag_attr_egenskaber a
            JOIN sag_registrering b on a.sag_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.afleveret IS NULL
                    OR
                    a.afleveret = attrEgenskaberTypeObj.afleveret
                )
                AND
                (
                    attrEgenskaberTypeObj.beskrivelse IS NULL
                    OR
                    a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.hjemmel IS NULL
                    OR
                    a.hjemmel ILIKE attrEgenskaberTypeObj.hjemmel --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.kassationskode IS NULL
                    OR
                    a.kassationskode ILIKE attrEgenskaberTypeObj.kassationskode --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.offentlighedundtaget IS NULL
                    OR
                        (
                            (
                                (attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel IS NULL
                                OR
                                (a.offentlighedundtaget).AlternativTitel ILIKE (attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel
                            )
                            AND
                            (
                                (attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel IS NULL
                                OR
                                (a.offentlighedundtaget).Hjemmel ILIKE (attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel
                            )
                        )
                )
                AND
                (
                    attrEgenskaberTypeObj.principiel IS NULL
                    OR
                    a.principiel = attrEgenskaberTypeObj.principiel
                )
                AND
                (
                    attrEgenskaberTypeObj.sagsnummer IS NULL
                    OR
                    a.sagsnummer ILIKE attrEgenskaberTypeObj.sagsnummer --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.titel IS NULL
                    OR
                    a.titel ILIKE attrEgenskaberTypeObj.titel --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )

            );


            sag_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'sag_candidates_is_initialized step 3:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 3:%',sag_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        sag_candidates:=array(

            SELECT DISTINCT
            b.sag_id
            
            FROM  sag_attr_egenskaber a
            JOIN sag_registrering b on a.sag_registrering_id=b.id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                                
                        a.beskrivelse ILIKE anyAttrValue OR
                        a.hjemmel ILIKE anyAttrValue OR
                        a.kassationskode ILIKE anyAttrValue OR
                                    (a.offentlighedundtaget).Hjemmel ilike anyAttrValue OR (a.offentlighedundtaget).AlternativTitel ilike anyAttrValue OR
                                
                        a.sagsnummer ILIKE anyAttrValue OR
                        a.titel ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )


        );

    sag_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Fremdrift
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsFremdrift IS NULL THEN
    --RAISE DEBUG 'as_search_sag: skipping filtration on tilsFremdrift';
ELSE
    IF (coalesce(array_length(sag_candidates,1),0)>0 OR sag_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsFremdriftTypeObj IN ARRAY registreringObj.tilsFremdrift
        LOOP
            sag_candidates:=array(
            SELECT DISTINCT
            b.sag_id
            FROM  sag_tils_fremdrift a
            JOIN sag_registrering b on a.sag_registrering_id=b.id
            WHERE
                (
                    tilsFremdriftTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsFremdriftTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsFremdriftTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsFremdriftTypeObj.virkning).AktoerRef IS NULL OR (tilsFremdriftTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsFremdriftTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsFremdriftTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsFremdriftTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsFremdriftTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsFremdriftTypeObj.virkning) IS NULL OR (tilsFremdriftTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsFremdriftTypeObj.fremdrift IS NULL
                    OR
                    tilsFremdriftTypeObj.fremdrift = a.fremdrift
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )

    );


            sag_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer SagRelationType[]
*/


--RAISE DEBUG 'sag_candidates_is_initialized step 4:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 4:%',sag_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_sag: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(sag_candidates,1),0)>0 OR NOT sag_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            sag_candidates:=array(
            SELECT DISTINCT
            b.sag_id
            FROM  sag_relation a
            JOIN sag_registrering b on a.sag_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                AND
                (
                        relationTypeObj.indeks IS NULL
                        OR
                        relationTypeObj.indeks = a.rel_index
                )
                AND
                (
                        relationTypeObj.relTypeSpec IS NULL
                        OR
                        relationTypeObj.relTypeSpec = rel_type_spec
                )
                AND
                (
                        relationTypeObj.journalNotat IS NULL
                        OR
                        (
                                (
                                        (relationTypeObj.journalNotat).titel IS NULL
                                        OR
                                        (a.journal_notat).titel ILIKE (relationTypeObj.journalNotat).titel
                                )
                                AND
                                (
                                        (relationTypeObj.journalNotat).notat IS NULL
                                        OR
                                        (a.journal_notat).notat ILIKE (relationTypeObj.journalNotat).notat
                                )
                                AND
                                (
                                        (relationTypeObj.journalNotat).format IS NULL
                                        OR
                                        (a.journal_notat).format ILIKE (relationTypeObj.journalNotat).format
                                )
                        )
                )
                AND
                (
                        relationTypeObj.journalDokumentAttr IS NULL
                        OR
                        (
                                (
                                        (relationTypeObj.journalDokumentAttr).dokumenttitel IS NULL
                                        OR
                                        (a.journal_dokument_attr).dokumenttitel ILIKE (relationTypeObj.journalDokumentAttr).dokumenttitel
                                )
                                AND
                                (
                                        (relationTypeObj.journalDokumentAttr).offentlighedundtaget IS NULL
                                        OR
                                                (
                                                        (
                                                                ((relationTypeObj.journalDokumentAttr).offentlighedundtaget).AlternativTitel IS NULL
                                                                OR
                                                                ((a.journal_dokument_attr).offentlighedundtaget).AlternativTitel ILIKE ((relationTypeObj.journalDokumentAttr).offentlighedundtaget).AlternativTitel 
                                                        )
                                                        AND
                                                        (
                                                                ((relationTypeObj.journalDokumentAttr).offentlighedundtaget).Hjemmel IS NULL
                                                                OR
                                                                ((a.journal_dokument_attr).offentlighedundtaget).Hjemmel ILIKE ((relationTypeObj.journalDokumentAttr).offentlighedundtaget).Hjemmel
                                                        )
                                                )
                                )
                        )
                )
                
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )

    );

            sag_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        sag_candidates:=array(
            SELECT DISTINCT
            b.sag_id
            
            FROM  sag_relation a
            JOIN sag_registrering b on a.sag_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )


            );

    sag_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        sag_candidates:=array(
            SELECT DISTINCT
            b.sag_id
            
            FROM  sag_relation a
            JOIN sag_registrering b on a.sag_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )


            );

    sag_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 




--RAISE DEBUG 'sag_candidates_is_initialized step 5:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 5:%',sag_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT sag_candidates_is_initialized THEN
        sag_candidates:=array(
        SELECT DISTINCT
            sag_id
        FROM
            sag_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT sag_candidates_is_initialized) OR b.sag_id = ANY (sag_candidates) )

        )
        ;

        sag_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT sag_candidates_is_initialized THEN
    --No filters applied!
    sag_candidates:=array(
        SELECT DISTINCT id FROM sag a
    );
ELSE
    sag_candidates:=array(
        SELECT DISTINCT id FROM unnest(sag_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'sag_candidates_is_initialized step 6:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 6:%',sag_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_sag(sag_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_sag(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_SagRegistreringType_to_json(SagRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END sagegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsFremdrift,1),0)>0 THEN to_json($1.tilsFremdrift) 
        ELSE 
        NULL
        END sagfremdrift
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType,e.indeks,e.relTypeSpec,e.journalNotat,e.journalDokumentAttr)::SagRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType,indeks,relTypeSpec,journalNotat,journalDokumentAttr)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (SagRegistreringType as json);
create cast (SagRegistreringType as json) with function actual_state._cast_SagRegistreringType_to_json(SagRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_sagType_to_json(SagType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg SagRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (SagType as json);
create cast (SagType as json) with function actual_state._cast_sagType_to_json(SagType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_sag(
    sag_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    SagRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    sag_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    sag_sorted_uuid:=array(
          SELECT b.sag_id
            FROM sag_registrering b
            JOIN sag_attr_egenskaber a ON a.sag_registrering_id=b.id
           WHERE b.sag_id = ANY (sag_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.sag_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.sag_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN sag_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_sag(
	sag_uuids uuid[],
	registreringObjArr SagRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	sag_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	sag_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj SagEgenskaberAttrType;
	
  	tilsFremdriftTypeObj SagFremdriftTilsType;
	relationTypeObj SagRelationType;
	registreringObj SagRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN sag_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF sag_uuids IS NULL OR coalesce(array_length(sag_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

sag_candidates:= sag_uuids;



--RAISE DEBUG 'sag_candidates_is_initialized step 1:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 1:%',sag_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_sag: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(sag_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			sag_candidates:=array(
			SELECT DISTINCT
			b.sag_id 
			FROM  sag_attr_egenskaber a 
			JOIN sag_registrering b on a.sag_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.afleveret IS NULL
					OR 
					a.afleveret = attrEgenskaberTypeObj.afleveret 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND
				(
					attrEgenskaberTypeObj.hjemmel IS NULL
					OR 
					a.hjemmel = attrEgenskaberTypeObj.hjemmel 
				)
				AND
				(
					attrEgenskaberTypeObj.kassationskode IS NULL
					OR 
					a.kassationskode = attrEgenskaberTypeObj.kassationskode 
				)
				AND
				(
					attrEgenskaberTypeObj.offentlighedundtaget IS NULL
					OR
						(
							(
								(attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel IS NULL
								OR
								(a.offentlighedundtaget).AlternativTitel = (attrEgenskaberTypeObj.offentlighedundtaget).AlternativTitel 
							)
							AND
							(
								(attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel IS NULL
								OR
								(a.offentlighedundtaget).Hjemmel = (attrEgenskaberTypeObj.offentlighedundtaget).Hjemmel
							)
						) 
				)
				AND
				(
					attrEgenskaberTypeObj.principiel IS NULL
					OR 
					a.principiel = attrEgenskaberTypeObj.principiel 
				)
				AND
				(
					attrEgenskaberTypeObj.sagsnummer IS NULL
					OR 
					a.sagsnummer = attrEgenskaberTypeObj.sagsnummer 
				)
				AND
				(
					attrEgenskaberTypeObj.titel IS NULL
					OR 
					a.titel = attrEgenskaberTypeObj.titel 
				)
				AND b.sag_id = ANY (sag_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'sag_candidates_is_initialized step 3:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 3:%',sag_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Fremdrift
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsFremdrift IS NULL THEN
	--RAISE DEBUG 'as_search_sag: skipping filtration on tilsFremdrift';
ELSE
	IF coalesce(array_length(sag_candidates,1),0)>0 THEN 

		FOREACH tilsFremdriftTypeObj IN ARRAY registreringObj.tilsFremdrift
		LOOP
			sag_candidates:=array(
			SELECT DISTINCT
			b.sag_id 
			FROM  sag_tils_fremdrift a
			JOIN sag_registrering b on a.sag_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsFremdriftTypeObj.fremdrift IS NULL
					OR
					tilsFremdriftTypeObj.fremdrift = a.fremdrift
				)
				AND b.sag_id = ANY (sag_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer SagRelationType[]
*/


--RAISE DEBUG 'sag_candidates_is_initialized step 4:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 4:%',sag_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_sag: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(sag_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			sag_candidates:=array(
			SELECT DISTINCT
			b.sag_id 
			FROM  sag_relation a
			JOIN sag_registrering b on a.sag_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.sag_id = ANY (sag_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'sag_candidates_is_initialized step 5:%',sag_candidates_is_initialized;
--RAISE DEBUG 'sag_candidates step 5:%',sag_candidates;

sag_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (sag_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (sag_candidates) b(id)
);

--optimization 
IF coalesce(array_length(sag_passed_auth_filter,1),0)=coalesce(array_length(sag_uuids,1),0) AND sag_passed_auth_filter @>sag_uuids THEN
	RETURN sag_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN sag_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

--create custom type sans db-ids to be able to do "clean" function signatures "for the outside world".

CREATE TYPE TilstandStatusTils AS ENUM ('Inaktiv','Aktiv',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE TilstandStatusTilsType AS (
    virkning Virkning,
    status TilstandStatusTils
)
;
CREATE TYPE TilstandPubliceretTils AS ENUM ('Publiceret','IkkePubliceret','Normal',''); --'' means undefined (which is needed to clear previous defined tilstand_values in an already registered virksnings-periode)

CREATE TYPE TilstandPubliceretTilsType AS (
    virkning Virkning,
    publiceret TilstandPubliceretTils
)
;



CREATE TYPE TilstandEgenskaberAttrType AS (
brugervendtnoegle text,
beskrivelse text,

 virkning Virkning
);



CREATE TYPE TilstandVaerdiRelationAttrType AS (
  forventet boolean,
  nominelVaerdi text
);


CREATE TYPE TilstandRelationKode AS ENUM  ('tilstandsobjekt','tilstandstype','tilstandsvaerdi','begrundelse','tilstandskvalitet','tilstandsvurdering','tilstandsaktoer','tilstandsudstyr','samtykke','tilstandsdokument');  --WARNING: Changes to enum names requires MANUALLY rebuilding indexes where _as_convert_tilstand_relation_kode_to_txt is invoked.



CREATE TYPE TilstandRelationType AS (
  relType TilstandRelationKode,
  virkning Virkning,
  uuid uuid,
  urn text,
  objektType text,
  indeks int,
  tilstandsVaerdiAttr TilstandVaerdiRelationAttrType

)
;



CREATE TYPE TilstandRegistreringType AS
(
registrering RegistreringBase,
tilsStatus TilstandStatusTilsType[],
tilsPubliceret TilstandPubliceretTilsType[],
attrEgenskaber TilstandEgenskaberAttrType[],
relationer TilstandRelationType[]
);

CREATE TYPE TilstandType AS
(
  id uuid,
  registrering TilstandRegistreringType[]
);  


 CREATE Type _TilstandRelationMaxIndex AS
 (
   relType TilstandRelationKode,
   indeks int
 );




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



/*************** FUNCTIONS (NEEDED FOR TABLE/INDEX-DEFS) DEFS ***************/

CREATE OR REPLACE FUNCTION _as_convert_tilstand_relation_kode_to_txt(
    TilstandRelationKode
) RETURNS TEXT LANGUAGE sql STRICT IMMUTABLE AS $$
    SELECT $1::text;
$$;


/****************************** TBLS DEFS ***********************************/

CREATE TABLE tilstand (
    id uuid NOT NULL,
    CONSTRAINT tilstand_pkey PRIMARY KEY (id)
)
WITH (
    OIDS=FALSE
);
ALTER TABLE tilstand
    OWNER TO mox;


/****************************************************************************/

CREATE SEQUENCE tilstand_registrering_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE tilstand_registrering_id_seq
    OWNER TO mox;


CREATE TABLE tilstand_registrering (
   id bigint NOT NULL DEFAULT nextval('tilstand_registrering_id_seq'::regclass),
   tilstand_id uuid NOT NULL ,
   registrering RegistreringBase NOT NULL CHECK( (registrering).TimePeriod IS NOT NULL AND not isempty((registrering).timeperiod) ),
   CONSTRAINT tilstand_registrering_pkey PRIMARY KEY (id),
   CONSTRAINT tilstand_registrering_tilstand_fkey FOREIGN KEY (tilstand_id)
       REFERENCES tilstand (id) MATCH SIMPLE
       ON UPDATE NO ACTION ON DELETE NO ACTION,
   CONSTRAINT tilstand_registrering__uuid_to_text_timeperiod_excl EXCLUDE 
   USING gist (_uuid_to_text(tilstand_id) WITH =, _composite_type_to_time_range(registrering) WITH &&)
)
WITH (
  OIDS=FALSE
);

ALTER TABLE tilstand_registrering
  OWNER TO mox;


CREATE INDEX tilstand_registrering_idx_livscykluskode
    ON tilstand_registrering
    USING btree
    (((registrering).livscykluskode));


CREATE INDEX tilstand_registrering_idx_brugerref
    ON tilstand_registrering
    USING btree
    (((registrering).brugerref));


CREATE INDEX tilstand_registrering_idx_note
    ON tilstand_registrering
    USING btree
    (((registrering).note));


CREATE INDEX tilstand_registrering_pat_note
    ON tilstand_registrering
    USING gin
    (((registrering).note) gin_trgm_ops);


CREATE INDEX tilstand_id_idx
    ON tilstand_registrering (tilstand_id);


CREATE TRIGGER notify_tilstand
    AFTER INSERT OR UPDATE OR DELETE ON tilstand_registrering
    FOR EACH ROW EXECUTE PROCEDURE notify_event();


/****************************************************************************/



CREATE SEQUENCE tilstand_attr_egenskaber_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;

ALTER TABLE tilstand_attr_egenskaber_id_seq
    OWNER TO mox;


CREATE TABLE tilstand_attr_egenskaber (
    id bigint NOT NULL DEFAULT nextval('tilstand_attr_egenskaber_id_seq'::regclass),
        brugervendtnoegle text NOT NULL,
        beskrivelse text  NULL,
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND NOT isempty((virkning).TimePeriod) ),
    tilstand_registrering_id bigint NOT NULL,
    CONSTRAINT tilstand_attr_egenskaber_pkey PRIMARY KEY (id),
    CONSTRAINT tilstand_attr_egenskaber_forkey_tilstandregistrering FOREIGN KEY (tilstand_registrering_id) REFERENCES tilstand_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT tilstand_attr_egenskaber_exclude_virkning_overlap EXCLUDE USING gist (tilstand_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE tilstand_attr_egenskaber
  OWNER TO mox;


 
     
        CREATE INDEX tilstand_attr_egenskaber_pat_brugervendtnoegle
            ON tilstand_attr_egenskaber
            USING gin
            (brugervendtnoegle gin_trgm_ops);

        CREATE INDEX tilstand_attr_egenskaber_idx_brugervendtnoegle
            ON tilstand_attr_egenskaber
            USING btree
            (brugervendtnoegle); 
 
     
        CREATE INDEX tilstand_attr_egenskaber_pat_beskrivelse
            ON tilstand_attr_egenskaber
            USING gin
            (beskrivelse gin_trgm_ops);

        CREATE INDEX tilstand_attr_egenskaber_idx_beskrivelse
            ON tilstand_attr_egenskaber
            USING btree
            (beskrivelse); 



CREATE INDEX tilstand_attr_egenskaber_idx_virkning_aktoerref
    ON tilstand_attr_egenskaber
    USING btree
    (((virkning).aktoerref));

CREATE INDEX tilstand_attr_egenskaber_idx_virkning_aktoertypekode
    ON tilstand_attr_egenskaber
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX tilstand_attr_egenskaber_idx_virkning_notetekst
    ON tilstand_attr_egenskaber
    USING btree
    (((virkning).notetekst));

CREATE INDEX tilstand_attr_egenskaber_pat_virkning_notetekst
    ON tilstand_attr_egenskaber
    USING gin
    (((virkning).notetekst) gin_trgm_ops);







/****************************************************************************/



CREATE SEQUENCE tilstand_tils_status_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE tilstand_tils_status_id_seq
    OWNER TO mox;


CREATE TABLE tilstand_tils_status (
    id bigint NOT NULL DEFAULT nextval('tilstand_tils_status_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    status TilstandStatusTils NOT NULL, 
    tilstand_registrering_id bigint not null,
    CONSTRAINT tilstand_tils_status_pkey PRIMARY KEY (id),
    CONSTRAINT tilstand_tils_status_forkey_tilstandregistrering FOREIGN KEY (tilstand_registrering_id) REFERENCES tilstand_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT tilstand_tils_status_exclude_virkning_overlap EXCLUDE USING gist (tilstand_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE tilstand_tils_status
    OWNER TO mox;


CREATE INDEX tilstand_tils_status_idx_status
    ON tilstand_tils_status
    USING btree
    (status);
  
CREATE INDEX tilstand_tils_status_idx_virkning_aktoerref
    ON tilstand_tils_status
    USING btree
    (((virkning).aktoerref));

CREATE INDEX tilstand_tils_status_idx_virkning_aktoertypekode
    ON tilstand_tils_status
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX tilstand_tils_status_idx_virkning_notetekst
    ON tilstand_tils_status
    USING btree
    (((virkning).notetekst));

CREATE INDEX tilstand_tils_status_pat_virkning_notetekst
    ON tilstand_tils_status
    USING gin
    (((virkning).notetekst) gin_trgm_ops);


CREATE SEQUENCE tilstand_tils_publiceret_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE tilstand_tils_publiceret_id_seq
    OWNER TO mox;


CREATE TABLE tilstand_tils_publiceret (
    id bigint NOT NULL DEFAULT nextval('tilstand_tils_publiceret_id_seq'::regclass),
    virkning Virkning NOT NULL CHECK( (virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    publiceret TilstandPubliceretTils NOT NULL, 
    tilstand_registrering_id bigint not null,
    CONSTRAINT tilstand_tils_publiceret_pkey PRIMARY KEY (id),
    CONSTRAINT tilstand_tils_publiceret_forkey_tilstandregistrering FOREIGN KEY (tilstand_registrering_id) REFERENCES tilstand_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT tilstand_tils_publiceret_exclude_virkning_overlap EXCLUDE USING gist (tilstand_registrering_id WITH =, _composite_type_to_time_range(virkning) WITH &&)
)
WITH (
    OIDS=FALSE
);

ALTER TABLE tilstand_tils_publiceret
    OWNER TO mox;


CREATE INDEX tilstand_tils_publiceret_idx_publiceret
    ON tilstand_tils_publiceret
    USING btree
    (publiceret);
  
CREATE INDEX tilstand_tils_publiceret_idx_virkning_aktoerref
    ON tilstand_tils_publiceret
    USING btree
    (((virkning).aktoerref));

CREATE INDEX tilstand_tils_publiceret_idx_virkning_aktoertypekode
    ON tilstand_tils_publiceret
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX tilstand_tils_publiceret_idx_virkning_notetekst
    ON tilstand_tils_publiceret
    USING btree
    (((virkning).notetekst));

CREATE INDEX tilstand_tils_publiceret_pat_virkning_notetekst
    ON tilstand_tils_publiceret
    USING gin
    (((virkning).notetekst) gin_trgm_ops);



/****************************************************************************/

CREATE SEQUENCE tilstand_relation_id_seq
    INCREMENT 1
    MINVALUE 1
    MAXVALUE 9223372036854775807
    START 1
    CACHE 1;
ALTER TABLE tilstand_relation_id_seq
    OWNER TO mox;


CREATE TABLE tilstand_relation (
    id bigint NOT NULL DEFAULT nextval('tilstand_relation_id_seq'::regclass),
    tilstand_registrering_id bigint not null,
    virkning Virkning not null CHECK((virkning).TimePeriod IS NOT NULL AND not isempty((virkning).TimePeriod) ),
    --we have to allow null values (for now at least), as it is needed to be able to clear/overrule previous registered relations.
    rel_maal_uuid uuid NULL,
    rel_maal_urn text null,
    rel_type TilstandRelationKode not null,
    objekt_type text null,

    
    rel_index int null,
    tilstand_vaerdi_attr TilstandVaerdiRelationAttrType null,
    

    CONSTRAINT tilstand_relation_forkey_tilstandregistrering FOREIGN KEY (tilstand_registrering_id) REFERENCES tilstand_registrering (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT tilstand_relation_pkey PRIMARY KEY (id),
    CONSTRAINT tilstand_relation_no_virkning_overlap EXCLUDE USING gist (tilstand_registrering_id WITH =, _as_convert_tilstand_relation_kode_to_txt(rel_type) WITH =, _composite_type_to_time_range(virkning) WITH &&)  WHERE ( rel_type<>('tilstandsvaerdi'::TilstandRelationKode ) AND rel_type<>('begrundelse'::TilstandRelationKode ) AND rel_type<>('tilstandskvalitet'::TilstandRelationKode ) AND rel_type<>('tilstandsvurdering'::TilstandRelationKode ) AND rel_type<>('tilstandsaktoer'::TilstandRelationKode ) AND rel_type<>('tilstandsudstyr'::TilstandRelationKode ) AND rel_type<>('samtykke'::TilstandRelationKode ) AND rel_type<>('tilstandsdokument'::TilstandRelationKode )) ,-- no overlapping virkning except for 0..n --relations
    CONSTRAINT tilstand_relation_either_uri_or_urn CHECK (NOT (rel_maal_uuid IS NOT NULL AND (rel_maal_urn IS NOT NULL AND rel_maal_urn<>''))),
    CONSTRAINT tilstand_relation_nominel_vaerdi_relevant_null_check CHECK (tilstand_vaerdi_attr IS NULL OR rel_type='tilstandsvaerdi')
);
ALTER TABLE tilstand_relation
  OWNER TO mox;



CREATE UNIQUE INDEX tilstand_relation_unique_index_within_type
    ON tilstand_relation (tilstand_registrering_id,rel_type,rel_index)
    WHERE ( rel_type IN ('tilstandsvaerdi'::TilstandRelationKode,'begrundelse'::TilstandRelationKode,'tilstandskvalitet'::TilstandRelationKode,'tilstandsvurdering'::TilstandRelationKode,'tilstandsaktoer'::TilstandRelationKode,'tilstandsudstyr'::TilstandRelationKode,'samtykke'::TilstandRelationKode,'tilstandsdokument'::TilstandRelationKode));




CREATE INDEX tilstand_relation_idx_rel_maal_obj_uuid
    ON tilstand_relation
    USING btree
    (rel_type,objekt_type,rel_maal_uuid);



CREATE INDEX tilstand_relation_idx_rel_maal_obj_urn
    ON tilstand_relation
    USING btree
    (rel_type,objekt_type,rel_maal_urn);

CREATE INDEX tilstand_relation_idx_rel_maal_uuid
    ON tilstand_relation
    USING btree
    (rel_type, rel_maal_uuid);

CREATE INDEX tilstand_relation_idx_rel_maal_uuid_isolated
    ON tilstand_relation
    USING btree
    (rel_maal_uuid);

CREATE INDEX tilstand_relation_idx_rel_maal_urn_isolated
    ON tilstand_relation
    USING btree
    (rel_maal_urn);

CREATE INDEX tilstand_relation_idx_rel_maal_urn
    ON tilstand_relation
    USING btree
    (rel_type, rel_maal_urn);

CREATE INDEX tilstand_relation_idx_virkning_aktoerref
    ON tilstand_relation
    USING btree
    (((virkning).aktoerref));

CREATE INDEX tilstand_relation_idx_virkning_aktoertypekode
    ON tilstand_relation
    USING btree
    (((virkning).aktoertypekode));

CREATE INDEX tilstand_relation_idx_virkning_notetekst
    ON tilstand_relation
    USING btree
    (((virkning).notetekst));

CREATE INDEX tilstand_relation_pat_virkning_notetekst
    ON tilstand_relation
    USING gin
    (((virkning).notetekst) gin_trgm_ops);




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/





CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr TilstandStatusTilsType[])
  RETURNS TilstandStatusTilsType[] AS
  $$
  DECLARE result TilstandStatusTilsType[];
  DECLARE element TilstandStatusTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.status IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr TilstandPubliceretTilsType[])
  RETURNS TilstandPubliceretTilsType[] AS
  $$
  DECLARE result TilstandPubliceretTilsType[];
  DECLARE element TilstandPubliceretTilsType;
  BEGIN

 IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP
      IF element IS NULL OR (( element.publiceret IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 
     -- RAISE DEBUG 'Skipping element';
      ELSE 
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;


CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr TilstandEgenskaberAttrType[])
  RETURNS TilstandEgenskaberAttrType[] AS
  $$
  DECLARE result TilstandEgenskaberAttrType[]; 
   DECLARE element TilstandEgenskaberAttrType; 
  BEGIN

  IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR (( element.brugervendtnoegle IS NULL AND element.beskrivelse IS NULL ) AND element.virkning IS NULL) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

    --  RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;

  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;




CREATE OR REPLACE FUNCTION _remove_nulls_in_array(inputArr TilstandRelationType[])
RETURNS TilstandRelationType[] AS
$$
 DECLARE result TilstandRelationType[];
 DECLARE element TilstandRelationType;  
  BEGIN

   IF inputArr IS NOT NULL THEN
    FOREACH element IN ARRAY inputArr
    LOOP

      IF element IS NULL OR ( element.relType IS NULL AND element.uuid IS NULL AND element.urn IS NULL AND element.objektType IS NULL AND element.indeks IS NULL AND (element.tilstandsVaerdiAttr IS NULL OR ((element.tilstandsVaerdiAttr).nominelVaerdi IS NULL AND (element.tilstandsVaerdiAttr).forventet IS NULL )) AND element.virkning IS NULL  ) THEN --CAUTION: foreach on {null} will result in element gets initiated with ROW(null,null....) 

      --RAISE DEBUG 'Skipping element';
      ELSE
      result:=array_append(result,element);
      END IF;
    END LOOP;
  ELSE
    return null;  
  END IF;

  RETURN result;
    
  END;
 
 $$ LANGUAGE plpgsql IMMUTABLE
;





-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_get_prev_tilstand_registrering(
    tilstand_registrering
) RETURNS tilstand_registrering AS $BODY$
  SELECT * FROM tilstand_registrering as a WHERE
    tilstand_id = $1.tilstand_id 
    AND UPPER((a.registrering).TimePeriod) = LOWER(($1.registrering).TimePeriod) 
    AND UPPER_INC((a.registrering).TimePeriod) <> LOWER_INC(($1.registrering).TimePeriod)
    LIMIT 1 --constraints on timeperiod will also ensure max 1 hit
$BODY$ LANGUAGE sql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_create_tilstand_registrering(
    tilstand_uuid uuid,
    livscykluskode Livscykluskode,
    brugerref uuid,
    note text DEFAULT ''::text
) RETURNS tilstand_registrering AS $$
DECLARE
    registreringTime TIMESTAMPTZ := clock_timestamp();
    registreringObj RegistreringBase;
    rows_affected int;
    tilstand_registrering_id bigint;
    tilstand_registrering    tilstand_registrering;
BEGIN
    --limit the scope of the current unlimited registrering
    UPDATE tilstand_registrering as a
        SET registrering.timeperiod = TSTZRANGE(
            lower((registrering).timeperiod),
            registreringTime,
            concat(
                CASE WHEN lower_inc((registrering).timeperiod) THEN '[' ELSE '(' END,
                ')'
            ))
        WHERE tilstand_id = tilstand_uuid
        AND upper((registrering).timeperiod)='infinity'::TIMESTAMPTZ
        AND _as_valid_registrering_livscyklus_transition((registrering).livscykluskode,livscykluskode)  --we'll only limit the scope of the old registrering, if we're dealing with a valid transition. Faliure to move, will result in a constraint violation. A more explicit check on the validity of the state change should be considered.
    ;

    GET DIAGNOSTICS rows_affected = ROW_COUNT;

    IF rows_affected=0 THEN
      RAISE EXCEPTION 'Error updating tilstand with uuid [%], Invalid [livscyklus] transition to [%]',tilstand_uuid,livscykluskode USING ERRCODE = 'MO400';
    END IF;

    --create a new tilstand registrering

    tilstand_registrering_id := nextval('tilstand_registrering_id_seq'::regclass);

    registreringObj := ROW (
        TSTZRANGE(registreringTime,'infinity'::TIMESTAMPTZ,'[)'),
        livscykluskode,
        brugerref,
        note
    ) :: RegistreringBase;

    tilstand_registrering := ROW(
        tilstand_registrering_id,
        tilstand_uuid,
        registreringObj
    )::tilstand_registrering;

    INSERT INTO tilstand_registrering SELECT tilstand_registrering.*;

    RETURN tilstand_registrering;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


-- Also notice, that the given arrays of TilstandAttr...Type
-- must be consistent regarding virkning (although the allowance of
-- null-values might make it possible to construct
-- 'logically consistent'-arrays of objects with overlapping virknings)
CREATE OR REPLACE FUNCTION as_update_tilstand(
    tilstand_uuid uuid,
    brugerref uuid,
    note text,
    livscykluskode Livscykluskode,

    
    attrEgenskaber TilstandEgenskaberAttrType[],
    

    
    tilsStatus TilstandStatusTilsType[],
    
    tilsPubliceret TilstandPubliceretTilsType[],
    

    relationer TilstandRelationType[],

    

    lostUpdatePreventionTZ TIMESTAMPTZ = null,
    auth_criteria_arr      TilstandRegistreringType[] = null
) RETURNS bigint AS $$
DECLARE
    read_new_tilstand          TilstandType;
    read_prev_tilstand         TilstandType;
    read_new_tilstand_reg      TilstandRegistreringType;
    read_prev_tilstand_reg     TilstandRegistreringType;
    new_tilstand_registrering  tilstand_registrering;
    prev_tilstand_registrering tilstand_registrering;
    tilstand_relation_navn     TilstandRelationKode;

    
    attrEgenskaberObj TilstandEgenskaberAttrType;
    

    

    auth_filtered_uuids uuid[];

    
    rel_type_max_index_prev_rev int;
    rel_type_max_index_arr _tilstandRelationMaxIndex[];
    tilstand_rel_type_cardinality_unlimited tilstandRelationKode[]:=ARRAY['tilstandsvaerdi'::TilstandRelationKode,'begrundelse'::TilstandRelationKode,'tilstandskvalitet'::TilstandRelationKode,'tilstandsvurdering'::TilstandRelationKode,'tilstandsaktoer'::TilstandRelationKode,'tilstandsudstyr'::TilstandRelationKode,'samtykke'::TilstandRelationKode,'tilstandsdokument'::TilstandRelationKode]::TilstandRelationKode[];
    tilstand_uuid_underscores text;
    tilstand_rel_seq_name text;
    tilstand_rel_type_cardinality_unlimited_present_in_argument tilstandRelationKode[];
    
BEGIN
    -- Create a new registrering
    IF NOT EXISTS (select a.id from tilstand a join tilstand_registrering b ON b.tilstand_id=a.id WHERE a.id=tilstand_uuid) THEN
        RAISE EXCEPTION 'Unable to update tilstand with uuid [%], being unable to find any previous registrations.',tilstand_uuid USING ERRCODE = 'MO400';
    END IF;

    -- We synchronize concurrent invocations of as_updates of this particular
    -- object on a exclusive row lock. This lock will be held by the current
    -- transaction until it terminates.
    PERFORM a.id FROM tilstand a WHERE a.id=tilstand_uuid FOR UPDATE;

    -- Verify that the object meets the stipulated access allowed criteria
    auth_filtered_uuids := _as_filter_unauth_tilstand(array[tilstand_uuid]::uuid[], auth_criteria_arr);
    IF NOT (coalesce(array_length(auth_filtered_uuids, 1), 0) = 1 AND auth_filtered_uuids @>ARRAY[tilstand_uuid]) THEN
      RAISE EXCEPTION 'Unable to update tilstand with uuid [%]. Object does not met stipulated criteria:%', tilstand_uuid, to_json(auth_criteria_arr) USING ERRCODE = 'MO401';
    END IF;

    new_tilstand_registrering := _as_create_tilstand_registrering(tilstand_uuid, livscykluskode, brugerref, note);
    prev_tilstand_registrering := _as_get_prev_tilstand_registrering(new_tilstand_registrering);

    IF lostUpdatePreventionTZ IS NOT NULL THEN
      IF NOT (LOWER((prev_tilstand_registrering.registrering).timeperiod) = lostUpdatePreventionTZ) THEN
        RAISE EXCEPTION 'Unable to update tilstand with uuid [%], as the tilstand seems to have been updated since latest read by client (the given lostUpdatePreventionTZ [%] does not match the timesamp of latest registration [%]).', tilstand_uuid, lostUpdatePreventionTZ, LOWER((prev_tilstand_registrering.registrering).timeperiod) USING ERRCODE = 'MO409';
      END IF;
    END IF;

    -- Handle relationer (relations)
    IF relationer IS NOT NULL AND coalesce(array_length(relationer, 1), 0) = 0 THEN
        -- raise notice 'Skipping relations, as it is explicit set to empty array. Update note [%]', note;
    ELSE

    -- 1) Insert relations given as part of this update
    -- 2) for aktivitet: Insert relations of previous registration, with index
    --      values not included in this update. Please notice that for the
    --      logic to work, it is very important that the index sequences
    --      start with the max value for index of the same type in the
    --      previous registration
    -- 2) for everything else: Insert relations of previous registration,
    --      taking overlapping virknings into consideration
    --      (using function subtract_tstzrange)

    --Ad 1)
    
    -- Build array with the max index values of the different types of
    -- relations of the previous registration
    
    SELECT array_agg(rel_type_max_index)::_tilstandRelationMaxIndex[] into rel_type_max_index_arr
    
    FROM
    (
        SELECT
        
        (ROW(rel_type,coalesce(max(rel_index),0))::_tilstandRelationMaxIndex) rel_type_max_index
        
            FROM tilstand_relation a
           WHERE a.tilstand_registrering_id=prev_tilstand_registrering.id
             AND a.rel_type = ANY (tilstand_rel_type_cardinality_unlimited)
        GROUP BY rel_type
    ) AS a;

 
    ---Create temporary sequences
    

    SELECT array_agg(DISTINCT a.RelType) INTO tilstand_rel_type_cardinality_unlimited_present_in_argument FROM unnest(relationer) a WHERE a.RelType = ANY (tilstand_rel_type_cardinality_unlimited);
    
    tilstand_uuid_underscores := replace(tilstand_uuid::text, '-', '_');
    

    IF coalesce(array_length(tilstand_rel_type_cardinality_unlimited_present_in_argument, 1), 0) > 0 THEN
        FOREACH tilstand_relation_navn IN ARRAY (tilstand_rel_type_cardinality_unlimited_present_in_argument) LOOP
            tilstand_rel_seq_name := 'tilstand_' || tilstand_relation_navn::text || tilstand_uuid_underscores;

            rel_type_max_index_prev_rev := null;

            SELECT a.indeks into rel_type_max_index_prev_rev
              FROM unnest(rel_type_max_index_arr) a(relType,indeks)
             WHERE a.relType=tilstand_relation_navn;

            IF rel_type_max_index_prev_rev IS NULL THEN
              rel_type_max_index_prev_rev := 0;
            END IF;

            EXECUTE 'CREATE TEMPORARY SEQUENCE ' || tilstand_rel_seq_name || '
            INCREMENT 1
            MINVALUE 1
            MAXVALUE 9223372036854775807
            START ' ||  (rel_type_max_index_prev_rev+1)::text ||'
            CACHE 1;';

        END LOOP;
    END IF;
    

    INSERT INTO tilstand_relation (tilstand_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type , rel_index, tilstand_vaerdi_attr )
    SELECT
        new_tilstand_registrering.id,
        a.virkning,
        a.uuid,
        a.urn,
        a.relType,
        a.objektType ,
            CASE WHEN a.relType = ANY (tilstand_rel_type_cardinality_unlimited) THEN
                CASE WHEN a.indeks IS NULL
                    OR b.id IS NULL THEN
                    -- For new relations and relations with index given that
                    -- is not found in prev registrering, we'll assign new
                    -- index values.
                    nextval('tilstand_' || a.relType::text || tilstand_uuid_underscores)
                ELSE
                    a.indeks
                END
            ELSE
                NULL
            END,
            CASE WHEN a.relType = 'tilstandsvaerdi'
                AND (NOT ((a.tilstandsVaerdiAttr)
                        IS NULL))
                AND ((a.tilstandsVaerdiAttr).forventet IS NOT NULL
                    OR (a.tilstandsVaerdiAttr).nominelVaerdi IS NOT NULL) THEN
                (a.tilstandsVaerdiAttr)
            ELSE
                NULL
            END 
        FROM
            unnest(relationer) AS a 
        LEFT JOIN tilstand_relation b ON a.relType = ANY (tilstand_rel_type_cardinality_unlimited) AND b.tilstand_registrering_id = prev_tilstand_registrering.id AND a.relType = b.rel_type AND a.indeks = b.rel_index ;

    
    -- Drop temporary sequences
    IF coalesce(array_length(tilstand_rel_type_cardinality_unlimited_present_in_argument, 1), 0) > 0 THEN
        
        FOREACH tilstand_relation_navn IN ARRAY (SELECT array_agg(DISTINCT a.RelType) FROM unnest(relationer) a WHERE a.RelType = ANY (tilstand_rel_type_cardinality_unlimited))
        
        LOOP
          tilstand_rel_seq_name := 'tilstand_' || tilstand_relation_navn::text || tilstand_uuid_underscores;
          EXECUTE 'DROP SEQUENCE ' || tilstand_rel_seq_name || ';';
        END LOOP;
    END IF;
    


    -- Ad 2)
    -- 0..1 relations

    
    -- Please notice, that for 0..1 relations for aktivitet, we're ignoring index
    -- here, and handling it the same way, that is done for other object types (like
    -- Facet, Klasse etc). That is, you only make changes for the
    -- virkningsperiod that you explicitly specify (unless you delete all relations)
    
    
    FOREACH tilstand_relation_navn IN ARRAY ARRAY['tilstandsobjekt'::TilstandRelationKode ,  'tilstandstype'::TilstandRelationKode  ]::TilstandRelationKode[]  LOOP
        INSERT INTO tilstand_relation (tilstand_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type , rel_index, tilstand_vaerdi_attr )
        SELECT
            new_tilstand_registrering.id,
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.rel_maal_uuid,
            a.rel_maal_urn,
            a.rel_type,
            a.objekt_type ,
                NULL, -- a.rel_index, rel_index is not to be used for 0..1 relations
                a.tilstand_vaerdi_attr 
            FROM (
                -- Build an array of the timeperiod of the virkning of the
                -- relations of the new registrering to pass to
                -- _subtract_tstzrange_arr on the relations of the previous
                -- registrering.
                SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                  FROM tilstand_relation b
                 WHERE b.tilstand_registrering_id = new_tilstand_registrering.id AND b.rel_type = tilstand_relation_navn) d
            JOIN tilstand_relation a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.tilstand_registrering_id = prev_tilstand_registrering.id AND a.rel_type = tilstand_relation_navn;
    END LOOP;

    -- 0..n relations
    -- We only have to check if there are any of the relations with the
    -- given name present in the new registration, otherwise copy the ones
    -- from the previous registration.

    
                    INSERT INTO tilstand_relation (tilstand_registrering_id, virkning, rel_maal_uuid, rel_maal_urn, rel_type, objekt_type , rel_index, tilstand_vaerdi_attr )
                    SELECT
                        new_tilstand_registrering.id,  a.virkning, a.rel_maal_uuid, a.rel_maal_urn, a.rel_type, a.objekt_type, a.rel_index, a.tilstand_vaerdi_attr
            FROM tilstand_relation a
            LEFT JOIN tilstand_relation b ON b.tilstand_registrering_id = new_tilstand_registrering.id AND b.rel_type = a.rel_type AND b.rel_index = a.rel_index
        WHERE
            a.tilstand_registrering_id = prev_tilstand_registrering.id AND a.rel_type = ANY (tilstand_rel_type_cardinality_unlimited) AND b.id IS NULL
            -- Don't transfer relations of prev. registrering, if the index
            -- was specified in data given to the/this update-function
            ;

    
    END IF;


    -- Handle tilstande (states)
    
    IF tilsStatus IS NOT NULL AND coalesce(array_length(tilsStatus, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Status] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- tilstand_tils_status

        -- Ad 1)
        INSERT INTO tilstand_tils_status(virkning, status, tilstand_registrering_id)
             SELECT a.virkning, a.status, new_tilstand_registrering.id
               FROM unnest(tilsStatus) AS a;

        -- Ad 2
        INSERT INTO tilstand_tils_status(virkning, status, tilstand_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.status,
            new_tilstand_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- tilstand_tils_status of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- tilstand_tils_status of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM tilstand_tils_status b
             WHERE b.tilstand_registrering_id = new_tilstand_registrering.id) d
              JOIN tilstand_tils_status a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.tilstand_registrering_id = prev_tilstand_registrering.id;
    END IF;
    
    IF tilsPubliceret IS NOT NULL AND coalesce(array_length(tilsPubliceret, 1), 0) = 0 THEN
        -- raise debug 'Skipping [Publiceret] as it is explicit set to empty array';
    ELSE
        -- 1) Insert tilstande/states given as part of this update
        -- 2) Insert tilstande/states of previous registration, taking
        --      overlapping virknings into consideration (using function
        --      subtract_tstzrange)

        -- tilstand_tils_publiceret

        -- Ad 1)
        INSERT INTO tilstand_tils_publiceret(virkning, publiceret, tilstand_registrering_id)
             SELECT a.virkning, a.publiceret, new_tilstand_registrering.id
               FROM unnest(tilsPubliceret) AS a;

        -- Ad 2
        INSERT INTO tilstand_tils_publiceret(virkning, publiceret, tilstand_registrering_id)
        SELECT
            ROW (c.tz_range_leftover,
                (a.virkning).AktoerRef,
                (a.virkning).AktoerTypeKode,
                (a.virkning).NoteTekst)::virkning,
            a.publiceret,
            new_tilstand_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- tilstand_tils_publiceret of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- tilstand_tils_publiceret of the previous registrering
            SELECT coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
              FROM tilstand_tils_publiceret b
             WHERE b.tilstand_registrering_id = new_tilstand_registrering.id) d
              JOIN tilstand_tils_publiceret a ON TRUE
              JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE a.tilstand_registrering_id = prev_tilstand_registrering.id;
    END IF;
    


    -- Handle attributter (attributes)
    
    -- tilstand_attr_egenskaber

    -- Generate and insert any merged objects, if any fields are null
    -- in attrTilstandObj
    IF attrEgenskaber IS NOT NULL THEN
        --Input validation:
        --Verify that there is no overlap in virkning in the array given
        IF EXISTS (
                SELECT a.* FROM
                    unnest(attrEgenskaber) a
                    JOIN unnest(attrEgenskaber) b ON (a.virkning).TimePeriod && (b.virkning).TimePeriod
                GROUP BY
                    a.brugervendtnoegle,a.beskrivelse,
                    a.virkning
                    
                    HAVING COUNT(*) > 1) THEN
                    RAISE EXCEPTION 'Unable to update tilstand with uuid [%], as the tilstand have overlapping virknings in the given egenskaber array :%', tilstand_uuid, to_json(attrEgenskaber) USING ERRCODE = 'MO400';
    END IF;

    FOREACH attrEgenskaberObj IN ARRAY attrEgenskaber LOOP
        -- To avoid needless fragmentation we'll check for presence of
        -- null values in the fields - and if none are present, we'll skip
        -- the merging operations
        IF  (attrEgenskaberObj).brugervendtnoegle IS NULL  OR  (attrEgenskaberObj).beskrivelse IS NULL  THEN
            
            INSERT INTO tilstand_attr_egenskaber ( brugervendtnoegle,beskrivelse, virkning, tilstand_registrering_id)
                SELECT
                    
                        
                        
                            coalesce(attrEgenskaberObj.brugervendtnoegle, a.brugervendtnoegle),
                    
                        
                        
                            coalesce(attrEgenskaberObj.beskrivelse, a.beskrivelse),
                    
                    ROW ((a.virkning).TimePeriod * (attrEgenskaberObj.virkning).TimePeriod,
                            (attrEgenskaberObj.virkning).AktoerRef,
                            (attrEgenskaberObj.virkning).AktoerTypeKode,
                            (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                            new_tilstand_registrering.id
                        FROM tilstand_attr_egenskaber a
                    WHERE
                        a.tilstand_registrering_id = prev_tilstand_registrering.id
                        AND (a.virkning).TimePeriod && (attrEgenskaberObj.virkning).TimePeriod
                        ;

        -- For any periods within the virkning of the attrEgenskaberObj,
        -- that is NOT covered by any "merged" rows inserted above, generate
        -- and insert rows.
        
            INSERT INTO tilstand_attr_egenskaber ( brugervendtnoegle,beskrivelse, virkning, tilstand_registrering_id)
                SELECT
                    
                     attrEgenskaberObj.brugervendtnoegle,
                    
                     attrEgenskaberObj.beskrivelse,
                    
                    ROW (b.tz_range_leftover,
                        (attrEgenskaberObj.virkning).AktoerRef,
                        (attrEgenskaberObj.virkning).AktoerTypeKode,
                        (attrEgenskaberObj.virkning).NoteTekst)::Virkning,
                        new_tilstand_registrering.id
                    FROM (
                        -- Build an array of the timeperiod of the virkning
                        -- of the tilstand_attr_egenskaber of the new
                        -- registrering to pass to _subtract_tstzrange_arr.
                        SELECT
                            coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
                        FROM tilstand_attr_egenskaber b
                    WHERE b.tilstand_registrering_id = new_tilstand_registrering.id) AS a
                    JOIN unnest(_subtract_tstzrange_arr ((attrEgenskaberObj.virkning).TimePeriod, a.tzranges_of_new_reg)) AS b (tz_range_leftover) ON TRUE ;

        ELSE
            -- Insert attrEgenskaberObj raw (if there were no null-valued fields)
            

            INSERT INTO tilstand_attr_egenskaber ( brugervendtnoegle,beskrivelse, virkning, tilstand_registrering_id)
                VALUES (  attrEgenskaberObj.brugervendtnoegle,  attrEgenskaberObj.beskrivelse, attrEgenskaberObj.virkning, new_tilstand_registrering.id );
        END IF;

        END LOOP;

        END IF;

        IF attrEgenskaber IS NOT NULL AND coalesce(array_length(attrEgenskaber, 1), 0) = 0 THEN
            -- raise debug 'Skipping handling of egenskaber of previous registration as an empty array was explicit given.';
        ELSE



-- Handle egenskaber of previous registration, taking overlapping
-- virknings into consideration (using function subtract_tstzrange)

    INSERT INTO tilstand_attr_egenskaber ( brugervendtnoegle,beskrivelse, virkning, tilstand_registrering_id)
    SELECT
        
        
            a.brugervendtnoegle,
        
            a.beskrivelse,
        
        ROW (c.tz_range_leftover,
            (a.virkning).AktoerRef,
            (a.virkning).AktoerTypeKode,
            (a.virkning).NoteTekst)::virkning,
            new_tilstand_registrering.id
        FROM (
            -- Build an array of the timeperiod of the virkning of the
            -- tilstand_attr_egenskaber of the new registrering to
            -- pass to _subtract_tstzrange_arr on the
            -- tilstand_attr_egenskaber of the previous registrering.
            SELECT
                coalesce(array_agg((b.virkning).TimePeriod), ARRAY[]::TSTZRANGE[]) tzranges_of_new_reg
            FROM
                tilstand_attr_egenskaber b
            WHERE
                b.tilstand_registrering_id = new_tilstand_registrering.id) d
            JOIN tilstand_attr_egenskaber a ON TRUE
            JOIN unnest(_subtract_tstzrange_arr ((a.virkning).TimePeriod, tzranges_of_new_reg)) AS c (tz_range_leftover) ON TRUE
        WHERE
            a.tilstand_registrering_id = prev_tilstand_registrering.id ;

END IF;






    /******************************************************************/
    -- If the new registrering is identical to the previous one, we need
    -- to throw an exception to abort the transaction.

    read_new_tilstand := as_read_tilstand(tilstand_uuid, (new_tilstand_registrering.registrering).timeperiod, null);
    read_prev_tilstand := as_read_tilstand(tilstand_uuid, (prev_tilstand_registrering.registrering).timeperiod, null);

    -- The ordering in as_list (called by as_read) ensures that the latest
    -- registration is returned at index pos 1.

    IF NOT (lower((read_new_tilstand.registrering[1].registrering).TimePeriod) = lower((new_tilstand_registrering.registrering).TimePeriod) and lower((read_prev_tilstand.registrering[1].registrering).TimePeriod)=lower((prev_tilstand_registrering.registrering).TimePeriod)) THEN
      RAISE EXCEPTION 'Error updating tilstand with id [%]: The ordering of as_list_tilstand should ensure that the latest registrering can be found at index 1. Expected new reg: [%]. Actual new reg at index 1: [%]. Expected prev reg: [%]. Actual prev reg at index 1: [%].', tilstand_uuid, to_json(new_tilstand_registrering), to_json(read_new_tilstand.registrering[1].registrering), to_json(prev_tilstand_registrering), to_json(prev_new_tilstand.registrering[1].registrering) USING ERRCODE = 'MO500';
    END IF;
     
    -- We'll ignore the registreringBase part in the comparrison - except
    -- for the livcykluskode
    read_new_tilstand_reg := ROW(
        ROW (null, (read_new_tilstand.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_new_tilstand.registrering[1]).tilsStatus ,
        (read_new_tilstand.registrering[1]).tilsPubliceret ,
        
        (read_new_tilstand.registrering[1]).attrEgenskaber ,
        (read_new_tilstand.registrering[1]).relationer
    )::tilstandRegistreringType;

    read_prev_tilstand_reg := ROW(
        ROW(null, (read_prev_tilstand.registrering[1].registrering).livscykluskode, null, null)::registreringBase,
        
        (read_prev_tilstand.registrering[1]).tilsStatus ,
        (read_prev_tilstand.registrering[1]).tilsPubliceret ,
        
        (read_prev_tilstand.registrering[1]).attrEgenskaber ,
        (read_prev_tilstand.registrering[1]).relationer
    )::tilstandRegistreringType;


    IF read_prev_tilstand_reg = read_new_tilstand_reg THEN
      --RAISE NOTICE 'Note[%]. Aborted reg:%',note,to_json(read_new_tilstand_reg);
      --RAISE NOTICE 'Note[%]. Previous reg:%',note,to_json(read_prev_tilstand_reg);
      RAISE EXCEPTION 'Aborted updating tilstand with id [%] as the given data, does not give raise to a new registration. Aborted reg:[%], previous reg:[%]', tilstand_uuid, to_json(read_new_tilstand_reg), to_json(read_prev_tilstand_reg) USING ERRCODE = 'MO400';
    END IF;


    return new_tilstand_registrering.id;
END; $$ LANGUAGE plpgsql VOLATILE;




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_create_or_import_tilstand (
    tilstand_registrering TilstandRegistreringType,
    tilstand_uuid uuid DEFAULT NULL, auth_criteria_arr
    TilstandRegistreringType[] DEFAULT NULL) RETURNS uuid AS
$$ DECLARE tilstand_registrering_id bigint;

    
    tilstand_attr_egenskaber_obj tilstandEgenskaberAttrType;
    

    
    tilstand_tils_status_obj tilstandStatusTilsType;
    
    tilstand_tils_publiceret_obj tilstandPubliceretTilsType;
    

    tilstand_relationer TilstandRelationType;

    

    auth_filtered_uuids uuid[];

    
    tilstand_relation_kode tilstandRelationKode;
    tilstand_uuid_underscores text;
    tilstand_rel_seq_name text;
    tilstand_rel_type_cardinality_unlimited tilstandRelationKode[]:=ARRAY['tilstandsvaerdi'::TilstandRelationKode,'begrundelse'::TilstandRelationKode,'tilstandskvalitet'::TilstandRelationKode,'tilstandsvurdering'::TilstandRelationKode,'tilstandsaktoer'::TilstandRelationKode,'tilstandsudstyr'::TilstandRelationKode,'samtykke'::TilstandRelationKode,'tilstandsdokument'::TilstandRelationKode]::TilstandRelationKode[];
    tilstand_rel_type_cardinality_unlimited_present_in_argument tilstandRelationKode[];
    

    does_exist boolean;
    new_tilstand_registrering tilstand_registrering;
BEGIN
    IF tilstand_uuid IS NULL THEN LOOP
        tilstand_uuid:=uuid_generate_v4(); EXIT WHEN NOT EXISTS (SELECT id
            from tilstand WHERE id=tilstand_uuid); END LOOP; END IF;

    IF EXISTS (SELECT id from tilstand WHERE id=tilstand_uuid) THEN
        does_exist = True; ELSE

        does_exist = False; END IF;

    IF
        (tilstand_registrering.registrering).livscykluskode<>'Opstaaet'::Livscykluskode
        and
        (tilstand_registrering.registrering).livscykluskode<>'Importeret'::Livscykluskode
        and
        (tilstand_registrering.registrering).livscykluskode<>'Rettet'::Livscykluskode
        THEN RAISE EXCEPTION 'Invalid livscykluskode[%] invoking
        as_create_or_import_tilstand.',(tilstand_registrering.registrering).livscykluskode
        USING ERRCODE='MO400'; END IF;

    IF NOT does_exist THEN INSERT INTO tilstand (ID) SELECT
        tilstand_uuid; END IF;

    /*********************************/
    --Insert new registrering

    IF NOT does_exist THEN
        tilstand_registrering_id:=nextval('tilstand_registrering_id_seq');

        INSERT INTO tilstand_registrering (id, tilstand_id,
            registrering) SELECT tilstand_registrering_id,
        tilstand_uuid, ROW (
            TSTZRANGE(clock_timestamp(),'infinity'::TIMESTAMPTZ,'[)' ),
        (tilstand_registrering.registrering).livscykluskode,
        (tilstand_registrering.registrering).brugerref,
        (tilstand_registrering.registrering).note):: RegistreringBase ;
    ELSE
        -- This is an update, not an import or create
            new_tilstand_registrering :=
            _as_create_tilstand_registrering(tilstand_uuid,
                (tilstand_registrering.registrering).livscykluskode,
                (tilstand_registrering.registrering).brugerref,
                (tilstand_registrering.registrering).note);

            tilstand_registrering_id := new_tilstand_registrering.id;
    END IF;


/*********************************/
--Insert attributes


/************/
--Verification
--For now all declared attributes are mandatory (the fields are all optional,though)


IF coalesce(array_length(tilstand_registrering.attrEgenskaber,
    1),0)<1 THEN RAISE EXCEPTION 'Savner påkraevet attribut [egenskaber] for
    [tilstand]. Oprettelse afbrydes.' USING ERRCODE='MO400'; END IF;



IF tilstand_registrering.attrEgenskaber IS NOT NULL and coalesce(array_length(tilstand_registrering.attrEgenskaber,1),0)>0 THEN
  FOREACH tilstand_attr_egenskaber_obj IN ARRAY tilstand_registrering.attrEgenskaber
  LOOP

  
    INSERT INTO tilstand_attr_egenskaber (
      
      brugervendtnoegle,
      beskrivelse,
      virkning,
      tilstand_registrering_id
    )
    SELECT
     
     tilstand_attr_egenskaber_obj.brugervendtnoegle,
      tilstand_attr_egenskaber_obj.beskrivelse,
      tilstand_attr_egenskaber_obj.virkning,
      tilstand_registrering_id
    ;
  
    
  END LOOP;
END IF;

/*********************************/
--Insert states (tilstande)


--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(tilstand_registrering.tilsStatus, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [status] for tilstand. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF tilstand_registrering.tilsStatus IS NOT NULL AND coalesce(array_length(tilstand_registrering.tilsStatus,1),0)>0 THEN
  FOREACH tilstand_tils_status_obj IN ARRAY tilstand_registrering.tilsStatus
  LOOP

    INSERT INTO tilstand_tils_status (
      virkning,
      status,
      tilstand_registrering_id
    )
    SELECT
      tilstand_tils_status_obj.virkning,
      tilstand_tils_status_obj.status,
      tilstand_registrering_id;

  END LOOP;
END IF;

--Verification
--For now all declared states are mandatory.
IF coalesce(array_length(tilstand_registrering.tilsPubliceret, 1),0)<1 THEN
  RAISE EXCEPTION 'Savner påkraevet tilstand [publiceret] for tilstand. Oprettelse afbrydes.' USING ERRCODE='MO400';
END IF;

IF tilstand_registrering.tilsPubliceret IS NOT NULL AND coalesce(array_length(tilstand_registrering.tilsPubliceret,1),0)>0 THEN
  FOREACH tilstand_tils_publiceret_obj IN ARRAY tilstand_registrering.tilsPubliceret
  LOOP

    INSERT INTO tilstand_tils_publiceret (
      virkning,
      publiceret,
      tilstand_registrering_id
    )
    SELECT
      tilstand_tils_publiceret_obj.virkning,
      tilstand_tils_publiceret_obj.publiceret,
      tilstand_registrering_id;

  END LOOP;
END IF;

/*********************************/
--Insert relations


IF coalesce(array_length(tilstand_registrering.relationer,1),0)>0 THEN

--Create temporary sequences
tilstand_uuid_underscores:=replace(tilstand_uuid::text, '-', '_');

SELECT array_agg(DISTINCT a.RelType) into tilstand_rel_type_cardinality_unlimited_present_in_argument FROM unnest(tilstand_registrering.relationer) a WHERE a.RelType = any (tilstand_rel_type_cardinality_unlimited) ;
IF coalesce(array_length(tilstand_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN

FOREACH tilstand_relation_kode IN ARRAY (tilstand_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  tilstand_rel_seq_name := 'tilstand_' || tilstand_relation_kode::text || tilstand_uuid_underscores;

  EXECUTE 'CREATE TEMPORARY SEQUENCE ' || tilstand_rel_seq_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START 1
  CACHE 1;';

END LOOP;
END IF;


    INSERT INTO tilstand_relation (
      tilstand_registrering_id,
      virkning,
      rel_maal_uuid,
      rel_maal_urn,
      rel_type,
      objekt_type,
      rel_index,
      tilstand_vaerdi_attr
    )
    SELECT
      tilstand_registrering_id,
      a.virkning,
      a.uuid,
      a.urn,
      a.relType,
      a.objektType,
      CASE WHEN a.relType = any (tilstand_rel_type_cardinality_unlimited) THEN --rel_index
      nextval('tilstand_' || a.relType::text || tilstand_uuid_underscores)
      ELSE 
      NULL
      END,
      CASE
        WHEN a.relType='tilstandsvaerdi' AND
          (NOT (a.tilstandsVaerdiAttr IS NULL))
          AND 
          (
            (a.tilstandsVaerdiAttr).forventet IS NOT NULL
            OR
            (a.tilstandsVaerdiAttr).nominelVaerdi IS NOT NULL
          ) THEN a.tilstandsVaerdiAttr
        ELSE
        NULL
      END
    
    FROM unnest(tilstand_registrering.relationer) a
  ;



--Drop temporary sequences
IF coalesce(array_length(tilstand_rel_type_cardinality_unlimited_present_in_argument,1),0)>0 THEN
FOREACH tilstand_relation_kode IN ARRAY (tilstand_rel_type_cardinality_unlimited_present_in_argument)
  LOOP
  tilstand_rel_seq_name := 'tilstand_' || tilstand_relation_kode::text || tilstand_uuid_underscores;
  EXECUTE 'DROP SEQUENCE ' || tilstand_rel_seq_name || ';';
END LOOP;
END IF;


END IF;


/*** Verify that the object meets the stipulated access allowed criteria  ***/
/*** NOTICE: We are doing this check *after* the insertion of data BUT *before* transaction commit, to reuse code / avoid fragmentation  ***/
auth_filtered_uuids:=_as_filter_unauth_tilstand(array[tilstand_uuid]::uuid[],auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=1 AND auth_filtered_uuids @>ARRAY[tilstand_uuid]) THEN
  RAISE EXCEPTION 'Unable to create/import tilstand with uuid [%]. Object does not met stipulated criteria:%',tilstand_uuid,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/




RETURN tilstand_uuid;

END;
$$ LANGUAGE plpgsql VOLATILE;

-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/

CREATE OR REPLACE FUNCTION as_list_tilstand(tilstand_uuids uuid[],
  registrering_tstzrange tstzrange,
  virkning_tstzrange tstzrange,
  auth_criteria_arr TilstandRegistreringType[]=null
  )
  RETURNS TilstandType[] AS
$$
DECLARE
	auth_filtered_uuids uuid[];
	result TilstandType[];
BEGIN


/*** Verify that the object meets the stipulated access allowed criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_tilstand(tilstand_uuids,auth_criteria_arr); 
IF NOT (coalesce(array_length(auth_filtered_uuids,1),0)=coalesce(array_length(tilstand_uuids,1),0) AND auth_filtered_uuids @>tilstand_uuids) THEN
  RAISE EXCEPTION 'Unable to list tilstand with uuids [%]. All objects do not fullfill the stipulated criteria:%',tilstand_uuids,to_json(auth_criteria_arr)  USING ERRCODE = 'MO401'; 
END IF;
/*********************/

SELECT 
array_agg(x.tilstandObj) into result
FROM
(
SELECT
ROW(
	a.tilstand_id,
	array_agg(
		ROW (
			a.registrering,
			a.TilstandTilsStatusArr,
			a.TilstandTilsPubliceretArr,
			a.TilstandAttrEgenskaberArr,
			a.TilstandRelationArr
		)::TilstandRegistreringType
		order by upper((a.registrering).TimePeriod) DESC		
	) 
):: TilstandType  tilstandObj
FROM
(
	SELECT
	a.tilstand_id,
	a.tilstand_registrering_id,
	a.registrering,
	a.TilstandAttrEgenskaberArr,
	a.TilstandTilsStatusArr,
	a.TilstandTilsPubliceretArr,
	_remove_nulls_in_array(array_agg(
		CASE
		WHEN b.id is not null THEN
		ROW (
				b.rel_type,
				b.virkning,
				b.rel_maal_uuid,
				b.rel_maal_urn,
				b.objekt_type,
                b.rel_index,
                b.tilstand_vaerdi_attr
			):: TilstandRelationType
		ELSE
		NULL
		END
        
		order by b.rel_maal_uuid,b.rel_maal_urn,b.rel_type,b.objekt_type,b.rel_index,b.tilstand_vaerdi_attr,b.virkning
        
	)) TilstandRelationArr
	FROM
	(
			SELECT
			a.tilstand_id,
			a.tilstand_registrering_id,
			a.registrering,
			a.TilstandAttrEgenskaberArr,
			a.TilstandTilsPubliceretArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.status
						) ::TilstandStatusTilsType
					ELSE NULL
					END
					order by b.status,b.virkning
				)) TilstandTilsStatusArr		
			FROM
			(
			SELECT
			a.tilstand_id,
			a.tilstand_registrering_id,
			a.registrering,
			a.TilstandAttrEgenskaberArr,
			_remove_nulls_in_array(array_agg
				(
					CASE
					WHEN b.id is not null THEN 
					ROW(
						b.virkning,
						b.publiceret
						) ::TilstandPubliceretTilsType
					ELSE NULL
					END
					order by b.publiceret,b.virkning
				)) TilstandTilsPubliceretArr		
			FROM
			(
					SELECT
					a.tilstand_id,
					a.tilstand_registrering_id,
					a.registrering,
					_remove_nulls_in_array(array_agg(
						CASE
                        
						WHEN b.id is not null THEN
                        
						ROW(
                            
					 		b.brugervendtnoegle,
					 		b.beskrivelse,
					   		b.virkning
                            
							)::TilstandEgenskaberAttrType
						ELSE
						NULL
						END
                        
						order by b.brugervendtnoegle,b.beskrivelse,b.virkning
                        
					)) TilstandAttrEgenskaberArr
                    
					FROM
					(
					SELECT
					a.id tilstand_id,
					b.id tilstand_registrering_id,
					b.registrering			
					FROM		tilstand a
					JOIN 		tilstand_registrering b 	ON b.tilstand_id=a.id
					WHERE a.id = ANY (tilstand_uuids) AND ((registrering_tstzrange is null AND upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ) OR registrering_tstzrange && (b.registrering).timeperiod)--filter ON registrering_tstzrange
					) as a
					LEFT JOIN tilstand_attr_egenskaber as b ON b.tilstand_registrering_id=a.tilstand_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
                    
					GROUP BY 
					a.tilstand_id,
					a.tilstand_registrering_id,
					a.registrering	
			) as a
			LEFT JOIN tilstand_tils_publiceret as b ON b.tilstand_registrering_id=a.tilstand_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.tilstand_id,
			a.tilstand_registrering_id,
			a.registrering,
			a.TilstandAttrEgenskaberArr	
			) as a
			LEFT JOIN tilstand_tils_status as b ON b.tilstand_registrering_id=a.tilstand_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given			
			GROUP BY 
			a.tilstand_id,
			a.tilstand_registrering_id,
			a.registrering,
			a.TilstandAttrEgenskaberArr,
			a.TilstandTilsPubliceretArr
	) as a
	LEFT JOIN tilstand_relation b ON b.tilstand_registrering_id=a.tilstand_registrering_id AND (virkning_tstzrange is null OR (b.virkning).TimePeriod && virkning_tstzrange) --filter ON virkning_tstzrange if given
	GROUP BY
	a.tilstand_id,
	a.tilstand_registrering_id,
	a.registrering,
	a.TilstandAttrEgenskaberArr,
	a.TilstandTilsPubliceretArr,
	a.TilstandTilsStatusArr
) as a

WHERE a.tilstand_id IS NOT NULL
GROUP BY 
a.tilstand_id
order by a.tilstand_id
) as x
;



RETURN result;

END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_read_tilstand(
    tilstand_uuid uuid,
    registrering_tstzrange tstzrange,
    virkning_tstzrange tstzrange,
    auth_criteria_arr      TilstandRegistreringType[]=null
) RETURNS TilstandType AS $$
DECLARE
	resArr TilstandType[];
BEGIN
    resArr := as_list_tilstand(ARRAY[tilstand_uuid], registrering_tstzrange, virkning_tstzrange, auth_criteria_arr);
    IF resArr is not null and coalesce(array_length(resArr, 1), 0) = 1 THEN
	    RETURN resArr[1];
    ELSE
        RETURN null;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION as_search_tilstand(
    firstResult int,--TOOD ??
    tilstand_uuid uuid,
    registreringObj   TilstandRegistreringType,
    virkningSoeg TSTZRANGE, -- = TSTZRANGE(current_timestamp,current_timestamp,'[]'),
    maxResults int = 2147483647,
    anyAttrValueArr text[] = '{}'::text[],
    anyuuidArr uuid[] = '{}'::uuid[],
    anyurnArr text[] = '{}'::text[],
    auth_criteria_arr TilstandRegistreringType[]=null

    

) RETURNS uuid[] AS $$
DECLARE
    tilstand_candidates uuid[];
    tilstand_candidates_is_initialized boolean;
    --to_be_applyed_filter_uuids uuid[];
    attrEgenskaberTypeObj TilstandEgenskaberAttrType;

    
    tilsStatusTypeObj TilstandStatusTilsType;
    tilsPubliceretTypeObj TilstandPubliceretTilsType;

    relationTypeObj TilstandRelationType;
    anyAttrValue text;
    anyuuid uuid;
    anyurn text;

    

    auth_filtered_uuids uuid[];

    
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

tilstand_candidates_is_initialized := false;

IF tilstand_uuid is not NULL THEN
    tilstand_candidates:= ARRAY[tilstand_uuid];
    tilstand_candidates_is_initialized:=true;
    IF registreringObj IS NULL THEN
    --RAISE DEBUG 'no registreringObj'
    ELSE
        tilstand_candidates:=array(
                SELECT DISTINCT
                b.tilstand_id
                FROM
                tilstand a
                JOIN tilstand_registrering b on b.tilstand_id=a.id
                WHERE
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )

        );
    END IF;
END IF;


--RAISE DEBUG 'tilstand_candidates_is_initialized step 1:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 1:%',tilstand_candidates;
--/****************************//


--RAISE NOTICE 'tilstand_candidates_is_initialized step 2:%',tilstand_candidates_is_initialized;
--RAISE NOTICE 'tilstand_candidates step 2:%',tilstand_candidates;

--/****************************//
--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
    --RAISE DEBUG 'as_search_tilstand: skipping filtration on attrEgenskaber';
ELSE

    IF (coalesce(array_length(tilstand_candidates,1),0)>0 OR NOT tilstand_candidates_is_initialized) THEN
        
        FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
        
        LOOP
            tilstand_candidates:=array(
            SELECT DISTINCT
            b.tilstand_id
            FROM  tilstand_attr_egenskaber a
            JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
            
            WHERE
                (
                    (
                        attrEgenskaberTypeObj.virkning IS NULL 
                        OR
                        (
                            (
                                (
                                     (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL
                                )
                                OR
                                (
                                    (attrEgenskaberTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                                )
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerRef IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).AktoerTypeKode IS NULL OR (attrEgenskaberTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                            )
                            AND
                            (
                                    (attrEgenskaberTypeObj.virkning).NoteTekst IS NULL OR  (a.virkning).NoteTekst ILIKE (attrEgenskaberTypeObj.virkning).NoteTekst  
                            )
                        )
                    )
                )
                AND
                (
                    (NOT (attrEgenskaberTypeObj.virkning IS NULL OR (attrEgenskaberTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    attrEgenskaberTypeObj.brugervendtnoegle IS NULL
                    OR
                    a.brugervendtnoegle ILIKE attrEgenskaberTypeObj.brugervendtnoegle --case insensitive
                )
                AND
                (
                    attrEgenskaberTypeObj.beskrivelse IS NULL
                    OR
                    a.beskrivelse ILIKE attrEgenskaberTypeObj.beskrivelse --case insensitive
                )
                AND
                
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )

            );


            tilstand_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--RAISE DEBUG 'tilstand_candidates_is_initialized step 3:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 3:%',tilstand_candidates;

--/**********************************************************//
--Filtration on anyAttrValueArr
--/**********************************************************//
IF coalesce(array_length(anyAttrValueArr ,1),0)>0 THEN

    FOREACH anyAttrValue IN ARRAY anyAttrValueArr
    LOOP
        tilstand_candidates:=array(

            SELECT DISTINCT
            b.tilstand_id
            
            FROM  tilstand_attr_egenskaber a
            JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
            
            WHERE
            (
                        a.brugervendtnoegle ILIKE anyAttrValue OR
                        a.beskrivelse ILIKE anyAttrValue
                
            )
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            AND
            
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )


        );

    tilstand_candidates_is_initialized:=true;

    END LOOP;

END IF;



--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Status
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsStatus IS NULL THEN
    --RAISE DEBUG 'as_search_tilstand: skipping filtration on tilsStatus';
ELSE
    IF (coalesce(array_length(tilstand_candidates,1),0)>0 OR tilstand_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsStatusTypeObj IN ARRAY registreringObj.tilsStatus
        LOOP
            tilstand_candidates:=array(
            SELECT DISTINCT
            b.tilstand_id
            FROM  tilstand_tils_status a
            JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
            WHERE
                (
                    tilsStatusTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsStatusTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsStatusTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsStatusTypeObj.virkning).AktoerRef IS NULL OR (tilsStatusTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsStatusTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsStatusTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsStatusTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsStatusTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsStatusTypeObj.virkning) IS NULL OR (tilsStatusTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsStatusTypeObj.status IS NULL
                    OR
                    tilsStatusTypeObj.status = a.status
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )

    );


            tilstand_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;
--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
    --RAISE DEBUG 'as_search_tilstand: skipping filtration on tilsPubliceret';
ELSE
    IF (coalesce(array_length(tilstand_candidates,1),0)>0 OR tilstand_candidates_is_initialized IS FALSE ) THEN

        FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
        LOOP
            tilstand_candidates:=array(
            SELECT DISTINCT
            b.tilstand_id
            FROM  tilstand_tils_publiceret a
            JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
            WHERE
                (
                    tilsPubliceretTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (tilsPubliceretTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).AktoerRef IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).AktoerTypeKode IS NULL OR (tilsPubliceretTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (tilsPubliceretTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (tilsPubliceretTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT ((tilsPubliceretTypeObj.virkning) IS NULL OR (tilsPubliceretTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    tilsPubliceretTypeObj.publiceret IS NULL
                    OR
                    tilsPubliceretTypeObj.publiceret = a.publiceret
                )
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )

    );


            tilstand_candidates_is_initialized:=true;


        END LOOP;
    END IF;
END IF;

/*
--relationer TilstandRelationType[]
*/


--RAISE DEBUG 'tilstand_candidates_is_initialized step 4:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 4:%',tilstand_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL THEN
    --RAISE DEBUG 'as_search_tilstand: skipping filtration on relationer';
ELSE
    IF (coalesce(array_length(tilstand_candidates,1),0)>0 OR NOT tilstand_candidates_is_initialized) AND (registreringObj).relationer IS NOT NULL THEN
        FOREACH relationTypeObj IN ARRAY registreringObj.relationer
        LOOP
            tilstand_candidates:=array(
            SELECT DISTINCT
            b.tilstand_id
            FROM  tilstand_relation a
            JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
            WHERE
                (
                    relationTypeObj.virkning IS NULL
                    OR
                    (
                        (
                             (relationTypeObj.virkning).TimePeriod IS NULL
                            OR
                            (relationTypeObj.virkning).TimePeriod && (a.virkning).TimePeriod
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerRef IS NULL OR (relationTypeObj.virkning).AktoerRef=(a.virkning).AktoerRef
                        )
                        AND
                        (
                                (relationTypeObj.virkning).AktoerTypeKode IS NULL OR (relationTypeObj.virkning).AktoerTypeKode=(a.virkning).AktoerTypeKode
                        )
                        AND
                        (
                                (relationTypeObj.virkning).NoteTekst IS NULL OR (a.virkning).NoteTekst ILIKE (relationTypeObj.virkning).NoteTekst
                        )
                    )
                )
                AND
                (
                    (NOT (relationTypeObj.virkning IS NULL OR (relationTypeObj.virkning).TimePeriod IS NULL)) --we have already filtered on virkning above
                    OR
                    (
                        virkningSoeg IS NULL
                        OR
                        virkningSoeg && (a.virkning).TimePeriod
                    )
                )
                AND
                (
                    relationTypeObj.relType IS NULL
                    OR
                    relationTypeObj.relType = a.rel_type
                )
                AND
                (
                    relationTypeObj.uuid IS NULL
                    OR
                    relationTypeObj.uuid = a.rel_maal_uuid
                )
                AND
                (
                    relationTypeObj.objektType IS NULL
                    OR
                    relationTypeObj.objektType = a.objekt_type
                )
                AND
                (
                    relationTypeObj.urn IS NULL
                    OR
                    relationTypeObj.urn = a.rel_maal_urn
                )
                
                
                AND
                (
                        relationTypeObj.indeks IS NULL
                        OR
                        relationTypeObj.indeks = a.rel_index
                )
                AND
                (
                relationTypeObj.tilstandsVaerdiAttr IS NULL
                OR
                (
                        (
                                (relationTypeObj.tilstandsVaerdiAttr).nominelVaerdi IS NULL
                                OR
                                (a.tilstand_vaerdi_attr).nominelVaerdi ILIKE (relationTypeObj.tilstandsVaerdiAttr).nominelVaerdi
                        )
                        AND
                        (
                                (relationTypeObj.tilstandsVaerdiAttr).forventet IS NULL
                                OR
                                (a.tilstand_vaerdi_attr).forventet = (relationTypeObj.tilstandsVaerdiAttr).forventet
                        )
 
                )
                )
                
                AND
                		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )

    );

            tilstand_candidates_is_initialized:=true;

        END LOOP;
    END IF;
END IF;
--/**********************//

IF coalesce(array_length(anyuuidArr ,1),0)>0 THEN

    FOREACH anyuuid IN ARRAY anyuuidArr
    LOOP
        tilstand_candidates:=array(
            SELECT DISTINCT
            b.tilstand_id
            
            FROM  tilstand_relation a
            JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
            WHERE
            
            anyuuid = a.rel_maal_uuid
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )


            );

    tilstand_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

IF coalesce(array_length(anyurnArr ,1),0)>0 THEN

    FOREACH anyurn IN ARRAY anyurnArr
    LOOP
        tilstand_candidates:=array(
            SELECT DISTINCT
            b.tilstand_id
            
            FROM  tilstand_relation a
            JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id
            WHERE
            
            anyurn = a.rel_maal_urn
            
            AND
            (
                virkningSoeg IS NULL
                OR
                virkningSoeg && (a.virkning).TimePeriod
            )
            
            AND
            		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )


            );

    tilstand_candidates_is_initialized:=true;
    END LOOP;
END IF;

--/**********************//

 




--RAISE DEBUG 'tilstand_candidates_is_initialized step 5:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 5:%',tilstand_candidates;

IF registreringObj IS NULL THEN
    --RAISE DEBUG 'registreringObj IS NULL';
ELSE
    IF NOT tilstand_candidates_is_initialized THEN
        tilstand_candidates:=array(
        SELECT DISTINCT
            tilstand_id
        FROM
            tilstand_registrering b
        WHERE
        		(
				(registreringObj.registrering) IS NULL 
				OR
				(
					(
						(registreringObj.registrering).timeperiod IS NULL 
						OR
						(registreringObj.registrering).timeperiod && (b.registrering).timeperiod
					)
					AND
					(
						(registreringObj.registrering).livscykluskode IS NULL 
						OR
						(registreringObj.registrering).livscykluskode = (b.registrering).livscykluskode 		
					) 
					AND
					(
						(registreringObj.registrering).brugerref IS NULL
						OR
						(registreringObj.registrering).brugerref = (b.registrering).brugerref
					)
					AND
					(
						(registreringObj.registrering).note IS NULL
						OR
						(b.registrering).note ILIKE (registreringObj.registrering).note
					)
			)
		)
		AND
		(
			(
				((b.registrering).livscykluskode <> 'Slettet'::Livscykluskode )
				AND
					(
						(registreringObj.registrering) IS NULL 
						OR
						(registreringObj.registrering).livscykluskode IS NULL 
					)
			)
			OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				(registreringObj.registrering).livscykluskode IS NOT NULL 
			)
		)
		AND
		(
			(
			  (
			  	(registreringObj.registrering) IS NULL
			  	OR
			  	(registreringObj.registrering).timeperiod IS NULL
			  )
			  AND
			  upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			)  	
		OR
			(
				(NOT ((registreringObj.registrering) IS NULL))
				AND
				((registreringObj.registrering).timeperiod IS NOT NULL)
			)
		)
		AND
		((NOT tilstand_candidates_is_initialized) OR b.tilstand_id = ANY (tilstand_candidates) )

        )
        ;

        tilstand_candidates_is_initialized:=true;
    END IF;
END IF;


IF NOT tilstand_candidates_is_initialized THEN
    --No filters applied!
    tilstand_candidates:=array(
        SELECT DISTINCT id FROM tilstand a
    );
ELSE
    tilstand_candidates:=array(
        SELECT DISTINCT id FROM unnest(tilstand_candidates) as a(id)
        );
END IF;

--RAISE DEBUG 'tilstand_candidates_is_initialized step 6:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 6:%',tilstand_candidates;


/*** Filter out the objects that does not meets the stipulated access criteria  ***/
auth_filtered_uuids:=_as_filter_unauth_tilstand(tilstand_candidates,auth_criteria_arr); 
/*********************/
IF firstResult > 0 or maxResults < 2147483647 THEN
   auth_filtered_uuids = _as_sorted_tilstand(auth_filtered_uuids, virkningSoeg, registreringObj, firstResult, maxResults);
END IF;
return auth_filtered_uuids;


END;
$$ LANGUAGE plpgsql STABLE; 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/



CREATE OR REPLACE FUNCTION actual_state._cast_TilstandRegistreringType_to_json(TilstandRegistreringType) 

RETURNS
json
AS 
$$
DECLARE 
result json;

BEGIN

SELECT row_to_json(a.*) into result
FROM
(
  WITH 
  attr AS (
    SELECT 
    row_to_json(
      c.*
      ) attr_json
    FROM 
      (
        SELECT
        CASE 
        WHEN coalesce(array_length($1.attrEgenskaber,1),0)>0 THEN to_json($1.attrEgenskaber) 
        ELSE 
        NULL
        END tilstandegenskaber
        
        
      ) as c
  ),
  tils as (
      SELECT 
    row_to_json(
      d.*
      ) tils_json
    FROM 
      (
        SELECT 
        
        CASE 
        WHEN coalesce(array_length($1.tilsStatus,1),0)>0 THEN to_json($1.tilsStatus) 
        ELSE 
        NULL
        END tilstandstatus
        ,
        
        CASE 
        WHEN coalesce(array_length($1.tilsPubliceret,1),0)>0 THEN to_json($1.tilsPubliceret) 
        ELSE 
        NULL
        END tilstandpubliceret
        
        
      ) as d
  ),
  rel as (
    SELECT 
    ('{' || string_agg(  to_json(f.relType::text) || ':' || array_to_json(f.rel_json_arr,false) ,',') || '}')::json rel_json
    FROM
    (
      SELECT
      e.relType,

      array_agg(_json_object_delete_keys(row_to_json(ROW(e.relType,e.virkning,e.uuid,e.urn,e.objektType,e.indeks,e.tilstandsVaerdiAttr)::TilstandRelationType),ARRAY['reltype']::text[])) rel_json_arr
      from unnest($1.relationer) e(relType,virkning,uuid,urn,objektType,indeks,tilstandsVaerdiAttr)

      group by e.relType
      order by e.relType asc
    ) as f
  )
  SELECT 
  row_to_json(FraTidspunkt.*) FraTidspunkt
  ,row_to_json(TilTidspunkt.*) TilTidspunkt
  ,($1.registrering).livscykluskode
  ,($1.registrering).note
  ,($1.registrering).brugerref
  ,(SELECT attr_json FROM attr) attributter
  ,(SELECT tils_json FROM tils) tilstande
  ,CASE WHEN coalesce(array_length($1.relationer,1),0)>0 THEN
    (SELECT rel_json from rel)
    ELSE
    '{}'::json
    END relationer

  FROM
    (
    SELECT
     (SELECT LOWER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT lower_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as FraTidspunkt,
    (
    SELECT
     (SELECT UPPER(($1.registrering).TimePeriod)) as TidsstempelDatoTid
    ,(SELECT upper_inc(($1.registrering).TimePeriod)) as GraenseIndikator
    ) as TilTidspunkt
  

)
as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;


drop cast if exists (TilstandRegistreringType as json);
create cast (TilstandRegistreringType as json) with function actual_state._cast_TilstandRegistreringType_to_json(TilstandRegistreringType);


---------------------------------------------------------

CREATE OR REPLACE FUNCTION actual_state._cast_tilstandType_to_json(TilstandType) 

RETURNS
json
AS 
$$
DECLARE 
result json;
reg_json_arr json[];
reg TilstandRegistreringType;
BEGIN


IF coalesce(array_length($1.registrering,1),0)>0 THEN
   FOREACH reg IN ARRAY $1.registrering
    LOOP
    reg_json_arr:=array_append(reg_json_arr,reg::json);
    END LOOP;
END IF;

SELECT row_to_json(a.*) into result
FROM
(
  SELECT
    $1.id id,
    reg_json_arr registreringer
) as a
;

RETURN result;

END;
$$ LANGUAGE plpgsql immutable;

drop cast if exists (TilstandType as json);
create cast (TilstandType as json) with function actual_state._cast_tilstandType_to_json(TilstandType); 




-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_sorted_tilstand(
    tilstand_uuids uuid[],
    virkningSoeg TSTZRANGE,
    registreringObj    TilstandRegistreringType,
    firstResult int,
    maxResults int
) RETURNS uuid[] AS $$
DECLARE
    tilstand_sorted_uuid uuid[];
    registreringSoeg TSTZRANGE;
BEGIN
    IF registreringObj IS NULL OR (registreringObj.registrering).timePeriod IS NULL THEN
        registreringSoeg = TSTZRANGE(current_timestamp, current_timestamp, '[]');
    ELSE
        registreringSoeg = (registreringObj.registrering).timePeriod;
    END IF;

    tilstand_sorted_uuid:=array(
          SELECT b.tilstand_id
            FROM tilstand_registrering b
            JOIN tilstand_attr_egenskaber a ON a.tilstand_registrering_id=b.id
           WHERE b.tilstand_id = ANY (tilstand_uuids)
             AND (b.registrering).timeperiod && registreringSoeg
             AND (a.virkning).timePeriod && virkningSoeg
        GROUP BY b.tilstand_id
        ORDER BY array_agg(DISTINCT a.brugervendtnoegle), b.tilstand_id
           LIMIT maxResults OFFSET firstResult
    );

    RETURN tilstand_sorted_uuid;
END;
$$ LANGUAGE plpgsql STABLE;


-- Copyright (C) 2015 Magenta ApS, https://magenta.dk.
-- Contact: info@magenta.dk.
--
-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

/*
NOTICE: This file is auto-generated!
*/


CREATE OR REPLACE FUNCTION _as_filter_unauth_tilstand(
	tilstand_uuids uuid[],
	registreringObjArr TilstandRegistreringType[]
	)
  RETURNS uuid[] AS 
$$
DECLARE
	tilstand_passed_auth_filter uuid[]:=ARRAY[]::uuid[];
	tilstand_candidates uuid[];
	--to_be_applyed_filter_uuids uuid[]; 
	attrEgenskaberTypeObj TilstandEgenskaberAttrType;
	
  	tilsStatusTypeObj TilstandStatusTilsType;
  	tilsPubliceretTypeObj TilstandPubliceretTilsType;
	relationTypeObj TilstandRelationType;
	registreringObj TilstandRegistreringType;
	actual_virkning TIMESTAMPTZ:=current_timestamp;
BEGIN

--RAISE DEBUG 'step 0:registreringObj:%',registreringObj;

IF registreringObjArr IS NULL THEN
	RETURN tilstand_uuids; --special case: All is allowed, no criteria present
END IF;

IF coalesce(array_length(registreringObjArr,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: Nothing is allowed. Empty list of criteria where at least one has to be met.				
END IF; 

IF tilstand_uuids IS NULL OR coalesce(array_length(tilstand_uuids,1),0)=0 THEN
	RETURN ARRAY[]::uuid[]; --special case: No candidates given to filter.
END IF;



FOREACH registreringObj IN ARRAY registreringObjArr
LOOP

tilstand_candidates:= tilstand_uuids;



--RAISE DEBUG 'tilstand_candidates_is_initialized step 1:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 1:%',tilstand_candidates;
--/****************************//

--filter on attributes 
--/**********************************************************//
--Filtration on attribute: Egenskaber
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).attrEgenskaber IS NULL THEN
	--RAISE DEBUG 'as_search_tilstand: skipping filtration on attrEgenskaber';
ELSE
	IF coalesce(array_length(tilstand_candidates,1),0)>0 THEN
		FOREACH attrEgenskaberTypeObj IN ARRAY registreringObj.attrEgenskaber
		LOOP
			tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_attr_egenskaber a 
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					attrEgenskaberTypeObj.brugervendtnoegle IS NULL
					OR 
					a.brugervendtnoegle = attrEgenskaberTypeObj.brugervendtnoegle 
				)
				AND
				(
					attrEgenskaberTypeObj.beskrivelse IS NULL
					OR 
					a.beskrivelse = attrEgenskaberTypeObj.beskrivelse 
				)
				AND b.tilstand_id = ANY (tilstand_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
			);
			
		END LOOP;
	END IF;
END IF;
--RAISE DEBUG 'tilstand_candidates_is_initialized step 3:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 3:%',tilstand_candidates;

--RAISE DEBUG 'registrering,%',registreringObj;


--/**********************************************************//
--Filtration on state: Status
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsStatus IS NULL THEN
	--RAISE DEBUG 'as_search_tilstand: skipping filtration on tilsStatus';
ELSE
	IF coalesce(array_length(tilstand_candidates,1),0)>0 THEN 

		FOREACH tilsStatusTypeObj IN ARRAY registreringObj.tilsStatus
		LOOP
			tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_tils_status a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsStatusTypeObj.status IS NULL
					OR
					tilsStatusTypeObj.status = a.status
				)
				AND b.tilstand_id = ANY (tilstand_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;
--/**********************************************************//
--Filtration on state: Publiceret
--/**********************************************************//
IF registreringObj IS NULL OR (registreringObj).tilsPubliceret IS NULL THEN
	--RAISE DEBUG 'as_search_tilstand: skipping filtration on tilsPubliceret';
ELSE
	IF coalesce(array_length(tilstand_candidates,1),0)>0 THEN 

		FOREACH tilsPubliceretTypeObj IN ARRAY registreringObj.tilsPubliceret
		LOOP
			tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_tils_publiceret a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ 
			WHERE
				(
					tilsPubliceretTypeObj.publiceret IS NULL
					OR
					tilsPubliceretTypeObj.publiceret = a.publiceret
				)
				AND b.tilstand_id = ANY (tilstand_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning
	);
			
		END LOOP;
	END IF;
END IF;

/*
--relationer TilstandRelationType[]
*/


--RAISE DEBUG 'tilstand_candidates_is_initialized step 4:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 4:%',tilstand_candidates;

--/**********************************************************//
--Filtration on relations
--/**********************************************************//


IF registreringObj IS NULL OR (registreringObj).relationer IS NULL OR coalesce(array_length((registreringObj).relationer,1),0)=0 THEN
	--RAISE DEBUG 'as_search_tilstand: skipping filtration on relationer';
ELSE
	IF coalesce(array_length(tilstand_candidates,1),0)>0 THEN
		FOREACH relationTypeObj IN ARRAY registreringObj.relationer
		LOOP
			tilstand_candidates:=array(
			SELECT DISTINCT
			b.tilstand_id 
			FROM  tilstand_relation a
			JOIN tilstand_registrering b on a.tilstand_registrering_id=b.id and upper((b.registrering).timeperiod)='infinity'::TIMESTAMPTZ
			WHERE
				(	
					relationTypeObj.relType IS NULL
					OR
					relationTypeObj.relType = a.rel_type
				)
				AND
				(
					relationTypeObj.uuid IS NULL
					OR
					relationTypeObj.uuid = a.rel_maal_uuid	
				)
				AND
				(
					relationTypeObj.objektType IS NULL
					OR
					relationTypeObj.objektType = a.objekt_type
				)
				AND
				(
					relationTypeObj.urn IS NULL
					OR
					relationTypeObj.urn = a.rel_maal_urn
				)
				AND b.tilstand_id = ANY (tilstand_candidates)
				AND (a.virkning).TimePeriod @> actual_virkning 
	);
		END LOOP;
	END IF;
END IF;
--/**********************//

--RAISE DEBUG 'tilstand_candidates_is_initialized step 5:%',tilstand_candidates_is_initialized;
--RAISE DEBUG 'tilstand_candidates step 5:%',tilstand_candidates;

tilstand_passed_auth_filter:=array(
SELECT
a.id 
FROM
unnest (tilstand_passed_auth_filter) a(id)
UNION
SELECT
b.id
FROM
unnest (tilstand_candidates) b(id)
);

--optimization 
IF coalesce(array_length(tilstand_passed_auth_filter,1),0)=coalesce(array_length(tilstand_uuids,1),0) AND tilstand_passed_auth_filter @>tilstand_uuids THEN
	RETURN tilstand_passed_auth_filter;
END IF;


END LOOP; --LOOP registreringObj


RETURN tilstand_passed_auth_filter;


END;
$$ LANGUAGE plpgsql STABLE; 



